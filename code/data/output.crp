0
The analysis of the experimental results will illustrate the necessity for handling various sentence constructions by fundamental improvement of parsers such as re-construction of feature designs .
Analysis of the experimental results illustrates the need to handle different sentence constructions through fundamental improvement of the parsers such as re-construction of feature designs .
1
Behind their approaches , there seems to be an assumption that grammatical constructions are not largely different among domains or do not affect parsing systems , and therefore the same parsing system can be applied to a novel domain .
Underlying these approaches , there seems to be the assumption that grammatical constructions are not largely different between domains or do not affect parsing systems , and therefore the same parsing system can be applied to a novel domain .
2
However , there are some cases where we cannot achieve as high parsing accuracies as parsing the Penn Treebank just by re-training or adaptation .
However , there are some cases where we cannot achieve such high parsing accuracy as parsing the Penn Treebank ( PTB ) merely by re-training or adaptation .
3
For example , the parsing accuracy for the Brown corpus is significantly lower than for the WSJ portion of the Penn Treebank , even when re-training the parser with much more in-domain training data than other successful domains .
For example , the parsing accuracy for the Brown corpus is significantly lower than that for the Wall Street Journal ( WSJ ) portion of the Penn Treebank , even when re-training the parser with much more in-domain training data than other successful domains .
4
This research attempts to identify the cause of these difficulties , and focuses on two types of sentence constructions which were not extensively studied in the recent parsing research : imperatives and questions .
This research attempts to identify the cause of these difficulties , and focuses on two types of sentence constructions that have not been extensively studied in recent parsing research : imperatives and questions .
5
In order to do so , we prepare an annotated corpus for each of the two sentence constructions by borrowing sentences from fiction and query domains .
To do so , we first prepare an annotated corpus for each of the two sentence constructions by borrowing sentences from fiction and query domains .
6
In the experiments , parsing accuracies of two shallow dependency parsers and a deep parser are examined for imperatives and questions , as well as the accuracies of a part-of-speech tagger for them .
In the experiments , parsing accuracies of two shallow dependency parsers and a deep parser are examined for imperatives and questions , as well as the accuracy of their part-of-speech ( POS ) tagger .
7
Since domain adaptation has been an extensive research area in parsing research \CITE , a lot of ideas have been proposed , including un- / semi-supervised approaches \CITE and supervised approaches \CITE .
Since domain adaptation is an extensive research area in parsing research \CITE , many ideas have been proposed , including un- or semi-supervised approaches \CITE and supervised approaches \CITE .
8
Their main focus was on adapting parsing models trained with a specific genre of text ( in most cases Penn Treebank WSJ ) to other genres of text , such as biomedical research papers and broadcast news .
The main focus of these works is on adapting parsing models trained with a specific genre of text ( in most cases the Penn Treebank WSJ ) to other genres of text , such as biomedical research papers and broadcast news .
9
A major problem tackled in such a task setting is the handling of unknown words and domain-specific ways of expressions .
The major problem tackled in such tasks is the handling of unknown words and domain-specific manners of expression .
10
The work pointed out low accuracy of state-of-the-art parsers on questions , and proposed supervised parser adaptation by manually creating a treebank of questions .
This work highlighted the low accuracy of state-of-the-art parsers on questions , and proposed a supervised parser adaptation by manually creating a treebank of questions .
11
QuestionBank was used for the supervised training of an LFG parser , and achieved a significant improvement in parsing accuracy .
QuestionBank was used for the supervised training of an LFG parser , resulting in a significant improvement in parsing accuracy .
12
They collected question sentences from TREC 9-12 competitions , and annotated these sentences with POSs and CCG lexical categories .
In this work , question sentences were collected from TREC 9-12 competitions and annotated with POS and CCG lexical categories .
13
They reported a significant improvement in CCG parsing without phrase structure annotations .
The authors reported a significant improvement in CCG parsing without phrase structure annotations .
14
Although QuestionBank and the resource of \CITE are claimed to be a corpus of questions , they are biased because the sentences come from QA queries .
Although QuestionBank and the resource of \CITE claim to be corpora of questions , they are biased because the sentences come from QA queries .
15
In our work , sentences are collected from the Brown corpus , which includes a wider range of types of questions and imperatives .
For our study , sentences were collected from the Brown corpus , which includes a wider range of types of questions and imperatives .
16
In the experiments , we will additionally use QuestionBank for comparison .
In the experiments , we also used QuestionBank for comparison .
17
The MST parser and Malt parser are dependency parsers that produce non-projective dependency trees , using the spanning tree algorithm \CITE and transition-based algorithm \CITE respectively .
The MST and Malt parsers are dependency parsers that produce non-projective dependency trees , using the spanning tree algorithm \CITE and transition-based algorithm \CITE , respectively .
18
For the evaluation of the output from each of the MST and Malt parser , we used the labeled attachment accuracy excluding the punctuations .
To evaluate the output from each of the parsers , we used the labeled attachment accuracy excluding punctuation .
19
The Enju parser \CITE is a deep parser based on the HPSG formalism .
The Enju parser \CITE is a deep parser based on the HPSG ( Head Driven Phrase Structure Grammar ) formalism .
20
It produces an analysis of a sentence that includes the syntactic structure ( i.e. , parse tree ) and the semantic structure represented as a set of predicate-argument dependencies .
It produces an analysis of a sentence including the syntactic structure ( i.e. , parse tree ) and the semantic structure represented as a set of predicate-argument dependencies .
21
As the evaluation metrics of the Enju parser , we used labeled and unlabeled precision / recall / F-score of the predicate-argument dependencies produced by the parser .
As evaluation metrics for the Enju parser , we used labeled and unlabeled precision / recall / F-score of the predicate-argument dependencies produced by the parser .
22
This section explains how we collected the treebanks of imperatives and questions , which were used in the experiments in Section \REF .
This section explains how we collected the treebanks of imperatives and questions used in the experiments in Section \REF .
23
While the Wall Street Journal ( WSJ ) treebank has extensively been used for parsing experiments , we use the treebank of the Brown Corpus in our experiments .
Although the WSJ treebank has been used extensively for parsing experiments , we used the treebank of the Brown Corpus in our experiments .
24
Because the Brown Corpus portion includes texts of literary works , it is expected that it inherently contains a larger number of imperatives and questions than the WSJ portion .
As the Brown Corpus portion includes texts of literary works , it is expected to contain inherently a larger number of imperatives and questions than the WSJ portion .
25
We extracted those sentences annotated with these phrase labels .
All sentences annotated with these phrase labels were extracted .
26
When they are embedded in another imperative or question , we only extracted the outermost one .
However , is these were embedded in another imperative or question , we only extracted the outermost one .
27
Extracted sentences are post-processed so that they have natural sentence forms : first characters are capitalized , and question marks or periods are added when appropriate .
Extracted sentences were post-processed to fit the natural sentence form ; that is , with first characters capitalized and question marks or periods added as appropriate .
28
The number of sentences for each section is shown in Table \REF .
The numbers of sentences for each section are given in Table \REF .
29
We will not use this data in the experiments .
This data was not used in the experiments .
30
As we will describe below , we additionally use QuestionBank in experiments .
As described below , we also used QuestionBank in the experiments .
31
However , an advantage of using the Brown treebank is that it includes annotations of function tags and empty categories . Therefore , we can apply the Penn Treebank-to-HPSG conversion program of Enju \CITE , which relies on function tags and empty categories .
The advantage , however , of using the Brown treebank is that it includes annotations of function tags and empty categories , and therefore , we can apply the Penn Treebank-to-HPSG conversion program of Enju \CITE , which relies on function tags and empty categories .
32
Hence , we will show experimental results on Enju only with the Brown data .
Hence , we show experimental results for Enju only with the Brown data .
33
It should also be noted that , a constituency-to-dependency converter , pennconverter \CITE , provides more accurate conversion when function tags and empty categories are available ( See footnote 6 ) .
It should also be noted that , a constituency-to-dependency converter , pennconverter \CITE , provides a more accurate conversion when function tags and empty categories are available ( see footnote 6 ) .
34
We extracted 3 ,859 sentences that are annotated with " SBARQ " or " SQ " .
We extracted 3 ,859 sentences annotated with " SBARQ " or " SQ " .
35
During experiments , we found several annotation errors that caused fatal errors of treebank conversion .
During the experiments , we found several annotation errors that caused fatal errors in the treebank conversion .
36
We plan to make these corrections publicly available .
We intend making these corrections publicly available .
37
We also found and corrected obvious inconsistencies in the corpus : character " ' " replaced by " $<$ " ( 737 sentences ) , token " ? " tagged not with " . " but with " ? " ( 2 ,051 sentences ) , and phrase labels annotated as POS ( one sentence ) .
We also found and corrected obvious inconsistencies in the corpus : character " ' " replaced by " $<$ " ( 737 sentences ) , token " ? " tagged with " ? " instead of " . " ( 2 ,051 sentences ) , and phrase labels annotated as the POS ( one sentence ) .
38
By observing the effects of parser or tagger adaptation to each domain , we would like to see the difficulties in parsing imperative and question sentences .
By observing the effect of the parser or tagger adaptation in each domain , we can identify the difficulties in parsing imperative and question sentences .
39
We also examined the portability of sentence construction properties between two similar domains : questions in Brown and QuestionBank .
We also examined the portability of sentence construction properties between two similar domains : questions in Brown and in QuestionBank .
40
We made experimental datasets for five domains : Wall Street Journal ( WSJ ) , Brown overall sentences , Brown imperatives , Brown questions , and QuestionBank questions .
We created experimental datasets for five domains : WSJ , Brown overall , Brown imperatives , Brown questions , and QuestionBank questions .
41
- Divided into three parts for training ( Section 02 - 21 , 39 ,832 sentences ) , development test ( Section 22 , 1 ,700 sentences ) , and final test ( Section 23 , 2 ,416 sentences ) .
- Divided into three parts , for training ( Section 02 - 21 , 39 ,832 sentences ) , development test ( Section 22 , 1 ,700 sentences ) , and final test ( Section 23 , 2 ,416 sentences ) .
42
- Randomly divided into three parts for training ( 19 ,395 sentences ) , development set ( 2 ,424 sentences ) , and final test ( 2 ,424 sentences )
- Randomly divided into three parts for training ( 19 ,395 sentences ) , development set ( 2 ,424 sentences ) , and final test ( 2 ,424 sentences ) .
43
- divided into two parts : one for ten-folds cross validation test ( 65 $\times$ 10 sentences ) and the other for error analysis ( 100 sentences )
- divided into two parts : one for ten-fold cross validation test ( 65 $\times$ 10 sentences ) and the other for error analysis ( 100 sentences ) .
44
- divided into two parts : one for ten-folds cross validation test ( 112 $\times$ 10 sentences ) and the other for error analysis ( 141 sentences )
- divided into two parts : one for ten-fold cross validation test ( 112 $\times$ 10 sentences ) and the other for error analysis ( 141 sentences ) .
45
- from the top of the corpus divided into three parts for final test ( 1 ,000 sentences ) , training ( 2 ,560 sentences ) , and analysis ( 299 sentences )
- from the top of the corpus divided into three parts for final test ( 1 ,000 sentences ) , training ( 2 ,560 sentences ) , and analysis ( 299 sentences ) .
46
In order to adapt each parser or POS tagger to a target domain , we trained the parser on combined training data for the target domain and for the original parser .
To adapt each parser and the POS tagger to a target domain , we trained the parser using combined training data for the target domain and the original parser .
47
For a domain which contains only small training data , we replicated the training data for certain times and just utilized the concatenated replicas for training .
For a domain containing only a small amount of training data , we replicated the training data a certain number of times and utilized the concatenated replicas for training .
48
For Brown imperatives / questions and QuestionBank , we replicated the training data for certain times and utilized the concatenated replicas and WSJ training data for training .
For Brown imperatives / questions and QuestionBank , we replicated the training data a certain number of times and utilized the concatenated replicas and WSJ training data for training .
49
For POS tagger , the number of replicas of training data was determined among 1 , 2 , 4 , 8 , 16 , 32 , 64 , and 128 , by testing these numbers on development test sets in three of ten datasets of cross validation .
For the POS tagger , the number of replicas of training data was determined as either 1 , 2 , 4 , 8 , 16 , 32 , 64 , or 128 , by testing these numbers on the development test sets in three of the ten datasets for cross validation .
50
- We used a toolkit in the Enju parser \CITE
- We used the toolkit in the Enju parser \CITE .
51
When we applied WSJ tagger to other domains , the tagging accuracy more or less decreased .
When we applied the WSJ tagger to other domains , the tagging accuracy basically decreased .
52
Among them , for Brown overall sentences , the accuracy did not decrease much from WSJ .
For Brown overall , compared with the WSJ , the accuracy did not decrease much .
53
The table shows the adaptation could improve the tagging accuracy to some extent , while the table also shows that the improved accuracy for the imperatives and questions could not reach eventhe accuracy of adapted tagger for Brown overall .
The table shows that the adaptation improved the tagging accuracy to some extent , but that the improved accuracy for imperatives and questions was still below that of the adapted tagger for Brown overall .
54
Figure \REF shows the POS tagging accuracy for the target domains given by changing the size of the target training data .
Figure \REF shows the POS tagging accuracy for the target domains for varying sizes of the target training data .
55
This graph shows that for both types of sentences , first 300 training sentences improved the accuracy rapidly , and after that , the effect of adding training corpus declined .
This graph shows that for both types of sentences , the first 300 training sentences greatly improved the accuracy , but thereafter , the effect of adding training data declined .
56
In order to recover the tagging accuracy of the WSJ tagger for WSJ ( 97 .53\% in Table \REF ) , it would not seem to be enough only to prepare much more training data .
To match the tagging accuracy of the WSJ tagger for the WSJ ( 97 .53\% in Table \REF ) , preparing much more training data does not appear to be enough .
57
Especially , the problem would be more serious for imperatives .
In particular , the problem is more serious for imperatives .
58
We then explored the tagging errors in each domain in order to observe what types of errors the WSJ tagger gave and what types of errors were solved or still unsolved by the adapted taggers .
Next , we explored the tagging errors in each domain to observe the types of errors from the WSJ tagger and which of these were either solved by the adapted taggers or remain unsolved .
59
Table \REF , \REF , and \REF show the most frequent tagging errors given by the WSJ tagger / adapted tagger for Brown questions , Brown imperatives , and QuestionBank respectively .
Tables \REF , \REF , and \REF show the most frequent tagging errors given by the WSJ tagger / adapted tagger for Brown questions , Brown imperatives , and QuestionBank , respectively .
60
In the tables , we could find that the major errors of the WSJ tagger for the Brown domains were the mis-tagging to verbs , that is , " VB \SPEC " .
From the results , we found that the main errors of the WSJ tagger for the Brown domains were mistagging of verbs , that is , " VB \SPEC " .
61
These two types of errors would respectively come from the following differences in sentence constructions between WSJ declarative and the Brown imperative sentences .
These two types of errors arise from the following differences in sentence constructions between the WSJ declarative and Brown imperative sentences .
62
Firstly , declarative sentences normally begin with noun phrases while imperative sentences normally begin with verb phrases .
First , a declarative sentence normally begins with a noun phrase , whereas an imperative sentence normally begins with a verb phrase .
63
The WSJ tagger was trained on the domain mainly consisting of declarative sentences , and the training was based on N-gram sequences of words or POSs . The tagger therefore preferred to give noun phrase-derived tags to the beginning of a sentence .
Since The WSJ tagger was trained on a domain consisting mainly of declarative sentences , with the training based on N-gram sequences of words or POSs , preference was given to noun phrase-derived tags at the beginning of a sentence .
64
Secondly , main verbs in imperative sentences take base forms while main verbs in declarative sentences take the forms according to tense .
Second , the main verb in an imperative sentence takes a base form , whereas the main verb in a declarative sentence takes a form based on tense .
65
The problem is that , for present tense except for third person singular , verbs in the declarative sentences always take the same appearances as the base forms , while the tags are different : VBP and VB .
A problem arises in that , for the present tense , except for third person singular , the verb in a declarative sentence always has the same appearance as the base form , although the tags are different : VBP and VB , respectively .
66
The WSJ tagger mainly based on declarative sentences therefore prefer to give VBP tags to main verbs .
Since the WSJ tagger is predominantly based on declarative sentences , it prefers to give VBP tags to main verbs .
67
After adapting the tagger to Brown imperatives , the N-gram model of tagger would have learned that the first word in a sentence tends to be a verb , and the main verb tends to take base form ( VB ) .
After adapting the tagger to Brown imperatives , the N-gram model of the tagger would have learned that the first word in a sentence tends to be a verb , and that the main verb tends to take the base form ( VB ) .
68
Table \REF shows that the above two types of errors did decrease to some extent . However , we can also observe that not a few mis-tags to verbs were still left after the adaptation .
Table \REF shows that after adaptation the above two types of errors decreased to some extent , although a few mistags of verbs still remained .
69
When we observe each of the left errors around VB , we found that several errors still occurred even in simple imperative sentences such as " VB \SPEC NN " for " Charge " in " Charge something for it . " , and that some errors tended to occur after to-infinitive phrase or conjunction , such as " VB \SPEC NN " for " subtract " in " To find estimated net farm income , subtract . . . "
By investigating the remaining errors associated with VB , we found that several errors still occurred even in simple imperative sentences such as " VB \SPEC NN " for " Charge " in " Charge something for it " , and that some errors tended to occur after a to-infinitive phrase or conjunction , such as " VB \SPEC NN " for " subtract " in " To find the estimated net farm income , subtract . . . " .
70
The former type of errors might be solved by increasing the training data , while the latter type of errors would not be easily solved with the model based on word N-gram which cannot detect the existence of long phrases .
The former type could be solved by increasing the training data , whereas the latter error type cannot easily be solved with a model based on a word N-gram that cannot detect the existence of long phrases .
71
We also analyzed the errors in Brown questions and QuestionBank , and again found that the WSJ tagger seems to make many errors due to the fact that the tagger was trained on a corpus mainly consisting of declarative sentences .
We also analyzed the errors in Brown questions and QuestionBank , and again found that many errors were due to the fact that the WSJ tagger was trained on a corpus consisting mainly of declarative sentences .
72
After the adaptation , while some of the errors such as special usage of wh-words , i.e. , " WDT \SPEC WP " , were corrected , we found that some kinds or errors related to the global change of sentence structures still remained .
After the adaptation , although some of the errors such as the special use of wh-words , i.e. , " WDT \SPEC WP " , were corrected , other kinds or errors related to the global change in sentence structure still remained .
73
In order to give correct tags to words both in imperatives and questions , we might have to consider richer information than only N-gram based features , such as long distance dependencies or phrases .
To tag words correctly both in imperatives and questions , we may have to consider richer information than only N-gram based features , such as long distance dependencies or phrases .
74
Table \REF shows the parsing accuracies of MST( first order ) , MST( second order ) , Malt , and Enju parser for WSJ , Brown overall , Brown imperatives and Brown questions .
Table \REF gives the parsing accuracy of MST ( first order ) , MST ( second order ) , Malt , and the Enju parser for WSJ , Brown overall , Brown imperatives , and Brown questions .
75
Figure \REF shows the parsing accuracies against the training data size of the four parsers for WSJ , Brown imperatives , Brown questions , and QuestionBank .
Figure \REF plots the parsing accuracy against the training data size of the four parsers for WSJ , Brown imperatives , Brown questions , and QuestionBank .
76
Note that , since training MST parser ( second order ) on Brown overall , Brown questions , and QuestionBank could not be completed in our experimental environments , the parsing accuracies represented by the bracketed hyphens in Table \REF could not be measured and we could not draw full graphs of second order MST for Brown questions and QuestionBank in Figure \REF .
Note that , since the training of the MST parser ( second order ) on Brown overall , Brown questions , and QuestionBank could not be completed in our experimental environment , the corresponding parsing accuracies denoted by bracketed hyphens in Table \REF could not be measured , Consequently , we could not plot complete graphs of second order MST for Brown questions and QuestionBank in Figure \REF .
77
When we adapted the parser model ( see fifth column in Table \REF ) , the parser could give two to four points higher accuracies for each of the Brown domains than the WSJ parser .
After adaptation ( see " Adapted " column in Table \REF ) , the parser achieved two to four percent higher accuracy for each of the Brown domains compared to the WSJ parser .
78
For the QuestionBank , 25 to 35 points accuracy improvements were observed .
For QuestionBank , 25 to 35 percent improvement in accuracy was observed .
79
Figure \REF shows that , the improvements increased according to the size of the training data , and the tendencies would not seem to converge .
Figure \REF shows that the improvement is proportional to the size of the training data and that this tendency does not seem to converge .
80
This would suggest that lower accuracies than the WSJ parser for WSJ would be still brought by the lack of training data .
This would suggest that lower accuracy than that of the WSJ parser for the WSJ could still be as a result of a lack of training data .
81
In Figure \REF , when we focus on the QuestionBank where we could use much more training data than Brown questions , the parser accuracies were approaching the accuracies of WSJ parser for WSJ or exceeded the accuracy .
In Figure \REF , the parser accuracy for QuestionBank , for which we could use much more training data than for Brown questions , approaches or even exceeds that of the WSJ parser for WSJ .
82
However , we have no more training data for Brown imperatives and questions . We should prepare more training data or explore approaches to enable us to sufficiently adapt parsers with small training data .
However , as there is no more training data for Brown imperatives and questions , we need to either prepare more training data or explore approaches that enable the parsers to be adapted with small amounts of training data .
83
In order to capture the outline of the adaptation effects , we observed error reduction for the Malt parser .
To capture an overview of the adaptation effects , we observed the error reduction in the Malt parser .
84
Table \REF and \REF show the recall errors on labeled dependencies which were observed more than ten times for 100 analysis sentences of each domain .
Tables \REF and \REF give the recall errors on labeled dependencies , which were observed more than ten times for 100 analysis sentences in each domain .
85
For each dependency shown in the first column , the second and third columns show the number of parsing errors by the WSJ parser with gold tags and the adapted parser with gold tags .
For each dependency shown in the first column , the second and third columns show the number of parsing errors by the WSJ parser with gold tags and the adapted parser with gold tags , respectively .
86
Since ROOT dependencies , that is , heads of sentences would be critical to construction of sentences , we mainly focus on that type of errors .
Since ROOT dependencies , that is , heads of sentences , are critical to the construction of sentences , we focus mainly on this type of error .
87
For Brown imperatives and questions , we could observe that the reduction of ROOT dependency was prominent .
For Brown imperatives and questions , the reduction in ROOT dependencies was prominent .
88
When we focus on this type of errors , we could find that the WSJ parser could often make mistakes in parsing sentences which began or ended with the names of persons who were talk to .
On investigation , we found that the WSJ parser often made mistakes in parsing sentences which began or ended with the name of the person being addressed .
89
For example in Brown imperatives , for the sentence " See for yourself , Miss Zion . " , the WSJ parser regarded the person name " Zion " as ROOT , and the main verb " See " as modifiers of the name .
For example , in Brown imperatives , for the sentence " See for yourself , Miss Zion . " , the WSJ parser mistook the name " Zion " to be ROOT , and the main verb " See " to be a modifier of the name .
90
The adapted parser could then correctly give ROOT to the main verb .
The adapted parser correctly assigned ROOT to the main verb .
91
We could also often find that the WSJ parser could often make mistakes in parsing sentences containing quotation , exclamation , and question marks , such as " " Hang on " !! " " or " Why did you kill it " ? ? " or " " " " .
We also found that the WSJ parser often made mistakes in parsing sentences containing quotation , exclamation , or question marks , such as " " Hang on " !! " " or " Why did you kill it " ? ? " or " " " " .
92
We thought that this kind of errors would partly come fromthe Brown corpus itself . The exclamation or question marks should be inside the quotation , while the Brown corpus usually put the marks outside .
A possible reason for this type of error could be that the Brown corpus places exclamation or question marks outside , instead of inside the quotation .
93
However , the adapted parser could take in such doubtful construction and gave ROOT to the main verbs as the corpus required .
The adapted parser could handle this dubious construction and assigned ROOT to the main verbs as the corpus required .
94
On the other hand , we also observed some still unsolved errors . We would show the two kinds of major errors among them .
On the other hand , we also observed some unsolved errors , of which we discuss two .
95
First , Brown imperatives and questions , include many conversation sentences , and therefore rather flexible constructions could be observed especially for imperatives , such as " Lift , don't shove lift! " , " Come out , come out in the meadow! " , etc.
First , Brown imperatives and questions , include many colloquial sentences , which have rather flexible constructions , especially imperatives , such as " Lift , don't shove lift! " , " Come out , come out in the meadow! " , etc.
96
The parsing models based on the plausibility of constructions could hardly capture such sentences .
The parsing models based on the plausibility of constructions were not able to capture such sentences .
97
Second , when the different constructions of sentences were in one sentence , such as , the case where to-infinitive phrases or subordinate clauses precede imperatives and questions , the parser would often be confused .
Second , having different sentence constructions within a single sentence , such as , where a to-infinitive phrase or subordinate clause precedes an imperative or question , often confused the parser .
98
For example , for the imperative sentence " To find estimated net farm income , subtract estimated annual farming expenditures . . . " , both of the WSJ and adapted parsers regarded " find " as ROOT , because the parsers regarded the words following " find " as a that-clause complement for the " find " , like " To find [ ( that ) estimated net farm income , subtract estimated annual farming . . .] " .
For example , for the imperative sentence , " To find the estimated net farm income , subtract the estimated annual farming expenditure . . . " , both the WSJ and adapted parsers regarded " find " as ROOT , because the parsers regarded the words following " find " as a that-clause complementing " find " , as in " To find [ ( that ) the estimated net farm income , subtract the estimated annual farming . . .] " .
99
It would be difficult for the parsers to know where the main clause in such complex sentences .
It would be difficult for the parsers to know which is the main clause in such complex sentences .
100
This type of errors would hardly be solved only by increasing the training data .
This type of error cannot be solved merely by increasing the training data .
101
The parser would parse such complex sentences without partition into each construction , and therefore it would sometimes be confused .
These complex sentences were parsed without being partitioned into separate constructions , and as a result the parser sometimes became confused .
102
In this section , we examined whether the parser adapted to one domain would be portable to the other domain .
In this section , we examine whether a parser adapted to one domain could be ported to another domain .
103
QuestionBankdoes not give function tags , and therefore in training and evaluation of the parsers , abstracted dependencies were extracted from the corpus .
QuestionBank does not provide function tags , and therefore in training and evaluation of the parsers , abstracted dependencies were extracted from the corpus .
104
Therefore , the parser adapted to one domain could not give correct dependency labels on such functions for the other domain .
As a result , a parser adapted to one domain could not provide correct dependency labels on functions for the other domain .
105
However , we would be able to expect that sentence constructions would be basically common and portable between two domains , which would contribute to give correct boundary for phrases and therefore the correct dependencies in phrases would be introduced by the adaptation .
However , we would expect that sentence constructions are basically common and portable between two domains , which would provide a correct boundary for phrases and therefore , the correct dependencies in phrases would be introduced by the adaptation .
106
the difference from Table \REF was that the parsers and the tagger were adapted to another question domain .
These results differ from those in Table \REF in that the parsers and the tagger have been adapted to another question domain .
107
The table shows that the parsers adapted to Brown questions improved the parsing accuracies for QuestionBank , while the parsers adapted to QuestionBank decreased .
The table shows that the parsers adapted to the Brown questions improved their parsing accuracy with QuestionBank , whereas the parsers adapted to QuestionBank decreased in accuracy .
108
With Brown questions , we could learn wh-questions which QuestionBank mainly contain , while with QuestionBank , we could not we could not learn yes-no questions which more than half of Brown corpus contain .
Using Brown questions , many wh-questions were learnt , which is what QuestionBank mainly contains . On the other hand , despite yes-no questions constituting more than half the Brown corpus , these were not learnt using QuestionBank for training .
109
A question domain contains various types of questions and gives various sentence constructions .
A question domain contains various types of questions with various sentence constructions .
110
In order to parse questions correctly , we should capture each of them correctly .
In order to parse questions correctly , we need to capture each of these correctly .
111
This type of problem would not be noticed so much when we were working mainly on declarative sentences .
This type of problem was not so obvious when we were working mainly with declarative sentences .
112
Through the experiments on various parsers we observed that simple supervised adaptation methods are insufficient to arrive at theparsing accuracy comparable to that of declarative sentences .
Through experiments with various parsers we observed that simple supervised adaptation methods are insufficient to achieve parsing accuracy comparable with that of declarative sentences .
113
This observation holds both for POS tagging and syntactic parsing , and itindicates that we need fundamental improvement of parsers , such as re-constructing feature designs or changing parsing models .
This observation holds both for POS tagging and syntactic parsing , and indicates that the parsers need to be fundamentally improved , such as re-constructing feature designs or changing parsing models .
114
Following the present work , future work should include investigating parsing frameworks that are robust for sentences with various sentence constructions , and / or methods that can effectively adapt a parser to different sentence constructions including imperatives , questions , and more .
Following on from this study , future work includes investigating parsing frameworks that are robust for sentences with different sentence constructions , and / or methods that can effectively adapt a parser to different sentence constructions including imperatives and questions , among others .
115
While word segmentation is a necessary step to process languages like Chinese and Japanese , its effects on Statistical Machine Translation ( SMT ) have not been discussed intensively in such languages .
While word segmentation is necessary for processing the Chinese and Japanese languages , its effects on Statistical Machine Translation ( SMT ) have not yet been thoroughly discussed for such languages .
116
In this paper , we investigate the effects of word segmentation methods on SMT , by comparing evaluation results of translation outputs while varying word segmentation methods .
In this paper , we investigate the effects of word segmentation methods on SMT , by comparing the evaluation results of the translation outputs , while varying word segmentation methods .
117
The experiments revealed that supervised morphological analyzers were competitive , and considerably better than an unsupervised analyzer and a heuristic segmentation method .
The experimental results confirmed that supervised morphological analyzers were competitive with , and performed considerably better than an unsupervised analyzer and a heuristic segmentation method .
118
However , a character-based segmentation has achieved 10 .27 positive and 1 .95 negative differences in word-based and character-based BLEU , depending on corpus sizes and domains .
However , a character-based segmentation achieved 10 .27 positive and 1 .95 negative differences in word-based and character-based BLEU , depending on the corpus sizes and domains .
119
For this result we discuss the problem of the comparability of evaluation metrics and the possibility of better word segmentation than popular supervised morphological analyzers .
In conclusion , we discuss the problem of the comparability of evaluation metrics , and consider ways of improving word segmentation more than popular supervised morphological analyzers .
120
Several natural languages like Chinese and Japanese do not have to put spaces between words in their written forms .
Several languages , including Chinese and Japanese , do not require spaces between words , in their written forms .
121
Since the process is fundamental and indispensable , we need to explore how word segmentation affects Natural Language Processing applications .
Since word segmentation is a fundamental process , and is therefore indispensable , it is important that we explore how word segmentation affects Natural Language Processing applications .
122
We also examine an unsupervised morphological analyzer and its results .
In addition , we examine an unsupervised morphological analyzer , and its results .
123
In addition , we focus on the meta-evaluation of the current evaluation metrics and find whether the metrics are consistent or not , when we vary word segmentation methods .
We focus on the meta-evaluation of the current evaluation metrics and determine whether the metrics are consistent or not , when we vary word segmentation methods .
124
They acquired the 2 .3 score improvement from the worst to the best combinations .
They acquired a 2 .3 score improvement in comparing the worst to best combinations .
125
( 2010 ) suggested a new short unit word segmentation standard in Chinese which defines a more frequent string subset as a word .
( 2010 ) suggested a new short unit word segmentation standard in Chinese , which defines a more frequent string subset as a word .
126
For instance , They separated one word " 全球化 globalization " into two words " 全球 global " and " 化 -lization " .
For instance , one word “全球化 globalization” was separated into two words “全球 global” and “化 -lization” .
127
Though , they have not discussed about BLEU is a good metric for such an evaluation of word segmentation .
However , it has not yet been discussed whether BLEU is a good metric for such an evaluation of word segmentation .
128
In addition , comparison of morphological analyzers are necessary because different analyzers produce different outputs to SMT .
In addition , comparing morphological analyzers is necessary , because different analyzers produce different outputs to SMT .
129
Therefore , we conduct several translation tasks between English and Japanese .
We therefore conduct several translation tasks between English and Japanese .
130
- Whether or not SMT evaluation metrics provide a consistent measure while varying word segmentation methods .
- Whether or not SMT evaluation metrics provide a consistent measure , while varying word segmentation methods .
131
We setup word segmentation methods , corpora , and evaluation metrics as three parameters of our experiments to see the effects of Japanese word segmentation on SMT .
We set up word segmentation methods , corpora , and evaluation metrics , as the three parameters for our experiments , in order to observe the effects of Japanese word segmentation on SMT .
132
As shown in Table 1 , the following word segmentation methods output delimiters ( " | " represents a delimiter ) for a given input character sequence .
As shown in Table 1 , the following word segmentation methods output delimiters ( “|” represents a delimiter ) for a given input character sequence .
133
It is , however , not clear which analyzer works better for the SMT task than the other analyzers .
It is ; however , unclear as to which analyzer works better for the SMT task .
134
- JUMAN also regards word segmentation as a sequence labeling , but it decides the minimum cost paths without machine learning , from segmentation and association costs in human annotated lexicons and automatically generated Web lexicons .
- JUMAN also regards word segmentation as a sequence labeling problem , but it decides the minimum cost paths without machine learning , from segmentation and association costs in human annotated lexicons and automatically generated Web lexicons .
135
On the other hand , the unsupervised method latticelm achieved 66 .6% accuracy ( Mochihashi et al. , 2009 ) for human annotated news text , while the method does not have any answers of word definitions .
On the other hand , the unsupervised method , latticelm , achieved 66 .6% accuracy ( Mochihashi et al. , 2009 ) for human annotated news texts , while the method does not have any answers for word definitions .
136
Therefore , it is not possible to compare such a result with the supervised results . Even though , it is fair to compare it with SMT contribution point of view .
Therefore , it is not possible to compare its result with the supervised results , even though it is fair to compare it from the SMT contribution point-of-view .
137
Furthermore , their policies about word segmentation definitions are very much different .
Furthermore , their policies concerning word segmentation definitions vary significantly .
138
While MeCab can change its definitions by external lexicons and JUMAN has its own internal standard , KyTea is based on the short unit standard of Balanced Corpus of Contemporary Written Japanese , which is considered one of the shortest definitions of Japanese words .
While MeCab can change its definitions by external lexicons , and JUMAN has its own internal standard , KyTea is based on the short unit standard of the Balanced Corpus of Contemporary Written Japanese , which is considered to have one of the shortest definitions of Japanese words .
139
For example , if we are given a string " 見れば( if someone see ) " , MeCab separates it into two words " 見れ | ば " and JUMAN keep the same string , but KyTea outputs it as three words " 見 | れ | ば " where every character is a word .
For example , if we are given a string , “見れば( if someone sees )” , MeCab separates it into two words , “見れ | ば” and JUMAN retains the same string , but KyTea outputs it as three words , “見 | れ | ば” where every character is a word .
140
In the case of latticelm , as it has no supervised definition of words , it uses the expectation maximized length of words for every word depending on training data .
For latticelm , since it has no supervised definition of words , it uses the expectation maximized length of words for every word , depending on the training data .
141
We also investigate such morphological analysis accuracy and word definition problems in our experiments .
In our experiments , we further investigate such morphological analysis accuracies and word definition problems .
142
One is segmentation by character category ( CAT ) , and the other is segmentation by characters ( CHAR ) .
One method is segmentation by character category ( CAT ) , and the other is segmentation by characters ( CHAR ) .
143
The CHAR method considers every Unicode character as a word as proposed by Xu et al.
The CHAR method considers every Unicode character as a word , as proposed by Xu et al.
144
Another corpus we use in the experiments is a Wikipedia corpus , Japanese-English Bilingual Corpus of Wikipedia 's Kyoto Articles 2 .01 ( WIKIPEDIA ) .
Another corpus we use in the experiments is a Wikipedia corpus : the Japanese-English Bilingual Corpus of Wikipedia 's Kyoto Articles 2 .01 ( WIKIPEDIA ) .
145
From these corpora , we prepared three data sets as explained below .
From these corpora , we prepared three data sets , as explained below .
146
In the case of REUTERS , we have used all 56 ,282 sentences .
For REUTERS , we used all 56 ,282 sentences .
147
In this data , we have combined JENAAD and REUTERS news corpora to get one news corpus .
For this data , we combined the JENAAD and REUTERS news corpora to acquire one news corpus .
148
We have used all 56 ,282 and 150 ,000 sentences respectively .
We used all 56 ,282 and 150 ,000 sentences , respectively .
149
For each corpus , we divide it into the first 1 ,000 , the next 500 , and the rest for test , development , and training .
For each corpus , we divided the sentences into the first 1 ,000 for testing , the next 500 for development , and the remaining for training .
150
We have gathered 2000 , 1000 , and 203 ,782 sentences for test , development , and training , respectively , in total .
In total , we gathered 2000 , 1000 , and 203 ,782 sentences for test , development , and training , respectively .
151
Firstly , since the WIKIPEDIA corpus is a multi-category XML dataset , we have sorted them by the DOCID in the ascending order and by the document categories LTT , EPR , FML , BDS , CLT , BLD , GNM , SCL , ROD , SNT , PNM , HST , RLW , and SAT .
Since the WIKIPEDIA corpus is a multi-category XML dataset , we sorted them by the DOCID in ascending order , and by the document categories : LTT , EPR , FML , BDS , CLT , BLD , GNM , SCL , ROD , SNT , PNM , HST , RLW , and SAT .
152
Secondly , we parsed it by xml .etree .ElementTree .parse of Python 2 .7 .2 , and obtained 477 ,036 sentence pairs without parsing errors .
Next , we parsed it by xml .etree .ElementTree .parse of Python 2 .7 .2 , and obtained 477 ,036 sentence pairs without parsing errors .
153
Thirdly , sentence pairs that include a character " | " in English or Japanese are removed because it caused a problem with Moses .
Then , sentence pairs that include a character “|” in English or Japanese were removed , because it caused a problem with Moses .
154
In order to adjust the balance of the domains , we have sampled the data twice : First we extract the first line for every 477 lines .
In order to adjust the balance of the domains , we sampled the data twice : First , we extracted the first line for every 477 lines .
155
After this , we have merged the remaining 476 ,012 lines and from this extract the first line for every 952 lines .
Then , we merged the remaining 476 ,012 lines , and from this extract , we extracted the first line for every 952 lines .
156
Finally , we have obtained 1 ,000 test , 500 development , and 475 ,512 training data .
Finally , we obtained 1 ,000 test , 500 development , and 475 ,512 training data .
157
Currently , the most popular way to evaluate Statistical Machine Translation is to use word-based evaluation metrics such as BLEU and RIBES .
Currently , the most popular way to evaluate SMT is to use word-based evaluation metrics , such as BLEU and RIBES .
158
For example , in the case of English-Japanese translations , we must tokenize reference data to evaluate SMT outputs .
For example , for English-Japanese translations , we must tokenize reference data to evaluate SMT outputs .
159
On the other hand , in the case of Japanese-English translations , we must tokenize test data to evaluate the outputs .
On the other hand , for Japanese-English translations , we must tokenize test data to evaluate the outputs .
160
As a result , we need to tokenize every sentence by word segmentation before evaluation , and it is hard to independently evaluate the effects of word segmentation on training data .
As a result , we need to tokenize every sentence by word segmentation before evaluation , and it is therefore difficult to independently evaluate the effects of word segmentation on training data .
161
However , our preliminary experiments showed that the results obtained with this method were not independent from word segmentation of training data .
However , our preliminary experiments indicated that the results obtained with this method were not independent from word segmentation of the training data .
162
And the best results were obtained when we use the same word segmentation as the training data .
The best results were obtained when we used the same word segmentation as the training data .
163
Hence , this problem remains if we keep our word-based evaluations .
Hence , if we keep our word-based evaluations , this problem remains .
164
In order to manage such a problem , we use one character-based metric BLEU in Characters ( De-noual and Lepage , 2005 ) with 4-gram .
In order to manage this issue , we used one character-based metric BLEU in Characters ( De-noual and Lepage , 2005 ) with 4-gram .
165
As this method evaluates the character-level information , outputs are not required to be segmented and it is free from word segmentation variations .
As this method evaluates the character-level information , outputs are not required to be segmented , and it is free from word segmentation variations .
166
We have conducted English and Japanese machine translation in both directions by the following steps :
We have conducted English and Japanese machine translation in both directions , following the steps below :
167
1Apply the Head-Finalization ( Isozaki et al. , 2010b ) to English text in the case of English-Japanese translation .
1 .Apply the Head-Finalization ( Isozaki et al. , 2010b ) to English text in the case of English-Japanese translation .
168
2Run Japanese word segmentation methods and a normalization script which was introduced by the NTCIR-9 PATMT task .
2 .Run Japanese word segmentation methods and a normalization script , which was introduced by the NTCIR-9 PATMT task .
169
3Tokenize and lowercase English text by Moses' tokenizer and lowercase scripts .
3 .Tokenize and lowercase English texts by Moses' tokenizer and lowercase scripts .
170
4Create language models from target languages' training data , with SRILM 1 .5 .12 .
4 .Create language models from target languages' training data , with SRILM 1 .5 .12 .
171
5Create translation models with Giza++ 1 .0 .5 ( 2011-09-24 ) .
5 .Create translation models with Giza++ 1 .0 .5 ( 2011-09-24 ) .
172
6Decode source test data with Moses ( 2010-08-13 ) .
6 .Decode source test data with Moses ( 2010-08-13 ) .
173
7Compute evaluation scores of the outputs .
7 .Compute evaluation scores of the outputs .
174
- Remove articles " a " , " an " , and " the "
- Remove articles “a” , “an” , and “the”
175
In this case , the evaluation scores created by BLEU and RIBES are not comparative due to the differences of Japanese word definitions between the outputs of word segmentation methods .
In this case , the evaluation scores created by BLEU and RIBES are not comparative , due to the differences in the Japanese word definitions among the outputs of word segmentation methods .
176
Furthermore , the CHAR scores in BLEU and BLEU in Characters should be regarded as almost same while small changes have been introduced due to statistical errors and the differences in the methods how to treat space characters .
Furthermore , the CHAR scores in BLEU and BLEU in Characters should be regarded as almost the same , while small changes have been introduced , due to statistical errors and the differences in the methods in how to treat space characters .
177
We found that the three supervised morphological analyzers KyTea , MeCab , and JUMAN were much higher than latticelm and CAT , and were competitive .
We found that the three supervised morphological analyzers : KyTea , MeCab , and JUMAN were much higher than latticelm and CAT , and were competitive .
178
For instance , on REUTERS in Table 2 , BLEU scores were ranged from 27 .88 to 29 .53 , while latticelm was 15 .28 and CAT was 22 .10 .
For instance , on REUTERS in Table 2 , BLEU scores ranged from 27 .88 to 29 .53 , while for latticelm , the score was 15 .28 and for CAT , the score was 22 .10 .
179
The unsupervised morphological analyzer latticelm and one of heuristic methods CAT were worse than our expectations .
The unsupervised morphological analyzer , latticelm , and one of heuristic methods , CAT , performed worse than expectations .
180
These two were the worst or the second worst results in all settings .
These two results were the worst , in all of the settings .
181
The results of CHAR were counterintuitive and yet to be discussed .
The results of CHAR were counterintuitive and are yet to be discussed .
182
It was relatively much better than the supervised morphological analyzers in BLEU .
The results were better than the results for the supervised morphological analyzers in BLEU .
183
Besides , it was almost competitive in RIBES and BLUE in Characters .
It was almost competitive in RIBES and BLUE in Characters .
184
For example , CHAR achieved the best 38 .42 score in BLEU on REUTERS , but the second best KyTea was 29 .53 .
CHAR achieved the best score in BLEU on REUTERS ( 38 .42 ) , but the second-best was KyTea ( 29 .53 ) .
185
In the case of BLEU in Characters on REUTERS , CHAR achieved 38 .61 , while the worst supervised result was KyTea 's 39 .82 .
For BLEU in Characters on REUTERS , CHAR achieved 38 .61 , while the worst supervised result was KyTea 's 39 .82 .
186
In this case , the evaluation scores are lower than English-Japanese translations in general .
For Japanese-English translations , the evaluation scores were generally lower than for English-Japanese translations .
187
It is because Japanese-English translations are conducted without Head-Finalization .
This is because Japanese-English translations are conducted without Head-Finalization .
188
On the other hand , the unsupervised morphological analyzer latticelm and one of heuristic methods CAT were competitive to the supervised analyzers in RIBES .
Conversely , the unsupervised morphological analyzer latticelm and one of heuristic methods CAT performed competitively with the supervised analyzers in RIBES .
189
For example , latticelm was 62 .51 and KyTea was 62 .90 on REUTERS .
latticelm was 62 .51 and KyTea was 62 .90 on REUTERS .
190
The results were the worst scores in BLEU and RIBES on REUTERS and JENAAD+REUTERS . The only one exception was in the case of the best 56 .55 BLEU in Characters on REUTERS .
The results for CHAR were the lowest scores in BLEU and RIBES on REUTERS and JENAAD+REUTERS , with the exception of the best 56 .55 BLEU in Characters on REUTERS .
191
We found the results of the supervised morphological analyzers are better in both English-Japanese and Japanese-English experiments .
We found that the results of the supervised morphological analyzers were better in both English-Japanese and Japanese-English experiments .
192
And the differences in the word definition of KyTea , MeCab , and JUMAN were not remarkable , especially in English-Japanese translations , although the word definition of KyTea is much shorter than MeCab and JUMAN .
Furthermore , the differences in the word definition of KyTea , MeCab , and JUMAN were not substantial , especially for English-Japanese translations , although the word definition of KyTea is much shorter than for MeCab and JUMAN .
193
This result implies that phrase-based SMT can output sufficiently reasonable word / phrase alignments that can treat different word definitions in most cases .
This result implies that phrase-based SMT can output sufficiently reasonable word / phrase alignments that can treat different word definitions , in most cases .
194
It was good at English-Japanese but not at Japanese-English translations .
It excelled with English-Japanese translations , but not with Japanese-English translations .
195
We consider the possible reasons for this result :
We consider the possible reasons for this result in the following list :
196
- Long sentences were translated worse than the other word segmentation outputs .
- Long sentences were not translated as well as other word segmentation outputs .
197
The current evaluation metrics we pursued in this paper were not sufficient to discuss more accurately about the relative advantages and disadvantages of word segmentation , since they did not produce consistent scores as explained below :
The current evaluation metrics that we pursued in this paper were insufficient to discuss the relative advantages and disadvantages of word segmentation in detail , since the scores that were produced were inconsistent , as explained below :
198
Moreover , there is also a case that RIBES and BLEU in Characters were incompatible with each other .
Moreover , there is also a case in which RIBES and BLEU in Characters were incompatible with each other .
199
For example , on WIKIPEDIA in Table 2 , while CHAR was relatively the highest and greatly better than the supervised morphological analyzers in RIBES , MeCab achieved the best score and notably better than CHAR in BLEU in Characters .
For example , on WIKIPEDIA in Table 2 , while CHAR was the highest , and performed better than the supervised morphological analyzers in RIBES , MeCab achieved the best score and notably better than CHAR in BLEU in Characters .
200
After all , a heuristic word segmentation method CHAR achieved relatively good word-based BLEU scores and competitive character-based BLEU results , compared to the supervised analyzers .
Nevertheless , a heuristic word segmentation method CHAR achieved relatively good word-based BLEU scores and competitive character-based BLEU results , compared to the supervised analyzers .
201
Additionally , as we could not always obtain consistent scores from the current evaluation metrics , they were not sufficient to discuss more accurately about the relative advantages and disadvantages of word segmentation .
Additionally , as we could not always obtain consistent scores from the current evaluation metrics , the data was insufficient for discussing the relative advantages and disadvantages of word segmentation , with accuracy .
202
We also suggested it is possible to implement more optimized word segmentation on SMT .
We have also suggested that it is possible to implement more optimized word segmentation on SMT .
203
However , problems with their approaches are the disregard of the interdependencies of word senses , and the limited applicability to those word senses for which training instances are served .
However , the problem with these approaches , is that they disregard the interdependencies of word senses , and that it is limited in its applicability to the word senses for which training instances are served .**[<-This sentence is a bit confusing]
204
Particularly , we assume that there exist strong dependencies between the sense of a syntactic head and those of its dependents .
In particular , we assume that strong dependencies between the sense of a syntactic head and those of its dependents exist .
205
Also , we define these sense dependencies in combination with various coarse-grained sense tag sets , so that our model can even work for words that do not appear in the training data , and these combined features help relieve the data sparseness problem .
Furthermore , we define these sense dependencies in combination with various coarse-grained sense tag sets , so that our model can also work for words that do not appear in the training data ; these combined features help relieve the data sparseness problem .
206
In experiments , we show the appropriateness of considering the sense dependencies , as well as the advantage of the combination of fine- and coarse-grained tag sets .
In experiments , we display the appropriateness of considering the sense dependencies , as well as the advantage of [having ? Using ?] the combination of fine- and coarse-grained tag sets .
207
We also present an in-depth analysis on the effectiveness of the sense dependency features with intuitive examples .
We also present an in-depth analysis of the effectiveness of the sense dependency features by using intuitive examples .
208
Word sense disambiguation ( WSD ) is one of the fundamental problems in computational linguistics .
Word sense disambiguation ( WSD ) is one of the most fundamental problems in computational linguistics .
209
It is considered to be an intermediate , but necessary step toward many NLP applications including machine translation and information extraction , which require the knowledge of word senses to achieve better performance .
It is considered to be an intermediate , but necessary step for many NLP applications , including machine translation and information extraction , which[what does " which " refer to ? Machine translation ? Information extraction , or both ? Clarify] require the knowledge of word senses to perform better .
210
One major obstacle to large-scale and precise WSD is the data sparseness problem caused by the fine-grainedness of the sense distinction .
One major obstacle for large-scale and precise WSD is solving the data sparseness problem caused by the fine-grained nature of sense distinction .
211
Some researchers have addressed directly the scarcity of the training data , and explored the methods to obtain more tagged instances , by the co-training and self-training .
Some researchers have addressed the scarcity of the training data directly , and have explored the methods to obtain more tagged instances , by co-training and self-training .
212
One of such information yet to be explored is the interdependencies of word senses .
One such information yet to be explored , is the interdependency of word senses .
213
Although the use of local and syntactic information has been common in WSD , traditional approaches to WSD are based on the individual classification framework for each word , in which each word 's sense is treated independently , regardless of any interdependencies nor cooccurrences of word senses .
Although the use of local and syntactic information has been common in WSD , traditional approaches to WSD are based on the individual classification framework for each word ; each word 's sense is treated independently , regardless of any interdependencies or cooccurrences of word senses .
214
As a result , the resulting sense assignment may not semantically consistent over the sentence .
In turn , the resulting sense assignment may not be semantically consistent over the sentence .
215
We focus on the use of the interdependency of word senses , so that we can directly address the issue of semantic ambiguity of a whole sentence arose from the interaction of each word 's sense ambiguity .
We focus on using the interdependency of word senses , so that we can directly address the issue of semantic ambiguity in a whole sentence that arose from the interaction of each word 's sense ambiguity . **[ <- this part is confusing .]
216
Specifically , we assume that there exist strong sense dependencies between a syntactic head and its dependents in the dependency tree , rather than between neighboring words in the sentence .
Specifically , we assume that are strong sense dependencies between a syntactic head , and its dependents in the dependency tree , rather than between neighboring words of a sentence .
217
We confirm the appropriateness of this assumption by showing the superiority of the tree-structured models over the linear-chain models .
We confirm the validity of this assumption , by showing the superiority of the tree-structured models over the linear-chain models .
218
The combined features also enable our model to work even for those words that do not appear in the training data , which the traditional individual classifiers cannot handle .
The combined features also enable our model to work , even for words that do not appear in the training data , which traditional individual classifiers cannot handle .
219
We solve WSD as a labeling problem to a sentence described as a dependency tree , where the vertices correspond to words and the edges correspond to the sense dependencies .
We solve WSD as a labeling problem to a sentence described as a dependency tree , where the vertices correspond to the words , and the edges correspond to the sense dependencies .
220
These results are confirmed on three data sets ( the SemCor corpus and the Senseval-2 and -3 English all-words task test sets ) and on two sense inventories ( WordNet synsets and supersenses ) .
These results are confirmed on three data sets ( the SemCor corpus and the Senseval-2 and -3 English all-words task test sets ) , and on two sense inventories ( WordNet synsets and supersenses ) .
221
In Section 4 , we describe our model with intuitive examples , and the machine learning method we use .
In Section 4 , we describe our model with intuitive examples , and we describe the machine learning method that we use .
222
In Section 5 , 6 , and 7 , we present our experimental setup and results , and an in-depth analysis on the contribution of the sense dependency features .
In Section 5 , 6 , and 7 , we present our experimental setup , the results , and an in-depth analysis on the contribution of the sense dependency features .
223
The WordNet is a broad-coverage machine-readable dictionary ( MRD ) for English , which contains about 150 ,000 words .
The WordNet is a broad-coverage machine-readable dictionary ( MRD ) for English , containing about 150 ,000 words .
224
It also serves as an ontology , in which various kinds of meta data , relations among words and senses , and well-organized hierarchical classification of word senses are defined .
WordNet also serves as an ontology of various kinds of meta data , relations among words and senses , and a well-organized hierarchical classification of word senses that are defined .
225
In the WordNet , nouns and verbs are organized in hierarchical structures with IS-A ( hypernym-hyponym ) relationships among words , as shown in Figure 1 .
As shown in Figure 1 , in WordNet , nouns and verbs are organized into hierarchical structures with IS-A ( hypernym-hyponym ) relationships among words , .
226
Nouns have a far deeper structure than verbs , while that of verbs is transversely developed .
Nouns have a far deeper structure than verbs do , while that the structure of verbs is transversely developed .
227
All nouns and verbs except some top-level concepts are classified into primitive groups called supersenses , which we describe later .
All nouns and verbs , with the exception of some top-level concepts , are classified into primitive groups called supersenses , which we will describe later .
228
Figure 1 shows the WordNet hierarchical structure for the first sense ( financial bank ) of a noun bank , where each line shows a synset with the list of words headed by its supersense label , and an arrow denotes that two synsets are in an IS-A relation .
Figure 1 shows the WordNet hierarchical structure for the first sense ( financial bank ) of a noun bank , where each line indicates a synset with the list of words headed by its supersense label ; an arrow denotes that the two synsets are in an IS-A relation .
229
The synset {group#1 , grouping#1} is a broad semantic category that governs the supersense noun group .
The synset {group#1 , grouping#1} is a broad semantic category that governs the supersense group noun .group .
230
Hence , we can expect them to act as a good smoothing feature for WSD , which would make up for the sparseness of features associated with finer-grained senses .
Hence , we can expect them to act as a good smoothing feature for WSD , which would make up for the problem of the sparseness of features , commonly associated with finer-grained senses .
231
Since senses of a word are ordered according to frequency , the sense ranking acts as a useful feature offering a preference for frequent senses .
Since senses of a word are ordered according to frequency , the sense ranking acts as a useful feature that offers a preference for frequent senses .
232
The first sense classifier is known as a strong baseline in WSD , which can be even considered to be a good alternative to WSD .
The first sense classifier is known as a strong baseline in WSD , which can even be considered as a good alternative to WSD .
233
It is considered to be a good feature that reflects the sense frequency information when sufficient training data is available for every sense .
When sufficient training data is available for every sense this method is considered to be a good feature that reflects the sense frequency information .
234
For this reason , we use this first sense feature instead of the ranking feature , for the supersense-based evaluation .
For such a reason , we use this first sense feature instead of the ranking feature , for the supersense-based evaluation .
235
built a model based on various word semantic similarity measures and graph centrality algorithms , which also used the graph structure incorporating the word-sense dependencies .
built a model based on various word semantic similarity measures , and graph centrality algorithms , which also used the graph structure that incorporates the word-sense dependencies .
236
On the other hand , the traditional approach to the supervised WSD is to solve an independent classification problem for each word .
On the contrary , the traditional approach to supervised WSD is to solve an independent classification problem for each word .
237
However , as we described in Section 1 , this approach cannot deal with the interdependencies among word senses , and may output a semantically inconsistent assignment of senses .
However , as described in Section 1 , this approach cannot handle the interdependencies among word senses , and may output a semantically inconsistent assignment of senses .
238
also took a sequencial tagging approach for the disambiguation of WordNet supersenses .
also took a sequential tagging approach for the disambiguation of WordNet supersenses . [<-This sentence is a bit confusing]
239
However , the dependencies they considered are rather simple ones between the adjacent words , and between either WordNet synsets or supersenses .
The dependencies that they considered , however , are rather simple ones between the adjacent words , and between either WordNet synsets or supersenses .
240
Note additionally that they do not mention how and how much they contribute to the improvement of supervised WSD .
Note additionally , that they do not mention the means or the quality of contribution in improving supervised WSD .
241
One interesting model related is the exponential family model proposed by , which captures the occurrences and co-occurrences of words and senses in a joint probability distribution .
The exponential family model proposed by , captures the occurrences and co-occurrences of words and senses in a joint probability distribution .
242
Although they focused on the use of the co-occurrences of word senses rather than the dependencies , they clarified the contribution of sense co-occurrences to the supervised WSD .
Although they focused on the use of the co-occurrences of word senses rather than that of dependencies , they clarified the contribution of sense co-occurrences to the supervised WSD .
243
In this context , it is of an interest if the sense dependencies on a syntactic structure , rather than on a linear chain , works effectively or not .
In this context , it is of interest to note whether the sense dependencies on a syntactic structure , rather than on a linear chain , works effectively or not .**[why ?]
244
Also , despite the approaches described above , the contribution of sense dependencies for the supervised WSD has not explicitly examined thus far .
Furthermore , despite the approaches described above , the contribution of sense dependencies for the supervised WSD has not been explicitly examined thus far .
245
In Section 1 , we presented one of the most significant problems in WSD - the data sparsity .
In Section 1 , we presented one of the most significant issues in WSD - the data sparsity problem .
246
This problem may even be magnified when we consider the interdependencies of word senses , since the number of features is roughly squared by the combination of two word senses .
This problem may even be magnified , when taking into consideration the interdependencies of word senses , since the number of features is roughly squared by the combination of two word senses .
247
In order to relieve this problem , we use the hierarchical information in the WordNet , including the superordinate words and supersenses , which we describe in Section 2 .1 and 2 .2 .
In order to relieve this problem , we use the hierarchical information in the WordNet , including the superordinate words and supersenses , as described in Section 2 .1 and 2 .2 .
248
The use of the hierarchical information has been motivated by several researches .
The use of hierarchical information has been motivated by several different researches .
249
For example , a WSD system by , which was ranked second in the Senseval-3 , consists of two models : the first model applied to words seen in the training data , and the second model that performs a generalized disambiguation process for words unseen in the data by using the hierarchical information in the WordNet .
For example , a WSD system by , ranked second in the Senseval-3 , consists of two models : the first model applied to words seen in the training data , and the second model performs a generalized disambiguation process for words unseen in the data , by using the hierarchical information in the WordNet .
250
The fine granularity of the WordNet synsets is not just a major obstacle to high-performance WSD , but is sometimes too fine-grained even for a human to disambiguate .
The fine granularity of the WordNet synsets is not just a major obstacle in achieving a high-performance WSD , but is sometimes too fine-grained even for a human to disambiguate .
251
This is reflected in the low inter-annotator agreement of sense tagging ( typically around 70% ) , which implies that WSD models are unlikely to perform better than this accuracy .
This is reflected in the low inter-annotator agreement of sense tagging ( typically around 70% ) , which implies that WSD models would be unlikely to perform better than the accuracy achieved .
252
Also , this fine-grainedness is reported to be not appropriate for many NLP applications .
Also , this fine-grained nature is reported to be inappropriate for many NLP applications .
253
Especially , the use of the supersenses has recently been investigated by , and receiving much attention in the WSD field .
In particular , the use of the supersenses has recently been investigated by , and has received much attention in the WSD field .
254
In this case , the inter-annotator agreements are turned out to reach around 90% .
In this case , the inter-annotator agreements have reached nearly90% .
255
For this reason , we use as our sense inventory the WordNet supersenses as well as the synsets .
For this reason , we use the WordNet supersenses , as well as the synsets as our sense inventory .
256
One is the independent classification of each word 's sense regardless of the sense dependencies among words .
One problem is the independent classification of each word 's sense , regardless of the sense dependencies among words .
257
The other is the scarcity of the training data arose from the fine granularity of the sense distinction .
The other problem is the scarcity of the training data that arose from the fine granularity of the sense distinction .
258
We address these problems by the combination of two methods .
We address these problems by combining two methods .
259
The first is the use of the syntactic dependencies of word senses on a dependency tree .
The first [method ?] is the use of the syntactic dependencies of word senses on a dependency tree .
260
Particularly , we assume that there exist strong dependencies of word senses between a head and its dependents in the dependency tree , rather than between neighboring words in the sentence .
In particular , we assume that there are strong dependencies of word senses between a head and its dependents in the dependency tree , rather than between neighboring words in the sentence .
261
The second is the combination of various coarse-grained sense tag sets with the WordNet synsets .
The second [method ?] combines various coarse-grained sense tag sets with the WordNet synsets .
262
One way is to use them directly as the sense inventory instead of a finer sense inventory .
One way directly uses them as the sense inventory , instead of as a finer sense inventory .
263
The other is to use them in combination with finer sense tag sets .
The other way uses them**[<-define " them " ] in combination with finer sense tag sets .
264
Although the sense disambiguation is still based on the finer senses , the coarser sense tags will help the discrimination of the finer senses , serving generalized information for each fine-grained sense .
Although sense disambiguation is still based on the finer senses , the coarser sense tags will help the discrimination of the finer senses , thereby serving generalized information for each fine-grained sense .
265
This approach has been taken in several hierarchical WSD methods , but never combined with the sense dependencies as we use .
This approach has been taken in several hierarchical WSD methods , but has never been combined with the sense dependencies in a way that have used them .
266
The process of WSD is summarized as below .
The process of WSD is summarized below .
267
In the training phase , all vertex features and edge features are extracted using the gold-standard senses , and the weight vectors for them are optimized over the training data .
In the training phase , all vertex features and edge features are extracted using the gold-standard senses , and the weight vectors are optimized over the training data .
268
The conditional probability of a label sequence / MATH conditioned on a data sequence / MATH is given by / MATH	 , where / MATH and / MATH are the feature vectors for an edge and a vertex , / MATH and / MATH are the weight vectors for them , / MATH and / MATH are the set of components of / MATH associated with an edge / MATH and a vertex / MATH , and / MATH is the partition function which constrains the sum of all the probabilities to be 1 .
The conditional probability of a label sequence / MATH conditioned on a data sequence / MATH is given by / MATH	 , where / MATH and / MATH are the feature vectors for an edge and a vertex , / MATH and / MATH are the weight vectors , / MATH and / MATH are the set of components of / MATH associated with an edge / MATH and a vertex / MATH , and / MATH is the partition function that constrains the sum of all the probabilities to be 1 .
269
Tree-structured CRFs ( T-CRFs ) are different from widely used linear-chain CRFs in that the random variables are organized in a tree structure ( acyclic graph ) .
Tree-structured CRFs ( T-CRFs ) are different from widely used linear-chain CRFs , in that the random variables are organized in a tree structure ( acyclic graph ) .
270
In this model , the optimal label assignment / MATH for an observation sequence / MATH is then calculated by / MATH , where / MATH denotes a vertex corresponding to a word while / MATH denotes the vertex corresponding to its parent in the dependency tree .
In this model , the optimal label assignment / MATH for an observation sequence / MATH is then calculated by / MATH , where / MATH denotes a vertex corresponding to a word , while / MATH denotes the vertex corresponding to its parent in the dependency tree .
271
At the beginning , we parse this sentence with the Sagae and Tsujii 's dependency parser , which outputs parsed trees in the CoNLL-X dependency format .
In the beginning , we parse this sentence with Sagae and Tsujii 's dependency parser , which outputs parsed trees in the CoNLL-X dependency format .
272
For this reason , for the synset-based model , we convert the outputted dependency tree into a tree of content words , as exemplified on the right-hand side of Figure 2 .
Thus , for the synset-based model , we convert the outputted dependency tree into a tree of content words , as exemplified on the right-hand side of Figure 2 .
273
Then , on the right-hand side of Figure 2 , we can see that the dependency between confidence and bank is now described as a direct edge .
Then , on the right-hand side of Figure 2 , the dependency between confidence and bank is now described as a direct edge .
274
Thus , by the compaction of the trees , our model can capture more useful dependencies among word senses .
By the compaction of the trees , therefore , our model can capture more useful dependencies among word senses .
275
Note that for the supersense-based model , we further convert the tree into a tree of nouns and verbs , because supersenses are defined for only these two parts of speech .
For the supersense-based model , we further convert the tree into a tree of nouns and verbs , because supersenses are defined for only these two parts of speech .
276
The inclusion of removed words and dependency relation labels are performed in the same manner as in the synset-based model , and the tree on the right hand side of Figure 2 in this case remains unchanged because the sentence does not contain any adjectives nor adverbs .
The inclusion of removed words and dependency relation labels are performed in the same manner as in the synset-based model ; the tree on the right hand side of Figure 2 in this case remains unchanged , because the sentence does not contain any adjectives nor adverbs .
277
For the linear-chain models , we do not need to parse a sentence .
For the linear-chain models , parsing a sentence is unnecessary .
278
Thus , the process of the tree compaction is performed in the same manner , as described in Figure 3 .
Thus , the process of the tree compaction[ ? ?] is performed in the same manner , as described in Figure 3 .
279
Here , we focus on three words destroy , confidence , and bank in Sentence ( i ) , and for simplicity consider only two major senses for each word as described in Table 3 , so that the number of possible sense assignments is in this case / MATH .
Here , we focus on three words : destroy , confidence , and bank in Sentence ( I ) . For simplicity , we consider only two major senses for each word as described in Table 3 , so that the number of possible sense assignments is / MATH .
280
The first intuition would be that confidence( n )#2 is strongly related to a group or an institution ( financial bank ) but not related to natural landscape ( river bank ) , while confidence( n )#1 depends mostly on persons and not on other entities .
The first intuition would be that confidence( n )#2 is strongly related to a group or an institution ( financial bank ) , but is unrelated to a natural landscape ( river bank ) , while confidence( n )#1 depends mostly on persons and not on other entities .
281
Because bank does not have a " person " meaning , the weight of confidence( n )#2-bank( n )#1 is expected to be higher than other possible sense bigrams .
Because bank does not have a " person " meaning , the weight of confidence( n )#2-bank( n )#1 is expected to be higher than for other possible sense bigrams .
282
Given confidence does not have an " object " meaning , the weights of destroy( v )#2-confidence( n )#1 and destroy( v )#2-confidence( n )#2 would be the largest among others .
Given confidence does not have an " object " meaning , the weights of destroy( v )#2-confidence( n )#1 and destroy( v )#2-confidence( n )#2 would be the largest [largest what ?] among others .
283
These labels represent word senses at various levels , and to be combined with the vertex and edge features .
These labels represent word senses at various levels , and are to be combined with the vertex and edge features .
284
We implement as vertex features a set of typical contextual features widely used in a lot of supervised WSD models .
We implement as vertex features a set of typical contextual features widely used in many supervised WSD models .
285
In order to see whether the sense dependency features are certainly effective or not , we include as vertex features the word forms , lemmas , and parts of speech of both the parent and the child words in the dependency tree .
In order to see the efficiency of sense dependency features , we include as vertex features the word forms , lemmas , and parts of speech of both the parent and the child words in the dependency tree .
286
Using this contextual information and the set of vertex labels / MATH , we construct a set of features on a vertex / MATH by / MATH .
Using this contextual information , and the set of vertex labels / MATH , we construct a set of features on a vertex / MATH by / MATH .
287
Note that this feature is not combined with any sense labels nor contextual information .
Note that this feature is not combined with any sense label nor with any contextual information .
288
For the supersense-based model , we use vertex features based on , which includes some features from the named entity recognition literature such as the word shape features along with the standard feature set for WSD .
For the supersense-based model , we use vertex features based on , which include some features from the named entity recognition literature , including the word shape features , along with the standard feature set for WSD .
289
In this section , we introduce corpora we use for the evaluation .
In this section , we introduce corpora that we have used for the evaluation .
290
SemCor is a corpus , in which all content words are annotated with the WordNet synsets , and consists of balanced 352 files from the Brown Corpus .
SemCor is a corpus in which all content words are annotated with the WordNet synsets , and consists of balanced 352 files from the Brown Corpus .
291
Note that these data sets are different from the originals in that multi-word expressions are already segmented .
These data sets are different from the originals because multi-word expressions are already segmented .
292
However , on the other hand , our model cannot output any answers to multi-word expressions that have no directly corresponding WordNet synsets , because we treat expression as one unit in the process of WSD .
However , our model cannot output any answers to multi-word expressions that have no directly corresponding WordNet synsets , because we treat expression as one unit in the process of WSD .
293
For example , the multi-word expression tear-filled is treated as one instance but not tagged with any WordNet synsets in the converted corpus , while in the original corpus it is tagged with two WordNet synsets for tear and filled .
For example , the multi-word expression tear-filled is treated as one instance , but are untagged with any WordNet synsets in the converted corpus , while in the original corpus it[define " it " ] is tagged with two WordNet synsets for tear and filled .
294
For the evaluation on the Senseval data sets , all instances of the rest ( e.g. SEM-E ) is used for development and one of the Senseval data sets ( SE2 or SE3 ) is used for evaluation .
For the evaluation on the Senseval data sets , all instances of the rest ( e.g. SEM-E ) are used for development , and one of the Senseval data sets ( SE2 or SE3 ) is used for evaluation .
295
As the evaluation measure , we use the standard recall measure , which is equivalent to the precision as we output answers to all instances .
As the evaluation measure , we use the standard recall measure , which is equivalent to the precision as we output answers to all instances . **[This section is a bit monotonous]
296
As they noted , in the WordNet , there is semantically inconsistent labeling of supersenses such that top level synsets are tagged as the supersense noun .Tops rather than the specific supersense they govern .
As noted , in the WordNet , the labeling of supersensesis semantically inconsistent , and top level synsets are tagged as the supersense noun .Tops[ ? ?] rather than the specific supersense they govern .
297
For this reason , we adopted the modification of noun supersenses in the same way as , substituting noun .Tops labels with more specific supersense labels when possible , and left some general nouns with noun .TopsoteNouns which are left with noun .Tops are : entity , thing , anything , something , nothing , object , living thing , organism , benthos , heterotroph , life , and biont . .
For this reason , we adopted the modification of noun supersenses in the same way as , substituting noun .Tops labels with more specific supersense labels when possible , and left some general nouns with noun .TopsoteNouns , which are left with noun .Tops are : entity , thing , anything , something , nothing , object , living thing , organism , benthos , heterotroph , life , and biont . .
298
We ignore the adjective and adverb instances in the evaluation .
We ignore the adjective and adverb instances in the evaluation .**[This section is a bit confusing . Maybe break up the longer sentences to clarify]
299
Table 6 is the list of models we use for the evaluation , where FS and SR correspond to the first sense and sense ranking features respectively , and non-dependency denotes models that do not incorporate sense dependency features ( i.e.
Table 6 is the list of models that we use for the evaluation , where FS and SR correspond to the first sense and sense ranking features respectively , and non-dependency denotes models that do not incorporate sense dependency features ( i.e.
300
In this section , each figure shows the mean recall ( equivalent to the precisions ) averaged over the five trials of the cross validation , the " Diff . " rows show the differences between the dependency models and the non-dependency models , and / MATH and / MATH denote the statistical significance of / MATH and / MATH respectively .
Each figure displays the mean recall ( equivalent to the precisions ) averaged over the five trials of the cross validation , the " Diff . " rows show the differences between the dependency models and the non-dependency models , and / MATH and / MATH denote the statistical significance of / MATH and / MATH respectively .
301
We can see from Table 7 that with the sense frequency information , the tree-structured models ( statistically ) significantly outperformed the non-dependency models on all the data sets .
From Table 7 , it can be seen that with the sense frequency information , the tree-structured models ( statistically ) significantly outperformed the non-dependency models on all the data sets .
302
These improvements seem small in terms of figures ; However , considering for instance the No-Dep-SS-FS model outperforms the Baseline-SS-FS model only by 0 .37% on SEM , the further improvement of 0 .21% is considerable because this means our dependency model could handle 57% more instances over the first sense baseline .
These improvements seem insignificant in figures ; however , considering that for instance the No-Dep-SS-FS model outperforms the Baseline-SS-FS model by only 0 .37% on SEM , the further improvement of 0 .21% is substantial , because it indicates that our dependency model could handle 57% more instances over the first sense baseline .
303
Note that , without the sense frequency information , the synset-based tree-structured model ( Tree-WS ) performed poorer than the non-dependency model ( NoDep-WS ) on all the data sets , whereas the supersense-based model ( Tree-SS ) exhibited the robustness regardless of the existence of the sense frequency information .
Note that , without the sense frequency information , the synset-based tree-structured model ( Tree-WS ) performed worse than the non-dependency model ( NoDep-WS ) on all the data sets , whereas the supersense-based model ( Tree-SS ) exhibited the robustness [of ...] regardless of the existence of the sense frequency information .
304
However , by the incorporation of the sense dependencies , the improvements with the sense ranking features are even smaller , and the deteriorations without them are even larger than in the tree-structured case .
Nonetheless , by the incorporation of the sense dependencies , the improvements with the sense ranking features was even less , and the deteriorations without them[define " them " ] were even more than in the tree-structured case .
305
In the results shown in Table 9 , although some of the differences are marginal , we can see that the tree-structured models outperformed the linear-chain models , focusing on the statistically significant differences .
In the results shown in Table 9 , although some of the differences are marginal , we can see that the tree-structured models outperformed the linear-chain models , focusing on the statistically significant differences .**[<-This is a confusing sentence]
306
These results suggest that although both the dependency trees and the linear chains capture useful dependencies of word senses , the dependencies on the tree structures capture more important information .
Thus , although both the dependency trees and the linear chains capture useful dependencies of word senses , the dependencies on the tree structures capture more important information .
307
Whereas Tree-WS-SR and Tree-WS use all four sense labels for the edge features ( / MATH ) , Tree-WS-SR' and Tree-WS' only use the synset labels ( / MATH ) , so that we can see the contribution of the coarse-grained sense labels .
Whereas Tree-WS-SR and Tree-WS use all four sense labels for the edge features ( / MATH ) , Tree-WS-SR' and Tree-WS' only use the synset labels ( / MATH ) . Thus , we can see the contribution of the coarse-grained sense labels .
308
These results suggest that even though the granularity of the supersenses is sufficient for many NLP tasks , they are too coarse-grained to capture enough information for WSD models ; Therefore , even for the supersense-based disambiguation , we can improve the performance by considering finer-grained senses .
Thus , even though the granularity of the supersenses is sufficient for many NLP tasks , they are too coarse-grained to capture enough information for WSD models ; therefore , for the supersense-based disambiguation , we can improve the performance by considering finer-grained senses .
309
However , considering that all systems in Table 12 except for Simil-Prime utilize other sense-annotated corpora in addition to SemCor , such as the Senseval data sets or example sentences in the WordNet , and our model cannot handle multi-word expressions that do not exist in the WordNet as noted in Section 5 .1 , we can conclude that the performance of our T-CRF model is comparable to that of state-of-the-art WSD systems .
However , taking into consideration that all systems in Table 12 except for Simil-Prime utilize other sense-annotated corpora in addition to SemCor , such as the Senseval data sets or example sentences in the WordNet , and that our model cannot handle multi-word expressions that do not exist in the WordNet as noted in Section 5 .1 , we can conclude that the performance of our T-CRF model is comparable to that of state-of-the-art WSD systems . **[This is a long sentence- shorten .]
310
We call a feature either with a positive lambda or with an alpha larger than 1 as an excitatory feature , while that either with a negative lambda or an alpha smaller than 1 as an inhibitory feature .
We call a feature either with a positive lambda or with an alpha larger than 1 as an excitatory feature , and those features with either with a negative lambda or an alpha smaller than 1 as an inhibitory feature .
311
Thus , although the difference of the recalls is small , we can assume that the sense dependency features in the tree-structured model and those in the linear-chain model have different contributions to the results .
Thus , although the difference of the recalls is small , we can assume that the sense dependency features in the tree-structured model , and those in the linear-chain model have different contributions to the results .
312
One noteworthy point is that more number of noun-noun dependencies are found in the positive instances than in the negative instances , which might suggest that noun-noun dependencies are particularly likely to capture useful dependencies and contribute to positive instances .
One noteworthy point is that more number of noun-noun dependencies are found in the positive instances than in the negative instances , further suggesting that noun-noun dependencies are particularly likely to capture useful dependencies and contribute to positive instances .
313
The first sentence is
The first sentence is :
314
The verb take has surprisingly as many as 42 senses in the WordNet .
Surprisingly , the verb take has as many as 42 senses in the WordNet .
315
But , fortunatelly , the first six senses belong to different supersenses , and our dependency model succeeded in outputting the correct sense take#4 ( SS :verb .contact , take physically ) by making use of the strong dependency SS :verb .contact-SS :noun .substance ( / MATH ) , given dust#1 belongs to noun .substance .
But fortunately , the first six senses belong to different supersenses , and our dependency model succeeded in outputting the correct sense take#4 ( SS :verb .contact , take physically ) by making use of the strong dependency SS :verb .contact-SS :noun .substance ( / MATH ) , given dust#1 belongs to noun .substance .
316
While this verb-object dependency had a large excitatory weight , the corresponding verb-subject dependency had an inhibitory weight ( G1 :have( v )#2-( SBJ )-SS :noun .attribute ( / MATH ) ) , which means the dependency relationlabel also contributed to the result .
While this verb-object dependency had a large excitatory weight , the corresponding verb-subject dependency had an inhibitory weight ( G1 :have( v )#2-( SBJ )-SS :noun .attribute ( / MATH ) ) , which indicates that the dependency relationlabel also contributed to the result .
317
This subject information seems to be not adequate for the disambiguation of show .
This subject information seems to be inadequate for the disambiguation of show .
318
From the phrase career as a player , we can assume that the correct sense of career can be either of two senses , and possibly there is a preference for career#2 , as captured by the largest-weighted dependency WS :career%1%2-( NMOD )-SS :noun .person ( / MATH ) between career and player .
From the phrase career as a player , we can assume that the correct sense of career can be either of two senses , with the possibility that there is a preference for career#2 , as captured by the largest-weighted dependency WS :career%1%2-( NMOD )-SS :noun .person ( / MATH ) between career and player .
319
Since dependencies of this type were not observed in the negative instances at all , they seem to particularly contribute to the positive instances .
Since dependencies of this type were not observed in the negative instances , they seem to particularly contribute to the positive instances .
320
Another interesting result observed is that the noun-noun dependencies in coordination relations work remarkably strongly .
Through our result , we observed that the noun-noun dependencies in coordination relations work remarkably well .
321
Here , the correct sense for nail is nail#2 ( noun .artifact , a thin pointed piece of metal ) and that for level is level#5 ( noun .artifact , indicator of the horizontal ) .
Here , the correct sense for nail is nail#2 ( noun .artifact , a thin pointed piece of metal ) , and that for level is level#5 ( noun .artifact , indicator of the horizontal ) .
322
In our experiments , the sense dependency features were shown to work effectively for WSD , with 0 .29% , 0 .64% , and 0 .30% improvements of recalls for SemCor , Senseval-2 , and Senseval-3 data sets respectively .
In our experiments , the sense dependency features were shown to work effectively for WSD , with a 0 .29% , 0 .64% , and 0 .30% improvement of recalls for SemCor , Senseval-2 , and Senseval-3 data sets , respectively .
323
Despite the small improvements in terms of overall figures , these improvements indeed correspond to 25%-57% improvements over the first sense baseline .
Despite the small improvements in overall figures , these improvements indeed correspond to 25%-57% improvements over the first sense baseline .
324
The dependency tree structures was shown to be appropriate for modeling the dependencies of word senses , by the results that the tree-structured models outperformed the linear-chain models .
The dependency tree structures were shown to be appropriate in modeling the dependencies of word senses , because the results of the tree-structured models outperformed the [results of ?] linear-chain models .
325
Also , the combination of coarse-grained tag sets with the sense dependency features were proved to be effective .
In addition , the combination of coarse-grained tag sets with the sense dependency features were proved to be effective .
326
However , our experiments on the other hand showed that even when combined with the coarse-grained tag sets , the sense dependency features do not improve the performance unless combined with proper sense frequency information , due to the data sparseness problem .
However , our experiments showed that even when combined with the coarse-grained tag sets , the sense dependency features do not improve the performance , unless combined with proper sense frequency information . This is due to the data sparseness problem .
327
The supersense-based WSD models , on the contrary , exhibited the robustness regardless of the existence of the sense frequency information , while they are defeated by the synset-based models in recalls .
The supersense-based WSD models , on the contrary , exhibited the robustness [of ...] regardless of the existence of the sense frequency information , while they are defeated by the synset-based models in recalls .
328
These results show the importance of fine-grained and coarse-grained sense information , and that the combination of both enables us to build a precise and robust WSD system .
These results show the importance of fine-grained and coarse-grained sense information , and show that the combination of both enables us to build a more precise and robust WSD system .
329
Although our model was based on a simple framework and trained only on the SemCor corpus , the results we gained were promising , suggesting that our model still has a great potential for improvement .
Although our model was based on a simple framework , and was trained only on the SemCor corpus , the results that we gained were promising . They suggested that our model still has a great potential for improvement .
330
Generating short summary videos for rushes is a challenging task due to difficulty in redundancy elimination and determination of important objects and events being placed in the summary .
Generating short summary videos for rushes is a challenging task due to the difficulty in eliminating redundancy and determining the important objects and events to be placed in the summary .
331
This makes approaches using one keyframe for shot representation failed in doing clustering .
This makes approaches using one keyframe for a shot representation fail when trying to form a cluster .
332
In addition , even repetitive segments can be determined precisely , the summary generated by concatenating together selected segments still has longer duration than the upper limit .
In addition , even repetitive segments can be precisely determined , but the summary generated by concatenating together the selected segments still takes longer than the upper limit .
333
In this paper , we introduce two approaches to these problems .
,We introduce two approaches to solve these problems .
334
In the first approach , one keyframe is used for shot representation in doing clustering; and sub-segments are selected using motion information for generating the summary .
In the first approach , one keyframe is used for representing a shot when forming a cluster; and sub-segments are selected using the motion information for generating the summary .
335
Meanwhile , in the second approach , all frames of a shot are used for clustering; and a simple skimming method is used to select sub-segments .
Meanwhile , in the second approach , all the frames of a given shot are used for clustering; and a simple skimming method is used to select the sub-segments .
336
Experimental results on the TRECVID 2008 dataset and comparison between the two approaches are reported .
The experimental results on the TRECVID 2008 dataset and a comparison between the two approaches are also reported .
337
Video summarization is a significant research that helps to meet these needs by developing a condensed version of a full length digital video with the most important contents \CITE .
Video summarization significantly helps to meet this need by developing a condensed version of a full length digital video using only the most important contents \CITE .
338
Summary videos can help users to browse and navigate large video archives efficiently and effectively .
Summary videos can help users more efficiently and effectively browse and navigate through large video archives .
339
Generating summary videos for BBC rushes \CITE is a challenging task due to difficulty in redundancy elimination and determination of important objects and events being placed in the summary .
Generating summary videos for BBC rushes \CITE is a challenging task due to the difficulty with redundancy elimination and determining the most important objects and events to be placed in the summary .
340
Since the length of the summary is limited to 2\% duration of the original video , there is a trade-off between recall and usability ( e.g user friendly through smooth presentation , being easy to understand ) .
Since the length of the summary is limited to 2\% duration of the original video , there is a trade-off between the recall and usability ( e.g. user friendly through smooth presentation , / being easy to understand ) .
341
High recall , i.e many objects and events ( called scenes ) are included in the summary , usually reduce the number of frames for each scene .
High recall , i.e. many objects and events ( called scenes ) included in the summary , usually reduces the number of frames for each scene .
342
For the event such as " `Woman attacks man on bench on left and runs off with large bag .
For an event such as " `Woman attacks man on bench on left and runs off with large bag .
343
" ', with this length constraint , it is difficult to present it in a pleasant tempo and rhythm .
" ', with this length constraint , it would be difficult to present it in a pleasant tempo and rhythm .
344
On the contrary , smooth presentation of events consumes a lot number of frames , that decrease the recall .
On the other hand , a smooth presentation of these events would consume a large number of frames , which would decrease the recall .
345
Video segmentation : This step decomposes the original video into segments , such shots or sub-shots .
Video segmentation : This step breaks down the original video into segments , such as shots or sub-shots .
346
Junk elimination : This step removes color bars , clapboards , all black or all white frames that are unnecessary for the final summary video .
Junk elimination : This step removes the color bars , clapboards , and the all black or all white frames that are unnecessary in the final summary video .
347
Summary generation : This step selects frames from representative segments of clusters and concatenate to form the final summary video .
Summary generation : This step selects the frames from the representative segments of clusters and concatenates them to form the final summary video .
348
The question is how to determine the important part of the selected segment such that it conveys information of the scene as much as possible .
The question is how to determine the most important parts of the selected segments so that they convey as much of the information of the scene as possible .
349
The first approach represents each segment by one key-frame and groups similar segments by doing clustering on these key-frames .
The first approach represents each segment by using one key-frame and groups similar segments by clustering them on these key-frames .
350
Then the portion of each segment that has high motion is used to include into the final summary .
Then the portion of each segment that has the highest motion is included in the final summary .
351
Specifically , for each segment , a set of frames are extracted by sampling at a certain time interval ( e.g 5 frames ) .
Specifically , for each segment , a set of frames are extracted by sampling at a certain time interval ( e.g. 5 frames ) .
352
This paper is organized as follows : section \REF introduces details of the first approach; , while section \REF presents details of the second approach .
This paper is organized as follows : section \REF introduces the details of the first approach; , while section \REF presents the details of the second approach .
353
From the definition , all rushes are unedited; therefore it must consist of hard cut only .
By definition , all rushes are unedited; therefore they must consist of hard cuts only .
354
The shot boundary detection algorithm in \CITE is used to determine shot boundary and partition the input video into shots .
The shot boundary detection algorithm in \CITE is used to determine the shot boundary and to partition the input video into shots .
355
A first frame of the shot is chosen as the base frame \MATH and next frame \MATH for comparison .
The first frame of the shot is chosen as the base frame \MATH and the next frame \MATH for a comparison .
356
The \MATH distance used to compute the distance of frame sequence until the sum of the sorted value of lower eight is larger than a threshold \MATH .
The \MATH distance used to compute the distance of the frame sequence until the sum of the sorted value of the lower eight is larger than the threshold \MATH . //[distance / length?]
357
We employ the algorithm proposed in \CITE by using \MATH distance to compute histogram differences between any two neighboring blocks in each column .
We used the algorithm proposed in \CITE by using the \MATH distance to compute the histogram differences between any two neighboring blocks in each column .
358
In rushes videos , there are many types of clapper boards , appearance but the same type of clapper boards is often used in the same movie .
In rushes videos , there are many types of clapper boards , but the same type of clapper board is often used in the same movie .
359
The clapper boards have many types , such as scale , rotation , and illumination changes .
There are many types of clapper boards , such as scale , rotation , and illumination changes .
360
A set of 80 example keyframes of clapper boards are extracted from the development set and used as a set of queries .
A set of 80 example keyframes of clapper boards were extracted from the development set and is used as a set of queries .
361
If a result of the NDK algorithm returns a match between a keyframe with a query then we define the sub-shot is a clapper board sub-shot .
If the result of the NDK algorithm returns a match from a keyframe with a query then the sub-shot is defined as a clapper board sub-shot .
362
The unused keyframes containing of story units for generate video summary are removed .
The unused keyframes containing story units for the generated video summary are removed .
363
To create the efficiently of rushes videos , the repetitive contents must be eliminated .
To efficiently create rushes videos , the repetitive contents must be eliminated .
364
From this characteristic , clustering technique can be used to separate the data into groups of similar contents .
With this characteristic in mind , a clustering technique can be used to separate the data into groups of similar contents .
365
These values are used to represent the keyframes content and defined as follows :
These values are used to represent the keyframes content and are defined as follows :
366
So far , we completely remove the unused contents from rushes video and reduce repetition of the story contents .
So far , we have completely removed the unused contents from rushes videos and reduced any repetition of the story contents .
367
The objective of rushes summarization at TRECVID 2008 is to generate short summaries ( the upper limit of the duration of summary is 2\% of the original video ) , less repetitive of content , and must have many objects and events as possible .
The objective of rushes summarization at TRECVID 2008 is to generate short summaries ( the upper limit of the duration of a summary is 2\% of the original video ) , less repetitive content , and must have as many objects and events as possible .
368
To reach this objective , the important keyframes should be selected to generate summary video .
To reach this objective , only the most important keyframes should be selected to generate a summary video .
369
Third , merge consecutive sub-shots in each cluster into shots and compute the priority of each shot based on priority of shot weighted duration and shot weighted average motion magnitude using the following equation : \MATH</p>
Third , merge the consecutive sub-shots in each cluster into shots and compute the priority of each shot based on the priority of the shot weighted duration and shot weighted average motion magnitude using the following equation : \MATH</p>
370
Forth , sort sub-shots in the selected shot in descending order based on the average motion magnitude .
Fourth , sub-shots in the selected shot in descending order are sorted based on the average motion magnitude .
371
Select sub-shots from top to bottom until the quota length for that shot is reached .
The sub-shots are selected from top to bottom until the quota length for that shot is reached .
372
Fifth , for each selected sub-shot , extract 25 frames ( 1 second ) around the middle to generate the final summary .
Fifth , for each selected sub-shot , 25 frames ( 1 second ) around the middle are extracted to generate the final summary .
373
This system is adopted with some modifications from the system developed for the same task last year \CITE .
This system has some modifications from the system developed for the same task last year \CITE .
374
Specifically , the original video is decomposed into segments , which are shots with hard cut transition .
Specifically , the original video is broken down into segments , which are shots with a hard cut transition .
375
These segments are further decomposed into fragments so that each fragment represents a portion of a scene .
These segments are further broken down into fragments so that each fragment represents a portion of a scene .
376
In order to reduce the computation time , we only extract a subset of frames from the original video by sampling at a five frame interval ( i.e extract frames 0th , 5th , 10th , and so on ) .
In order to reduce the computation time , we only extract a subset of the frames from the original video by sampling it at a five frame interval ( i.e. extract frames 0 , 5th , 10th , and so on ) .
377
Meanwhile , the fragment boundary is determined by using a strict threshold to detect dramatic motion .
Meanwhile , the fragment boundary is determined by using a strict threshold to detect any dramatic motion .
378
We found that this approach is more effective than the approach using one keyframe for one fragment since the more number of keyframes is used , the more information is available to make right decision .
We found that this approach is more effective than the approach using one keyframe for one fragment since the more keyframes that are used , the more information is available to make the right decision .
379
We select junk frames such as color bar frames , single color ( black or white ) frames to form the reference junk frame set .
We select junk frames such as color bar frames , and single color ( black or white ) frames to form the reference junk frame set .
380
If the similarity between one frame in the input fragment and one frame in the reference junk frame set is lower than the predefined thresholds, the input fragment is considered as junk and all fragments of the cluster containing junk fragment are eliminated .
If the similarity between one frame in the input fragment and one frame in the reference junk frame set is lower than the predefined thresholds, the input fragment is considered junk and all the fragments of the cluster containing the junk fragment are eliminated .
381
In our system, we only check fragments that are located at two ends of the original video for reducing computation time .
In our system, we only check the fragments that are located at the two ends of the original video for reducing the computation time .
382
Since the length of these fragments is still larger than the maximum length of the final summary, we employ a simple strategy to shrink these fragments as follows .
Since the length of these fragments is still larger than the maximum length of the final summary, we use the following simple strategy to shrink these fragments .
383
Second, for each fragment, we extract the portion which is expanded from the central of the fragment .
Second, for each fragment, we extract the portion that is expanded from the central part of the fragment .
384
This portion covers a duration twice as much as the fragment quota by selecting frames with sampling rate of 2 frames .
This portion covers a duration twice the size of the fragment quota by selecting the frames with a sampling rate of two frames .
385
Specifically, we select frames \MATH, \MATH, ..., \MATH, \MATH, ..., \MATH, \MATH, where \MATH is the middle frame of the fragment, and \MATH is half of number of frames computed from the quota\MATH and frame rate ( 25fps ) \MATH :
Specifically, we select frames \MATH, \MATH, ..., \MATH, \MATH, ..., \MATH, \MATH, where \MATH is the middle frame of the fragment, and \MATH is half the number of frames computed from the quota\MATH and the frame rate ( 25fps ) \MATH :
386
We have tested our approaches with 40 videos of TRECVID 2008 test set .
We have tested our approaches on 40 videos from the TRECVID 2008 test set .
387
The system NII-2 achieves higher recall ( IN ) than the system NII-1 since NII-1 only uses one keyframe for each sub-shot and has shorter duration ( DU ) for summary videos .
The NII-2system achieves a higher recall ( IN ) than the NII-1 system because NII-1 only uses one keyframe for each sub-shot and has a shorter duration ( DU ) for summary videos .
388
However, NII-1 has a better score in quality .
However, NII-1 has better quality .
389
The summary videos generated by NII-1 have fewer duplications ( RE ), are presented in a smoother way ( TE ) and are easy to judge for inclusions ( TT ) .
The summary videos generated by NII-1 have less duplication ( RE ), are presented in a smoother way ( TE ), and are easy to judge for inclusions ( TT ) .
390
The clapper board detection process using NDK consumes around half of processing time of NII-1 but performance is low due to large variations of clapper boards in videos ( see Figure \REF ) .
The clapper board detection process using NDK consumes around half of the processing time of NII-1, but its performance is low due to the large variations in clapper boards in the videos ( see Figure \REF ) .
391
In addition, by using simple features and sampling frames in the original video, NII-2 significantly speeds up the processing time ( computed from the time taking the input video to the time picking the summary video ) to quasi real-time .
In addition, by using simple features and sampling frames in the original video, NII-2 significantly increases the processing time ( computed from the time the input video is taken to the time the summary video is picked ) to quasi real-time .
392
In Table \REF, we show performance of such systems .
In Table \REF, we present the performance of such systems .
393
The 14 systems listed in this table have IN score larger than the median ( 0.45 ); and other scores such as RE and TE larger than half of maximum score ( 2.5 ) .
The 14 systems listed in this table have an IN score that is above the median ( 0.45 ); and other scores, such as RE and TE, are larger than half of the maximum score ( 2.5 ) .
394
Compared to other systems listed in this list, our system NII-2 is one of the fastest systems .
Compared to the other systems listed in this table, our NII-2system is one of the fastest .
395
Compared to the other systems participating in this task of TRECVID 2008, NII-1 has good performance in measures such as DU and TT ( see Figure \REF and Figure \REF; while NII-2 achieves good performance in measure IN ( see Figure \REF ) .
Compared to the other systems participating in this task of TRECVID 2008, NII-1 performed better in such measures as DU and TT ( see Figure \REF and Figure \REF; while NII-2 performs well in the IN measure ( see Figure \REF ) .
396
Fragmentation is the case that samples of one cluster are put into several different clusters .
Fragmentation is where samples of one cluster are put into several different clusters .
397
Therefore, it is necessary to develop robust methods for detection of repetitive segments .
Therefore, it is necessary to develop robust methods for detecting repetitive segments .
398
Using all frames of one segment instead of using one keyframe as proposed in NII-2 is one of the efforts toward this direction .
Using all the frames of one segment instead of using one keyframe as proposed in NII-2 is one of the current efforts being made towards this end .
399
Although the result is not very high as expected, we still believe that this approach is promising .
Although the results are not as high as expected, we still believe that this approach is promising .
400
We have presented two different approaches for generating short summary for rushes video .
We have presented two different approaches for generating a short summary for rushes videos .
401
In the first approach, NII-1, redundancy elimination is done by doing clustering on the set of keyframes extracted from sub-shots .
In the first approach, NII-1, clustering the set of keyframes extracted from the sub-shots helps to eliminate redundancy .
402
With each representative segment of each cluster, the portion that has high degree of motion is selected to form the summary .
With each representative segment of each cluster, the portion with the highest degree of motion is selected to form the summary .
403
This approach achieves good performance in usability score but low performance in recall .
This approach has a good usability score but is not very good at recall .
404
In the second approach, NII-2, all frames of each sub-shot are used to compute the similarity among sub-shots in clustering process .
In the second approach, NII-2, all the frames of each sub-shot are used to compute the similarity among the sub-shots in the clustering process .
405
With each representative segment of each cluster, the middle part is selected to form the summary with skipping rate of 2 frames .
With each representative segment of each cluster, the middle part is selected to form the summary with a skipping rate of two frames .
406
This approach achieves good performance in recall and reasonable performance in usability score .
This approach is good for recall and has a reasonably good usability score .
407
Compared to other systems participating in TRECVID 2008 summarization task, NII-2 is among best systems that have good balance between recall and usability .
Compared to other systems participating in the TRECVID 2008 summarization task, NII-2 is among the best systems with a good balance between recall and usability .
408
Searching persons is one of the essential tasks required by users for image and video search engines .
Searching for images of people is one of the essential tasks required by users for image and video search engines .
409
However , the current search engines have limited capabilities for this task since they usually rely on texts associated with image and video which are likely to return many irrelevant results .
However , the current search engines have limited capabilities for this task since they usually rely on texts associated with image and video , which are likely to return many irrelevant results .
410
In this paper , we propose a method to effectively retrieve relevant faces for one person by learning visual consistency from results retrieved from text correlation based search engines .
We propose a method to effectively retrieve relevant faces for one person by learning visual consistency from results retrieved from text correlation based search engines .
411
This problem is challenging because ( i ) no any label is provided leading to be difficult to use supervised-based ranking methods .
This problem is challenging because ( i ) there is no label provided making it difficult to use supervised-based ranking methods .
412
In the proposed method , we treat the problem as a classification problem which input faces are classified as 'personX' ( the queried person ) or 'non-personX' and the faces are ranked based on their relevant score that is inferred from the classifier 's probability output .
In the proposed method , we treat this problem as a classification problem in which input faces are classified as 'person-X' ( the queried person ) or 'non-person-X' , and the faces are ranked based on their relevant score inferred from the classifier 's probability output .
413
In order to train this classifier , we use a bagging-based framework to combine results from multiple weak classifiers which are trained using different subsets .
To train this classifier , we use a bagging-based framework to combine results from multiple weak classifiers , which are trained using different subsets .
414
Experimental results on various face sets retrieved from the caption of news photos show that the retrieval performance is improved after each iteration leading the final performance outperforms the baseline algorithms .
Experimental results on various face sets retrieved from the captions of news photos show that the retrieval performance improved after each iteration with the final performance outperforming the baseline algorithms .
415
With the rapid growing of digital technology , large image and video databases are available easier than ever to users .
With the rapid growth of digital technology , large image and video databases are more available than ever to users .
416
Therefore , effective and efficient tools are strongly needed for indexing and retrieving based on visual contents .
Therefore , effective and efficient tools are needed for indexing and retrieving based on visual contents .
417
One of the typical examples for this application is to search a specific person by providing his or her name .
A typical example for this application is searching for a specific person by providing his or her name .
418
However , since it is not necessary faces and names appear simultaneously and are aligned ( as shown in Figure \REF ) , the main drawback of this approach is existence of many irrelevant results that makes the retrieval performance very low .
However , other un-queried faces and names appear simultaneously and are aligned ( as shown in Figure \REF ) , which significantly lowers retrieval performance .
419
Therefore it is necessary to improve the retrieval performance by taking into account visual information from the retrieved faces .
Therefore , it is necessary to improve the retrieval performance by taking into account the visual information from the retrieved faces .
420
-Large variations in face appearance due to pose changes , illumination conditions , occlusions and facial expressions make face recognition difficult even with state of the art techniques \CITE .
-Large variations in face appearance due to pose changes , illumination conditions , occlusions , and facial expressions make face recognition difficult even with state of the art techniques \CITE .
421
-The fact the retrieved face set consists of faces of several persons while no any label is given makes supervised learning methods as well as unsupervised learning methods such as \MATH -means inapplicable .
-The fact the retrieved face set consists of faces of several people with no label makes supervised learning methods as well as unsupervised learning methods such as , \MATH -means , inapplicable .
422
In this paper , we propose a method to solve the mentioned problem .
We propose a method to solve the above-mentioned problem .
423
The main idea is to learn visual consistency assumed to exist among the results returned from current text-based search engines .
The main idea is to assume that there is visual consistency among the results returned from current text-based search engines .
424
The method consists of two stages .
This method consists of two stages .
425
This stage is stemmed from the observation that faces relevant to the queried person tend to form dense clusters while irrelevant faces are very sparse since they look different from each other .
This stage is based on the observation that facial images of the queried person tend to form dense clusters while irrelevant facial images are sparse since they look different from each other .
426
The output is a rank list in which faces having larger number of neighbors within a distance are predicted as relevant ones and therefore are put on the top .
The output is a rank list in which faces with larger number of neighbors within a certain distance are considered as relevant and are therefore put at the top of the list . //[What do you mean by �gneighbors�h ? Do you mean the un-queried faces ? ]
427
It is necessary to use the second stage to improve the rank list .
A second stage is necessary to improve this rank list .
428
We model this problem as a classification problem which input faces are classified as personX ( the queried person ) or non-personX ( the irrelevant person ) .
We model this problem as a classification problem in which input faces are classified as person-X ( the queried person ) or non-person-X ( the irrelevant person ) .
429
This stage is effective for improving the rank list due to the following reasons :
This stage is effective for improving the rank list for the following reasons :
430
-Supervised learning methods such as SVM have strong theoretical background in finding optimal decision boundary even with existence of noisy data .
-Supervised learning methods such , as SVMs , provide a strong theoretical background in finding optimal decision boundary even with existence of noisy data .
431
Furthermore , with recent studies \CITE SVM classifiers can provide probability outputs that are suitable for ranking .
Furthermore , recent studies suggest that \CITE SVM classifiers provide probability outputs that are suitable for ranking .
432
It integrates seamlessly current existing data mining methods such as outliers detection , supervised learning and unsupervised learning based on bagging for a practical problem .
It seamlessly integrates current data mining methods such as outlier detection , supervised learning , and unsupervised learning based on bagging for a practical problem . //[What or who is �glearning�h visual consistency ? Are the search engines learning ? ]
433
There are several approaches proposed for general object classification rather than for face retrieval .
There are several more proposed approaches for general object classification than for those for face retrieval .
434
Compared to the problem of face retrieval based recognition , the problem of object classification is easier since classification of different object types such as airplane and non-airplane only needs to handle inter-variations between different categories while discriminating personA and personB requires to handle both intra-variations and inter-variations of the same category .
Compared to the problem of face-based recognition , the problem of object classification is easier since classification of different object types such as airplane and non-airplane only needs to handle inter-variations between different categories , while discriminating between person-A and person-B requires handling of both intra-variations and inter-variations of the same category .
435
Furthermore , in order to work in unsupervised mode , these approaches need a method to collect negative samples ( e.g. non-airplane ) which are inapplicable in our problem .
Furthermore , in order to work in unsupervised mode , these approaches need a method to collect negative samples ( e.g. non-airplane ) , which are inapplicable to our problem .
436
Working closely to our problem , in \cite{Ozkan06CVPR} , a graph based approach was proposed \CITEin which a graph is formed by faces as nodes and weights of edges linked between nodes are the similarity of faces .
A graph-based approach was proposed by \CITE , in which a graph is formed by faces as nodes , and the weights of edges linked between nodes are the similarity of faces , is closely related to our problem .
437
By assuming that the number of faces of the queried person are larger than that of other persons , and these faces tend to form the most similar subset among the set of retrieved faces , this problem is considered equal to the problem of finding the densest subgraph of a full graph whose solution is available .
Assuming that the number of faces of the queried person is larger than that of others and that these faces tend to form the most similar subset among the set of retrieved faces , this problem is considered equal to the problem of finding the densest subgraph of a full graph with an available solution . //[Do graphs have solutions ? They just provide information .]
438
Furthermore , choosing an optimal threshold to convert the initial graph into a binary graph is difficult and rather ad hoc due to the curse of dimensionality .
Furthermore , choosing an optimal threshold to convert the initial graph into a binary graph is difficult and rather ad hoc due to dimensionality .
439
Although the result was impressive , it is not easy to apply for our problem since a large number of irrelevant faces ( more than 12% ) are eliminated manually before doing clustering .
Although the result was impressive , it is not easy to apply it to our problem since a large number of irrelevant faces ( more than 12% ) are eliminated manually before performing clustering .
440
Given a set of faces returned by any text-based correlation search engine , our method performs a ranking process summarized as follows :
Given a set of faces returned by any text-based correlation search engine , our method is used to perform a ranking process summarized as follows :
441
-Step 6 : Repeat steps from 4 and 5 $T$ times and return ranked faces produced by the last classifier \MATH to users .
-Step 6 : Repeat steps 4 and 5 $T$ times and return ranked faces produced by the last classifier \MATH to users .
442
Step 3 used to find initial ranks for faces is described in \REF .
Step 3 used to find initial ranks for faces described in \REF .
443
Since it is not guaranteed top \MATH and bottom \MATH of faces in the rank list are correctly correspondent to faces of the queried person \MATH and faces of non person \MATH as shown in Figure \REF , selecting randomly subsets to train weak classifiers and then combining these classifiers might help to reduce risk of using noisy training sets .
Since it is not guaranteed that the top \MATH and bottom \MATH of faces in the rank list correctly correspond to the faces of the queried person-\MATH and faces of non person-\MATH as shown in Figure \REF , randomly selecting subsets to train weak classifiers , and then combining these classifiers might help reduce the risk of using noisy training sets .
444
We introduce here two common outliers detection methods including distance-based outliers detection( DBO ) \CITE and local outliers factor based method ( LOF ) \CITE .
We introduce two common outlier detection methods , distance-based outlier detection ( DBO ) \CITE and local outlier factor-based method ( LOF ) \CITE .
445
Adapting the definition \CITE , given a set of objects \MATH , an object \MATH is considered as an outliers if there are fewer than \MATH neighboring objects in \MATH lying within a distance \MATH .
Adapting the definition from Knorr \CITE , given a set of objects \MATH , an object \MATH is considered as an outlier if there are fewer than \MATH neighboring objects in \MATH lying within a distance \MATH .
446
The outliers detection process is summarized as follows :
This outlier detection process is summarized as follows :
447
-Step 2 : For each object , compute \MATH which is the number of neighboring objects lying within a distance \MATH .
-Step 2 : For each object , compute \MATH , which is the number of neighboring objects lying within a distance \MATH .
448
-Step 3 : Compute local reachability density of data object \MATH as inverse of the average reachability distance based on the \MATH ( minimum number of data objects ) nearest neighbors of data object \MATH .
-Step 3 : Compute local reachability density of data object \MATH as inverse of the average reachability distance based on the \MATH ( minimum number of data objects ) of the nearest neighbors to data object \MATH .
449
We selected sixteen celebrities who are government leaders such as George W . Bush ( US ) , Vladimir Putin ( Russia ) , Ziang Jemin ( China ) , Tony Blair ( UK ) , Junichiro Koizumi ( Japan ) , Roh Moo-hyun ( Korea ) , Abdullah Gul ( Turkey ) , and other key persons such as John Paul II ( the Former Pope ) , Kofi Annan and Hans Blix ( UN ) . These persons are selected since their appearances are highly frequent in the dataset \CITE .
We selected sixteen government leaders including George W . Bush ( US ) , Vladimir Putin ( Russia ) , Ziang Jemin ( China ) , Tony Blair ( UK ) , Junichiro Koizumi ( Japan ) , Roh Moo-hyun ( Korea ) , Abdullah Gul ( Turkey ) , and other key individuals such as John Paul II ( the Former Pope ) and Kofi Annan and Hans Blix ( UN ) since their images appeared frequently in the dataset \CITE .
450
On average , the precision is 52.49% .
On average , the precision was 52.49% . //[precision / accuracy ? ]
451
We then used PCA \CITE to reduce the number of dimensions of the feature vector for face representation .
We then used principle component analysis \CITE to reduce the number of dimensions of the feature vector for face representation .
452
The number of eigenfaces was selected so that 97% of the total energy are retained \CITE .
A number of eigenfaces was selected so that 97% of the total energy was retained \CITE . //[What is that number ? ]
453
We evaluated the retrieval performance with measures that are popularly used in information retrieval such as precision , recall and average precision .
We evaluated the retrieval performance with measures that are commonly used in information retrieval such as precision , recall , and average precision .
454
Given a queried person , assuming that \MATH is the total number of faces returned , \MATH is the number of relevant faces , \MATH is the number of relevant faces , we calculate recall and precision as follows :
Given a queried person , assuming that \MATH is the total number of faces returned , \MATH is the number of relevant faces , \MATH is the number of relevant faces , we calculated recall and precision as follows : //[Nrel and Nhit are exactly the same here . They should be different .]
455
In addition , to evaluate performance of multiple queries , we used mean average precision that is the mean of average precisions computed from queries .
In addition , to evaluate the performance of multiple queries , we used mean average precision , which is the mean of average precisions computed from queries .
456
In the baseline method , faces are sorted by the time that the associated news article is published .
In the baseline method , faces were sorted by the time the associated news article was published .
457
We studied effect of choosing number of times \MATH in the Bag-Rank-SVM algorithm .
We studied the effect of choosing the number of times \MATH appeared in the Bag-Rank-SVM algorithm .
458
To select one subset , we set \MATH and \MATH which means 20% of highest ranked faces are used for \MATH and 30% of lowest ranked faces are used for \MATH .
To select one subset , we set \MATH and \MATH which means 20% of the highest ranked faces were used for \MATH and 30% of the lowest ranked faces were used for \MATH .
459
The subsets \MATH and \MATH are generated by randomly selecting with replacement 70% samples of \MATH amd \MATH .
The subsets \MATH and \MATH were generated by randomly selecting with replacement 70% samples of \MATH and \MATH .[�gWith replacement�h does not make sense here . I am not sure what you want to say .]
460
In addition , the performance of the ranking process is improved when using the ensemble classifier .
In addition , the performance of the ranking process improved when the ensemble classifier was used .
461
The performance of different methods shown in Figure \REF indicates that our proposed method outperforms the distance-based outliers detection method and has comparable performance with the supervised method using 5% annotation data .
The performance of different methods shown in Figure \REF indicates that our proposed method outperformed the distance-based outlier detection method and performed comparable to the supervised method using 5% annotation data .
462
Using the rank list estimated from the previous steps , we automatically select a subset of positive and negative samples to train a classifier using SVM with probability outputs .
Using the rank list estimated from the previous steps , we automatically selected a subset of positive and negative samples to train a classifier using SVM with probability outputs . //[Since this is the conclusion , you might want to be more specific on what �gthe previous steps�h are . ]
463
By combining multiple weak classifiers in a bagging framework , the final strong classifier is constructed and produce good results .
By combining multiple weak classifiers in a bagging framework , we constructed the final strong classifier , which produced good results .
464
Human face processing techniques for broadcast video including face detection , tracking and recognition have long been a topic that attracts much research interest due to its crucial value in various applications including video structuring , indexing , retrieval , summarization , etc.
Human face processing techniques for broadcast video , including face detection , tracking , and recognition , have long been a topic that has attracted a lot of research interest due to its crucial value in various applications , such as in video structuring , indexing , retrieval , and summarization .
465
The main reason is human face provides rich information for people 's appearance such as a government leader in a news video , a pitcher in a sport video or a hero in a movie , and is the basis for interpreting facts .
The main reason for this is that the human face provides rich information for people 's appearances , such as for a government leader in a news video , a pitcher in a sports video or a hero in a movie , and is the basis for interpreting facts .
466
This article describes state-of-the art techniques for face detection , tracking and recognition with application to broadcast video .
This article describes some state-of-the art techniques for face detection , tracking , and recognition with applications to broadcast video .
467
Face detection which is the task of localizing faces in an input image is fundamental for any face processing system .
Face detection , which is the task of localizing faces in an input image , is a fundamental part of any face processing system .
468
- Robustness : it should be capable of handling appearance variations of pose changes , size , illuminations , occlusions , complex background , facial expressions , low resolutions , etc.
- Robustness : it should be capable of handling appearance variations , such as pose changes , size , illuminations , occlusions , complex backgrounds , facial expressions , and low resolutions .
469
- Fastness : it should be fast for real-time processing which is an important factor in processing large video archives .
- Quickness : it should be fast in order to perform real-time processing , which is an important factor in processing large video archives .
470
For example , the training time is short , the number of parameters is small and training samples are collected without costly .
For example , the training time is short , the number of parameters is small , and training samples are collected cheaply .
471
Many approaches have been proposed for building fast and robust face detectors \CITE .
Many approaches have been proposed for building faster and more robust face detectors \CITE .
472
Among them , those using advanced learning methods such as neural network , support vector machines and boosting are the best .
Among them , those using advanced learning methods , such as neural network , support vector machines and boosting , are the best .
473
- Window scanning : in order to detect faces at multiple locations and sizes , a fixed window size ( e.g. 24x24 pixels ) is used to extract image patterns at every location and scale .
- Window scanning : in order to detect faces at multiple locations and sizes , a fixed window size ( e.g. 24 x 24 pixels ) is used to extract image patterns at every location and scale .
474
The number of patterns extracted from one 320x240 frame image is large , approximately 160 ,000 in which only a small number of patterns containing face .
The number of patterns extracted from a 320 x 240 frame image is large , approximately 160 ,000 , in which only a small number of patterns contain a face .
475
Other feature types can be listed including pixel intensity \CITE , local binary patterns \CITE and edge orientation histogram \CITE .
Other feature types can be listed including the pixel intensity \CITE , local binary patterns \CITE , and edge orientation histogram \CITE .
476
- Classification : the extracted features is passed through a classifier which is trained beforehand to classify the input pattern associated with these features as a face or a non-face .
- Classification : the extracted features are passed through a classifier that has been previously trained to classify the input pattern associated with these features as a face or a non-face . //[trained / programmed ?]
477
In order to return one final detection per face , it is necessary to combine overlapping detections into a single detection .
In order to return a single final detection per face , it is necessary to combine the overlapping detections into a single detection .
478
Since the number of processed patterns is large while the vast majority of them are non-face , a single classifier based systems such as neural network \CITE and support vector machines \CITE are usually slow .
Since the vast majority of processed patterns are non-face , the single classifier based systems , such as the neural network \CITE and the support vector machines \CITE , are usually slow .
479
In this way , the complexity of classifiers can be adapted corresponding to the increasing difficulty in the input patterns .
In this way , the complexity of classifiers can be adapted to correspond to the increasing difficulty with the input patterns .
480
Training classifiers usually consists of several steps :
Training classifiers usually consist of the following steps :
481
Face patterns are manually collected in images containing faces and then are scaled to the same size and normalized to a canonical pose which eyes , mouth and nose are aligned .
Face patterns are manually collected from images containing faces and then are scaled to the same size and normalized to a canonical pose in which the eyes , mouth , and nose are aligned .
482
Then these face patterns can be used to generate other artificial faces by randomly rotating the images ( about their center points ) up to 10 degree , scaling between 90% and 110% , translating up to half a pixel , and mirroring to enlarge the number of positive samples \CITE .
Then these face patterns can be used to generate other artificial faces by randomly rotating the images ( about their center points ) by up to 10 degrees , scaling them between 90 and 110% , translating them up to half a pixel , and mirroring them to enlarge the number of positive samples \CITE .
483
Collecting non-face patterns are usually done automatically by scanning through images which contain no faces .
The collection of non-face patterns is usually done automatically by scanning through images which contain no faces .
484
The accurate classifier described in \CITE requires about five thousand original face patterns and hundreds of million non-face patterns extracted from 9 ,500 non-face images .
The accurate classifier described in \CITE requires about five thousand original face patterns and hundreds of millions of non-face patterns extracted from 9 ,500 non-face images .
485
- Learning method selection : Basically , in the ideal case with proper settings , advanced learning methods such as neural network , support vector machines and AdaBoost produce similar performance .
- Learning method selection : Basically , in an ideal situation with the proper settings , the advanced learning methods , such as the neural network , support vector machines , and AdaBoost , can perform similarly .
486
Using neural network requires the design of layers , nodes , etc.hich is complicated .
Using a neural network requires the design of layers , nodes , etc. , which is complicated .
487
Therefore , it is preferable to use support vector machines since the number of parameters is only two if using RBF kernel and many tools are available .
Therefore , it is preferable to use support vector machines because only two parameters are necessary if a RBF kernel is used and many tools are available .
488
Face tracking is the process of locating a moving face or several ones in time using a camera , as illustrated in Figure 1 .
Face tracking is the process of locating a moving face or several of them over a period of time using a camera , as illustrated in Fig. 1 .
489
Face is first initialized manually or by a face detector .
A given face is first initialized manually or by a face detector .
490
Different from face detection , the outcome of which is the position and scale of one single face in one single frame , face tracking enables the information acquisition of multiple consecutive faces within consecutive video frames .
This is different from face detection , the outcome of which is the position and scale of one single face in one single frame ; face tracking enables the information acquisition of multiple consecutive faces within consecutive video frames .
491
Although frame-based face detection techniques have demonstrated success on real images , the current ability on detecting faces from video is still primitive .
Although frame-based face detection techniques have been successfully demonstrated on real images , the current ability for detecting faces from video is still primitive .
492
The detector responses can decrease due to different reasons including occlusions , lighting conditions and face pose .
The quality of the detector responses can decrease due to different reasons including occlusions , lighting conditions , and face poses .
493
Without any additional information , these responses can easily be rejected even if they indicate the presence of a face .
Without any additional information , these responses can easily be rejected , even if they indicate the presence of a face .
494
It is therefore important to incorporate the temporal information in a video sequence to provide more complete video segments displaying the person of interest , which is always named as face tracking .
It is therefore important to incorporate the temporal information in a video sequence to provide more complete video segments displaying the person of interest , which is always named as / already called ? face tracking .
495
One of the main applications of face tracking is person retrieval from broadcast video , for example : intelligent fast-forwards " , where the video jumps to the next scene containing a certain person / actor ; or retrieval of different TV interventions , e.g. interviews , shows , etc. , of a given person in a video or a large collection of TV broadcast videos .
One of the main applications for face tracking is in the person retrieval from broadcast video , for example : " Intelligent fast-forwards�E, where the video jumps to the next scene containing a certain person / actor ; or retrieval of different TV interventions , e.g. interviews , shows , etc. , of a given person in a video or a large collection of TV broadcast videos .
496
In [5] , a person retrieval system for feature-length movie video is proposed using straightforward face tracking .
In [5] , the person retrieval system for a feature-length movie video is proposed using straightforward face tracking .
497
At run time a user outlines a face in a frame of the video , and the face tracks within the movie are then ranked according to the similarity to the outlined query face in the manner of Google .
At run time a user outlines a face in a video frame , and the face tracks within the movie are then ranked according to their similarity to the outlined query face in the same way as Google .
498
Face tracking also finds applications in the area of face-name association , the objective of which is to label television or movie footage with the identity of the person present in each frame of the video .
Face tracking is also used in the area of face-name association , the objective of which is to label television or movie footage with the identity of the person present in each frame of the video .
499
Everingham et al [8] proposed an automatic face-name association system .
Everingham et al. [8] proposed an automatic face-name association system .
500
This system uses a face tracker similar with [5] to extract a few hundred tracks of a particular character each in a single shot .
This system uses a face tracker similar to the one in [5] that can extract a few hundred tracks of each particular character in a single shot .
501
For instance , shots containing a particular person can be retrieved by a keyword like " Bush " or " Julia Roberts " instead of an outlined query face as used in [5] .
For instance , shots containing a particular person can be retrieved by a keyword like " Bush " or " Julia Roberts " instead of the use of an outlined query face as used in [5] .
502
Besides broadcast video , face tracker also has important applications in the video used in humanoid robotics , visual surveillance , human-computer interaction ( HCI ) , video conferencing , face-based biometric person authentication , etc.
Besides broadcast video , face tracker also has important applications in the videos used in humanoid robotics , visual surveillance , human-computer interaction ( HCI ) , video conferencing , and face-based biometric person authentication among others .
503
Choosing a face tracker can be a difficult task due to the variety of face trackers available .
Choosing a face tracker can be a difficult task because of the variety of face trackers currently available .
504
Generally speaking , the important issues that should be addressed include speed , robustness and accuracy .
Generally speaking , the important issues that should be addressed include speed , robustness , and accuracy .
505
Can the system run in real time ? Similar with many other processing tools for broadcast video , speed is not the most critical issue because offline processing is permitted in most cases of video structuring and indexing .
Can the system run in real time ? Similar to many other processing tools for broadcast video , speed is not the most critical issue because offline processing is permitted in most video structuring and indexing cases .
506
However , a real-time face tracker will become necessary if the target archive is established from too large quantities of videos , e.g. 24-hour continuous video recording that needs daily structuring .
However , a real-time face tracker will become necessary if a target archive is established from too large a quantity of videos , e.g. 24-hour continuous video recording that needs daily structuring .
507
On the other hand , the speed of the tracker is critical in most cases of applications for non-broadcast video , e.g. HCI .
On the other hand , the speed of the tracker is critical in most of the application cases for non-broadcast video , e.g. HCI .
508
Can the system cope with varying illumination , facial expression , scale , pose , camerawork , occlusion and large head motion ? A number of illumination factors , e.g. light sources , background colors , luminance levels , and media , impact greatly on the change in appearance of a moving face , for instance , when tracking a person who are moving from indoor to outdoor environment .
Can the system cope with varying illuminations , facial expressions , scales , poses , camerawork , occlusion , and large head motions ? A number of illumination factors , e.g. light sources , background colors , luminance levels , and media , impact greatly on the change in appearance of a moving face , for instance , when tracking a person who is moving from an indoor to an outdoor environment .
509
Face tracking also tends to fail under large facial deformations of eyes , nose , mouth , etc. due to facial expression variation .
Face tracking also tends to fail under large facial deformations of the eyes , nose , mouth , etc. due to the facial expression variation .
510
Small face scale always leads to low resolution and will reject most face trackers designed by computer vision researchers .
A smaller face scale always leads to a lower resolution and will reject most face trackers designed by computer vision researchers .
511
Pose variation , i.e. head rotations including pitch , roll and yaw , is another influencing factor , which can cause disappearance of part of the face .
Pose variations , i.e. head rotations including the pitch , roll , and yaw , is another influencing factor , which can cause disappearances of parts of faces .
512
Disappearance of part of the face is also apt to happen due to occlusion by other objects , and motion information may be distracted by alternate motion of them .
The partial disappearance of a face is also apt to happen due to occlusion by other objects , and motion information may be distracted by an alternate motion .
513
Moreover , the task of face tracking becomes even more difficult when the head are moving fast relative to the frame rate so that the tracker fails to arrive in time " .
Moreover , the task of face tracking becomes even more difficult when the head is moving fast relative to the frame rate , so that the tracker fails to �arrive in time�E.
514
This problem is difficult to solve due to a fixed threshold .
This problem is difficult to solve because it has a fixed threshold .
515
Lowering the threshold of the face detector reduces false rejections but increases the number of false detections , and vice versa .
Lowering the threshold of the face detector reduces the number of false rejections , but increases the number of false detections , and vice versa .
516
Face tracking can be considered as an algorithm that analyses the video frames and outputs the location of moving faces within the video frame .
Face tracking can be considered an algorithm that analyzes the video frames and outputs the location of moving faces within the video frame .
517
For each tracked face , three steps are involved that are initialization , tracking and a stopping procedure , as illustrated in Figure 2 .
For each tracked face , three steps are involved , which are the initialization , tracking , and stopping procedures , as illustrated in Fig. 2 .
518
To alleviate these two problems , Chaudhury et al [1] used two face probability maps instead of a fixed threshold to initialize face tracker , one for frontal views and one for profiles .
To alleviate these two problems , Chaudhury et al. [1] used two face probability maps instead of a fixed threshold to initialize the face tracker , one for frontal views and one for profiles .
519
Their experiments showed that the proposed probabilistic detector improved the accuracy over traditional face detector and is able to handle the head movement covering a range of �90 degrees out-of-plane rotation ( yaw ) .
Their experiments showed that the proposed probabilistic detector improved the accuracy more than a traditional face detector and is able to handle the head movement covering a range of �90 degrees out-of-plane rotation ( yaw ) .
520
The exploitation of color is one of the common choices in order to be invariant to facial expression , scale and pose change [4 , 9] .
The exploitation of color is one of the more common choices in order to be invariant to facial expressions , scale , and pose changes [4 , 9] .
521
Another two choices are key-point [5 , 8] and facial features [3 , 6 , 10] , e.g. eyes , nose , mouth , etc. , both of which are more robust to varying illumination and occlusion .
Two other choices are the key-point [5 , 8] and facial features [3 , 6 , 10] , e.g. eyes , nose , mouth , etc. , both of which are more robust to varying illuminations and occlusions .
522
Although the generality of key-point allows for tracking different kinds of objects , without any face-specific knowledge its discriminant power between target and clutter might be in peril under tough conditions , e.g. strong background noise .
Although the generality of key-points allows for tracking different kinds of objects , without any face-specific knowledge its discriminant power between the target and clutter might be in peril under tough conditions , e.g. strong background noise .
523
Facial features enable to track higher-level information from a human face but are weak in low video quality .
Facial features enable the tracking of higher-level information from a human face , but are weak in lower video quality .
524
Most facial-feature-based face trackers [6 , 10] are only tested by using non-broadcast video , e.g. webcam video , and their application potentiality to broadcast video is questionable .
Most facial-feature-based face trackers [6 , 10] have been tested using only non-broadcast video , e.g. webcam video , and their application potentiality to broadcast video is questionable .
525
An appearance-based or featureless tracker matches an observation model of the entire facial appearance with the input image , instead of choosing a few features to track .
An appearance-based or featureless tracker matches an observation model of the entire facial appearance with the input image , instead of choosing only a few features to track .
526
One example of appearance-based face tracker is [1] that has been introduced above .
One example of an appearance-based face tracker is [1] , which was introduced above .
527
Another example is proposed by Li et al [9] , which uses a multi-view face detector to detect and track faces of different poses .
Another example was proposed by Li et al. [9] , which uses a multi-view face detector to detect and track faces from different poses .
528
It is based on the idea that head can be considered as the object of interest instead of face because face is not always present in the tracking process .
It is based on the idea that a head can be considered an object of interest instead of a face , because the face is not always present in the tracking process .
529
An extended particle filter is proposed to fuse these two interrelated information so as to handle the occlusion due to out-of-plane head rotation ( yaw ) that is more than �90 degrees .
An extended particle filter is proposed to fuse these two interrelated information together so as to handle the occlusion due to out-of-plane head rotation ( yaw ) that is more than �90 degrees .
530
Examples of simple motion models are as follows .
Some examples of simple motion models are as follows .
531
Based on the assumption that face can be considered as a planar object , the corresponding motion model can be a 2D transformation , e.g. affine transformation or homography , of an image of the face , e.g. the initial frame [3 , 6] .
Based on the assumption that a face can be considered a planar object , the corresponding motion model can be a 2D transformation , e.g. affine transformation or homography , of an image of the face , e.g. the initial frame [3 , 6] .
532
Some researchers assume the face as a rigid 3D object , thus the motion model defines its aspect depending on its 3D position and orientation [10] .
Some researchers view a face as a rigid 3D object , thus the motion model defines its aspect depending on its 3D position and orientation [10] .
533
Generally if the quality of the video is high , more sophisticated motion model is used , more accurate result the face tracker generates .
Generally if the quality of the video is high , a more sophisticated motion model is used , and then the face tracker generates a more accurate result .
534
For instance , a sophisticated geometry and texture model might suffer from false face detections and drifting less than a simple 2D transformation model .
For instance , a sophisticated geometry and texture model might suffer from false face detections and a level of drifting [less than / that is worse than ?] a simple 2D transformation model .
535
But note that most 3D-based and mesh-based face trackers require relatively clear appearance , high resolution , and limited pose variation of the face , e.g. out-of-plane head rotations ( roll and yaw ) that are far less than �90 degrees .
However , it must be noted that most 3D-based and mesh-based face trackers require a relatively clear appearance , high resolution , and a limited pose variation of the face , e.g. out-of-plane head rotations ( roll and yaw ) that are far less than �90 degrees .
536
This constitutes a major deficiency of face tracking algorithms that are generally not able to stop a face track in case of tracking error , i.e. drifting .
This constitutes a major deficiency for the face tracking algorithms that are generally not able to stop a face track in case of tracking errors , i.e. drifting .
537
Arnaud et al [3] proposed an approach that uses a general object tracker for face tracking and a stopping criterion based on the addition of an eye tracker to alleviate drifting .
Arnaud et al. [3] proposed an approach that uses a general object tracker for face tracking and a stopping criterion based on the addition of an eye tracker to alleviate drifting .
538
If none of the two eyes are in the face region , it will be determined as drifting and the tracking process will be stopped .
If neither of the eyes is in the face region , it will be determined as drifting and the tracking process will be stopped .
539
Besides , most mesh-based trackers and top-down trackers are considered to be able to avoid drifting .
In addition , most mesh-based and top-down trackers are assumed to be able to avoid drifting .
540
However , while most attempts have been made on face tracking for videos with high quality by computer vision researchers , only a limited number of face trackers are designed for broadcast video .
However , while most of the attempts have been on the face tracking for high-quality videos by computer vision researchers , only a limited number of face trackers are designed for broadcast video .
541
A general evaluation criterion , in terms of speed , robustness and accuracy , is needed for performance comparison between face trackers of different purposes .
A general evaluation criterion , in terms of speed , robustness , and accuracy , is needed for a performance comparison between the face trackers with different purposes .
542
Faces that are possibly very relevant or irrelevant are ranked at the top or bottom of the list .
Faces that are possibly very relevant or irrelevant are ranked at the top or bottom of the list , respectively .
543
This trend has shown the need for effective and efficient tools for indexing and retrieving based on visual content .
This trend has shown the need for effective and efficient tools for indexing and retrieving visual content .
544
However , other un-queried faces and names may appear with the queried ones ( as shown in Figure xx ) , and this significantly lowers retrieval performance .
However , other un-queried faces and names may appear with the queried ones ( Figure xx ) , and this significantly lowers the retrieval performance .
545
-Large variations in facial appearance due to pose changes , illumination conditions , occlusions and facial expressions make face recognition difficult even with state-of-the-art techniques\CITE ( see an example in Figure xx ) .
-Large variations in facial appearance due to pose changes , illumination conditions , occlusions , and facial expressions make face recognition difficult even with state-of-the-art techniques\CITE ( see example in Figure xx ) .
546
The main idea is to assume that there is visual consistency among the results returned from text-based search engines ; and then learn this visual consistency through an interactive process .
The main idea is the assumption that there is visual consistency among the results returned from text-based search engines and this visual consistency is then learned through an interactive process .
547
This score is used to form a ranked list , in which faces having high density scores are considered relevant and are put at the top of the list .
This score is used to form a ranked list , in which faces with high-density scores are considered relevant and are put at the top .
548
This subset is then used to train a classifier using supervised methods such as support vector machine ( SVM ) .
This subset is then used to train a classifier using supervised methods such as a support vector machine ( SVM ) .
549
To get the final strong classifier , we use the idea of ensemble learning \CITE in which weak classifiers trained on different subsets are combined to improve the stability and classification accuracy of single classifiers .
To obtain the final strong classifier , we use the [idea / concept?] of ensemble learning \CITE in which weak classifiers trained on different subsets are combined to improve the stability and classification accuracy of single classifiers .
550
The framework seamlessly integrates data mining techniques such as supervised learning , and unsupervised learning based on bagging .
The framework seamlessly integrates data mining techniques such as supervised learning and unsupervised learning based on bagging .
551
A comprehensive evaluation on a large face dataset of many people was carried out and it confirmed that our approach is promising .
A comprehensive evaluation on a large face dataset of many people was carried out and confirmed that our approach is promising .
552
For examples , as described in \CITE , [Reference numbers generally should not be grammatically part of the sentence .
For examples , as described by Fergus et al. \CITE , [Reference numbers generally should not be grammatically part of the sentence .
553
It is better to use the authors�f names .]objects retrieved by an image search engine are re-ranked by extending the constellation model .
It is better to use the authors�f names .] objects retrieved using an image search engine are re-ranked by extending the constellation model .
554
However , these models are complicated , since they require several hundred parameters for learning , and they are susceptible to over-fitting .
However , these models are complicated since they require several hundred parameters for learning and are susceptible to over-fitting .
555
Although the result was impressive , it is not easy to apply it to our problem since it is based on a strong assumption that requires a perfect alignment in the case that the news photo only has one face and its caption only has one name .
Although the result was impressive , it is not easy to apply it to our problem since it is based on a strong assumption that requires a perfect alignment when a news photo only has one face and its caption only has one name .
556
A graph-based approach was proposed by \CITE , in which a graph is formed by faces as nodes , and the weights of edges linked between nodes are the similarity of faces , is closely related to our problem .
A graph-based approach was proposed by Ozkan and Duygu \CITE , in which a graph is formed from faces as nodes , and the weights of edges linked between nodes are the similarity of faces , is closely related to our problem .
557
Assuming that the number of faces of the queried person is larger than that of others and that these faces tend to form the most similar subset among the set of retrieved faces , this problem is considered equal to the problem of finding the densest subgraph of a full graph ; and therefore can be solved by taking an available solution .[It might be unclear as to what " available solution " you are talking about .
Assuming that the number of faces of the queried person is larger than that of others and that these faces tend to form the most similar subset among the set of retrieved faces , this problem is considered equal to the problem of finding the densest subgraph of a full graph ; and can therefore , be solved by taking an available solution . //It might be unclear as to what " available solution " you are talking about . You might want to give more detail here .
558
You might want to give more detail here .] Although , experimental results showed the effectiveness of this method , it is still questionable whether the densest subgraph intuitively describes most of relevant faces of the queried person and it is easy to extend for the ranking problem .
Although experimental results showed the effectiveness of this method , it is still questionable whether the densest subgraph intuitively describes most of the relevant faces of the queried person and it is easy to extend for the ranking problem .
559
Furthermore , choosing an optimal threshold to convert the initial graph into a binary graph is difficult and rather ad hoc due to the curse of dimensionality .
Furthermore , choosing an optimal threshold to convert the initial graph into a binary one is difficult and rather ad hoc due to dimensionality .
560
The good point of the methods \CITE is they are fully unsupervised .
An advantage of these methods \CITE is they are fully unsupervised .
561
However , the bad point is no model is learned to predict new images of the same category .
However , a disadvantage is that no model is learned for predicting new images of the same category .
562
Furthermore , they perform hard categorization on input images that is [It is not clear if " hard categorization " is inapplicable or if the " input images " are inapplicable .]in applicable for re-ranking .
Furthermore , they are used for performing hard categorization on input images that are inapplicable for re-ranking . //It is not clear if " hard categorization " is inapplicable or if the " input images " are inapplicable .
563
This leads the number of collected images is reduced .
This leads to the reduction in the number of collected images .
564
However , different from the methods in \cite{xx} , we used an unsupervised method to select training samples automaticallyCITE .
However , we used an unsupervised method to select training samples automatically , which is different from the methods proposed by Fergus et al. and Li et al. \CITE .
565
This unsupervised method is different from the one in \CITE in its way of modeling the distribution of relevant images .
This unsupervised method is different from the one by Ozkan and Dugyu \CITE in the modeling of the distribution of relevant images .
566
-Step 3 : Estimate the ranked list of these faces by Rank-By-Local-Density-Score .
-Step 3 : Estimate the ranked list of these faces by rank-by-local-density score .
567
-Step 4 : Improve this ranked list by Rank-By-Bagging-ProbSVM . //I found not hits for " rank-by-bagging-probSVM " on the Internet . You might want to double check to see if this is a standard term . The same is true for " rank-by-local-density score " . If this is your own term , you might want to specify this at some point .
-Step 4 : Improve this ranked list using rank-by-bagging-probSVM . //I found not hits for " rank-by-bagging-probSVM " on the Internet. You might want to double check to see if this is a standard term . The same is true for " rank-by-local-density score " . If this is your own term , you might want to specify this at some point .
568
The algorithms used in Step 3 and Step 4 are described in section \REF and section \REF .
The algorithms used in Steps 3 and 4 are described in section \REF and section \REF , respectively .
569
Among the faces retrieved by the text-based search engines for a query of person-\MATH , as shown in Figure \REF , relevant faces usually look similar and can form the largest cluster .
Among the faces retrieved by text-based search engines for a query of person-\MATH , as shown in Figure \REF , relevant faces usually look similar and forms the largest cluster .
570
One approach to re-rank these faces is to do clustering based on visual similarity .
One approach of re-ranking these faces is to cluster based on visual similarity .
571
However , to get ideal clustering result is impossible , since these faces are high dimensional data and the clusters are in different shapes , sizes and densities .
However , to obtain ideal clustering results is impossible since these faces are high dimensional data and the clusters are in different shapes , sizes , and densities .
572
Instead , in \cite{xx} , a graph based approach was proposed CITEin which the nodes are faces and edge weights are the similarities between two faces .
Instead , a graph-based approach was proposed by Ozkan and Dugyu \CITE in which the nodes are faces and edge weights are the similarities between two faces .
573
We use the idea of density-based clustering described in \CITE to solve this problem .
We use the idea of density-based clustering described by Ester et al. and Breunig et al. \CITE to solve this problem . //idea / concept?
574
Specifically , we define local density score ( LDS ) of a point \MATH( i.e. a face ) as the average distance to its k-nearest neighbors :
Specifically , we define the local density score ( LDS ) of a point \MATH( i.e. a face ) as the average distance to its k-nearest neighbors .
575
Since faces are represented in high dimensional feature space , and face clusters might have different sizes , shapes and densities ; we do not use directly the Euclidean distance between two points in this feature space for \MATH .
Since faces are represented in high dimensional feature space , and face clusters might have different sizes , shapes , and densities , we do not directly use the Euclidean distance between two points in this feature space for \MATH .
576
The efficiency of this similarity measure for density-based clustering methods was described . //There is no period here , so it is not clear if there should be a period or there should be more to this sentence that is not here . If the sentence does end here , you might want to go into more detail about who or what " described " this .]
The efficiency of this similarity measure for density-based clustering methods was described . //There is no period here , so it is not clear if there should be a period or there should be more to this sentence that is not here . If the sentence does end here , you might want to go into more detail about who or what " described " this .
577
Step 2 : Rank these faces using LDS( p , k ) ( The higher the more relevant ) .
Step 2 : Rank these faces using LDS( p , k ) ( The higher the score the more relevant ) .
578
One limitation of the local density score based ranking is it could not handle the case that faces of another person have strong association in \MATH-neighbor set ( for example , many duplicates ) .
One limitation of the local density score based ranking is it cannot handle faces of another person strongly associated in the \MATH-neighbor set ( for example , many duplicates ) .
579
This model is applied to faces of the original set and the output probabilistic scores are used to re-rank these faces .
This model is applied to faces of the original set , and the output probabilistic scores are used to re-rank these faces .
580
Since it is not guaranteed that faces lying at two ends of the input rank list correctly correspond to the faces of person-\MATH and faces of non person-\MATH , we adopt the idea of bagging framework \CITE in which randomly selecting subsets to train weak classifiers , and then combining these classifiers help reduce the risk of using noisy training sets .
Since it is not guaranteed that faces lying at two ends of the input rank list correctly correspond to the faces of person-\MATH and faces of non person-\MATH , we adopt the [idea / concept?] of a bagging framework \CITE in which randomly selecting subsets to train weak classifiers , and then combining these classifiers help reduce the risk of using noisy training sets .
581
The details of Rank-By-Bagging-ProbSVM-InnerLoop method , improving an input rank list by combining weak classifiers trained from subsets annotated by that rank list are described in Algorithm 2 .
The details of the Rank-By-Bagging-ProbSVM-InnerLoop method , improving an input rank list by combining weak classifiers trained from subsets annotated by that rank list , are described in Algorithm 2 .
582
Step 1 : Train a weak classifier hi .
Step 1 : Train a weak classifier , hi .
583
Step 1 .1 : Select a set Spos including p% top ranked faces and then randomly select a subset S?pos from Spos .
Step 1 .1 : Select a set Spos including p% of top ranked faces and then randomly select a subset S?pos from Spos .
584
Step 1 .2 : Select a set Sneg including p% bottom ranked faces and then randomly select a subset S? neg from Sneg .
Step 1 .2 : Select a set Sneg including p% of bottom ranked faces and then randomly select a subset S? neg from Sneg .
585
Step 1 .3 : Use S?pos and S? neg to train a weak classifier hj using LibSVM [8] with probability outputs .
Step 1 .3 : Use S?pos and S? neg to train a weak classifier , hj , using LibSVM [8] with probability outputs .
586
Step 3 : Apply Hi to the original face set and form the rank list Ranki by using the output probabilistic scores .
Step 3 : Apply Hi to the original face set and form the rank list , Ranki , using the output probabilistic scores .
587
Step 4 : Repeat steps from Step 1 to Step 3 until Dist2RankList( Ranki?1 ,Ranki ) <= ? .
Step 4 : Repeat steps 1 to 3 until Dist2RankList( Ranki?1 ,Ranki ) <= ? .
588
Step 1 : Rankcur = Rank-By-Bagging-ProbSVM-InnerLoop( Rankprev ) .
Step 1 : Rankcur = Rank-By-Bagging-ProbSVM-InnerLoop ( Rankprev ) .
589
Step 5 : Repeat steps from Step 1 to Step 4 until dist <= ? .
Step 5 : Repeat steps 1 to 4 until dist <= ? .
590
The \MATH distance between two list \MATH and \MATH is defined as follows :
The \MATH distance between two lists , \MATH and \MATH , is defined as follows :
591
Since the maximum value of \MATH is \MATH where \MATH is the number of members of the list , the normalized Kendall tau distance can be written as follows :
Since the maximum value of \MATH is \MATH , where \MATH is the number of members of the list , the normalized Kendall tau distance can be written as follows :
592
We used the dataset described in \CITE for our experiments .
We used the dataset described by Berg et al. \CITE for our experiments .
593
This dataset consists of approximately half a million news [pictures / photos?] and captions from Yahoo News collected over a period of roughly two years .
This dataset consists of approximately half a million news pictures and captions from Yahoo News collected over a period of roughly two years .
594
Only frontal faces were considered since current frontal face detection systems \CITE can work in real time and have accuracies exceeding 95\% .
Only the front of faces were considered since current frontal face detection systems \CITE work in real time and have accuracies exceeding 95\% .
595
44 ,773 faces were detected and normalized to the size of 86\MATH86 pixels .
44 ,773 faces were detected and normalized to 86\MATH86 pixels .
596
We selected fifteen government leaders , including George W. Bush ( US ) , Vladimir Putin ( Russia ) , Ziang Jemin ( China ) , Tony Blair ( UK ) , Junichiro Koizumi ( Japan ) , Roh Moo-hyun ( Korea ) , and Abdullah Gul ( Turkey ) , and other key individuals , such as John Paul II ( the Former Pope ) and Hans Blix ( UN ) , because their images frequently appear in the dataset \CITE .
We selected fifteen government leaders , including George W. Bush ( US ) , Vladimir Putin ( Russia ) , Ziang Jemin ( China ) , Tony Blair ( UK ) , Junichiro Koizumi ( Japan ) , Roh Moo-hyun ( Korea ) , Abdullah Gul ( Turkey ) , and other key individuals , such as John Paul II ( the Former Pope ) and Hans Blix ( UN ) , because their images frequently appear in the dataset \CITE .
597
The eye detector , built with the same approach as in \CITE , had an accuracy of more than 95\% .
The eye detector , built with the same approach as that of Viola and jones \CITE , had an accuracy of more than 95\% .
598
The number of eigenfaces used to form the eigen space was selected so that 97\% of the total energy was retained \CITE .
The number of eigenfaces used to form the eigen space was selected so that 97\% of the total energy was retained \CITE . //It is not clear what you mean by " energy " in this context . This is the first time you mention this term . You might want to specify what kind of energy you are talking about .
599
Precision and recall only evaluate the quality of an unordered set of retrieved faces .
Precision and recall are only used to evaluate the quality of an unordered set of retrieved faces .
600
-\MATH : the fraction of faces lying at the top and bottom of the ranked list that are used to form a positive set \MATH and negative set \MATH for training weak classifiers in Rank-By-Bagging-ProbSVM-InnerLoop .
-\MATH : the fraction of faces at the top and bottom of the ranked list that are used to form a positive set \MATH and negative set \MATH for training weak classifiers in Rank-By-Bagging-ProbSVM-InnerLoop .
601
We empirically selected \MATH ( i .e 40\% samples of the rank list were used ) since larger \MATH will increase the number of incorrect labels and smaller \MATH will cause over-fitting .
We empirically selected \MATH ( i .e 40\% samples of the rank list were used ) since a larger \MATH will increase the number of incorrect labels , and a smaller \MATH will cause over-fitting .
602
This value is used to determine when the inner loop and the outer loop are stopped .
This value is used to determine when the inner loop and the outer loop stop .
603
Note that smaller \MATH requires more number of iterations making the system 's speed slower .
Note that a smaller \MATH requires more iterations , making the system 's speed slower .
604
We have tested other kernel types such as RBF or polynomial , the performance did not change so much .
We have tested other kernel types , such as RBF or polynomial , but the performance did not change much .
605
Text Based Baseline ( TBL ) : Once faces corresponding with images whose captions contain the query name are returned , they are ranked by the time order .
Text Based Baseline ( TBL ) : Once faces corresponding with images whose captions contain the query name are returned , they are ranked in time order .
606
Since we do not know the number of returned faces from text based search engines , we used another input value \MATH defined as the fraction of neighbors and estimated \MATH by the formula : \MATH , where \MATH is the number of returned faces .
Since we do not know the number of returned faces from text-based search engines , we used another input value \MATH , defined as the fraction of neighbors , and estimated \MATH by the formula : \MATH , where \MATH is the number of returned faces .
607
In the case of large number of returned faces , we set \MATH to the maximum value of 200 : \MATH .
For a large number of returned faces , we set \MATH to the maximum value of 200 : \MATH .
608
Unsupervised Ensemble Learning Using Local Density Score ( UEL-LDS ) : This is a combination of ranking by local density scores and then the ranked list is used for training classifier [Singular or plural?]to boost the rank list .
Unsupervised Ensemble Learning Using Local Density Score ( UEL-LDS ) : This is a combination of ranking by local density scores , and the ranked list is used for training a classifier to boost the rank list .
609
Our proposed methods ( LDS and UEL-LDS ) outperform other unsupervised methods such as TBL , DBO and DSG .
Our proposed methods ( LDS and UEL-LDS ) outperform other unsupervised methods such as TBL , DBO , and DSG .
610
Figure \REF shows an examples of top 50 faces ranked by the methods TBL , DBO , DSG and LDS .
Figure \REF shows an examples of the top 50 faces ranked using the TBL , DBO , DSG , and LDS methods .
611
This makes irrelevant faces that are near duplicates ( row 2 and row 3 in Figure \REF( b ) ) ranked higher than relevant faces .
This ranks irrelevant faces that are near duplicates ( rows 2 and 3 in Figure \REF( b ) ) higher than relevant faces .
612
The ensemble classifier \MATH is formed by combination of single classifiers from \MATH to \MATH .
The ensemble classifier \MATH is formed by combining single classifiers from \MATH to \MATH .
613
It clearly indicates that the ensemble classifier is more stable that single weak classifiers .
It clearly indicates that the ensemble classifier is more stable than single weak classifiers . //You use both plural and singular forms of " classifier " here , so it is a bit confusing if you are talking about a single classifier or more than one . I suggest you use the same form throughout if applicable .]
614
We conducted another experiment to show the effectiveness of our approach in which learned models can be used to annotate new faces of other databases .
We conducted another experiment to show the effectiveness of our approach in which learned models are used to annotate new faces of other databases .
615
For each name in the list , we used it as the query to obtain top 500 images from Google Image Search Engine .
We used each name in the list as a query to obtain the top 500 images from the Google Image Search Engine ( GoogleSE ) .
616
Next , these images were processed as the steps described in section \REF : extracting faces , detecting eyes and doing normalization .
Next , these images were processed using the steps described in section \REF : extracting faces , detecting eyes , and doing normalization .
617
On average , the accuracy of the Google Search Engine ( GoogleSE ) is 57 .08\% .
On average , the accuracy of the GoogleSE is 57 .08\% .
618
The performances of SVM-SUP-05 and SVM-SUP-10 correspond to the supervised systems ( cf . section \REF ) that used \MATH of the data set respectively .
The performances of SVM-SUP-05 and SVM-SUP-10 correspond to the supervised systems ( cf . section \REF ) that used \MATH of the data set , respectively .
619
We evaluated the performance by calculating the precision at top 20 returned faces , which is popular for image search engines ; and recall and precision on all detected faces of the test set .
We evaluated the performance by calculating the precision of the top 20 returned faces , which is common for image search engines and recall and precision on all detected faces of the test set .
620
The precision at top 20 of SVM-SUP-05 is poorer than that of UEL-LDS is due to small number of training samples .
The precision of the top 20 of SVM-SUP-05 is poorer than that of UEL-LDS due to the small number of training samples .
621
Consequently , as shown in Figure \REF , the model learned by this set obtained poor performance in recognizing new faces returned by GoogleSE .
Consequently , as shown in Figure \REF , the model learned by this set performed poorly in recognizing new faces returned by GoogleSE .
622
Our approach solely relies on the above assumption , therefore it is not affected by the ranking of text-based search engines .
Our approach solely relies on the above assumption ; therefore , it is not affected by the ranking of text-based search engines .
623
Our future work is to study how to improve the quality of the training sets used in this iteration .
The aim of our future work is to study how to improve the quality of the training sets used in this iteration .
624
In the first stage , a relative density score is used to form a ranked list in which faces ranked at the top or bottom of the list are likely relevant or irrelevant faces .
In the first stage , a relative density score is used to form a ranked list in which faces ranked at the top or bottom of the list are likely to be relevant or irrelevant faces , respectively .
625
Our approach is beneficial in the case multiple faces residing in the returned image as shown in Figure \REF .
Our approach is beneficial when there are several faces in a returned image , as shown in Figure \REF .
626
Although many methods have been proposed for this task , finding a general and robust shot boundary method that is able to handle various transition types caused by photo flashes , rapid camera movement and object movement is still challenging .
Although many methods have been proposed for this task , finding a general and robust shot boundary method that is able to handle the various transition types caused by photo flashes , rapid camera movement , and object movement is still challenging .
627
In this paper , we present a novel approach for detecting video shot boundaries in which we cast the problem of shot boundary detection into the problem of text segmentation in natural language processing .
We present a novel approach for detecting video shot boundaries in which we cast the problem of shot boundary detection into the problem of text segmentation in natural language processing . //detecting / determining?
628
By the formulation that each frame is considered as a word and shot boundaries are treated as boundaries of text segments ( e .g topics ) .
This is possible by assuming that each frame is a word and then the shot boundaries are treated as text segment boundaries ( e.g. topics ) .
629
Text segmentation based approaches that have been well studied in natural language processing can be adopted .
The text segmentation based approaches in natural language processing can be used .
630
Experimental results on various long video sequences show the effectiveness of our approach .
The experimental results from various long video sequences have proven the effectiveness of our approach .
631
Recent advances in digital technology have made many video archives available .
Recent advances in digital technology have made many video archives readily available .
632
Therefore scalable , efficient and effective tools for indexing and retrieving video are needed .
Therefore scalable , efficient , and effective tools for indexing and retrieving video are needed .
633
With a large amount of information encoded in one video , typically the first step of any video processing tools is to segment the input video into elementary shots in which each shot is defined as continuous frames from a single camera at a time .
With a large amount of information encoded in one video , typically the first step of any video processing tools is to segment the input video into elementary shots in which each shot is defined as a continuous frame from a single camera at a given moment .
634
By decomposing a video into shots and then extracting keyframes from these shots , a 30-minute video with 54 ,000 frames can be represented by around 500 keyframes ( 108 times smaller ) which are easily manageable for many video applications in indexing , browsing , summarization , retrieval and so on .
By breaking down a video into individual shots and then extracting the keyframes from these shots , a 30-minute video containing 54 ,000 frames can be represented by around 500 keyframes ( 108 times smaller ) that are easily manageable for many video applications [in / such as? / including?] indexing , browsing , summarization , and retrieval .
635
A cut is an abrupt shot change that occurs in a single frame while a gradual is a slow change that occurs in a number of consecutive frames .
A cut is an abrupt shot change that occurs in a single frame while a gradual is a slow change that occurs over a number of consecutive frames .
636
A fade is usually a change in brightness with one or several solid black frames in between , while a dissolve occurs when the images in the current shot get dimmer and the images of the next shot get brighter \CITE .
A fade is usually a change in brightness with one or several solid black frames in between the key frames , while a dissolve occurs when the images in the current shot get dimmer and the images of the next shot get brighter \CITE .
637
Since these approaches use threshold-based models for detection , their advantage is fast speed .
Since these approaches use threshold-based models for detection , their advantage is they are fast .
638
Recent works \CITE use machine learning methods for making decision and show impressive results on test videos of TRECVID \CITE which is a de-facto benchmark for evaluation of various techniques in shot boundary detection .
Recent works \CITE use machine learning methods for making decisions and have received impressive results on the test videos of TRECVID \CITE , which is a de-facto benchmark for evaluating the various techniques used in shot boundary detection .
639
In this study , we propose a new approach inspired from natural language processing text segmentation techniques in which the problem of shot boundary detection is treated similarly to the problem of text segmentation .
In this study , we propose a new approach that was inspired by the natural language processing text segmentation techniques in which the problem of shot boundary detection is treated similarly to the problem in text segmentation .
640
Specifically , each frame is considered as a word and a set of consecutive frames , forming a shot , is considered as a text segment .
Specifically , each frame is considered a word and a set of consecutive frames , forming a shot , is considered a text segment .
641
Then , the text segmentation problem can be considered a sequential tagging problem in which each word is labeled by one of labels such as
Then , the text segmentation problem can be considered a sequential tagging problem in which each word is labeled by one of the following labels :
642
PRESEG ( word beginning of a segment ) , INSEG ( word inside a segment ) and POSTSEG ( word outside a segment ) .
PRESEG ( word beginning of a segment ) , INSEG ( word inside a segment ) , and POSTSEG ( word outside a segment ) .
643
Given a video , the shot boundary detection process is carried out through two main stages .
The shot boundary detection process for a given video is carried out through two main stages .
644
We use the following six labels to label frames in video : NORM -FRM ( frame of a normal shot ) , PRE -CUT ( pre-frame of a CUT transition ) , POST -CUT ( post-frame of a CUT transition ) , PRE -GRAD ( pre-frame of a GRADUAL transition ) , IN -GRAD ( frame inside a GRADUAL transition ) , POST -GRAD ( post-frame of a GRADUAL transition ) .
We use the following six labels to label frames in a video : NORM -FRM ( frame of a normal shot ) , PRE -CUT ( pre-frame of a CUT transition ) , POST -CUT ( post-frame of a CUT transition ) , PRE -GRAD ( pre-frame of a GRADUAL transition ) , IN -GRAD ( frame inside a GRADUAL transition ) , and POST -GRAD ( post-frame of a GRADUAL transition ) .
645
Given a sequence of labeled frames , shot boundaries and transition types are identified by looking up and processing frames marked by non NORM -FRM label .
Given a sequence of labeled frames , the shot boundaries and transition types are identified by looking up and processing the frames marked with a non NORM -FRM label .
646
In another case , if we encounter a number of frames marked by xxx-GRAD , we can declare a GRADUAL shot boundary occurs at these frames .
In another case , if we encounter a number of frames marked by xxx-GRAD , we can declare that a GRADUAL shot boundary occurs at these frames .
647
To label a frame in video , firstly we extract features for that frame and then use a classifier , that has been trained by annotated frames in advance , to classify it into one of six categories mentioned above .
To label a frame in a video , we must firstly extract the features for that frame and then use a classifier , which has been trained in advance by the annotated frames , to classify it into one of the six categories mentioned above .
648
The feature extraction process and classifier learning using support vector machine ( SVM ) are described in details below .
The feature extraction process and classifier learning using a support vector machine ( SVM ) are described in detail below .
649
We use two typical features that are color moments , edge direction histogram for representing visual information of each frame .
We use two typical features , which are the color moments and edge direction histogram , to represent the visual information of each frame .
650
However , using this representation is not discriminative enough for frame categorization since frames of a shot transition usually have strong relation to their neighbor frames .
However , using this representation is not discriminative enough for frame categorization since the frames of a shot transition usually strongly relate to their neighboring frames .
651
Specifically , for each frame , we compute \MATH distances between the current frame \MATH and neighbor frames ranging from \MATH .
In particular , for each frame , we compute \MATH distances between the current frame \MATH and neighboring frames ranging from \MATH .
652
By this way , we can have a unified framework for shot boundary detection and consequently avoid to have special treatments for different shot boundary types as described in many works participated the TRECVID benchmark \CITE .
In this way , we can have a unified framework for the shot boundary detection and consequently avoid having to give special treatment to the different shot boundary types as described in many of the works that participated the TRECVID benchmark \CITE .
653
The first order ( mean ) , the second order ( variance ) and the third order ( skewness ) color moments are defined as :
The first order ( mean ) , the second order ( variance ) , and the third order ( skewness ) color moments are defined as :
654
where \MATH is the value of the \MATH -th color component of the image pixel \MATH , and \MATH is the number of pixels in the image .
where \MATH is the value of the \MATH -th color component of image pixel \MATH , and \MATH is the number of pixels in the image .
655
The histogram is normalized by the number of all pixels to compensate for different image sizes .
The histogram is normalized by the total number of all the pixels to compensate for different image sizes .
656
We use color moments and edge orientation histogram to compute distances between the current frame \MATH and it neighbor frames as follows :
We use color moments and an edge orientation histogram to compute the distances between the current frame \MATH and its neighboring frames as follows :
657
For edge orientation histogram , there are \MATH values for each input frame image .
For the edge orientation histogram , there are \MATH values for each input frame image .
658
Compute \MATH values which are the Euclidean distance between current frame \MATH and its neighbor frames ranging from \MATH .
Compute \MATH values , which are the Euclidean distances between the current frame \MATH and its neighboring frames ranging from \MATH .
659
In other words , we compute \MATH where \MATH .
In other words , we compute \MATH , where \MATH .
660
It has been very efficiently proved in many pattern recognition applications \CITE .
They have been very efficiently proved to be useful in many pattern recognition applications \CITE .
661
To handle the case of multi-class classification , there are two common approaches .
There are two common approaches for handling multi-class classification .
662
The first one is the one-against-all method that combines \MATH binary classifiers where \MATH is the number of classes .
The first one is the one-against-all method that combines \MATH binary classifiers , where \MATH is the number of classes .
663
The \MATH SVM classifier is trained by positive samples being examples of the \MATH class and negative samples being examples of the other classes .
The \MATH SVM classifier is trained using positive samples as examples of the \MATH class and negative samples as the examples of the other classes .
664
of a CUT transition ) , PRE GRAD ( pre-frame of a GRADUAL transition ) , IN GRAD ( frame inside a GRADUALtransition ) , POST GRAD ( post-frame of a GRADUAL transition ) and NORM-FRM ( normal frame which does not belong to any shot transitions ) .
of a CUT transition ) , PRE GRAD ( pre-frame of a GRADUAL transition ) , IN GRAD ( frame inside a GRADUALtransition ) , POST GRAD ( post-frame of a GRADUAL transition ) , and NORM-FRM ( normal frame that does not belong to any shot transitions ) .
665
To learn this classifier , we manually annotate frames in the training data .
To train this classifier , we manually annotated frames in the training data . //learn / learn about? / find? / educate? / develop? / train?
666
A gradual transition usually has the pattern " ` . . . , PRE-GRAD , IN-GRAD , IN-GRAD , . . . , IN-GRAD , POS-GRAD , . . . " ' and a cut transition usually has the pattern " ` . . . , PRE-CUT , IN-CUT , . . . , IN-CUT , POST-CUT , . . . " ' .
A gradual transition usually has a " ` . . . , PRE-GRAD , IN-GRAD , IN-GRAD , . . . , IN-GRAD , POS-GRAD , . . . " ' pattern and a cut transition usually has a " ` . . . , PRE-CUT , IN-CUT , . . . , IN-CUT , POST-CUT , . . . " 'pattern .
667
Since the classifier occasionally produce false predictions due to variations caused by photo flashes , rapid camera movement and object movement , only using the perfect match between the predefined patterns and sub-sequences usually skips many truth shot boundaries .
Since the classifier occasionally produces false predictions due to the variations caused by photo flashes , rapid camera movement , and object movement , only using the perfect match between the predefined patterns and sub-sequences usually skips many of the true shot boundaries .
668
The number of frames , the number of shot boundaries and types of these sets are shown in Table \REF .
The number of frames , the number of shot boundaries , and the types of these sets are shown in Table \REF .
669
Note that , the number of shot boundaries is equal to the number of frames with PRE-CUT / GRAD label and the number of frames with PRE-CUT / GRAD label is equal to the number of frames with POST-CUT / GRAD label .
Note that , the number of shot boundaries is equal to the number of frames with a PRE-CUT / GRAD label and the number of frames with a PRE-CUT / GRAD label is equal to the number of frames within a POST-CUT / GRAD label .
670
where \MATH is the \MATH-th element of the feature vectors \MATH respectively , \MATH is the number of dimensions .
where \MATH is the \MATH-th element of the feature vectors \MATH , respectively , and \MATH is the number of dimensions .
671
In order to handle the problem of imbalanced training sets where the number of NORM-FRM frames is much larger than other frames , we randomly take \MATH of NORM-FRM frames and 100\% of the other frames to form the training set .
In order to handle the problem of imbalanced training sets where the number of NORM-FRM frames is much larger than other frames , we randomly take the \MATH of NORM-FRM frames and 100\% of the other frames to form the training set .
672
We use LibSVM \CITE to train SVM classifiers with RBF kernel .
We use LibSVM \CITE to train the SVM classifiers with a RBF kernel .
673
The results that were evaluated by a tool provided by TRECVID with standard measurement such as precision , recall and F1 score clearly show that our proposed method significantly outperforms the baseline method and the combination of GCM+EOH obtains the best result .
The results that were evaluated by a tool provided by TRECVID with a standard measurements , such as the precision , recall , and F1 score , clearly show that our proposed method significantly outperforms the baseline method and the combination of GCM+EOH obtains the best result .
674
We evaluated the performance of our system with different choices for taking the number of NORM -FRM frames used in training process .
We evaluated the performance of our system with different choices for taking the number of NORM -FRM frames used in training process . //for / by?
675
Specifically , we selected three sampling rates \MATH which are \MATH and \MATH .
Specifically , we selected three sampling rates \MATH , which were \MATH and \MATH .
676
As shown in Figure \REF , the best performance is obtained with the sampling rate of \MATH .
As shown in Figure \REF , the best performance was obtained at a sampling rate of \MATH .
677
In Table \REF we show the evaluation of using different features for forming the feature vector using distances between current frames and its neighbors .
In Table \REF , we list the evaluation results when using different features to form the feature vector using the distances between the current frames and their neighbors .
678
The first one is GCM , the second one is EOH and the last one GCM+EOH is combination of distances using GCM and distances using EOH .
The first one is GCM , the second one is EOH , and the last one GCM+EOH is a combination of the distances using GCM and the distances using EOH .
679
The number of dimensions of feature vectors using GCM and EOH is 20 while that of feature vectors using GCM+EOH is 40 .
The number of dimensions of the feature vectors using GCM and EOH was 20 , while that of feature vectors using GCM+EOH was 40 .
680
We also compare the proposed method with the baseline method that computes differences in color histograms between two consecutive frames and then decides a shot transitition by using a predefined threshold .
We also compared the proposed method with the baseline method that computes the differences in the color histograms between two consecutive frames , and then decides the shot transition by using a predefined threshold .
681
Therefore , it is difficult to generalize for new test sets .
Therefore , it is generalization is difficult for new test sets .
682
Different from these approaches , in this paper , we have proposed a unified and general framework for shot boundary detection using a text segmentation based approach .
We have proposed a unified and general framework for shot boundary detection that uses a text segmentation based approach .
683
Firstly , we label frames by one of six labels defined for different types of frames : NORM -FRM , PRE -CUT , POST -CUT , PRE -GRAD , IN -GRAD and POST -GRAD .
Firstly , we label the frames with one of the six labels defined for different types of frames : NORM -FRM , PRE -CUT , POST -CUT , PRE -GRAD , IN -GRAD , and POST -GRAD .
684
Experiments on various videos of TRECVID 2003 have shown that our approach is effective .
The experiments we conducted on various videos from TRECVID 2003 have shown that our approach is effective .
685
Recently , boosting is used widely in object detection applications because of its impressive performance in both speed and accuracy .
Recently , boosting has come to be used widely in object detection applications because of its impressive performance in both speed and accuracy .
686
However , learning weak classifiers which is one of the most significant tasks in using boosting is left for users .
However , learning weak classifiers , which is one of the most significant tasks in using boosting , is left to users . //learning / training / identifying / finding?<--Here and throughout , I am not sure that " learning " is the best word choice . If you change it here , it should be changed throughout .
687
Meanwhile , determining the appropriate number of bins for weak classifiers learned by Real AdaBoost is a challenging task because small one might not well approximate the real distribution while large one might cause over-fitting , increase computation time and waste storage space .
Meanwhile , determining the appropriate number of bins for weak classifiers learned by Real AdaBoost is a challenging task because small ones might not accurately approximate the real distribution while large ones might cause over-fitting , increase computation time , and waste storage space .
688
This paper describes a novel method for efficiently learning weak classifiers using entropy measures , called Ent-Boost .
We have developed Ent-Boost , a novel method for efficiently learning weak classifiers using entropy measures . //method / boosting scheme?
689
Then Kullback-Leibler divergence which is the relative entropy between probability distributions of positive and negative samples is employed to select the best weak classifier in the weak classifier set .
Then Kullback-Leibler divergence , which is the relative entropy between probability distributions of positive and negative samples , is used to select the best weak classifier in the weak classifier set .
690
Experiments have shown that strong classifiers learned by Ent-Boost can achieve good performance , and have compact storage space .
Experiments showed that strong classifiers learned by Ent-Boost can achieve good performance and be stored compactly . //[be stored compactly / achieve compact storage?]
691
Results on building a robust face detector are also reported .
The results of building a robust face detector using Ent-Boost showed the boosting scheme to be effective .
692
Boosting [3] and its variants [4] ,[5] ,[6] ,[7] ,[8] ,[9] ,[10] have recently gained a lot of attentions from researchers because of its excellent performance .
Boosting [3] and its variants [4] ? [10] have recently gained much attention from researchers because of their excellent performance .
693
In regards to face detection , for example , the methods described in works [4] ,[5] ,[10] represent the state of the art in terms of both high accuracy and running speed .
In regard to face detection , for example , the methods described in [4] , [5] , and [10] are state-of-the-art in terms of both accuracy and running speed .
694
Typically , each weak classifier is any classifier whose performance is better than random guessing ( i.e. , error rate is less than 0 .5 ) .
Typically , a weak classifier is any classifier whose performance is better than random guessing ( i.e. , its error rate is less than 0 .5 ) .
695
In practical problems , designing and learning weak classifiers are left for practitioners with two main challenges : computational evaluation and discriminant power .
In practical problems , designing and learning weak classifiers leave practitioners with two main challenges : computational evaluation and discriminant power .
696
Generally , for efficient computation , the dimension of the input space of weak classifiers is reduced to much lower than that of the strong classifier .
Generally , for efficient computation , the dimensions of the input space of weak classifiers are reduced be to much smaller than those of the strong classifier[s?] .
697
In object-detection frameworks [4] ,[5] ,[11] ,[12] ,[13] weak classifiers are usually constructed from one or several features .
In object-detection frameworks [4] , [5] , [11] ? [13] , weak classifiers are usually constructed from one or several features .
698
There are two key trends for seeking the most discriminant weak classifier .
Two key trends exist for seeking the most discriminant weak classifier .
699
Besides Haar wavelet features [4] , Gabor wavelets [5] , edge orientation histogram ( EOH ) [11] , orientation dominants [12] , scale invariant feature transform ( SIFT )-based-high-level features [13] and local binary pattern ( LBP ) [15] have also been used .
Besides Haar wavelet features [4] , Gabor wavelets [5] , edge orientation histograms ( EOH ) [11] , orientation dominants [12] , scale invariant feature transform ( SIFT )-based high-level features [13] , and local binary patterns ( LBP ) [15] have also been used .
700
In Discrete AdaBoost [16] , weak classifiers are threshold-functions whose the output is restricted to binary .
In Discrete AdaBoost [16] , weak classifiers are threshold-functions whose output is restricted to binary data. //[data / values??I think you need a noun here?binary what?]
701
This leads weak classifiers are too weak to boost when handling complex data sets .
This leads weak classifiers to be too weak to boost when handling complex data sets .
702
Typically , most current works [5] ,[17] ,[6] ,[8] ,[10] split the data into \MATH bins that are equal width which suffers from following limitations :
Typically , most current works [5] , [6] , [8] , [10] , [17] split the data into \MATH bins that are equal in width . This method suffers from the following limitations : //[works / systems?]
703
-Choosing the appropriate number of bins is undetermined .
-The way to choose the appropriate number of bins is undetermined .
704
Normally , it has been done by trials and errors [6] ,[17] - a tedious task .
Normally , it has been done by trial and error [6] , [17] ? a tedious task .
705
In the training cascade of classifiers [6] ,[17] , when the complexity of the training data changes over time , using the same number of bins for training every layers is not optimal .
In the training cascade of classifiers [6] , [17] , when the complexity of the training data changes over time , using the same number of bins for training every layer is not optimal .
706
Furthermore it might increase computation and training time , waste storage space which is critical in applications with limited resources , for example , face detection on mobile phones .
Furthermore , it might lengthen computation and training time and waste storage space , which is critical in applications with limited resources , for example , face detection on mobile phones .
707
Meanwhile choosing a small number of bins might not well approximate the real densities of the data distribution and thus influence selection of the best weak classifier .
Choosing a small number of bins , however , might not accurately approximate the real densities of the data distribution and could influence the selection of the best weak classifier .
708
It is therefore necessary to have a deterministic method to choose this number of bins automatically and optimally .
A deterministic method is therefore needed to automatically and optimally choose the number of bins .
709
This problem can be formulated as a discretization problem in which subspace boundaries are found by some criteria .
This problem can be formulated as a discretization problem in which subspace boundaries are found by some criteria . //[some criteria?This sounds a bit vague . Could you be more specific?]
710
The entropy based discretization method is an algorithm that automatically selects appropriate thresholds to split feature values into optimal bins by using entropy measurement .
The entropy-based discretization method is an algorithm that automatically selects appropriate thresholds to split feature values into optimal bins by using entropy measurement .
711
Furthermore , many studies have been shown that discretization process might help to improve performance in induction tasks [18] , it can also work with a weighted data distribution ; therefore , it is most appropriate for boosting-based methods .
Furthermore , many studies have shown that the discretization process might help to improve performance in induction tasks [18] and it can also work with a weighted data distribution . Therefore , it is most appropriate for boosting-based methods .
712
Besides learning weak classifiers , selecting the best weak classifier in the large weak classifier set in each round of boosting is also important .
Besides learning weak classifiers , selecting the best weak classifier in the large set of weak classifiers in each round of boosting is also important .
713
Adopting [5] , it is done by choosing the weak classifier that maximizes Kullback-Leibler ( KL ) divergence between two distributions of positive and negative samples .
Following the method used in [5] , it is done by choosing the weak classifier that maximizes Kullback-Leibler ( KL ) divergence between two distributions of positive and negative samples . // [used / proposed?]
714
Originally , Discrete AdaBoost proposed by Freund and Schapire [16] is a learning method of combining weak classifiers to a strong classier .
Originally , Discrete AdaBoost , proposed by Freund and Schapire [16] , was a learning method of combining weak classifiers to form a strong classier .
715
Given a training set \MATH where \MATH and \MATH , a weak classifier \MATH has the form \MATH .
Given a training set \MATH , where \MATH and \MATH , a weak classifier \MATH has the form \MATH .
716
Therefore , in many applications [4] ,[5] ,[7] , it is simplified by associating to one feature \MATH .
Therefore , in many applications [4] , [5] , [7] , it is simplified by associating with one feature \MATH .
717
In boosting process , a distribution \MATH or set of weights over the training samples are maintained and updated so that subsequent weak classifiers focus on the hard classified samples .
In the boosting process , a distribution \MATH or set of weights over the training samples are maintained and updated so that subsequent weak classifiers focus on the strong-classified samples . //[hard / strong?]
718
Real AdaBoost [3] is a generalized version of Discrete AdaBoost in that weak classifiers are real-valued functions instead of binary ones and \MATH is found numerically in general instead of predescription .
Real AdaBoost [3] is a generalized version of Discrete AdaBoost in that weak classifiers are real-valued functions instead of binary ones and \MATH is found numerically instead of by predescription . //[This method also involves?NOTE : A method cannot propose something .
719
This method also proposes designing weak classifiers that partition the input space into subspaces so that its predictions are unique in each subspace .
Do you mean that the creators of this system proposed this?] designing weak classifiers that partition the input space into subspaces so that the predictions are unique in each subspace .
720
Such weak classifiers are used widely in current state of the art object detection systems [5] ,[17] ,[8] .
Such weak classifiers are used widely in current state-of-the-art object detection systems [5] , [8] , [17] .
721
It is proved in [3] that the most appropriate choice for the prediction of the weak classifier on block \MATH to maximize the margin is \MATH where \MATH is a smoothed value in order to handle cases that \MATH is very small or even zero .
It is proven in [3] that the most appropriate choice for the prediction of the weak classifier on block \MATH to maximize the margin is \MATH where \MATH is a smoothed value in order to handle cases in which \MATH is very small or even zero .
722
Real AdaBoost is easy to implement ; however , in practical applications , designing and learning weak classifiers depend on specific applications .
Real AdaBoost is easy to implement , but in practical applications , designing and learning weak classifiers depend on specific applications .
723
In such face detection systems as [5] ,[6] ,[17] ,[8] , weak classifiers are usually associated with one feature .
In such face detection systems as [those described in?] [5] , [6] , [8] , and [17] , weak classifiers are usually associated with one feature .
724
With a very large number of available features , hundreds of thousands , there are a lot of choices to choose one weak classifier for each round of boosting .
With a very large number of available features ? hundreds of thousands ? [there are many candidates from which to / many choices must be made to?] select one weak classifier for each round of boosting .
725
Generally , optimally selecting the suitable weak classifier will make the final strong classifier more robust and efficient .
Optimally selecting the suitable weak classifier makes the final strong classifier more robust and efficient .
726
Furthermore , it can reduce the number of boosting rounds that directly shorten training time .
Furthermore , optimal selection can reduce the number of boosting rounds , thus directly shortening training time .
727
So far , most current studies have been focused on how to measure the discriminant power of weak classifiers in order to select the best weak classifier .
Most studies so far have been focused on how to measure the discriminant power of weak classifiers in order to select the best weak classifier .
728
Many measurements have been proposed ; for example , Bhattacharyya distance [6] , Kullback-Leibler divergence [5] and , recently , Jensen-Shannon divergence [8] and mutual information [9] ( cf . Table 1 .
Many measurements have been proposed , for example , Bhattacharyya distance [6] , Kullback-Leibler divergence [5] , and recently , Jensen-Shannon divergence [8] and mutual information [9] ( Table 1 ) .
729
As shown in Figure 1 , using a fixed number of bins , strong classifiers trained by above measurements give comparable performance .
As shown in Figure 1 , using a fixed number of bins , strong classifiers trained by the above measures give similar performances . //[measurements / measures?]
730
However , it will be shown in section 5 , these performances are affected seriously if different subspace splitting methods are used .
However , as section 5 will show , these performances are affected dramatically if different subspace splitting methods are used .
731
The proposed boosting scheme Ent-Boost is an integration of adaptive entropy-based subspace splitting and the symmetric KL divergence-based weak classifier selection .
The proposed boosting scheme , Ent-Boost , is an integration of adaptive entropy-based subspace splitting and the symmetric KL divergence-based weak classifier selection .
732
In Ent-Boost , each weak classifier is constructed from one feature and trained on the weighted training samples similar to Real AdaBoost .
In Ent-Boost , each weak classifier is constructed from one feature and trained on weighted training samples similar to [those used in?] Real AdaBoost .
733
However , instead of using equal-width binning method like Real AdaBoost [6] ,[17] which is hard to know the suitable number of bins in advance , we use entropy-based discretization method [19] to split the input space into subspaces .
However , instead of using the equal-width binning method used in Real AdaBoost [6] , [17] which has a hard time predicting the suitable number of bins in advance , we use the entropy-based discretization method [19] to split the input space into subspaces .
734
This subspace splitting process is totally automatically in which the stopping criteria of splitting process is determined through using Minimum Description Length Principles ( MDLP ) ( see the next section ) .
This subspace splitting process is totally automatic ; the stopping criteria of the splitting process are determined using minimum description length principles ( MDLP ) . This process will be described in greater detail in the next section .
735
To select the best weak classifier from the input weak classifier set , we use symmetric KL divergence as in [5] which measures the distance between two distributions as follows : \MATH where \MATH and \MATH are probability distributions of a discrete random variable .
To select the best weak classifier from the input weak classifier set , we use symmetric KL divergence as in [5] , which measures the distance between two distributions as follows : \MATH where \MATH and \MATH are probability distributions of a discrete random variable .
736
This formula can be rewritten in entropy terms : \MATH or \MATH where \MATH and \MATH are entropy , and \MATH is cross entropy of \MATH and \MATH .
This formula can be rewritten in entropy terms : \MATH or \MATH where \MATH and \MATH are entropy and \MATH is cross entropy of \MATH and \MATH .
737
As a result , the number of intervals of selected weak classifier varies .
As a result , the number of intervals of the selected weak classifier varies . //[classifier varies / classifiers vary?]
738
This is different from previous methods that fix the number of equal-width intervals in advance .
This is different from previous methods , which fix the number of equal-width intervals in advance .
739
This section gives a brief introduction on automatic subspace splitting using entropy-based discretization .
This section briefly describes automatic subspace splitting using entropy-based discretization .
740
Basically , discretization is a quantizing process that converts continuous values into discrete values ; it typically consists of four steps [18] :
Discretization is a quantizing process that converts continuous values into discrete values . It typically consists of four steps [18] .
741
The stopping criteria are usually selected according to a trade-off between lower arity ( the number of intervals or the number of bins ) and its effect on the accuracy of classification tasks .
The stopping criteria are usually selected by considering a trade-off between lower arity ( the number of intervals or the number of bins ) and its effect on the accuracy of classification tasks .
742
A higher arity can make the understanding of an attribute more difficult , while a very low arity may affect predictive accuracy negatively .
A higher arity can make the complicate the understanding of an attribute , while a very low arity may damage predictive accuracy .
743
Originally , the minimum description length of an object is defined as the minimum number of bits required to uniquely specify that object out of the universe of all objects .
The minimum description length of an object is defined as the minimum number of bits required to uniquely specify that object out of the universe of all objects .
744
The sender needs to convey to proper class labeling of the example set to the receiver .
The sender needs to convey needed information for the proper class labeling of the example set to the receiver .
745
It says that the partition induced by a cut-point is accepted if and only if the length of the message required to send before partition is more than the length of the message required to send after partition .
It says that the partition induced by a cut-point is accepted if and only if the length of the message required to be sent before the partition is more than the length of the message required to be sent after the partition .
746
where \MATH and \MATH \MATH is the number of classes in \MATH Extensive experiments [19] ,[18] recommended that this method should be the first choice for variable discretization because it gives small number of cut-points while maintaining consistency .
where \MATH and \MATH where\MATH is the number of classes in \MATH Extensive experiments [18] , [19] recommended that this method should be the first choice for variable discretization because it gives a small number of cut-points while maintaining consistency .
747
For experiments , face and non-face patterns are of size 24x24 .
For our experiments , face and non-face patterns were of size 24x24 . //[what is the unit here?]
748
Haar wavelet feature that has been widely used in many face detection systems [4] ,[6] ,[14] is used in our experiments .
Haar wavelet features , which have been used in many face detection systems [4] , [6] , [14] , were used in our experiments .
749
It consists of four kinds of features modeled from adjacent basic rectangles with the same size and shape .
These consisted of four kinds of features modeled from adjacent basic rectangles with the same size and shape .
750
Figure 4 shows a comparison of performances of strong classifiers trained by different boosting schemes that are AdaBoost [4] , Real AdaBoost [17] and Ent-Boost .
Figure 4 shows a comparison of the performances of strong classifiers trained by the different boosting schemes : AdaBoost [4] , Real AdaBoost [17] , and Ent-Boost .
751
As for Real AdaBoost , the subspace splitting is done by equal width binning in which the number of bins is arbitrarily selected to be 64 and 128 .
For Real AdaBoost , subspace splitting is done by equal-width binning in which the number of bins is arbitrarily selected to be 64 and 128 .
752
Overall , Ent-Boost has the best result .
Overall , Ent-Boost produced the best result .
753
As for storage space , the Ent-Boost based classifier only employs 6 .79 bins on average which is much smaller than that of Real AdaBoost-based classifiers .
As for storage space , the Ent-Boost-based classifier only uses 6 .79 bins on average , which is much fewer than the number used by Real AdaBoost-based classifiers .
754
It was a cascade of Ent-Boost based classifiers that were trained similar to [4] .
It was a cascade of Ent-Boost-based classifiers that were trained [through a process similar to that used in] [4] .
755
Performances of AdaBoost-based face detector [4] and Ent-Boost based face detector on MIT+CMU test set [1] shown in Table 2 has confirmed the effectiveness of our proposed boosting scheme .
The performances of the AdaBoost-based face detector [4] and our Ent-Boost-based face detector on the MIT+CMU test set [1] confirmed the effectiveness of our proposed boosting scheme ( Table 2 ) .
756
The resulted strong classifier has good performance and compact storage .
The resultant strong classifier has good performance and achieves compact storage .
757
Furthermore , it overcomes the main limitation of Real AdaBoost which is hard to determine the suitable number of bins for subspace splitting .
Furthermore , this new boosting scheme overcomes the main limitation of Real AdaBoost , which is difficulty in determining the suitable number of bins for subspace splitting .
758
By considering the class information and the distribution of the input data in splitting process , this method is generic and can be applied to other applications .
Because it considers the class information and the distribution of the input data in the splitting process , this method is generic and can be used for other applications .
759
This paper describes an efficient feature selection method which quickly selects a small subset out of a given huge feature set for building robust object detection systems .
This paper describes an efficient feature selection method which that quickly selects a small subset out of a given huge feature set ; the proposed method for will be useful for building robust object detection systems .
760
In this filter-based method , features are selected so that not only maximizing their relevance with the target class but also minimizing their mutual dependency .
In this filter-based method , features are selected so that not only to maximizeing their relevance with the target class but also to minimizeing their mutual dependency .
761
As a result , the selected feature set only contains highly informative and non-redundant features which when combined together , significantly improve classification performance .
As a result , the selected feature set only contains only highly informative and non-redundant features , which significantly improve classification performance when combined together , significantly improve classification performance .
762
The relevance and mutual dependency of features are measured by using conditional mutual information ( CMI ) in which features and classes are treated as discrete random variables .
The relevance and mutual dependency of features are measured by using conditional mutual information ( CMI ), in which features and classes are treated as discrete random variables . //[ ,?<--A comma can be used here if the following describes CMI in general .]
763
One of the fundamental research issues in pattern recognition is feature selection which is the task of finding a small subset out of a given large set of features .
One of the fundamental research issues in pattern recognition is feature selection , which is the task of finding a small subset out of a given large set of features .
764
It is significant due to the following three reasons .
Improving the method of accomplishing this task is important due to the following three reasons .
765
First , there are many ways to represent a target object , leading to a huge feature set .
First , there are many ways can be used to represent a target object , and this variety leadsleading to a huge feature set .
766
Second , a huge feature set usually includes many irrelevant and redundant features that can degrade the generalization performance of classifiers , waste storage space and increase training time [2 , 3] .
Second , a huge feature set usually includes many irrelevant and redundant features that can degrade the generalization performance of classifiers , waste storage space , and increase training time [2 , 3] .
767
Furthermore , less complex model is easier to understand and verify .
Furthermore , less complex models is are easier to understand and verify .
768
Generally , feature selection methods can be categorized into two kinds : filter-based approach and wrapper-based approach [5] .
Generally , feature selection methods can be categorized into two kinds : the filter-based approach and the wrapper-based approach [5] .
769
The filter-based approach is independent of any induction algorithm while the wrapper-based approach is associated with a specific induction algorithm to evaluate the goodness of the selected feature subset .
The filter-based approach is independent of any induction algorithm , while but the wrapper-based approach is associated with a specific induction algorithm to evaluate the quality of the selected feature subset . //[goodness / quality / appropriateness?<--If " goodness " is the word you would usually use in your field for this , it is fine , but I would suggest a different word choice otherwise . " Goodness " seems vague , so in what sense do you mean " good " ?]
770
In the filter-based approach , features are normally selected based on their individual predictive power which is measured by Fisher scores , Pearson correlation [6] or mutual information [7] .
In the filter-based approach , features are normally selected based on their individual predictive power . This power is measured by Fisher scores , Pearson correlation [6] , or mutual information [7] .
771
The major advantage of these methods is their speed and ability to scale to huge feature sets .
The major advantage of these measurement methods is their speed and ability to scale to huge feature sets .
772
However , the mutual relationships between features is often not taken into account , leading selected features might be highly redundant and less informative because two features with high individual predict power when combined together might not bring significant performance improvement compared with two features which one of them has low predictive power but is useful when combined with others .
However , because the mutual relationships between features is are often not taken into account , leading the selected features might be highly redundant and less informative because two features with high individual predictive power , when combined together , might not bring significant performance improvement . Combining compared with two features of which one of them has low predictive power but is useful when combined with others would thus be more effective for improving performance .
773
Since wrapper-based feature selection methods use machine learning algorithms as a black box in selection process , they can suffer from over-fitting in situations of small training sets .
Since wrapper-based feature selection methods use machine learning algorithms as a black box in the selection process , they can suffer from over-fitting in situations of when applied to small training sets . //[when used with / when applied to?]
774
Furthermore , in practical object detection systems as in [1 , 8] , the feature sets usually have hundreds of thousands features , using wrapper-based methods is obviously inefficient because of very high computation cost .
Furthermore , in practical object detection systems as in [1 , 8] , the feature sets usually have hundreds of thousands of features , so using wrapper-based methods is obviously inefficient because of the very high computation costs they incur .
775
For example , in the state of the art face detection system [1] , choosing a 6 ,061- feature set out of a 180 ,000-feature set by AdaBoost has taken several weeks .
For example , in the state- of- the- art face detection system in [1] , choosing a 6 ,061- feature set out of a 180 ,000-feature set by using AdaBoost has takentook several weeks . //[by using / generated by?]
776
Consequently , conditional mutual information ( CMI ) based feature selection methods have been proposed [9 , 8 , 7 , 10] to take full advantage of above approaches for handling large scale feature sets .
Consequently , feature selection methods based on conditional mutual information ( CMI ) based feature selection methods have been proposed [9 , 8 , 7 , 10] to take full advantage of the above approaches for handling large scale feature sets .
777
The main idea of CMI-based methods is to select features which maximize their relevance with the target class and simultaneously minimize mutual dependency between selected ones .
The main goal of these CMI-based methods is to select features which that maximize their relevance with the target class and to simultaneously minimize mutual dependency between selected ones . //[idea / goal?]
778
It does not select a feature similar to already selected ones , even if it is individual powerful , as selecting it might not increase much information about the target class [7] .
It doesThese methods do not select a feature similar to ones already selected ones , even if itthe feature is individually powerful , as because selecting it might not do much to increase much information about the target class [7] .
779
One of the important tasks in using CMI-based methods is mutual information estimation which involves to compute probability densities of continuous random variables .
One of the important tasks in using CMI-based methods is mutual information estimation , which involves to computecomputing the probability densities of continuous random variables .
780
In [9] , Kwak and Choi used Parzen windows based density estimation method in which many parameters such as kernel function and window width are complicated to determine .
In [9] , Kwak and Choi used a Parzen windows -based density estimation method in which many parameters such as kernel function and window width are complicated to determine .
781
For simplification , discretizing features is often used .
For simplification , discretizing features is often used on the features . //[discretizing features is often used on the features / the features are often discretized?]
782
So far , in object detection systems like [8 , 7] , features are treated as binary random variables by choosing appropriate thresholds .
So far , in object detection systems like [8 , 7] treat , features are treated as binary random variables by choosing appropriate thresholds .
783
However , binarizing features is not a suitable way to handle highly complex data for which it is hard to find the best threshold .
However , binarizing features is not a suitable way to handle highly complex data for which it is hard to finding the best threshold is difficult .
784
It is better if multiple thresholds are used to discretize data .
Using multiple thresholds to discretize data is better than using a binary approach .
785
Such a simple method is equal-width binning which divides the range of feature values into m equal sized bins , where m must be known in advance .
Such a simple method is equal-width binning , which divides the range of feature values into m equally sized bins , where m must be known in advance .
786
However , the main distinguished point is that it employs the entropy-based discretization method [11] to discretize features .
However , the method�fs main distinguishing point is that it employs the entropy-based discretization method [11] to discretize features . //[distinguishing / unique?]
787
This discretization method is simpler than Parzen windows based density estimation method and more efficient than binary discretization .
This discretization method is simpler than the Parzen window-s based density estimation method and is more efficient than binary discretization .
788
Furthermore , contrary to equal-width binning , it can automatically evaluate the optimal number of bins based on data distribution .
Furthermore , contrary to equal-width binning , it can automatically evaluate the optimal number of bins based on data distribution . //[evaluate / determine?]
789
Experiments show that the proposed method can well handle huge feature sets for face detection such as Haar wavelets [1] and Gabor wavelets [12] , significantly reduce the training time while maintaining high classification performance .
Experiments show that the proposed method can well capably handle huge feature sets of data such as Haar wavelets [1] and Gabor wavelets [12] for face detection , significantly reducinge the training time while maintaining high classification performance .
790
Huge feature sets usually contain four kinds of features : ( i ) irrelevant features , ( ii ) weakly relevant and redundant features , ( iii ) weakly relevant but non-redundant features and ( iv ) strongly relevant features in which ( iii ) and ( iv ) are the objective of feature selection methods [13] .
Huge feature sets usually contain four kinds of features : ( i ) irrelevant features , ( ii ) weakly relevant and redundant features , ( iii ) weakly relevant but non-redundant features , and ( iv ) strongly relevant features ; in which ( iii ) and ( iv ) are the objectives of feature selection methods [13] .
791
To measure relevance of a feature , the entropy-based measure which quantifies the uncertainty of random variables is normally used .
To measure the relevance of a feature , an entropy-based measure , which quantifies the uncertainty of random variables , is normally used .
792
The mutual dependence between two random variables is measured by mutual information \MATH .
The mutual dependence between two random variables is measured by mutual information : \MATH .
793
The conditional mutual information is defined as : \MATH
The conditional mutual information is defined as : \MATH .
794
In the first step , the most relevant feature F1 which has the highest mutual information is selected .
In the first step , the most relevant feature F1 , which has the highest largest amount of mutual information , is selected .
795
However , in the second step , the condition to select feature F2 is not its mutual information alone , but how much information of F2 can add with respect to the already existing F1 .
However , iIn the second step , however , the condition to select feature F2 is not its mutual information alone , but how much information of F2 can add with respect to the already existing F1 .
796
Therefore , F2 is selected so that maximizing :\MATH .
Therefore , F2 is selected so that maximizingas to maximize the information it can add :\MATH .
797
Following the same scheme , we iteratively add the feature that brings the highest increase of information content contained in current selected feature set .
Following the same scheme, we iteratively add the feature that brings the highest increase of the information content contained in the current selected feature set . //[the / an?<-- " An " is correct if there is more than one such measure .]
798
In order to simply estimate mutual information , the easiest way is features are discretized in binary values by specifying thresholds [8 , 7] .
To simply estimate mutual information , the easiest way is to discretize features are discretized in binary values by specifying thresholds [8 , 7] .
799
However , for complex data , it is not efficient ; therefore , we use entropy-based method proposed by Fayyad and Irani [11] for discretization .
However , for complex data , doing thisit is not efficient ; therefore , we use the entropy-based method proposed by Fayyad and Irani [11] for discretization .
800
This method is a supervised method , thus it is generic and can adapt very well to any kind of data distributions .
This method is a supervised method , thus so it is generic and can adapt very well to any kind of data distributions .
801
Basically , discretization is a quantizing process that converts continuous values into discrete values .
Discretization is essentially a quantizing process that converts continuous values into discrete values .
802
Suppose that we are given a set of instances S , a feature A and a cut-point T ( a cutpoint is a threshold value that divides the range of continuous values into two intervals ; one interval is less than or equal to the threshold , and the other interval is greater than the threshold ) .
Suppose that we are given a set of instances S , a feature A , and a cut-point T . ( A cut-point is a threshold value that divides the range of continuous values into two intervals ; one interval is less than or equal to the threshold , and the other interval is greater than the threshold . ) .
803
Among candidate cut-points , the best candidate cut-point Tmin which minimizes the entropy function \MATH is selected to split \MATH into two partitions \MATH and \MATH .
Among candidate cut-points , the best candidate cut-point Tmin , which minimizes the entropy function \MATH , is selected to split \MATH into two partitions \MATH and \MATH .
804
Using MDLP , the stopping criteria is proposed by Fayyad and Irani [11] as follows :
Using MDLP , the stopping criteria is was proposed by Fayyad and Irani [11] as follows :
805
MDLP Criteria : A partition induced by cut-point T for a set S of N examples is accepted if : \MATH Where \MATH ,where \MATH , \MATH , \MATH is the number of classes in \MATH , \MATH , \MATH .
MDLP Criteria : A partition induced by cut-point T for a set S of N examples is accepted if : \MATH wWhere \MATH ,where \MATH , \MATH , and \MATH is are the numbers of classes in \MATH , \MATH , and \MATH , respectively .
806
Extensive experiments [11 , 14] have shown that this method is one of the best variable discretization one because it gives small number of cut-points while maintaining consistency .
Extensive experiments [11 , 14] have shown that this method is one of the best in variable discretization one because it gives a small number of cut-points while maintaining consistency .
807
Another set of 10 ,000 complex non-face patterns were false positives collected by running a face detector based on a cascade of 17 AdaBoost classifiers at different locations and scales on 8 ,440 images with various subjects , such as rocks , trees , buildings , scenery , and flowers , containing no faces .
Another set of 10 ,000 complex non-face patterns were false positives collected by running a face detector based on a cascade of 17 AdaBoost classifiers at different locations and scales on 8 ,440 images that contained no faces ; the images with included various subjects , such as rocks , trees , buildings , scenery , and flowers , containing no faces .
808
Two types of features that are Haar wavelet feature and Gabor wavelet feature were used in experiments .
Two types of features ?that are Haar wavelet features and Gabor wavelet features ? were used in our experiments .
809
It consists of four kinds of features modeled from adjacent basic rectangles with the same size and shape .
They consists of four kinds of features modeled from adjacent basic rectangles with the same size and shape . //I�fm not 100 percent clear on what " they " points to here . " These Haar wavelet features , " perhaps? But can features consist of other kinds of features? You may want to clarify here .]
810
Gabor wavelet features have also often been used in face recognition systems [12] and are defined as : \MATH where \MATH and \MATH define the orientation and scale of the Gabor kernels respectively , \MATH , and the wave vector \MATH , is defined as : \MATH where \MATH , \MATH \MATH .
Gabor wavelet features have also often been used often in face recognition systems [12] and are defined as : \MATH , where \MATH and \MATH define the orientation and scale of the Gabor kernels respectively , \MATH , and the wave vector \MATH , is defined as : \MATH where \MATH , \MATH and \MATH .
811
Let \MATH be the face image , its convolution with a Gabor filter �� ,_( z ) is defined as : \MATH where \MATH denotes the convolution operator .
Let \MATH be the face image ; , its convolution with a Gabor filter �� ,_( z ) is defined as : \MATH where \MATH denotes the convolution operator .
812
Similar to [12] , Gabor kernels at five scales \MATH and eight orientations \MATH were used .
Similar to [12] , Gabor kernels at five scales , \MATH , and eight orientations , \MATH , were used .
813
As a result , \MATH there are \MATH Gabor features for one 24x24 training sample .
As a result , one \MATH training sample hasthere are \MATH Gabor features for one 24x24 training sample .
814
In order to show effectiveness of the proposed feature selection method ( CMI-Multi ) , we compared it with two other feature selection methods that are forward feature selection ( FFS ) [16] and CMI-basedmethod using binary features ( CMIBinary ) [8 , 7] on the data set and feature setsmentioned above .
To prove the effectiveness of the proposed feature selection method ( CMI-Multi ) , we compared it with two other feature selection methods ?that are forward feature selection ( FFS ) [16] and a CMI-based methods using binary features ( CMI-Binary ) [8 , 7] ? on the data set and feature sets mentioned described above .
815
We chose the forward feature selection proposed by Wu et. al. [16] because it has very impressive results when not only reducing significantly the training time of AdaBoost-based face detection system [1] ( about 100 times ) but also maintaining comparable performance .
We chose the forward feature selection proposed by Wu et. al. [16] because it has very impressive results , when not only reducing significantly the training time of the AdaBoost-based face detection systems [1] by ( about 100 times , ) but also maintaining comparable performance .
816
It indicates that , the proposed method CMI-Multi outperforms the others while FFS and CMI-Binary have comparable performance .
The figureIt indicates that , the proposed method , CMI-Multi , outperforms the others while the performances of FFS and CMI-Binary have were comparable performanceto one another .
817
The similar result is also shown when tested on Gabor wavelet features .
The A similar result is was also shown when the three feature selection methods were tested on Gabor wavelet features .
818
In this case , CMI-based feature selection methods obviously outperform FFS and CMI-Multi is confirmed to be more efficient than CMI-Binary .
In this case , CMI-based feature selection methods obviously clearly outperformed FFS , and CMI-Multi is was confirmed to be more efficient than CMI-Binary .
819
Because our proposed method uses same principle as FFS which only trains weak classifiers once , it is extremely fast compared with AdaBoost [1] .
Because our proposed method uses same principle as FFS , which only trains weak classifiers once , it is extremely fast compared with AdaBoost [1] .
820
However , CMI-Multi is trained faster than AdaBoost approximately 70 times .
However , CMI-Multi wasis trained faster than was AdaBoost by approximately 70 times .
821
Integrated into AdaBoost-based object detection systems , it can not only reduce the training time significantly but also achieve high classification performance .
Integrated into AdaBoost-based object detection systems , our proposed methodit can not only reduces the training time significantly , but also achieves high classification performance .
822
Experiments on two popular feature sets such as Haar wavelets and Gabor wavelets have demonstrated the effectiveness of the proposed method .
Experiments on two popular feature sets have demonstrated the effectiveness of the proposed method . //[Please note : I am not sure which of the following you mean .--> one composed of such as Haar wavelets and the other composed of Gabor wavelets / ? Haar wavelets and Gabor wavelets ?]
823
A multi-stage approach --- which is fast , robust and easy to train --- for a face-detection system is proposed .
A multi-stage approach that is fast , robust , and easy to train is proposed for a face-detection system .
824
However , it is distinguished from previous work by two features .
However , our [system / approach?] is distinguished from previous work by two features .
825
First , a new stage is added to detect face candidate regions more quickly by using a larger window size and larger moving step size .
First , a new stage has been added to detect face candidate regions more quickly by using a larger window size and larger moving step size .
826
Second , SVM classifiers are used instead of AdaBoost classifiers in the last stage , and Haar wavelet features selected by the previous stage are reused for the SVM classifier robustly and efficiently .
Second , support vector machine ( SVM ) classifiers are used instead of AdaBoost classifiers in the last stage , and Haar wavelet features selected by the previous stage are reused for the SVM classifier robustly and efficiently .
827
The proposed multi-stage-based system is shown to run faster than the original AdaBoost-based system while maintaining comparable accuracy .
The proposed multi-stage-based system has been shown to run faster than the original AdaBoost-based system while maintaining comparable accuracy .
828
For example , face detection is combined with other modules to identify who a person in a video sequence is [2] .
For example , face detection is combined with other modules to identify a person in a video sequence [2] .
829
Although it has been studied for more than 30 years , developing a fast and robust face detection system that can handle the variations found in different faces in real applications , such as facial expressions , pose changes , illumination changes , complex backgrounds , and low resolutions , is still a challenging research target [4] .
Although this area has been studied for more than 30 years , developing a fast and robust face detection system that can handle the variations found in different faces in real applications , such as facial expressions , pose changes , illumination changes , complex backgrounds , and low resolutions , is still a challenging research target [4] .
830
Recently , with advances in machine learning research , Neural Network [5] ,[6] , Support Vector Machines ( SVM ) [7] ,[8] ,[9] and AdaBoost [1] ,[10] ,[11] ,[12] ,[13] are typical choices for building robust face detectors .
Recently , with advances in machine learning research , neural networks [5] , [6] , support vector machines ( SVM ) [7] , [8] , [9] and AdaBoost [1] , [10] , [11] , [12] , [13] are typical choices for building robust face detectors .
831
Generally , to classify an input pattern of intensities as a face or non-face , features must be extracted and normalized before passing to a classifier [14] .
Generally , to classify an input pattern of intensities as a face or non-face , features must be extracted and normalized before passing [the image / the pattern / the results?] to a classifier [14] .
832
There are many kinds of features that have been used ranging from simple features such as intensity values [7] ,[5] and eigenspace [15] to complex features such as wavelets [16] ,[1] ,[12] , edge orientation histograms [17] ,[18] and Bayesian discriminating features ( BDF ) [19] .
Many kinds of features have been used , ranging from simple ones such as intensity values [7] , [5] and eigenspace [15] to complex ones such as wavelets [16] , [1] , [12] , edge orientation histograms [17] , [18] , and Bayesian discriminating features ( BDF ) [19] .
833
In a typical face detector which is scale-free and location-free , the number of analyzed patterns is usually very large ( 160 ,000 patterns for a 320x240 pixel image ) because the face classifier has to scan over the input image at every location and every scale .
In a typical face detector that is scale- and location-free , the number of analyzed patterns is usually very large ( 160 ,000 patterns for a 320x240 pixel image ) because the face classifier has to scan over the input image at every location and every scale .
834
Face detectors based on single classifiers such as SVM [7] ,[8] ,[9] and Neural Network [6] ,[5] are usually slow because they process non-face regions and face regions in the input image equally .
Face detectors based on single classifiers such as SVM [7] , [8] , [9] and neural networks [6] , [5] are usually slow because they equally process non-face and face regions in the input image .
835
To deal with the problem of processing a large number of patterns , a combination of simple-to-complex classifiers is proposed [8] ,[1] ,[9] ,[20] ,[21] ,[11] .
To deal with the problem of processing a large number of patterns , a combination of simple-to-complex classifiers has been proposed [8] , [1] , [9] , [20] , [21] , [11] .
836
In particular , fast and simple classifiers are used as filters at the earliest stages to quickly reject a large number of non-face patterns and a slower yet more accurate classifier is then used for classifying face-like patterns .
In particular , fast and simple classifiers are [recommended to be?] used as filters at the earliest stages to quickly reject a large number of non-face patterns and a slower yet more accurate classifier is then recommended to be used for classifying face-like patterns .
837
By this way , the complexity of classifiers is adapted corresponding to the difficulty in the input patterns .
In this way , the complexity of classifiers can be adapted corresponding to the difficulty in the input patterns . / / [is / can be?]
838
In [8] , non linear SVM classifiers using pixel-based features are arranged into a sequence with increasing number of support vectors , or in [9] , linear SVM classifiers trained at different resolutions are used for rejection and a reduced set of principle component analysis ( PCA )-based features are used with the non linear SVM at the classification stage in order to reduce computation time .
In [8] , nonlinear SVM classifiers using pixel-based features were arranged into a sequence by increasing the number of support vectors , while in [9] , linear SVM classifiers trained at different resolutions were used for rejection and a reduced set of principle component analysis ( PCA )-based features were used with the nonlinear SVM at the classification stage in order to reduce computation time .
839
It is believed that the cascade structure of classifiers is the key factor in enhancement of current real-time face detectors .
It is believed that the cascade structure of classifiers is the key factor in enhancement of current real-time face detectors . / / It is believed?This sounds vague?who believes this? " May researchers believe , " for example , would be clearer and sound more believable .]
840
This work is motivated by Viola and Jones [1] who proposed a framework for fast and robust face detection .
This work is motivated by Viola and Jones [1] , who proposed a framework for fast and robust face detection .
841
-Firstly , the cascaded structure of simple-to-complex classifiers reduces computation time dramatically ( as mentioned above ) .
-The cascaded structure of simple-to-complex classifiers reduces computation time dramatically .
842
-Secondly , AdaBoost is used to select discriminative and significant features from a pool of a very large number of features and then construct the classifier .
-AdaBoost is used to select discriminative and significant features from a pool of a very large number of features and then construct the classifier .
843
-Thirdly , Haar-wavelet features used for all stages are informative [22] and evaluated extremely fast due to the introduction of the integral image .
-Haar wavelet features used for all stages are informative [22] and can be evaluated extremely quickly due to the introduction of the integral image .
844
This need is apparent when face and non-face patterns become hard to distinguish , weak classifiers are too weak to boost [22] .
This need is apparent because when face and non-face patterns become hard to distinguish , weak classifiers are too weak to boost [22] .
845
However , turning the later layers into robustly classifying a smaller number of remaining patterns , it requires a lot more , e.g. , 5 ,660 , weak classifiers , thus making the training task much more complicated .
However , enabling the later layers to robustly classify a smaller number of remaining patterns requires many more weak classifiers ( around 5 ,660 ) , thus making the training task much more complicated .
846
Firstly , it requires a long training time because the training time is proportional to the number of features in the input feature set ( which is normally hundreds of thousands ) and the number of training samples ( which is generally tens of thousands ) .
It requires a long time because the training time is proportional to the number of features in the input feature set ( which is normally hundreds of thousands ) and the number of training samples ( which is generally tens of thousands ) .
847
Therefore , training a cascade of classifiers with around 6 ,060 features [1] might take in order of several weeks .
Therefore , training a cascade of classifiers with around 6 ,060 features [1] might take on the order of several weeks .
848
Secondly , AdaBoost-based classifiers are constructed by adding features after each round of boosting , so several training parameters must be tuned manually while training .
Another thing that complicates the training process is that AdaBoost-based classifiers are constructed by adding features after each round of boosting , so several training parameters must be tuned manually while training .
849
Because the complexity of the training sets varies through layers in the cascade , it is undetermined how to choose these parameters automatically and optimally .
Because the complexity of the training sets varies throughout the layers in the cascade , a way to choose these parameters automatically and optimally has not been determined .
850
Specifically , for quick rejection of non-face patterns , we reuse two key ingredients of Viola and Jones' system , that is , the cascaded structure of simple-to-complex classifiers and AdaBoost trained with Haar-wavelet features .
Specifically , for quick rejection of non-face patterns , we have reused two key ingredients of Viola and Jones' system , that is , the cascaded structure of simple-to-complex classifiers and AdaBoost trained with Haar wavelet features .
851
The contribution of this approach is three fold :
The contribution of this approach is threefold :
852
-First , to detect the face candidate regions , a new stage ( using a larger window size and a larger moving step size ) is added .
-First , to detect the face candidate regions , a new stage ( using a larger window size and a larger moving step size ) has been added .
853
We use 36 x 36-pixel window-based classifiers with a moving step size of 12 pixels , to quickly estimate the candidate face regions .
We use 36 x 36-pixel window-based classifiers with a moving step size of 12 pixels to quickly estimate the candidate face regions .
854
To improve speed while maintaining high accuracy , our approach takes advantage of the combination of the Haar wavelet features and the AdaBoost learning for fast and robust evaluation
To improve speed while maintaining high accuracy , our approach takes advantage of the combination of the Haar wavelet features and the AdaBoost learning for fast and robust evaluation .
855
Second , how to efficiently reuse the features selected by AdaBoost in the previous stage , for the SVM classifiers of the last stage , is investigated .
Second , we have investigated how to efficiently reuse the features selected by AdaBoost in the previous stage for the SVM classifiers of the last stage .
856
Reusing these features brings to two advantages : ( i ) Haar wavelet features are very fast in evaluating and normalizing [1] .
Reusing these features brings two advantages : ( i ) Haar wavelet features are very fast in being evaluated and normalized [1] .
857
Furthermore , it is unnecessary to re-evaluate these features because they have been previously evaluated .
Furthermore , these features do not need to be re-evaluated because they have already been evaluated .
858
( ii ) By using SVM classifiers with powerful generalization , using too many features in the cascade is avoided , therefore importantly training time is saved and over-fitting is avoided .
( ii ) By using SVM classifiers with powerful generalization , using too many features in the cascade is avoided , with the important results of saving training time and avoiding over-fitting .
859
Third , the training time of AdaBoost classifiers is shortened by using simple sampling techniques to reduce the number of features in the feature set .
Third , the training time of AdaBoost classifiers has been shortened by using simple sampling techniques to reduce the number of features in the feature set .
860
Experiments will show that for rejection , using a full feature set and a sampled feature set gives the comparable performance .
Experiments showed that for rejection , the performance gained by using a sampled feature set was comparable to that of a full feature set .
861
Along with using several SVM classifiers instead of many AdaBoost classifiers in later layers , the total training time is reduced significantly .
Along with using several SVM classifiers instead of many AdaBoost classifiers in later layers , the total training time has been significantly reduced .
862
There have been several studies working on how to handle the drawbacks of Viola and Jones' system .
Several studies have worked on addressing the drawbacks of Viola and Jones' system .
863
It is therefore very time consuming because all weak classifiers must be trained every time one feature is selected .
This process is very time consuming because all weak classifiers must be trained every time one feature is selected .
864
With their new proposal , weak classifiers are trained only once and features are selected by the direct feature selection method that directly maximizes the learning objective of the output classifier .
With the new proposal of Wu et al. , weak classifiers are trained only once and features are selected by the direct feature selection method , which directly maximizes the learning objective of the output classifier .
865
Another direction is to optimally build the cascade to improve the overall performance of the cascade .
Another direction is to optimally build the cascade to improve its overall performance .
866
Xiao et al. [20] and Huang et al. [11] propose the boosting chain structure in which subsequent layers utilize historical information of previous layers .
Xiao et al. [20] and Huang et al. [11] proposed a boosting chain structure in which subsequent layers utilize the historical information of the previous layers .
867
Studies based on RealBoost [26] , such as [12] ,[10] ,[27] ,[11] , introduced new kinds of weak classifiers that are stronger than binary weak classifiers .
Studies based on RealBoost [26] , such as [12] , [10] , [27] , and [11] , introduced new kinds of weak classifiers that are stronger than binary weak classifiers .
868
New real-valued weak classifiers can effectively discriminate face and non-face distributions and , in consequence , the total number of features used also reduces dramatically .
These new real-valued weak classifiers can effectively discriminate face and non-face distributions , so the total number of features used is also reduced dramatically .
869
Face detection systems such as [27] ,[11] only use around 800 features .
Face detection systems such as [27] and [11] only use around 800 features .
870
Small number of bins might not well approximate the real distribution while large number of bins might cause over-fitting , increase computation time and waste storage space .
A small number of bins might not accurately approximate the real distribution , while a large number of bins might cause over-fitting , increase computation time , and waste storage space .
871
Actually , our system can benefit from this approach when building the rejection stage and thus also reduce the training time much more .
However , our system can benefit from this approach when building the rejection stage and can thus reduce the training time even further .
872
The proposed face detection system consists of three stages that classify a 24x24 pixel window as either a face or a non-face .
The proposed face detection system consists of three stages that classify a 24x24-pixel window as either a face or a non-face .
873
To detect faces of different sizes and locations , the detector is applied at every location and scale in the input image with a scale factor of 1 .2 , which is similar to the other approaches [5] ,[6] ,[9] .
To detect faces of different sizes and locations , the detector is applied at every location and scale in the input image with a scale factor of 1 .2 , which is similar to other approaches [5] , [6] , [9] .
874
If a 36x36 window is detected as the existence of a face , 144 ( i.e. 12x12 ) likely face positions are collected and passed to the next stage .
If a 36x36-pixel window is detected as the existence of a face , 144 ( i.e. , 12x12 ) likely face positions are collected and passed to the next stage .
875
The reason why the fist stage , which is a cascade of \MATH classifiers , is added is to decrease the number of analyzed patterns .
For this reason , the first stage , which is a cascade of \MATH classifiers , is added is to decrease the number of analyzed patterns .
876
The \MATH window is chosen in accordance with the idea from [5] stated that the classifier can be trained to be invariant to translation by up to \MATH of original window size .
The \MATH window is chosen in accordance with the idea in [5] that the classifier can be trained to be invariant to translation by up to \MATH of the original window size .
877
In our experiments , only 100 features are used and hence it is faster than using any pixel-based SVM classifiers [8] ,[9] .
In our experiments , only 100 features were used , making classification faster than it would have been using pixel-based SVM classifiers [8] , [9] .
878
The same feature set as proposed in [1] is used ( cf. Figure 4 ) .
The same feature set proposed in [1] was used ( cf . Figure 4 ) .
879
Each feature is parameterized by four parameters : the position within the window \MATH , width \MATH and height \MATH ( cf. Figure 5 ) .
Each feature is parameterized by four parameters : the position within the window \MATH , the width \MATH , and the height \MATH ( cf . Figure 5 ) .
880
By using integral image definition [1] , these rectangle feature values can be computed extremely quickly .
By using integral image definition [1] , the feature values of these rectangles can be computed extremely quickly .
881
Given \MATH weak classifiers \MATH learned through \MATH rounds of boosting , the strong classifier is formed by a linear combination : \MATH where \MATH are coefficients found in the boosting process .
Given \MATH weak classifiers \MATH learned through \MATH rounds of boosting , the strong classifier is formed by a linear combination : \MATH , where \MATH are coefficients found in the boosting process .
882
The error of each weak classifier is measured with respect to the set of weights over each example of the training set \MATH , where \MATH and \MATH are the weight and the label of the training example \MATH , respectively .
The error of each weak classifier is measured with respect to the set of weights over each example of the training set \MATH , where \MATH and \MATH are the respective weight and label of the training example \MATH .
883
Training cascaded classifiers that can achieve both good detection rate and less computation time is quite complex , because a higher detection rate requires more features , but more features are correspondent to more time for evaluation .
Training cascaded classifiers that can achieve both good detection rates and less computation time is quite complex ; a higher detection rate requires more features , but more features correspond to more time needed for evaluation .
884
1 .	<section label= " SVM Classifier " >
1 .	<section label= " SVM Classifier " >
885
It has been very efficiently proved in many pattern recognition applications [29] ,[8] ,[9] .
It has been very efficiently proven in many pattern recognition applications [29] , [8] , [9] .
886
Although many kernels have been introduced by researchers , the following four kernels are commonly used : \MATH where \MATH and \MATH are kernel parameters .
Although many kernels have been introduced by researchers , the following four kernels are commonly used : \MATH where \MATH , and \MATH are kernel parameters .
887
Compared to AdaBoost classifiers , SVM classifiers run much slower in running because of the large number of support vectors and heavy kernel computation .
Compared to AdaBoost classifiers , SVM classifiers run much more slowly because of the large number of support vectors and the heavy kernel computation .
888
For training , we collected 7 ,500 , 24x24-size face patterns from the Internet .
For training , we collected 7 ,500 , 24x24-size face patterns from the Internet . / / size / pixel?
889
To compare the performance of classifiers , we have implemented a fully cascade of classifiers trained by AdaBoost , similar to that used by Viola and Jones [1] .
To compare the performance of classifiers , we implemented a full cascade of classifiers trained by AdaBoost , similar to that used by Viola and Jones [1] .
890
The minimum of the detection rate is \MATH , the maximum of the false positive rate is \MATH and the maximum of the number of features in each layer is 200 .
The minimum of the detection rate was \MATH , the maximum of the false positive rate was \MATH , and the maximum of the number of features in each layer was 200 .
891
As mentioned in section 4 .1 , each feature is parameterized by a tuple of four parameters \MATH .
As mentioned in section 4 .1 , each feature is parameterized by a tuple of four parameters \MATH . / / If this ( and other places ) do not display with spaces after the commas , spaces must be insert . A comma should always be followed by a space . I recommend checking this carefully throughout .]
892
In the other hand , a feature set is parameterized by \MATH .
A feature set , on the other hand , is parameterized by \MATH .
893
We carried out experiments to compare the performance of classifiers trained on these two feature sets : the full feature set \MATH containing 134 ,736 features and the reduced feature set \MATH containing 14 ,807 features ( excluding features with the small size ) .
We carried out experiments to compare the performance of classifiers trained on these two feature sets : the full feature set \MATH , containing 134 ,736 features and the reduced feature set \MATH , containing 14 ,807 features ( excluding features of small size ) .
894
Our another experiment has shown that , for similar performance , the AdaBoost classifier trained on the reduced feature set that uses larger sampling step sizes requires more features than that trained on the full feature set .
Another experiment we conducted showed that , for similar performance , an AdaBoost classifier trained on the reduced feature set that uses larger sampling step sizes requires more features than one trained on the full feature set . / / [Do you need a reference here , or is this still talking about the experiments you report in this paper?]
895
By taking advantage of simplification in training classifiers only for rejection demonstrated in section 6 .2 , training this cascade only uses the feature set generated from a 36x36 window with sampling parameters \MATH .
By taking advantage of simplification in training classifiers only for rejection , as demonstrated in section 6 .2 , training this cascade only uses the feature set generated from a 36x36 window with sampling parameters \MATH .
896
Since a 36x36 face sample contains a lot of background outside the 24x24 face region while the classifier is required to be fast and to keep all possible face regions , training parameters are set as follows : the minimum detection rate of \MATH and maximum of false positive rate of \MATH .
Since a 36x36 face sample contains a large proportion of background outside the 24x24 face region and the classifier is required to be fast and to keep all possible face regions , a minimum detection rate of \MATH and a maximum of false positive rate of \MATH were set as the training parameters .
897
It is somehow similar to features of the first 24x24 layer classifier as shown in Figure 11( b ) .
They are somehow similar to the features of the first 24x24 layer classifier as shown in Figure 11( b ) . / / [somehow?This sounds vague . How are they similar?]
898
Two main issues surrounding the reuse of features selected by AdaBoost are : ( i ) which layer whose features will be reused for SVM is the best? and ( ii ) How many features should be used?
Two main issues surrounding the reuse of features selected by AdaBoost are : ( i ) which layer�fs features should be reused for SVM and ( ii ) how many features should be used .
899
To determine how many features is robust enough , we used the 200-feature set selected in layer 17 to generate different subsets of features with different number of features .
To determine the number of features is that would be sufficiently robust , we used the 200-feature set selected in layer 17 to generate different subsets of features with different numbers of features .
900
Features in each set were selected in the order that they were added in the training process .
Features in each set were selected in the order in which they were added in the training process .
901
The results shown in Figure 14 indicate that with more than 100 features , the performance of classifiers is comparable .
The results shown in Figure 14 indicate that with more than 100 features , the performance of the classifiers was comparable . / / [to what?]
902
Figure 15 shows the processing speed of SVM classifiers that uses different subsets of features .
Figure 15 shows the processing speed of SVM classifiers using different subsets of features .
903
The SVM classifier using 25 features run fastest while the SVM classifier using 200 features run slowest .
The SVM classifier using 25 features ran the fastest , while the SVM classifier using 200 features was the slowest .
904
The speeds of SVM classifiers using 100 , 125 and 175 features are not importantly different because their difference in terms of number of features and number of support vectors is inconsiderable .
The speeds of SVM classifiers using 100 , 125 , and 175 features were not importantly different because their difference in terms of number of features and number of support vectors were not large enough to have a significant impact .
905
The remaining 34 ,000 non-face patterns and other 2 ,450 face patterns were used to compare the accuracy .
The remaining 34 ,000 non-face patterns and other 2 ,450 face patterns were used to compare the accuracy of the classifiers .
906
The result shown in Figure 16 demonstrates that with hard classified patterns that later layers of the cascade will process , the single SVM classifier can achieve higher accuracy than the cascade of AdaBoost classifiers trained by roughly predefined training parameters .
The result shown in Figure 16 demonstrates that with hard classified patterns that later layers of the cascade will process , the single SVM classifier can achieve higher accuracy than the cascade of AdaBoost classifiers trained by roughly predefined training parameters . / / ?NOTE : I believe that I hyphenated this term in your previous document , but after seeing it used here , I would say that it does not need to be hyphenated. My apologies for any confusion . A better way to express this , however , might be " patterns that have been classified as difficult " or " patterns shown to be difficult to classify .]
907
In the first stage , the cascaded 36x36 classifiers consist of three layers , making a total number of features used of 120 .
In the first stage , the cascaded 36x36 classifiers consist of three layers , making for a total of 120 features .
908
Compared to the system with 6 ,061 features used in [1] , our system uses fewer features and , thus , can save significant training time ( which is approximate 27 times in total ) .
Compared to the system with 6 ,061 features used in [1] , our system uses fewer features and can thus save significant training time ; the training time needed using the new system is approximately 27 times shorter / approximately 27 rounds of training are needed in the new system . / / <--I think that the first choice here is your intended meaning , but please check carefully .
909
All these parameters were found by using cross-validation test tool provided by LibSVM [31]} .
All these parameters were found by using a cross-validation test tool provided by LibSVM [31] . / / ?NOTE : I believe that I hyphenated this term in your previous document , but after seeing it used here , I would say that it does not need to be hyphenated
910
We tested our system on the MIT+CMU frontal-face standard test set [5] which consists of 124 images with 480 frontal faces ( excluding images containing hand-drawn , cartoon and small faces ) .
We tested our system on the MIT+CMU frontal-face standard test set [5] , which consists of 124 images with 480 frontal faces ( excluding images containing hand-drawn , cartoon , and small faces ) .
911
The first row presents the number of features of each layer , and the second row shows the fraction of the remaining patterns after each layer processing .
The first row presents the number of features of each layer and the second row shows the fraction of the remaining patterns after each layer were processed . / / [fraction / percentage?<--Here and after , you use " percentage " in the graph , so you may want to keep the same term here .]
912
The last row indicates the fraction of time that each layer consumes .
The last row indicates the fraction of time that each layer consumed . / / [fraction / percentage?]
913
If the first 24x24 layer classifier is added to the cascade of 36x36 classifiers , this combination rejects 85 .91\% of analyzed patterns compared to \MATH of using only the first layer of the single cascade 24x24 classifiers .
When the first 24x24 layer classifier was added to the cascade of 36x36 classifiers , this combination rejected 85 .91\% of analyzed patterns compared to \MATH of using only the first layer of the single cascade of 24x24 classifiers .
914
Furthermore , the rejection of this very large number of patterns is done extremely quickly , only using \MATH of processing time .
Furthermore , the rejection of this very large number of patterns was done extremely quickly , only using \MATH of the total processing time . / / [the total / the standard?]
915
It is clear that our multi-stage system runs faster than the single cascade of 24x24 AdaBoost classifiers while detection rates are comparable .
It is clear that our multi-stage system ran faster than the single cascade of 24x24 AdaBoost classifiers while achieving comparable detection rates .
916
This performance is possible because of the three following reasons :
This performance was possible for three reasons .
917
First , the cascade of 36x36 AdaBoost classifiers rejects a lot of non-face patterns extremely fast while slow SVM classifiers only process a very small number of the remaining patterns .
First , the cascade of 36x36 AdaBoost classifiers rejected many of non-face patterns extremely quickly , while slow SVM classifiers only processed a very small number of the remaining patterns .
918
Second , many images in the MIT+CMU test set contain large portion of background which was mentioned in [9] which said the ratio of non-face to face patterns is about 50 ,000 to 1 .
Second , many images in the MIT+CMU test set contain large portion of background , which [9] mentioned has a ratio of non-face to face patterns of about 50 ,000 to 1 .
919
Third , at a small number of false positives , some true face candidate regions rejected by 36x36 classifiers do not affect so much in final performance because it might also be rejected by 24x24 classifiers in later layers .
Third , at a small number of false positives , some true face candidate regions rejected by 36x36 classifiers did not severely affect the final performance because they might also be rejected by 24x24 classifiers in later layers .
920
The cascaded structure of AdaBoost-based classifiers in two first stages allows to best adapt to various complexities of input patterns ,while non linear SVM classifiers at the final stage are robust enough to achieve good results .
The cascaded structure of AdaBoost-based classifiers in the two first stages allows the system to best adapt to various complexities of input patterns , while nonlinear SVM classifiers at the final stage are robust enough to achieve good results .
921
Extensive experiments demonstrated that a significant computation time is devoted to potential face regions because almost all non-face patterns are rejected quickly by the two first stages , and only a very small number of face-like patterns is processed by the slow SVM classifiers .
Extensive experiments demonstrated that a significant computation time is devoted to potential face regions because almost all non-face patterns are rejected quickly by the two first stages , and only a very small number of face-like patterns are processed by the slow SVM classifiers . / / [are / need to be?]
922
to improve the retrieval performance of image search engines that use textual information for indexing , it is necessary to utilize visual information .
It is necessary to utilize visual information to improve the efficiency of retrieval in image-search engines that use textual information for indexing .
923
One popular approach is to learn visual consistency among the images returned by these search engines .
One popular approach has been to learn visual consistency between images returned by these search engines .
924
Most of the state of the art methods for learning the visual consistency usually learn one specific classifier for each query for re-ranking the returned images .
Most state-of-the-art methods of learning visual consistency usually learn one specific classifier for each query to re-rank the returned images .
925
The drawback of these methods is it requires computational cost and processing time that are unsuitable for handling a large number of queries .
The main drawback with these methods is that they require computational cost and processing time that are unsuitable for handling a large number of queries .
926
experimental results show that the proposed method achieves good performance in various datasets .
The experimental results demonstrated that the proposed method performed very well in various datasets .
927
Most of existing image search engines usually use text information for judging relevancy , resulting low precision performance .
Most existing image-search engines usually use text information to determine relevance , resulting in poor precision .
928
To improve the retrieval performance , it is necessary to use visual information of images for re-ranking .
To improve the accuracy of retrieval , it is necessary to use visual information from images to re-rank them .
929
In addition , using visual information requires huge computational cost compared with using text .
In addition , using visual information requires much greater computational cost than using text .
930
One popular approach \CITE combining both text and visual information is to use text information to quickly retrieve a set of candidates and then do post-processing (i . e . re-rank) on this set to improve the precision .
One popular approach \CITE combining both text and visual information has been to use text information to quickly retrieve a set of candidates and then do post-processing ( i . e . , re-ranking ) on this set to improve precision .
931
There are two ways for post-processing : The first way \CITE is to build a ranker or a classifier specific to the given query using the returned images .
There are two ways of doing post-processing : The first \CITE has been to build a ranker or a classifier specific to the given query using the returned images .
932
As a result , this way is not scalable for applications processing very large number of queries .
As a result , this way is not scalable for applications that process very large numbers of queries .
933
The second way \CITE is to build a generic classifier once and then use it for all new queries .
The second way \CITE has been to build a generic classifier once and then use it for all new queries .
934
This way is more scalable and can be used for practical applications such as meta search engines .
This is more scalable and can be used for practical applications such as meta-search engines .
935
We follow the latter way for the problem of face retrieval in which the system enables users to search persons's appearance by their names .
We pursued the latter way to solve the problem with face retrieval in which the system enables users to search people's appearances by their names .
936
Building such generic classifiers requires solving two problems : finding good query-relative representation of faces and collecting a large labeled dataset for training the classifier .
Building such generic classifiers requires two problems to be solved : finding a good query-relative representation of faces and collecting a large labeled dataset to train the classifier .
937
By addressing these problems , Our contribution is two-fold :
Our contribution by addressing these problems is two-fold :
938
In this framework , We learn a relevance classifier that classifies whether an input face is relevant to the associated query or not .
We learn a relevance classifier that classifies whether an input face is relevant to the associated query or not in this framework .
939
This approach is different from existing approaches such as \CITE that learn a classifier to recognize the identity of the returned faces .
This approach is different from existing ones \CITE that learn a classifier to recognize the identity of the returned faces .
940
experimental results show that the relevance classifier that is independent with underlying ranking algorithm of existing search engines can significantly boost the performance .
The experimental results demonstrated that the relevance classifier that is independent of the underlying ranking algorithms of existing search engines could significantly boost performance .
941
Specifically , We detect and group faces of persons appearing in video programs in face tracks in which each face track contains of the faces of one person .
We specifically detected and grouped faces of people appearing in video programs in face tracks in which each face track contained the faces of one person .
942
To distinguish face tracks of different persons , we assume that if multiple faces are detected at different locations in one frame , they are of different persons (cf . Figure \REF) .
To distinguish the face tracks of different people , we assumed that if multiple faces were detected at different locations in one frame , they would be of different people ( cf .
943
To enlarge the number of such face tracks , We use video programs of multiple genres and channels .
We used video programs from multiple genres and channels to increase the number of such face tracks .
944
From these faces , We can artificially generate face sets similar to the sets returned by search engines given person names .
We could artificially generate face sets from these faces similar to the sets returned by search engines given people's names .
945
Note that the label of faces in our approach is not identity of that face . It is the relevance between the face and the associated query .
Note that the labels of faces in our approach did not identity those faces but the relevance between the faces and the associated query .
946
Collecting training sets from such external sources as video archives is easy and efficient because : firstly , a large number of videos can be easy to obtain .
Collecting training sets from such external sources as video archives is easy and efficient because , first , a large number of videos can be easily obtained .
947
In addition , using temporal information , faces of one person appearing in consecutive frames can be automatically grouped with high accuracy .
In addition , the faces of one person appearing in consecutive frames can be automatically grouped with a high degree of accuracy using temporal information .
948
given a query described by text , for example , 'airplane' or 'George Bush' , finding relevant images with high precision is essential for image search engines .
It is essential for image-search engines to find relevant images with a high degree of precision given queries described by text , e.g. , 'airplane' or 'George Bush' .
949
There are different approaches described in \CITE for re-ranking images containing general objects and faces returned from text-based search engines .
There have been different approaches \CITE to re-ranking images containing general objects and faces returned from text-based search engines .
950
Work such as \CITE extend topics models using probabilistic Late Semantic Analysis , Latent Dirichlet Allocation , or Hierarchical Dirichlet Process to learn generative model based classifiers .
Work \CITE has extended to topics on models using probabilistic Late Semantic Analysis , Latent Dirichlet Allocation , or the Hierarchical Dirichlet Process to learn generative model-based classifiers .
951
However , they have many parameters needed to be tuned such as number of topics and feature configurations .
However , they have many parameters that need to be tuned such as the number of topics and feature configurations .
952
In addition , how to select the best topic associated with the input query for identifying target label is still challenging \CITE .
In addition , how the best topic is selected associated with the input query to identify the target label is still a difficult issue \CITE .
953
In \CITE , Textual information is used to build a text ranker to re-rank the returned images \CITE .
Textual information has been used to build a text ranker to re-rank the returned images \CITE .
954
In \CITE , A multiple instance learning framework is used to learn category models from images associated with keywords \CITE .
A multiple-instance learning framework has been used to learn category models from images associated with keywords \CITE .
955
The work mentioned above are for re-ranking images containing general objects .
These researchers re-ranked images containing general objects .
956
For re-ranking faces , work described in \CITE use Gaussian mixture models to build face recognizers and apply these recognizers back to the input faces for re-ranking \CITE .
Gaussian mixture models have been used for re-ranking faces to build face recognizers and apply these recognizers back to the input faces for re-ranking \CITE .
957
In \CITE , Discriminative approach based models such as SVM and linear discriminant analysis are used instead of Gaussian mixture models \CITE .
Discriminative-approach-based models such as SVM and linear discriminant analysis have been used instead of Gaussian mixture models \CITE .
958
In \CITE , A densest graph based method is used for finding the face group relevant to the query \CITE .
A densest-graph-based method has been used for finding the face group relevant to the query \CITE .
959
As for these approaches , One specific classifier is built for each query .
One specific classifier is built for each query in these approaches .
960
Therefore , to handle a large number of queries , many classifiers must be built which are not suitable in practice .
Therefore , many classifiers must be built , which are not suitable in practice , to handle a large number of queries .
961
In \CITE{Krapac10CVPR} , Only one generic classifier is built in advance \CITE and then used for all queries .
Only one generic classifier has been built in advance \CITE and then used for all queries .
962
As for specific classifiers , Each image is classified as 'class-A' or 'non-class-A' , where 'class-A' is the category associated with the query , for example , 'airplane' .
Each image for specific classifiers is classified as 'class-A' or 'non-class-A' , where 'class-A' is the category associated with the query , e.g. , 'airplane' .
963
In generic classifier , Each image is classified as relevant or irrelevant to the query .
Each image in a generic classifier is classified as relevant or irrelevant to the query .
964
This method works well for objects such as car , flag , but fails to handle faces .
This method works well for objects such as cars and flags , but fails to handle faces .
965
Our method is inspired by the generic classifier based approach .
Our method was inspired by the generic-classifier-based approach .
966
Given a set of faces returned by any search engine for a queried person ( e .g . 'George Bush' ) , our task is to re-rank these faces to improve the precision .
Given a set of faces returned by any search engine for a queried person ( e.g. , 'George Bush' ) , our task is to re-rank these faces to improve precision .
967
This approach is different from existing approaches such as \CITE as shown in Figure \REF( a ) in which one specific classifier is built for each query .
This approach is different from the existing approaches \CITE shown in Figure \REF( a ) in which one specific classifier is built for each query .
968
To build the specific classifier for re-ranking faces returned by the query of 'personX' , each face is represented by the query-independent feature such as pixel intensity around facial features such as eyes , nose , and mouth \CITE .
To build a specific classifier for re-ranking faces returned by the query of 'personX' , each face is represented by a query-independent feature such as pixel intensity around facial features such as the eyes , nose , and mouth \CITE .
969
Meanwhile , to build the generic classifier which is independent with any \textit{'personX'} , each face is represented by the query-dependent feature .
Further , each face is represented by the query-dependent feature to build a generic classifier that is independent of any 'personX' .
970
In \CITE , the Query-dependent features using textual information are proposed \CITE .
Query-dependent features using textual information has been proposed \CITE .
971
Each feature is treated as binary indicating the presence or absence of the query terms in textual data associated with the input image , for example , filename , image title , and nearby text .
Each feature was treated as binary indicating the presence or absence of query terms in the textual data associated with the input image , e.g. , filenames , image titles , and nearby text .
972
In \CITE , Each image \CITE is represented as a set of visual words .
Each image in \CITE is represented as a set of visual words .
973
Since this method is suitable for general objects rather than faces , we proposed another method described below for extracting query-dependent features to train the generic classifier .
Since this method is suitable for general objects rather than faces , we propose another method of extracting query-dependent features to train the generic classifier that is described below .
974
To be able to model the relevance between a face and the given query , We assume that there is visual consistency among faces returned by search engines for that query .
We assumed that there would be visual consistency between faces returned by search engines for a query to be able to model the relevance between a face and that given query .
975
In the other word , we assume faces that are relevant to the query form the largest cluster .
In the other words , we assumed faces that were relevant to the query would form the largest cluster .
976
We consider the problem of finding relevant and irrelevant faces in the input set as the problem of outlier detection \CITE that is popular in data mining community .
We consider the problem of finding relevant and irrelevant faces in the input set to be the problem of outlier detection \CITE that is popular in the data-mining community .
977
We first describe several distance based outlier detection methods that use the distance to the \MATH -nearest neighbors to determine observations as outliers or non-outliers .
We first describe several distance-based methods of outlier detection that use the distance to the \MATH -nearest neighbors to determine observations as outliers or non-outliers .
978
Then the adaptation is proposed to form the query-dependent feature .
Then , adaptation is proposed to form a query-dependent feature .
979
Given a threshold \MATH , for each point \MATH , we examine number of points \MATH so that \MATH , where \MATH is the distance ( e .g . Euclidean distance ) between \MATH and \MATH in the feature space .
Given threshold \MATH , for each point \MATH , we examine the number of points \MATH so that \MATH , where \MATH is the distance ( e.g. , Euclidean distance ) between \MATH and \MATH in the feature space .
980
This number of points \MATH is called the neighborhood score of \MATH and is defined as follows : \MATH where \MATH is the total number of points of the input dataset .
This number of points \MATH is called the neighborhood score of \MATH and is defined as : \MATH where \MATH is the total number of points in the input dataset .
981
In practice , it is difficult to know \MATH because it depends on underlying distribution of the input dataset .
In practice , it is difficult to know \MATH because this depends on the underlying distribution of the input dataset .
982
For each point \MATH , find its \MATH -nearest neighbors \MATH , the distance score of \MATH is the sum of the distances between \MATH and its \MATH -nearest neighbors \MATH and is defined as follows : \MATH
For each point \MATH , find its \MATH -nearest neighbors \MATH ; the distance score of \MATH is the sum of the distances between \MATH and its \MATH -nearest neighbors \MATH and is defined as : \MATH
983
Points with larger values for \MATH have more sparse neighborhoods and are likely outliers than points belonging to dense clusters which usually have lower values of \MATH .
Points with larger values for \MATH have sparser neighborhoods and are more likely outliers than points belonging to dense clusters , which usually have lower values for \MATH .
984
In our framework , Each face is an sample , and non-outliers / outliers mean faces relevant / irrelevant to the query ( i .e . target person ) .
Each face in our framework is a sample , and non-outliers / outliers mean faces are relevant / irrelevant to the query ( i.e. , target person ) .
985
In order to train the relevance classifier using supervised learning methods such as SVM , it requires a sufficient number of training samples .
It requires a sufficient number of training samples to train the relevance classifier using supervised learning methods such as SVM .
986
To collect training samples , The simplest way \CITE is we pick many names , and pass them to search engines .
The simplest way \CITE of collecting training samples is to pick many names , and pass them to search engines .
987
After collecting the returned faces , we manually label each face whether it is relevant to the input query or not .
After collecting the returned faces , we manually label each face as to whether it is relevant to the input query or not .
988
It is a tedious task and requires human labor cost .
This is a tedious task and involves a human-labor cost .
989
This approach consists of two steps :
This approach consists of two steps .
990
First , by mining video archives , we automatically collect a set of faces of \MATH different persons \MATH , where \MATH is the set of faces of person \MATH , and \MATH is the number of persons; and
First , by mining video archives , we automatically collect a set of faces of \MATH different people \MATH , where \MATH is the set of faces of person \MATH , and \MATH is the number of people .
991
In other words , as shown in Figure \REF , \MATH might have several face clusters and the largest cluster is equivalent to the faces relevant to the query if returning by a search engine .
In other words , as seen in Figure \REF , \MATH might have several face clusters and the largest cluster is equivalent to the faces relevant to the query if they are returned by a search engine .
992
As a result , this method can stimulate face sets returned by search engines using many names mentioned above .
As a result , this method can be used to stimulate face sets returned by search engines using many names as mentioned above .
993
Specifically , We use the following heuristics to pick a set of different persons appearing in video archives :
We specifically use the following heuristics to pick a set of different people appearing in video archives :
994
-If there are more than one face appearing in different locations in one frame , they likely belong to different persons .
-If there is more than one face appearing in different locations in one frame , they are likely to belong to different people .
995
Figure \REF shows an example of this case .
Figure \REF shows an example where this has occurred .
996
-If two persons appear in video programs broadcast by different broadcast stations ( e .g . , CNN , MSNBC , and CCTV ) , they are likely different .
-If two people appear in video programs broadcast by different broadcast stations ( e.g. , CNN , MSNBC , and CCTV ) , they are likely to be different .
997
If we have large video archives , using these heuristics we can collect a sufficient number of training samples for learning the relevance classifier .
If we have large video archives , we can collect a sufficient number of training samples to learn the relevance classifier by using these heuristics .
998
TRECVID dataset : We collected all video programs of TRECVID 2006 dataset \CITE .
TRECVID dataset : We collected all video programs from the TRECVID 2006 dataset \CITE .
999
There are 527 video programs broadcast on 7 channels in 3 languages including English , Chinese and Arabic .
There were 527 video programs broadcast on seven channels in three languages including English , Chinese , and Arabic .
1000
We extracted faces from these video programs and grouped faces belonging to one person in each shot in one face track using a similar method described in \CITE .
We extracted faces from these video programs and grouped faces belonging to one person in each shot in one face track using a similar method to that described in \CITE .
1001
For each channel , We scanned all face tracks extracted from the videos broadcast by this channel , and picked face tracks extracted from keyframes that several faces were detected at different locations .
We scanned all face tracks for each channel extracted from the videos broadcast by this channel , and picked face tracks extracted from key frames where several faces were detected at different locations .
1002
Note that , the system does not know the identity of these faces .
Note that the system did not know the identity of these faces .
1003
Using these face tracks , We generated 133 labeled sets described in Section \REF and used them for training the relevance classifier .
We generated the 133 labeled sets described in Section \REF using these face tracks and used them to train the relevance classifier .
1004
Using person names as queries , we applied simple string search to the captions this dataset to return a list of faces for each queried name .
Using people�fs names as queries , we applied a simple string search to the captions in this dataset to return a list of faces for each queried name .
1005
These names are widely used in experiments such as \CITE .
These names have widely been used in experiments \CITE .
1006
In total , 9 ,136 faces were retrieved in which 3 ,909 faces were relevant .
A total of 9 ,136 faces were retrieved in which 3 ,909 faces were relevant .
1007
On average , The accuracy was \MATH .
The accuracy was \MATH on average .
1008
Google Images : We used the same set of person names used in Yahoo News Images dataset and put to Google Image Search Engine .
Google Images : We used the same set of people�fs names used in the Yahoo News Images dataset and input them into the Google Image Search Engine .
1009
For each query , We crawled a maximum of 500 images from URLs returned by Google .
We crawled a maximum of 500 images from URLs returned by Google for each query .
1010
In total , 9 ,516 faces were extracted in which 5 ,816 faces were relevant .
A total of 9 ,516 faces were extracted in which 5 ,816 faces were relevant .
1011
On average , The accuracy was \MATH .
The accuracy was \MATH on average .
1012
The datasets , Yahoo News Images and Google Images as shown in Figure \REF , were used for testing .
The datasets for Yahoo News Images and Google Images , as shown in Figure \REF , were used for testing .
1013
To group faces belonging to one person in one video shot , We simply used a similar technique described in \CITE .
We simply used a similar technique to that described in \CITE to group faces belonging to one person in one video shot .
1014
Specifically , for each face , 9 facial feature points were detected , and 4 more facial feature points were inferred from these 9 points .
Nine facial-feature points were specifically detected for each face , and four more facial feature points were inferred from these nine points .
1015
In total , There were 13 feature points from which features are extracted .
There were a total of 13 feature points from which features were extracted .
1016
Figure \REF shows illustration of this feature .
Figure \REF illustrates this feature .
1017
We evaluated the retrieval performance with measures that are commonly used in information retrieval , such as precision , recall , and average precision .
We evaluated the efficiency of retrieval with measures that are commonly used in information retrieval , such as precision , recall , and average precision .
1018
Given a queried person and letting \MATH be the total number of faces returned , \MATH the number of relevant faces , and \MATH the total number of relevant faces , recall and precision can be calculated as follows : \MATH .
Given a queried person and letting \MATH be the total number of faces returned , \MATH the number of relevant faces , and \MATH the total number of relevant faces , recall and precision can be calculated as : \MATH .
1019
Precision and recall only evaluate the quality of an unordered set of retrieved faces .
Precision and recall were only used to evaluate the quality of an unordered set of retrieved faces .
1020
To evaluate ranked lists in which both recall and precision are taken into account , the average precision is usually used .
Average precision is usually used to evaluate ranked lists in which both recall and precision are taken into account .
1021
The interpolated precision \MATH at a certain recall level \MATH is defined as the highest precision found for any recall level \MATH :
The interpolated precision , \MATH , at a certain recall level , \MATH , is defined as the highest precision found for any recall level \MATH :
1022
In this experiment , We compare the MAP performance of the following systems testing on YahooNews Images :
We compared the performance of the Maximum A-Posteriori ( MAP ) algorithm in seven systems in this experiment by testing it on YahooNews Images :
1023
We re-implemented the method proposed by Krapac et al . \CITE for extracting query-dependent feature .
We re-implemented the method proposed by Krapac et al. \CITE of extracting the query-dependent feature .
1024
Specifically , Each face is represented as a bag of visual words .
Each face was specifically represented as a bag of visual words .
1025
top-$k$ visual words strongly related to the returned faces of each query and the binary feature vector are computed as described in \CITE .
The top-$k$ visual words strongly related to the returned faces of each query and the binary feature vector were computed as described in \CITE .
1026
-Mensink[15]-GaussianModels : This method proposed by Mensink et al . \CITE models the returned faces by using two Gaussians , one for the faces relevant to the target person and one for the remaining faces .
-Mensink[15]-GaussianModels : This method proposed by Mensink et al. \CITE modeled the returned faces by using two Gaussians , the first for the faces relevant to the target person and the second for the remaining faces .
1027
This method uses detected person names in captions associated with faces for query expansion to model faces of the target person 's friends .
This method used detected people�fs names in captions associated with faces for query expansion to model faces of the target person 's friends .
1028
The Methods such as Mensink[15]-GaussianModels and Mensink[15]-Friends are the state of the art methods that learn a specific classifier for each query .
Methods such as Mensink[15]-GaussianModels and Mensink[15]-Friends are state-of-the-art that learn a specific classifier for each query .
1029
The method Krapac[11]-TrainGoogleImages is similar to our method in which one generic classifier is trained in advance and then is used for new queries .
Krapac[11]-TrainGoogleImages is similar to our method in which one generic classifier is trained in advance and then used for new queries .
1030
Figure \REF shows the performance comparison of these systems when testing on YahooNews Images dataset .
Figure \REF compares the performance of these systems when they were tested on the YahooNews Images dataset .
1031
As for systems such as DistScore-TrainGoogleImages , NNScore-TrainGoogleImages , DistScore-TrainTRECVID , and NNScore-TrainTRECVID , the curves show the correlation between the performance and the number of features .
The curves plot the correlation between performance and the number of features for systems such as DistScore-TrainGoogleImages , NNScore-TrainGoogleImages , DistScore-TrainTRECVID , and NNScore-TrainTRECVID .
1032
-DistScore is significantly better than that of NNScore .
-DistScore performed significantly better than NNScore .
1033
-The performance of the system using the training data generated artificially by our method is comparable with that of the system using the training data returned by search engines .
-The performance of the system using training data generated artificially with our method was comparable to that of the system using training data returned by search engines .
1034
-Our proposed method DistScore-TrainTRECVID has comparable performance to the state of the art method in specific classifier-based approach Mensink[15]-Friends .
-The method of DistScore-TrainTRECVID we propose performed comparably to the state-of-the-art method in the specific classifier-based approach of Mensink[15]-Friends .
1035
It outperforms the method using only visual information Mensink[15]-GaussianModels .
It outperformed the method where only visual information was used , i.e. , Mensink[15]-GaussianModels .
1036
-Our proposed method DistScore-TrainTRECVID outperforms the method proposed by Krapac et al . customized for handling faces .
-Our proposed method DistScore-TrainTRECVID outperformed the method proposed by Krapac et al. , which was customized to handle faces .
1037
As shown in Figure \REF , DistScore-TrainTRECVID outperforms original ranking of Google Images Search Engine if using from 20 to 50 features .
As seen in Figure \REF , DistScore-TrainTRECVID outperformed the original ranking of the Google Images Search Engine if from 20 to 50 features were used .
1038
The result of DistScore-TrainTRECVID on YahooNews Images set and Google Images set indicates that the relevance classifier of our proposed method is able to generalize well on different queries and independent with underlying ranking algorithms of search engines .
The results for DistScore-TrainTRECVID on the YahooNews Images set and Google Images set indicate that the relevance classifier with our proposed method was able to generalize well on different queries and was independent of underlying ranking algorithms used in search engines .
1039
Figure \REF shows an example of re-ranking result of top-30 faces for the query John Paul that is one of the most difficult cases of the YahooNews Images set .
Figure \REF shows an example of re-ranking results for the top-30 faces for the query John Paul , which is one of the most difficult cases in the YahooNews Images set .
1040
The result clearly shows that our proposed method outperforms the other state of the art methods .
The results clearly demonstrate that our proposed method outperformed the other state-of-the-art methods .
1041
However , recent studies on indexing techniques such as \MATH -d tree , locality sensitive hashing ( LSH ) , and SASH \CITE can speed up the nearest neighbor search significantly .
However , recent studies on indexing techniques such as \MATH -d tree , locality sensitive hashing ( LSH ) , and a Self Adaptive Set of Histograms ( SASH ) \CITE could significantly speed up the nearest neighbor search .
1042
For example , as described in \CITE , the complexity of fast lookup of $k$ approximate nearest neighbors is \MATH \CITE .
For example , the complexity of the fast lookup of $k$ approximate nearest neighbors is \MATH \CITE .
1043
Studying other techniques to speedup the query-feature extraction process is our next step in future work .
Studying other techniques to speed up the process of query-feature extraction is our next step in future work .
1044
Instead of training a specific classifier for each new query , we train only one generic classifier and use it for ranking new queries .
Instead of training a specific classifier for each new query , we only trained one generic classifier and used it for ranking new queries .
1045
To train the generic classifier , We propose a simple unsupervised method to obtain a large number of labeled faces from video archives .
We propose a simple unsupervised method to train the generic classifier to obtain a large number of labeled faces from video archives .
1046
Experiments shown that although our method is unsupervised and independent with underlying algorithms of existing search engines but successfully learns visual consistency among returned faces to boosts retrieval performance .
Experiments revealed that although our method is unsupervised and independent of underlying algorithms in existing search engines , it successfully learned visual consistency between returned faces to boost efficiency of retrieval .
1047
We present a method to enhance the performance of a mathematical search system in this paper .
We present a method to enhance the performance of a mathematical search system .
1048
Targeting to mathematical formulas that appear in natural language documents , we collect the names of formulas from the surrounding text , and incorpo-rate the correspondence to the search system 's database .
By targeting mathematical formulas that appear in natural language documents , we collect the names of formulas from the surrounding text and incorporate the correspondence into the search system 's database .
1049
E ectiveness of the proposed approach is shown through experiments using Wikipedia mathematical articles and Wolfram Functions Site data sets .
The effectiveness of the approach is demonstrated through experiments using Wikipedia mathematical articles and Wolfram Functions Site data sets .
1050
In the current digital environment , the mathematical content being published on the Web is increasing day by day . While more and more mathematical contents being available on the Web , retrieving mathematical contents becomes an important issue for many users .
The mathematical content being published on the Web is increasing day by day , and retrieving mathematical content has become an important issue for many users .
1051
Teach-ers , students , researchers do need to gain access to mathematical resources for teaching , studying , or obtaining updated information for research and development .
Teachers , students , and researchers need better access to mathematical resources for teaching , studying , and obtaining information for research and development .
1052
Therefore , users need specialized search systems to nd the formula that is relevant to their requirements .
Moreover , users need specialized search systems to find formulas that are relevant to their needs .
1053
Internet search engines are able to detect some particular keywords in mathematical formula but they mostly fail to recognize mathematical symbols and constructs such as integral sym-bols , square root symbols , fractions , or matrices .
Internet search engines can detect particular keywords in mathematical formulas but they mostly fail at recognizing mathematical symbols and constructs such as integral and square root symbols , fractions , and matrices .
1054
There exist some mathematical-dedicated search engines available on the Internet .
There are some mathematically oriented search engines on the Internet .
1055
Furthermore , these systems do not take into account the semantics of mathematical formulas revealed by surrounding natural language text , like the name of the formula and its variables' descrip-tion .
Furthermore , these systems do not take into account the semantics of mathematical formulas as revealed by the surrounding natural language text , e.g. , the formula�fs name or the description of its variables .
1056
But full mathematical search is still not available .
But even this site does not provide a full mathematical search .
1057
The Wolfram Functions Site [7] contains large mathe-matical formulas and also provides a semantics search for mathematical formulas .
The Wolfram Functions Site [7] contains a large number of mathematical formulas and also provides a semantic search for them .
1058
This site and some recent works done by Adeel et al. [2] and Yokoi and Aizawa [1] propose similarity search methods based on MathML but these works do not make use of the semantics of the formulas' surrounding text , which is considered to be important information sources .
This site and some recent work done by Adeel et al. [2] and Yokoi and Aizawa [1] employ similarity search methods based on MathML but they do not make use of the semantics of the formulas' surrounding text . //[ ? ? propose is unclear in the sense of a website .]
1059
We describe here in detail our work toward creating a mathematical database that contains for-mulas , their names , their variables' descriptions and other related information .
We describe our work toward creating a mathematical database that contains formulas , their names , variable descriptions , and other related information .
1060
We also implement a mathematical search system that use this information as its base knowledge .
We implemented a mathematical search system that uses this information as its base knowledge .
1061
This information is very helpful when performing mathematical search by reducing the need for formula input and solving the notational variation problem where mathematically equivalent formulas follow di erent notations .
This information is very helpful when performing mathematical search by reducing the need for formula input and solving the notational variation problem where mathematically equivalent formulas follow different notations .
1062
Relations between formulas and their name could also be used to correct errors in mathematical OCR systems , such as Infty [5] .
The relationship between formulas and their names can also be used to correct errors in mathematical OCR systems , such as Infty [5] .
1063
It also provides opportunities to make mathematical better understandable and usable for di erent groups of people with disabilities .
It also provides opportunities to make mathematics better understandable and usable for people with disabilities .
1064
The remainder of this paper is organized as follow : In section 2 , we present an overview of the proposed framework .
The remainder of this paper is organized as follows : we present an overview of our framework in section 2 .
1065
Mathematical formulas on the Web has many di erent formats , some of them are LaTeX , and the Mathematical Markup Language ( MathML ) [6] .
Mathematical formulas on the Web have many different formats , e.g. , LaTeX and Mathematical Markup Language ( MathML ) [6] .
1066
This makes the search more dif-cult .
This diversity makes searches more difficult .
1067
In this paper , we use the presentation MathML format for mathematical formulas .
In this paper , we shall use the MathML format for mathematical formulas .
1068
For our works , we use LaTeXML Converter which is freely available at \URL .
For our work , we used LaTeXML Converter , which is freely available at \URL .
1069
Figure 1 shows a page on mathematical section on Wikipedia and the information we retrieved on this site besides the mathematical formulas .
Figure 1 shows a page from a mathematical section on Wikipedia and the information we retrieved on this site , besides the mathematical formulas .
1070
At this point , we use some heuristics to provide an adequate solution for matching mathematical formulas with their names .
We used heuristics to ensure adequate matching of mathematical formulas with their names .
1071
In the rst case , users can use the extracted keywords for search , for example : " sin " , " Pythagorean " or " trigonometric functions " .
In a text content search , users search with extracted keywords , e.g. , " sin " , " Pythagorean " or " trigonometric functions " .
1072
In the second case , users can input the mathematical formulas directly , for example : \MATH .
In a formula content search , users directly input the formulas , for example : \MATH .
1073
Else , it just looks for mathematical formulas which are similar to the input ( including formulas with similar structure ) .
If nothing matching is found , it looks for mathematical formulas which are similar to the input ( including formulas with a similar structure ) .
1074
In our work , we manually consider formulas with the same semantic meaning are relevant .
We consider that formulas with the same semantic meaning are relevant . //[The original is unclear the rewrite seems to be what you mean .]
1075
In order to show the e ect of linking the formula with its name , we also set up an experimental search system without using the formula 's names .
To show the effect of linking the formula with its name , we also set up an experimental search system without using the formula 's names .
1076
Table 1 shows top 5 of the searching results for the query \MATH .
Table 1 shows the top 5 search results for the query " sin( a + b ) " .
1077
As can be seen from the table , when the system associates the formulas with their names , it can provide more useful information to the user .
As can be seen , when the system associates the formulas with their names , it can provide more useful information to the user .
1078
In this paper , we presented a new framework for mathematical search where links between formulas and their names are automatically detected from the target documents and then utilized in the search .
We presented a new framework for mathematical searches where links between formulas and their names are automatically detected in the target documents and then utilized in the search .
1079
We believe that our approach , by incorporating information other than the mathematical formulas themselves , showed promising results .
We believe that our approach of incorporating information other than the mathematical formulas themselves showed promising results .
1080
The experimental results have shown how helpful this information provides to the users of mathematical search .
The experimental results showed how helpful this information is to mathematical search users .
1081
However , this is only a rst step , some important issues are left for future study .
However , this is only a first step ; many important issues are left for future study .
1082
Using formula 's name is one way of taking into account the semantic meaning of the formula , we are considering other information such as formula 's description and variable 's description .
Using a formula 's name is only one way of taking into account the semantic meaning of the formula ; we are considering other information such as the formula 's description and its variable 's description .
1083
Therefore , linking formulas across articles should be taken into account .
Therefore , linking formulas across articles should also be taken into account .
1084
This paper explores the use of MathML Pallel Markup Corpora for mathematical expression understanding , the task of which is formulated as a translation from Presentation to Content MathML Markups in our approach .
This paper explores the use of MathML Pallel Markup Corpora for automatic understanding of mathematical expressions , the task of which is formulated as a translation from Presentation to Content MathML Markups . // <the use of capitals implies that these are software applications like PowerPoint or Word . I assume this is the right idea .> .
1085
Experimental results on the Wolfram Function Site show that our approach achieves an improvement against the prior rule-based system .
Experimental results on the Wolfram Function Site show that our approach is an improvement over prior rule-based systems . // <Note : It seems that where were two prior systems that were compared . If not , you can go back to using a prior system .> .
1086
One of the most significant current discussions in the digitization of mathematical and scientific content and its applications is the semantic enrichment of mathematical documents , that is adding or associating semantic tags - usually concepts - to mathematical expressions .
One of the most significant discussions regarding the digitization of mathematical and scientific content and its applications is about semantic enrichment of mathematical documents , that is , adding or associating semantic tags - usually concepts - with mathematical expressions .
1087
The direct application of this is enabling semantic searches for mathematical expressions by understanding the intent of the searcher and the contextual meaning of mathematical terms improve search accuracy .
The direct application of this idea enables semantic searches for mathematical expressions whereby the system 's �eunderstanding ' of the intent of the searcher and the contextual meaning of mathematical terms improves search accuracy .
1088
- The third problem is that new notations tend to be introduced and used as and when needed so a mechanism is required for referring to mathematical concepts outside of the base collection , allowing them to be represented .
- The third problem is that new notations tend to be introduced and used when needed so a mechanism is required for referring to mathematical concepts outside of the base collection .
1089
The aim of this paper is to introduce a method for automatic mathematics semantic enrichment that capable of analyze and disambiguate mathematical terms .
The aim of this paper is to describe a method of automatic semantic enrichment for mathematics that is capable of analyzing and disambiguating mathematical terms .
1090
The semantic enrichment task then becomes generating Content MathML outputs from Presentation MathML expressions .
The semantic enrichment task then becomes one of generating Content MathML outputs from Presentation MathML expressions .
1091
- Last , large collections of formulas are available in MathML and we can easily assess these collections .
- Last , large collections of formulas are available in MathML , and we can easily assess these collections .
1092
- Since it is a hand written rule-based system , SnuggleTeX requires mathematical knowledge and human effort to develop
- Since it is a hand-written rule-based system , SnuggleTeX requires mathematical knowledge and human effort to develop .
1093
- Due to the diversity of mathematical expressions , SnuggleTeX is still to be considered experimental and has difficulty processing complicated mathematical symbols and expressions .
- Due to the diversity of mathematical expressions , SnuggleTeX is still considered experimental and has difficulty processing complicated mathematical symbols and expressions .
1094
In this paper , we propose an approach that automatically learn the semantics inference from a presentation from parallel markup data .
In this paper , we propose an approach that automatically learns semantic inferences in a presentation from parallel markup data . // <The original has too many from to be logically clear . The rewrite is a guess . > .
1095
The idea of this approach is based on statistical machine translation .
This approach is based on statistical machine translation .
1096
The underlying mathematical meaning of an expression is inferred according to the probability distribution $ p( c | p ) $ that a semantic expression $ c $ is the translation of a presentation expression $ p $ .
The underlying mathematical meaning of an expression is inferred from the probability distribution $ p( c | p ) $ that a semantic expression $ c $ is the translation of a presentation expression $ p $ .
1097
The probability distribution will be automatically learned from data that have both Presentation and Content MathML markup , that is the parallel markup MathML data .
The probability distribution is automatically learned from both Presentation and Content MathML markup data , that is , parallel markup MathML data .
1098
We have two main contributions in this paper
There are two main contributions in this paper :
1099
- First , successfully apply the machine translation techniques to the problem of mathematic semantic enrichment .
- First , we successfully applied machine translation techniques to solving the problem of mathematic semantic enrichment .
1100
Since both quantity and quality of mathematical expressions are continuing to grow and expand through time , we believe that our system will cover most of real life mathematical expressions .
The quantity and quality of mathematical expressions are continuing to grow , and we believe that our system will be able to cover most mathematical expressions .
1101
- Second , mathematics knowledge such as symbol 's meanings or structural relations is automatically learned while training , therefor it is not required mathematics experts nor human effort and it is also easier to update the system given more data .
- Second , mathematics knowledge such as a symbol 's meanings or structural relations is automatically learned while training ; therefore , the system requires no human effort or expertise , and it is easier to update with more data .
1102
Since new notations keep growing , it is important to update the system as quick as possible .
Since new notations keep cropping up , it is important to update the system as quickly as possible .
1103
In our experiments , we performed a 10-folds cross validation on mathematical expressions from 6 categories of the Wolfram Functions Site to evaluate the effectiveness of our proposed learning method .
We performed a ten-fold cross validation on mathematical expressions from six categories of the Wolfram Functions Site to evaluate the effectiveness of our learning method .
1104
We set up another experiment to confirm the correlation between system performance and training set size and saw that increasing the size of training data actually boost the system performance .
We performed another experiment to assess the correlation between the system 's performance and training set size and found that increasing the size of the training data boosted the system 's performance .
1105
We also performed extensive side-by-side comparison with prior work \CITE over a data set from ACL-ARC scientific papers .
We also performed an extensive comparison with prior work \CITE using a data set collected from ACL-ARC scientific papers .
1106
Our experimental results show that the proposed approach works well on the mathematics semantic enrichment problem and it excels the previous work by providing significantly less error rate .
Our experimental results show that our approach works well in dealing with the mathematics semantic enrichment problem and it outperforms the previous work by making significantly fewer errors .
1107
The remainder of this paper is organized as follows : In Section 2 , we give a brief overview of the background and related work for semantic enrichment of mathematical expressions , while in Section 3 we present our proposed method .
The remainder of this paper is organized as follows : In Section 2 , we give a brief overview of the background and related work on semantic enrichment of mathematical expressions .
1108
We then describe the experimental setup and results in Section 4 .
We present our method in Section 3 and describe the experimental setup and results in Section 4 .
1109
A way of dealing with mathematical formulas in this format is to convert them to another text-based format , as seen in InftyReader \CITE .
A way of dealing with mathematical formulas in this format is to convert them into another text-based format , for example , InftyReader \CITE .
1110
For scientific documents , \TeX{} has been used to encode mathematical formulas .
\TeX{} has been used to encode mathematical formulas in scientific documents .
1111
The formula is printed in a way a person would write by hand , or typeset the equation .
A formula is printed in a way a person would write by hand , or typeset the equation .
1112
In some web pages , such as the Wikipedia site , a formula is displayed in both image and \TeX{} formats .
In some web pages , such as on the Wikipedia site , formulas are displayed in both image and \TeX{} formats .
1113
MathML has two types of encoding , content-based encoding which is called Content MathML , dealing with the meaning of formulas , and presentation-based encoding which is called Presentation MathML , dealing with the display of formulas .
MathML has two types of encoding , content-based encoding , called Content MathML , dealing with the meaning of formulas , and presentation-based encoding , called Presentation MathML , dealing with the display of formulas .
1114
The illustration tree display of Presentation and Content Markup of the expression $ C_{-\frac{17}{2}}= \tilde {\infty} $ are depicted in Figure \REF and Figure \REF respectively .
The illustration trees of the Presentation and Content Markup of the expression $ C_{-\frac{17}{2}}= \tilde {\infty} $ are depicted in Figure \REF and Figure \REF .
1115
org Math \CITE , ASCIIMathML \CITE and OpenMath \CITE , but these markup can be converted to MathML using freely available tools .
org Math \CITE , ASCIIMathML \CITE , and OpenMath \CITE , but these markups can be converted into MathML by using freely available tools .
1116
In this section , we list some works that related to exploit the meaning of mathematical expressions .
In this section , we list some of the work on exploiting the meanings of mathematical expressions .
1117
For understanding mathematical expressions , Grigole et al. \CITE proposed an approach based on the surrounding text of mathematical expressions .
Grigole et al. \CITE proposed an approach to understanding mathematical expressions based on the text surrounding the mathematical expressions .
1118
The main idea of this approach is to use the surrounding text for disambiguation which is based on word sense disambiguation and lexical similarity .
The main idea of this approach is to use the surrounding text for disambiguation based on word sense disambiguation and lexical similarity .
1119
The assigned interpretation is the Term Cluster with the highest similarity score .
The Term Cluster with the highest similarity score is assigned as the interpretation .
1120
The approach was evaluated on 451 manually annotated mathematical expressions and the best result was 68.26 $ F_{0.5} $ score .
The approach was evaluated on 451 manually annotated mathematical expressions , and the best result was an F_{0.5} $ score of 68.26 $ .
1121
To deal with the meanings of mathematical formulas , Nghiem et al. \CITE proposed an approach for extracting the names or descriptions of the formulas using natural language text surrounding them .
To deal with the meanings of mathematical formulas , Nghiem et al. \CITE proposed an approach for extracting names or descriptions of formulas by using the natural language text surrounding them .
1122
This project investigates semantic enrichment , structural semantics and ambiguity resolution in mathematical corpora .
This project investigates semantic enrichment , structural semantics , and ambiguity resolution in mathematical corpora .
1123
Unfortunately , there are no evaluation report on these systems .
Unfortunately , there are no evaluations of these systems .
1124
Our task is inherently domain specific therefore we propose an approach which is based on statistical machine learning methods that automatically extract these rules from a dataset .
Our task is inherently domain-specific ; therefore , we devised an approach based on statistical machine learning for automatically extracting rules from a dataset .
1125
Nowadays , statistical machine translation ( SMT ) is by far the most widely-studied machine translation method .
Statistical machine translation ( SMT ) is by far the most widely studied machine translation method .
1126
The statistical model is then applied to new texts to make a translation .
The statistical model is then applied to new texts to make a translation of them .
1127
Tree-based or syntax-based SMT can be used for tree-to-tree translation but it has two drawbacks when apply to the problem of translating from Presentation to Content MathML expression .
Tree-based or syntax-based SMT can be used for tree-to-tree translation but it has two drawbacks when it is applied to the problem of translating Presentation into Content MathML .
1128
- The first drawback is tree-based SMT focus on generating the surface texts rather than the tree structures .
- The first drawback is that tree-based SMT focuses on generating surface texts rather than tree structures .
1129
While mathematical expressions have strict structures , it fails to fulfill this requirement .
Mathematical expressions have strict structures , and it fails to fulfill this requirement .
1130
- Preprocessing : processes MathML expressions to remove error expressions or format tags with no semantic meaning .
- Preprocessing : This module processes MathML expressions by removing error expressions or format tags with no semantic meaning .
1131
- Extracting Rules : given a dataset contains MathML parallel markup expressions , extract the rules for translation .
- Rule Extraction : This module is given a dataset containing MathML parallel markup expressions , and it extracts translation rules from it . // <The original is ungrammatical and unclear . The rewrite is a guess .> .
1132
- Generating Content MathML : given a mathematical expressions in Presentation MathML markup , and a set of rules , generate Content MathML expressions to enrich the Presentation MathML expressions .
- Content MathML Generation : This module is given mathematical expressions in Presentation MathML markup and a set of rules , and it generates Content MathML expressions to enrich the Presentation MathML expressions .
1133
Token elements represent identifier 's names , function 's names , numbers , etc.
Token elements represent the identifier 's names , function 's names , numbers , etc. // <the identifier 's names means there is one identifier with possibly many names . If this is what you want to say , it is okay . If not , maybe you mean simply " identifier names " . ><Likewise , maybe you mean " function names " .>
1134
By investigating the data from the Wolfram Function Site , we noticed that there are elements that have no specific meaning , they are used for displaying purpose only and most of them are layout schemata .
After investigating data on the Wolfram Function Site , we noticed that there are elements that have no specific meaning ; they are used for display purposes only and most of them are layout schemata .
1135
Another example are the pairs of parentheses , it is used to indicate that the expressions in the parentheses go together , while its structure already encoded that information .
Another example is pairs of parentheses ; these are used to indicate that the expressions in the parentheses go together , despite that their structure already encodes that information . // <The original is unclear . The rewrite is a guess . > .
1136
As a result , in this preprocessing step , these elements are removed .
This preprocessing step removes these elements .
1137
In this step , we also removed mathematical expressions with error markups such as expressions that have no Content markup .
We also remove mathematical expressions with error markups such as expressions that have no Content markup .
1138
For simplification , expressions with more than 200 content nodes also be removed .
For simplification , expressions with more than 200 content nodes are also removed .
1139
Based on the aligned data , we use some heuristics to extract rules which we called " fragment rules " .
Based on the aligned data , we use heuristics to extract rules that we call " fragment rules " .
1140
Each rule in fragment rule set is associated with its probability , that is the frequent that rule happened in the training data .
Each rule in the fragment rule set is associated with a probability , that is , the frequency at which a rule occurs in the training data .
1141
If the sub-trees can not be broken any longer , we extract another rules , which we called " translation rules " , at that point .
Once the sub-trees cannot be broken down further , we start to extract other rules , which we call " translation rules " .
1142
We then enhances the translation rule set with the translation terms extracted by GIZA++ .
We enhance the translation rule set with translation terms extracted by GIZA++ .
1143
The pseudo code of the algorithm for extracting fragment rules is described in Algorithm \REF .
The pseudo code for extracting fragment rules is described in Algorithm \REF .
1144
Given a mathematical expressions in Presentation MathML markup , the system will generate Content MathML markup of that expression .
Given mathematical expressions in Presentation MathML markup , the system will generate Content MathML markup for each expression .
1145
- Second , the fragment rule is applied to the expression until it could not be divided any further .
- Second , the fragment rule is applied to the expression until it cannot be divided any further .
1146
- Third , the small sub-expressions in Presentation MathML markup will be translated into sub-expressions in Content MathML markup using translation rule set .
- Third , the small sub-expressions in Presentation MathML markup are translated into sub-expressions in Content MathML markup by using the translation rule set .
1147
The reason for this is that there is infinite number and we could never present every number in the rule .
The reason for this is that there is an infinite number of rules . // <The rewrite is a guess .> .
1148
These datasets we used contain 205 , 653 mathematical expressions belong to 6 categories .
The datasets we used contain 205 , 653 mathematical expressions belonging to six categories .
1149
The cross-validation process is then repeated 10 times , with each of the 10 subsets used exactly once as the validation data .
The cross-validation process was repeated ten times , with each of the ten subsets used exactly once as the validation data .
1150
Currently we have 20 papers from ACL archive , all of the math expressions in these papers are annotated manually with both Presentation Markup and Content Markup .
Currently , we have 20 papers from the ACL archive , and we manually annotated all of the math expressions in these papers with both Presentation Markup and Content Markup . // The original is somewhat vague . The rewrite is a guess . Use it if it is correct . > .
1151
In the second experiment with ACL-ARC data , we compared our model side by side with SnuggleTeX .
In the second experiment with ACL-ARC data , we compared our model with SnuggleTeX .
1152
TEDR is defined as the rate between ( 1 ) the minimal cost to transform a tree A into another tree B using edit operations and ( 2 ) the maximum number of nodes of A and B .
TEDR is defined as the rate between ( 1 ) the minimal cost to transform a tree A into another tree B using edit operations and ( 2 ) the maximum number of nodes of A and B . // <The " rate between " is unclear to me . Do you mean , " the ratio of " >
1153
For example , the output tree using translation system for the expression $ C_{-\frac{17}{2}}= \tilde {\infty} $ is depict in Figure \REF .
For example , the output tree using the translation system for the expression $ C_{-\frac{17}{2}}= \tilde {\infty} $ is depicted in Figure \REF .
1154
Compare to the reference tree in Figure \REF , we need to substituting X node , inserting Y node , and deleting Z node , so that $ TED( A , B ) = x $ . While the maximum number of node of two trees is y .
Compared with the reference tree in Figure \REF , we need to substitute X nodes , insert Y nodes , and delete Z nodes , so that $ TED( A , B ) = x $ , while the maximum number of nodes of the two trees is y .
1155
For the data in Wolfram Function site , it appeared that SnuggleTeX is not applicable to this data since SnuggleTeX use ASCII MathML while the Wolfram Functions site does not .
It appeared that SnuggleTeX was not applicable to the data from the Wolfram Function site since it uses ASCII MathML but the site does not .
1156
Therefore we could not do the side-by-side comparison on this data .
Therefore , we could not do a comparison on this data .
1157
Our experimental results show that our approach can archive reasonable results , that is 20 percent TEDR with large training data .
Our experimental results show that our approach gives reasonable results , that is , a 20 percent TEDR with large training data .
1158
For small data which has less than 3000 training samples , the results vary from 50 to 75 percent TEDR .
For small data ( less than 3000 training samples ) , the results vary from 50 to 75 percent TEDR .
1159
For ACL-ARC data , the experimental results from our side-by-side comparison show that our system significantly outperforms SnuggleTeX in terms of Tree Edit Distance Rate .
For ACL-ARC data , the experimental results show that our system significantly outperforms SnuggleTeX in terms of the Tree Edit Distance Rate .
1160
Our system archived 24 percent TEDR less than the output using SnuggleTeX .
Our system had a 24 percent lower TEDR in comparison with SnuggleTeX .
1161
To find out the correlation between TEDR score and training set size , we set up an experiment using mathematical expressions in Elementary Functions category .
To investigate the correlation between the TEDR score and training set size , we set up an experiment using mathematical expressions in the Elementary Functions category .
1162
We started with one fifth of the data , and then increase data one fifth each run .
We started with one fifth of the data and increased the data by one fifth in each run .
1163
Table \REF and Table \REF show the TEDR of our proposed method on the Wolfram Functions Site data and in comparison with SnuggleTeX on ACL ARC data , respectively .
Table \REF and Table \REF show the TEDR of our method on the Wolfram Functions Site data and in comparison with SnuggleTeX on ACL ARC data , respectively .
1164
In this paper , we discussed the problem of the semantic enrichment of mathematical expressions .
We discussed the problem of semantic enrichment of mathematical expressions .
1165
Our experimental results show that our approach based on the statistical machine translation method for translating a Presentation MathML expression to a Content MathML expression has the significant improvement over a prior system .
Our experimental results show that our approach based on the statistical machine translation method for translating a Presentation MathML expressions to Content MathML expressions is a significant improvement over prior systems .
1166
In the scope of this paper , we only consider the first context information .
In the scope of this paper , we only considered the first sort of context information .
1167
- Expanding the work by incorporating the surrounding information of mathematical expressions , for example definitions or other mathematical expressions .
- Expanding the work by incorporating the surrounding information of mathematical expressions , for example , definitions or other mathematical expressions .
1168
By combining the automatic extraction of fragment rules and translation rules , our approach has shown promising results .
Our approach combining automatic extraction of fragment rules and translation rules has shown promising results .
1169
The experimental results confirm that this approach is helpful to the understanding of mathematical expressions .
The experimental results confirm that it would be helpful for automatic understanding of mathematical expressions .
1170
Currently , our system deals only with a sub-part of mathematical notations .
Currently , our system deals with a limited range of mathematical notations .
1171
In future work , we should also consider expanding it to cover all mathematical notations .
In the future , we should consider expanding it to cover all mathematical notations .
1172
Recent research shows a major part of difficult cases in event extraction for the biomedical domain are related to coreference .
Current research has shown that major difficulties in event extraction cases for the biomedical domain are related to coreference .
1173
Therefore , coreference resolution is believed to be useful for the improvement of event extraction .
Therefore , coreference resolution is believed to be useful for improving event extraction .
1174
To address the problem of coreference resolution in molecular biology literature , the Protein Coreference ( COREF ) task was arranged in the BioNLP-ST 2011 as a supporting task .
To address coreference resolution in molecular biology literature , the Protein Coreference ( COREF ) task was arranged in the BioNLP-ST 2011 , as a supporting task .
1175
However , the shared task results showed that transferring coreference resolution methods developed for other domains to the biological domain was not straight forward , which is supposed to be caused by the domain differences in coreference phenomena .
However , the shared task results indicated that transferring coreference resolution methods developed for other domains to the biological domain was not straightforward , due to the domain differences in the coreference phenomena .
1176
We studied the contribution of domain-specific information , i .e information indicating the protein type , in a rule-based protein coreference resolution system .
We studied the contribution of domain-specific information , including information that indicates the protein type , in a rule-based protein coreference resolution system .
1177
In particular , the domain-specific information is encoded into semantic classification modules whose output is used in different components of the coreference resolution .
In particular , the domain-specific information is encoded into semantic classification modules for which the output is used in different components of the coreference resolution .
1178
We compared our system with the top four systems in the BioNLP-ST 2011 , and surprisingly we found that the minimal configuration has outperformed the best system in the BioNLP-ST 2011 .
We compared our system with the top four systems in the BioNLP-ST 2011 ; surprisingly , we found that the minimal configuration had outperformed the best system in the BioNLP-ST 2011 .
1179
Analysis of the experimental results showed that semantic classification using protein information has contributed to an increase in performance ( 2.3 % on the test data , and 4 .0% on the development data , in F-score ) .
Analysis of the experimental results revealed that semantic classification , using protein information , had contributed to an increase in performance by 2.3 % on the test data , and 4 .0% on the development data , in F-score .
1180
Since such information is difficult to be transferred across different domains , we need to continue seeking for methods to exploit and use it in coreference resolution .
Since it is difficult to transfer domain-specific information across different domains , we need to continue to seek methods to exploit and use it in coreference resolution .
1181
While named entity recognition ( NER ) and relation or event extraction are regarded as standard tasks of biomedical information extraction ( IE ) , coreference resolution [ 2 , 16 , 30 ] is more and more recognized as an important component of IE for a higher performance .
While named entity recognition ( NER ) and relation / event extraction are regarded as standard tasks for biomedical information extraction ( IE ) , coreference resolution [ 2 , 16 , 30 ] is being recognized more and more as an important component of IE to achieve a higher performance .
1182
Without coreference resolution , the performance of IE is often substantially limited due to an abundance of coreference relations in natural language text , i.e. , information pieces written in text with involvement of a coreference relation are hard to be captured [ 9 , 14 ] .
Without coreference resolution , oftentimes , the IE performance issubstantially limited , due to the abundance of coreference relations in natural language text ; information pieces written in text with the involvement of a coreference relation are hard to be captured [ 9 , 14 ] .
1183
There have been several attempts for coreference resolution , particularly for newswire texts [ 7 , 8 , 22 , 23 , 28 , 30 ] .
There have been several attempts for coreference resolution ; in particular , they have been for newswire texts [ 7 , 8 , 22 , 23 , 28 , 30 ] .
1184
It is also one of the lessons from BioNLP Shared Task ( BioNLP-ST , hereafter ) 2009 that coreference relations in biomedical text substantially hinder the progress of fine-grained IE [ 10 ] .
Coreference resolution is also one of the lessons from the BioNLP Shared Task ( BioNLP-ST , hereafter ) 2009 , in which it was communicated that coreference relations in biomedical text substantially hinder the progress of fine-grained IE [ 10 ] .
1185
This task definition focuses on a specific type of entities , i.e. Protein .
This task definition focuses on protein , as a specific type of entity .
1186
In the figure , protein names are highlighted in bold face , P4 - P10 , and targeted anaphoric expressions of the shared task , e.g. pronouns and definite noun phrases , are T29 , and T32 , of which the antecedents are indicated by arrows if found in the text .
In the figure , protein names P4 - P10 are highlighted in boldface ; the targeted anaphoric expressions of the shared task ( pronouns and definite noun phrases ) are T29 , and T32 , for which the antecedents are indicated by arrows , if found in the text .
1187
Without knowing this coreference relation , it becomes hard to capture the information written in the phrase , nuclear exclusion of this transcription factor , which is localization of p65 ( out of nucleus ) according to the framework of BioNLP-ST .
Without knowing this coreference relation , it becomes difficult to capture the information written in the phrase , nuclear exclusion of this transcription factor , which is a localization of p65 ( out of nucleus ) , according to the framework of BioNLP-ST .
1188
A new term is introduced in the BioNLP-ST is antecedent protein , which indicates the protein mention contained in the antecedent expression , e.g. p65 in T28 .
A new term introduced in the BioNLP-ST is antecedent protein , which indicates the protein mention contained in the antecedent expression , e.g. , p65 in T28 .
1189
There are other coreferential expressions which are ignored in the context of this COREF task such as this complex and the NF-kappa B transcription factor complex ( Figure 1 ) , since we only focus on the antecedent expressions that contain and point to protein mentions .
There are other coreferential expressions , which are ignored in the context of this COREF task , such as : this complex and the NF-kappa B transcription factor complex ( Figure 1 ) , since our focus is on the antecedent expressions that contain and point to protein mentions .
1190
The best system in the COREF shared task according to the primary evaluation found 22 .2% of anaphoric protein references at the precision of 73 .3% ( 34 .1% Fscore ) .
The best system in the COREF shared task , according to the primary evaluation , found 22 .2% of the anaphoric protein references at the precision of 73 .3% ( 34 .1% F-score ) .
1191
This is an encouraging result , since the authors make use of an external coreference resolution tool originally built for the news domain , without much domain adaptation on the main coreference resolution algorithm .
The results are promising , since the authors make use of an external coreference resolution tool originally built for the news domain , without much domain adaptation on the main coreference resolution algorithm .
1192
However , the external coreference tool achieves much lower results on biological texts than that on news texts , from 66 .38% down to 49 .65% in MUC-score [ 11 , 27 ] , which is supposed to be caused by domain differences .
However , the external coreference tool " s performance drops for biological texts than for news texts , from 66 .38% to 49 .65% in MUC-score [ 11 , 27 ] , which is supposed to be caused by domain differences .
1193
Below are examples of the coreference types .
Examples of the coreference types are outlined below :
1194
- " . . . ,the phosphorylation status of [ TRAF2 ] had significant effects on the ability of [ the protein ] to bind to CD40 , " ( DNP )
- " [ . . . ] the phosphorylation status of [ TRAF2 ] had significant effects on the ability of [ the protein ] to bind to CD40 , " ( DNP )
1195
- " Subnuclear fractionation reveals that there are [ two ATF1 isoforms ] [ which ] appear to differ with respect to DNA binding activity , " ( RELAT )
- " Subnuclear fractionation reveals that there are [ two ATF1 isoforms , which ] appear to differ with respect to DNA binding activity , " ( RELAT )
1196
The analysis results in also showed that the best resolution results for definite noun phrases ( the DNP type ) , and several pronouns of the PRON type are 27 .5% F-score and 10 .1 F-score respectively , which are far less than that for relative pronoun ( the RELAT type ) 66 .2 % F-score .
An analysis of the results indicated that the best resolution results for definite noun phrases ( the DNP type ) , and several pronouns of the PRON type was 27 .5% F-score and 10 .1 F-score , respectively ; the scores were much lower than the F-score for relative pronouns ( the RELAT type ) , which yielded a 66 .2 % F-score .
1197
Thus , it can be inferred that definite noun phrases and pronouns are more difficult to be resolved than relative pronouns .
Thus , it can be inferred that it is more difficult to resolve definite noun phrases and pronouns than relative pronouns .
1198
The top four official results of the COREF shared task are shown again in the top four rows of Table 2 .
The top four official results of the COREF shared task are presented in the top four rows of Table 2 .
1199
In this paper , we compare the contributions of different features in coreference resolution , two simple types of domain-portable information : discourse preference and number-agreement , and domain-specific information which can be considered as more difficult to be transferred across different domains .
In this paper , we compare the contributions of different features in coreference resolution ; two simple types of domain-portable information : discourse preference and number-agreement , is compared , as well as domain-specific information , which is considered to be more difficult to be transferred across different domains .
1200
As we needed to get an insight into the problem , we took a rule-based approach , analyzing the training data of BioNLP-ST 2011 Coref task .
In order to acquire insight into the problem , we took a rule-based approach , analyzing the training data of BioNLP-ST 2011 Coref task .
1201
The performance of the system evaluated on the official test data set of the COREF task shows a significant improvement over the official winning system of the task .
The performance of the system evaluated on the official test dataset of the COREF task shows a significant improvement over the official winning system of the task .
1202
We used Genia Sentence Splitter and Enju Parser [ 15 ] for the purposes , respectively .
We used the Genia Sentence Splitter and Enju Parser [ 15 ] for sentence segmentation and syntactic parsing , respectively .
1203
( Enju parser comes with a default tokenizer and part-of-speech tagger for biological text . ) Row 1 in the example Table 1 shows three sentences outputted from Genia Sentence Splitter , and noun phrases outputted from Enju Parser for the sentence S3 .
( Enju parser comes with a default tokenizer and part-of-speech tagger for biological text . ) Row 1 in the example of Table 1 shows three sentences as the output from the Genia Sentence Splitter , and noun phrases as the output from the Enju Parser for the sentence , S3 .
1204
Due to the limit of space , only a part of the phrases are shown in the table .
Due to the limited space , only a part of the phrases are shown in the table .
1205
Step 1 - Markable detection : collects text chunks that are candidate coreferential expressions , which are also called markables following the jargon of MUC-7 .
Step 1 - Markable detection : Text chunks that are candidate coreferential expressions , which are also called markables following the jargon of MUC-7 , are collected .
1206
For the set of markables , noun phrases , which do not include subordinate clause , are collected as analyzed by a syntactic parser , Enju in our case .
For the set of markables , noun phrases , which do not include a subordinate clause , are collected as they are analyzed by a syntactic parser ( in our case , Enju ) .
1207
Then , for chunks that share the same head word , which is normally the main noun of a noun phrase , only the longest is taken .
Then , for chunks that share the same head word , which is normally the main noun of a noun phrase , only the longest chunk is taken .
1208
Since the Enju parser output such head-word information for every noun phrase , we make use of this information for our processing without any modification .
Since the Enju parser outputs head-word information for every noun phrase , we make use of this information for our processing , without any modification .
1209
In the sentence S3 , three noun phrases recognized by the NX and NP tags of Enju output , role , role for c-Myc in apoptosis , and this role for c-Myc in apoptosis ( Step 0 results ) share the same head word role , thus only the longest one this role for c-Myc in apoptosis is selected .
In the sentence S3 , three noun phrases recognized by the NX and NP tags of the Enju output , role , role for c-Myc in apoptosis , and this role for c-Myc in apoptosis ( Step 0 results ) share the same head-word role ; thus , only the longest noun phrase , this role for c-Myc in apoptosis , is selected .
1210
Step 2 - Anaphor selection : determines candidate anaphoric expressions , which are basically pronouns and definite noun phrases ( a minority of anaphors are indefinite noun phrases or entity names , which act as appositions . )
Step 2 - Anaphor selection : Candidate anaphoric expressions , which are basically pronouns and definite noun phrases , are determined . A minority of anaphors are indefinite noun phrases or entity names , which act as appositions .
1211
Syntactic filters are used to filter out pleonastic its , or pronouns such as he , she , which are not expected to refer to proteins .
Syntactic filters are used to filter out pleonastic its , or pronouns , like : he , she , which are not expected to refer to proteins .
1212
Moreover , because the focus of our task is protein references , semantic filters can be used to filter out non-protein anaphors at this stage .
Moreover , because our task focuses on protein references , semantic filters can be used to filter out non-protein anaphors at this stage .
1213
In practice , for definite noun phrase type of anaphors , this is done using a list of possible head words of protein references , and for pronouns , their context words are used .
In practice , for definite noun phrase type of anaphors , this is accomplished , by using a list of possible head-words of protein references ; for pronouns , their context words are used .
1214
One of the candidates will become the response antecedent as a result of the antecedent prediction step .
One of the candidates will become the response antecedent , as a result of the antecedent prediction step .
1215
In theory , all expressions in the set of markables can become antecedent candidates , however too much candidates makes it difficult to achieve correct antecedent prediction .
In theory , all expressions in the set of markables can become antecedent candidates ; however , too many candidates makes it difficult to achieve correct antecedent prediction .
1216
In our system , this is done by using a window size in sentences , together with several syntactic filters .
In our system , this is done by using a particular window size in sentences , together with several syntactic filters .
1217
The idea behind this is that some types of syntactic relations imply the impossibility of coreference relations between its argument noun phrases and the inclusive expressions of these noun phrases .
The idea behind this filter is that some types of syntactic relations imply the impossibility of coreference relations between its argument noun phrases and the inclusive expressions of these noun phrases .
1218
For example , the two expressions dominant negative form and its in our example in Table 1 , can not be coreferential with each other , since they are connected via the preposition of .
For example , the two expressions : dominant negative form and its in our example in Table 1 , cannot be coreferential with each other , since they are connected via the preposition of .
1219
Step 4 - Antecedent predicion : selects the best candidate in the antecedent candidate set , and forms a response coreference link .
Step 4 - Antecedent prediction : The best candidate in the antecedent candidate set is selected , and a response coreference link is formed .
1220
-Rule 1 ( Number agreement - NUM-AGREE ) : The candidate which is not number conflict with anaphor is selected .
-Rule 1 ( Number agreement - NUM-AGREE ) : The candidate , which does not conflict in number with the anaphor , is selected .
1221
The rules are implemented using different features of expressions such as syntactic types of expression , head noun , semantic types , etc. , in a similar way to [ 22 ] .
The rules are implemented using different features of expressions , such as syntactic types of expressions , head noun , semantic types , etc. , in a similar way to [ 22 ] .
1222
Thanks to this rule , the decision list never results in the equility result .
Because of this particular rule , the decision list never results in the equility result .
1223
By this way , candidates can be sorted , and the best candidate is selected as antecedent .
In this way , candidates can be sorted , and the best candidate is selected as the antecedent .
1224
Figure 4 illustrates how the decision list works when comparing two candidates and .
Figure 4 illustrates how the decision list works when comparing two candidates : and .
1225
In this step , we want to filter out those pronouns and definite noun phrases that are not target of this task , comprised of two types : non-anaphoric expressions , and anaphoric expressions which do not point to proteins .
In this step , we want to filter out those pronouns and definite noun phrases that are not a target of this task . The expressions are comprised of two types : non-anaphoric expressions , and anaphoric expressions , which do not point to proteins .
1226
Anaphoric expression means an expression that has a noun phrase as antecedent .
Anaphoric expression refers to an expression that has a noun phrase as an antecedent .
1227
This means expressions with a sentence or phrase antecedents , or nominal but successive antecedents , are not our target and should be filtered out .
Thus , expressions with a sentence or phrase antecedents , or nominal but successive antecedents , are not our target and should be filtered out .
1228
First and second person pronouns are easily to be recognized by the part-of-speech tags , thus we use part-of-speech information for the filtering .
First and second-person pronouns are easily recognized by the part-of-speech tags ; thus , we use part-of-speech information for the filtering .
1229
For pleonastic it , we make use of the following four patterns , which are similar to [ 13 ]
For pleonastic it , we make use of the following four patterns , which are similar to [ 13 ] :
1230
Basically all expressions detected in the initial expression set are antecedent candidate , except for anaphoric pronouns .
Basically , all of the expressions detected in the initial expression set are an antecedent candidate , with the exception of anaphoric pronouns .
1231
Window size sets a border to include or exclude antecedent candidates .
Window size Borders are set to include or exclude antecedent candidates .
1232
This is a common method for antecedent candidate filtering having been used in the previous work [ 3 , 5 , 26 ] .
This is a common method for antecedent candidate filtering , as seen in the previous work [ 3 , 5 , 26 ] .
1233
Since our task focuses on anaphoric coreference , antecedent expressions normally appear not too far ( in sentence distance ) from the anaphors , using window sizes is a proper technique .
Since our task focuses on anaphoric coreference , antecedent expressions normally appear not too far ( in sentence distance ) from the anaphors . Thus , using window sizes is a proper technique .
1234
Syntactic dependency relations The fact that arguments of some dependency relations such as poss-arg12 and prep-arg12 do not corefer with each other enables us to use them to correctly eliminate the number of antecedent candidates .
Syntactic dependency relations Since arguments of some dependency relations ( such as poss-arg12 and prep-arg12 ) do not corefer with each other , they can be used to correctly eliminate the number of antecedent candidates .
1235
For instance , two such truncated forms definitely cannot be antecedent of the protein in this context two such truncated forms of the protein
For instance , two such truncated forms definitely cannot be an antecedent of the protein in this context : two such truncated forms of the protein .
1236
This is exactly what our system does .
Our system accomplishes this task .
1237
However , a disadvantage of this method is when the parser makes mistake on finding the correct arguments , coreference also fails , as in the example " . . .of transcription factor NF-kappa B also encodes a p70 I kappa B protein , I kappa B gamma , which is identical to the C-terminal 607 amino acids of . . . "
However , a disadvantage to using this method is that when the parser makes a mistake on finding the correct arguments , the coreference also fails . This is exemplified in the following : " . . .of transcription factor NF-kappa B also encodes a p70 I kappa B protein , I kappa B gamma , which is identical to the C-terminal 607 amino acids of . . . "
1238
The rules are applied in a succession order one after another until the inequality occurs , or end of the rule list is reached .
The rules are applied in a successive order , one after another , until the inequality occurs , or until the end-of-the-rule list is reached .
1239
The default rule of the procedure prefers the closer antecedent candidate .
The default rule of the procedure , is in the preference of the closer antecedent candidate .
1240
By definition , two coreferential expressions refer to the same thing , which implies a semantic-constraint on coreference relationship .
By definition , two coreferential expressions are identical , which implies a semantic-constraint on coreference relationship .
1241
In practice , this compatibility is checked based on a given taxonomy of semantic classes in the following manner : two semantic classes are considered compatible or agreed with each other , when they have synonym relation , e.g. , or hypernym-hyponym relation .
In practice , this compatibility is checked based on a given taxonomy of semantic classes in the following manner : two semantic classes are considered compatible or agreed with each other , when they have a synonym relation , or hypernym-hyponym relation .
1242
In this work , we only focus on the Protein type , ignoring other possible semantic types , so we do not take the structure of taxonomy into account .
In this work , we only focus on the Protein type , ignoring other possible semantic types , so the structure of the taxonomy is not taken into account .
1243
Thus , the likelihood that two expressions are semantically compatible is definitely beneficial for antecedent prediction , besides syntactic information .
Therefore , the likelihood that two expressions are semantically compatible , is definitely beneficial for antecedent prediction , besides syntactic information .
1244
Focusing on specific entity types , i.e. Protein type , helps us to find a proper method for determining the likelihood , and how to encode the likelihood in coreference resolution .
Focusing on specific entity types , i.e. , Protein type , enables us to find a proper method for determining the likelihood , and method for encoding the likelihood in coreference resolution .
1245
In details , if an expression is a noun phrase with a single head word , and it contains a protein mention that completely overlaps with the head word , then the expression is classied as Protein .
If an expression is a noun phrase with a single head word , and it contains a protein mention that completely overlaps with the head word , then the expression is classified as Protein .
1246
Another case is when the head noun is either protein or gene , and has a protein mention as its premodifier , such as the Tax protein .
In another case , when the head noun is either protein or gene , and has a protein mention as its premodifier , such as the Tax protein .
1247
Pronouns , in particular , possessive pronouns occupy the majority of anaphoric pronouns in biological texts ( Table 5 ) .
Pronouns , in particular , possessive pronouns , occupy the majority of anaphoric pronouns in biological texts ( Table 5 ) .
1248
However , they do not contain in themselves much useful information for the resolution , thus we need to exploit more information from its context [ 17 ] .
However , they do not contain very much useful information for the resolution ; thus , we need to exploit more information from its context [ 17 ] .
1249
We implemented a simple function to classify the semantic type of a possessive pronoun based on its context word .
We implemented a simple function to classify the semantic type of a possessive pronoun , based on its context word .
1250
In particular , we check the noun phrase whose determiner is its or their ; if the noun phrase contains a protein key word then the inclusive pronoun is classified into the Protein semantic type .
In particular , we check the noun phrase in which the determiner is its or their ; if the noun phrase contains a protein key word , then the inclusive pronoun is classified into the Protein semantic type .
1251
protein key words can be a verb , a noun or an adjective that coocurred with protein mentions and can be used as a clue to distinguish the protein type from other semantic types .
Protein key words can be a verb , a noun or an adjective that co-occurred with protein mentions , and can be used as a clue to distinguish the protein type from other semantic types .
1252
For example , the word binding in the following noun phrases its heterodimeric binding partner , or its binding site is a good clue to infer that it must be a protein reference .
For example , the word binding in the following noun phrases : its heterodimeric binding partner , or its binding site , is a clue to infer that it must be a protein reference .
1253
For our preliminary experiment , we collect these key words manually by checking the noun phrases containing its and their in training data .
For our preliminary experiment , we collect these keywords manually by checking the noun phrases containing its and their in the training data .
1254
Our final protein key word set includes 12 words : binding , expression , interaction , regulation , phosphatase activity , localization , gene , sequence , region , phosphorylation , transactivation , and transcription .
Our final protein keyword set includes 12 words : binding , expression , interaction , regulation , phosphatase activity , localization , gene , sequence , region , phosphorylation , transactivation , and transcription .
1255
Coreferential definite noun phrases in text are used in broader meaning of coreference .
Coreferential definite noun phrases in text are used to include a broader definition of coreference .
1256
In other words , their antecedents do not necessarily exist in the textual context ; in particular in biomedical scientific papers , many definite noun phrases do not have antecedents since the referred concepts can be anything understood by experts in the domain .
In other words , their antecedents do not necessarily exist in the textual context ; in particular , in biomedical scientific papers , many definite noun phrases do not have antecedents , since the referenced concepts can include any concept that is understood by subject matter experts in the domain .
1257
Knowing their semantic type helps to filter out irrelevant candidate antecedents , increasing chance to pick up the right antecedent or the precision of antecedent prediction .
Knowing their semantic type helps to filter out irrelevant candidate antecedents , thereby increasing the chance of picking up the right antecedent , and increasing the precision of antecedent prediction .
1258
We tested two different head word lists : one is built automatically from the gold anaphoric nominals in gold data , the other word list contains top seven common head words : protein , gene , factor , molecule , element , family , inhibitor , and receptor .
We tested two different head word lists : one is built automatically from the gold anaphoric nominals in gold data ; the other word list contains the top seven common head words : protein , gene , factor , molecule , element , family , inhibitor , and receptor .
1259
Those candidates which are not agree with the anaphor in semantics are filtered out .
Those candidates that are not in agreement with the anaphor in semantics are filtered out .
1260
Our minimal system configuration includes all the processing and filters from step 0 to step 3 as explained in the above section ( RB-MIN ) .
Our minimal system configuration includes all of the processing and filters from step 0 to step 3 , as explained in the section above ( RB-MIN ) .
1261
For antecedent candidate selection , the window size used in step 4 is set to 2 , which means antecedent candidates are collected in the two nearest sentences from the anaphor , and the sentence embedding the anaphor .
For antecedent candidate selection , the window size used in step 4 is set to 2 , which means that antecedent candidates are collected in the two nearest sentences from the anaphor , and the sentence embedding the anaphor .
1262
As the statistics measured on the training set of the corpus shows that 97 .0% percent of protein coreference links have antecedents appearing in within 2 sentences .
The statistics measured on the training set of the corpus shows that 97 .0% percent of protein coreference links have antecedents appearing in within 2 sentences .
1263
The word list used to filter out anaphoric definite noun phrases in step 2 contains the following words : protein , gene , factor , molecule , element ,family , inhibitor , and receptor .
The word list used to filter out anaphoric definite noun phrases in step 2 contains the following words : protein , gene , factor , molecule , element , family , inhibitor , and receptor .
1264
Besides , premodifiers of definite noun phrases are also limited to numbers and popular premodifiers of proteins such as nuclear , transcription .
Premodifiers of definite noun phrases are also limited to numbers and popular premodifiers of proteins , such as nuclear , and transcription .
1265
To keep the minimal configuration simple , step 4 - antecedent selection of the baseline only uses the default comparison rule , which assures the closest antecedent candidate is selected .
To keep the minimal configuration simple , step 4 - antecedent selection of the baseline only uses the default comparison rule , which assures that the closest antecedent candidate is selected .
1266
This primary evaluation method , which was particularly designed for the shared task , is based on protein coreference links automatically generated from manually annotated coreference links .
This primary evaluation method , which was particularly designed for the shared task , is based on protein coreference links that have been automatically generated from manually annotated coreference links .
1267
Note that RB-MIN with minimal configuration already outperforms the best result by the UU team , with up to 7 .1% higher in Fscore .
Note that the results from RB-MIN with minimal configuration , already surpasses the best results obtained by the UU team , with up to 7 .1% higher performance in F-score .
1268
Since RB-MIN uses similar preprocessing tools as UU [ 11 ] , but less information in antecedent prediction , this gap in performance is supposed to be caused by the different markable detection methods .
Since RB-MIN uses similar preprocessing tools as UU [ 11 ] , but less information in antecedent prediction , this gap in performance is likely caused by the different markable detection methods .
1269
Breaking down the system performance by types of anaphors gives us an insight into what have been solved by our methods , and what needs more improvement effort .
Breaking down the system performance by the different types of anaphors provides us with insight into what has been accomplished / solved by our methods , and also provides us with improvement opportunities .
1270
However , it should be noted that our antecedent prediction for the RELAT type is based completely on the output of Enju parser for the RELAT type , so in order to improve this type of coreference , we have to find ways to overcome the parse errors on noun phrase boundary detection and relative clause attachment ( See section Discussions ) .
However , it should be noted that our antecedent prediction for the RELAT type is based solely on the output of the Enju parser for the RELAT type , so in order to improve this type of coreference , we have to find ways to overcome the parse errors on noun phrase boundary detection and relative clause attachment ( See Discussions section ) .
1271
The analysis results are given in section Discussions .
The analyses of the results are provided in the section entitled Discussions .
1272
The combination of rule 1 , 2 and 3 resulted in 62 .4% fscore ( RB-MIN+1 , 2 , 3 ) ( Table 3 ) In this configuration , rule 2 contribute to the increasement of 4 points Fscore on the development set , and 2 .3 points Fscore on the test set , when comparing RB-MIN+1 , 3 and RB-MIN+1 , 2 , 3 .
The combination of rule 1 , 2 and 3 resulted in a 62 .4% F-score ( RB-MIN+1 , 2 , 3 ) ( Table 3 ) In this configuration , rule 2 contributes to a 4-point F-score increase in the development set , and 2 .3-point F-score increase on the test set , when comparing RB-MIN+1 , 3 and RB-MIN+1 , 2 , 3 .
1273
This gain is due to the fact that the rule ensures the semantic type of antecedents is the same as their anaphors , enabling the correct detection of antecedents .
This gain is due to the fact that the rule ensures that the semantic type of antecedents is the same as for their anaphors , thus enabling the correct detection of antecedents .
1274
In other words , if anaphor is classified as a protein reference , then antecedent must also be a protein reference .
In other words , if an anaphor is classified as a protein reference , then the antecedent must also be a protein reference .
1275
( Coreference examples in this paper are represented as below : gold anaphoric and antecedent expressions are bracketed , antecedents before anaphors ; gold protein mentions are underlined ; and incorrect response antecedents are in italics . )
( Coreference examples in this paper are represented in the following manner : gold anaphoric and antecedent expressions are bracketed , antecedents before anaphors ; gold protein mentions are underlined ; and incorrect response antecedents are in italics . )
1276
Meanwhile since this transcription factor is recognized as a protein reference , its closest protein antecedent IRF-1 was successfully detected by RB-FULL .
Meanwhile , since this transcription factor is recognized as a protein reference , its closest protein antecedent IRF-1 was successfully detected by RB-FULL .
1277
Another interesting example is
Another example is :
1278
Although studies and a dominant negative form of its heterodimeric binding partner have been crossed out because of disagreement in numbers , and violation of abandoned syntactic constraints correspondingly , the system would return the incorrect antecedent apoptosis instead of c-Myc .
Although studies and a dominant negative form of its heterodimeric binding partner have been crossed out because of disagreement in numbers , and violation of abandoned syntactic constraints , correspondingly , the system would return the incorrect antecedent apoptosis instead of c-Myc .
1279
Without limiting the number of anaphors by using semantic information-based filtering , the precision significantly drops , causing a big decrease in Fscore ( Table 4 , RB-FULL w / o DEFNP-ANA-SEM ) . .
Without limiting the number of anaphors by using semantic information-based filtering , the precision significantly drops , causing a big decrease in the F-score ( Table 4 , RB-FULL without DEFNP-ANA-SEM ) .
1280
This is because the semantic filter is the only way to filter out definite noun phrase anaphors .
This decrease is due to the fact that the semantic filter is the only way to filter out definite noun phrase anaphors .
1281
In our system , contextual information of possessive pronouns is utilized through the protein key words ( Section Methods ) , and this contributed to 1 .8% gain in f-score ( Table 4 , RB-FULL w / o PRO-ANA-SEM ) .
In our system , contextual information of possessive pronouns is utilized through the protein key words ( Section Methods ) , and this contributed to a 1 .8% gain in F-score ( Table 4 , RB-FULL without PRO-ANA-SEM ) .
1282
This is an encouraging sign to seek for a systematic method to exploit and include such contextual information in coreference resolution .
This gain is a good indication for seeking a systematic method to develop and include such contextual information in coreference resolution .
1283
Below are the examples showing the effectiveness of semantic information from the context of pronouns .
Examples showing the effectiveness of semantic information from the context of pronouns is provided below :
1284
However , we found in the data several coreferential expressions violating this constraint .
However , in the data , we found several coreferential expressions that violate this constraint .
1285
For instance , the anaphor and antecedent in the following :
The anaphor and antecedent in the following is an instance of this violation :
1286
Therefore , when the proteins appear in premodifiers or postmodifers of noun phrases as [ cDNAs encoding EBF or a covalent homodimer of E47 ] in this example
Therefore , when the proteins appear in premodifiers or postmodifers of noun phrases as [ cDNAs encoding EBF or a covalent homodimer of E47 ] in this example :
1287
In furture , corpus annotation and evaluation scheme should be revised for the ease of automation of coreference resolution .
In future , revision of corpus annotation and evaluation schemes would benefit the ease of automation of coreference resolution .
1288
Our work has confirmed again that domain knowledge is indispensable for coreference resolution .
Our current work has reconfirmed that domain knowledge is indispensable for coreference resolution .
1289
Since the biologicaldomain has richer knowledge resources than any other domain , it would be interesting to continue studying how to exploit and employ domain-specific semantic information in coreference resolution for this domain .
Since the biological domain has richer knowledge resources than any other domain , it would be interesting to continue studying how to exploit and employ domain-specific semantic information in coreference resolution for this domain .
1290
This subproblem is often thought as an easy task in coreference resolution systems , however , indeed it is an important subtask which strongly affects the performance of coreference system .
This sub-problem is often regarded as an easy task in coreference resolution systems ; however , in actuality , it is an important subtask , which strongly affects the performance of coreference system .
1291
Sticking to the gold data in the designing markable detection method as we did in this paper is one of the strategies .
Sticking to the gold data in designing the markable detection method , as done in this paper , is one employed strategy .
1292
However , from another perspective , the perspective of coreference data creation , we should revise the markable annotations , for the sake of automatic and robust markable detection .
However , from the perspective of coreference data creation , revision of the markable annotations would aid in automatic and robust markable detection .
1293
As for the future , more effort should be spent on automating the semantic classification for coreference expressions using context .
For future opportunities , more effort should be spent on automating the semantic classification for coreference expressions , using context .
1294
The success of corpus-based methods has made syntactically annotated corpora important resources for natural language processing .
Syntactically annotated corpora have become important resources for natural language processing , due in part to the success of corpus-based methods .
1295
This is also a concern of Vietnamese Treebank ( VTB ) , the first and the only publicly available syntactically annotated corpus so far for the Vietnamese language .
This is also a concern for the Vietnamese Treebank ( VTB ) , which is the first and only publicly available syntactically annotated corpus thus far for the Vietnamese language .
1296
Although word segmentation is straight-forward for space-delimited languages like English , this is not true for languages like Vietnamese of which no standard criterion for word segmentation exists .
Although word segmentation is straight-forward for space-delimited languages like English , this is not the case for languages like Vietnamese for which a standard criterion for word segmentation does not exist .
1297
Then , by combining and splitting the inconsistent annotations detected , we could observe the influence of different word segmentation criteria on automatic word segmentation , and the applications of word segmentation , including text classification and English-Vietnamese statistical machine translation .
Then , by combining and splitting the inconsistent annotations that were detected , we are able to observe the influence of different word segmentation criteria on automatic word segmentation , and the applications of word segmentation , including text classification and English-Vietnamese statistical machine translation .
1298
Treebanks , corpora annotated with syntatic structures , have become more and more impor-tant for language processing .
Treebanks , which are corpora annotated with syntactic structures , have become more and more important for language processing .
1299
To strengthen the automatic processing of the Vietnamese language , the Vietnamese treebank ( VTB ) has been built as a part of the national project `` Vietnamese language and speech processing ( VLSP ) '' ( Nguyen et al ., 2009b ) .
In order to strengthen the automatic processing of the Vietnamese language , the Vietnamese Treebank ( VTB ) has been built as a part of the national project , `` Vietnamese language and speech processing ( VLSP ) '' ( Nguyen et al ., 2009b ) .
1300
However , in our preliminary experiment with VTB , when we trained the Berkeley parser ( Petrov et al ., 2006 ) and evaluated it using the corpus , the parser achieved only 65 .8% in F-score .
However , in our preliminary experiment with VTB , when we trained the Berkeley parser ( Petrov et al ., 2006 ) and evaluated it by using the corpus , the parser achieved only 65 .8% in F-score .
1301
This performance is far lower than the state-of-the-art performance reported for Berkeley Parser on English Penn Treebank , 90 .3% in F-score ( Petrov et al ., 2006 ) .
This score is far lower than the state-of-the-art performance reported for the Berkeley Parser on the English Penn Treebank , which reported 90 .3% in F-score ( Petrov et al ., 2006 ) .
1302
There are two possible reasons for this .
There are two possible reasons to explain this outcome .
1303
First , the quality of VTB is not good enough to build a good a parser , including the quality of the annotation scheme , the annotation guidelines , and the annotation process .
One reason for this outcome is the quality of VTB , including the quality of the annotation scheme , the annotation guidelines , and the annotation process .
1304
Second , parsing Vietnamese is a diffcult problem by its own , and we need to seek new solutions to the problem .
The second reason is the difficulty of parsing Vietnamese ; we need to seek new solutions to address this problem .
1305
This paper focuses on the word segmentation issues since the most basic unit of a treebank is word ( Di Sciullo and Edwin , 1987 ) , and defining `` What are words ? '' is the first problem that a treebank has to solve ( Xia , 2000b ,a ; Sornlertlamvanich et al ., 1997 , 1999 ) .
This paper focuses on the word segmentation , since the most basic unit of a treebank are words ( Di Sciullo and Edwin , 1987 ) , and defining `` words '' is the first step ( Xia , 2000b ,a ; Sornlertlamvanich et al ., 1997 , 1999 ) .
1306
For languages like English , answering this question is almost trivial because the blank spaces denote word delimiters .
For languages like English , defining `` words '' is almost trivial , because the blank spaces denote word delimiters .
1307
However , for an isolating language like Vietnamese , where blank spaces play a role of syllable delimiters , `` What are words ? '' is not a trivial question .
However , for an isolating language like Vietnamese , for which blank spaces play a role of syllable delimiters , `` What are words ? '' is not a trivial question .
1308
For example , the sentence `` H❅c sinh h❅c sinh h❅c ( students learn biology )1 '' is composed of three words `` h❅c sinh ( student ) '' , `` h❅c ( learn ) , '' and `` sinh h❅c ( biology ) ; '' Word segmentation is expected to break down the sentence at the boundaries of these words , not to split `` h❅c sinh ( student ) '' and `` sinh h❅c ( biology ) '' .
For example , the sentence `` H❅c sinh h❅c sinh h❅c ( students learn biology )1 '' is composed of three words , `` h❅c sinh ( student ) '' , `` h❅c ( learn ) , '' and `` sinh h❅c ( biology ) '' . Word segmentation is expected to break down the sentence at the boundaries of these words , instead of splitting `` h❅c sinh ( student ) '' and `` sinh h❅c ( biology ) '' .
1309
In such context , the extracted words are more appropriate for building a dictionary than for corpus-based language processing , which are out of the focus of this paper .
In such a context , the extracted words are more appropriate for building a dictionary , rather than for corpus-based language processing , which are outside of the scope of this paper .
1310
Establishing a gold standard for Vietnamese word segmentation faces some diffcuties coming from the characteristics of the language .
Because of the discussed characteristics of the language , there are challenges in establishing a gold standard for Vietnamese word segmentation .
1311
Although most people agree that the Vietnamese language has two types of words : single and compound , there is little consensus on how to segment a sentence into words .
Although most people agree that the Vietnamese language has two types of words : single and compound , there is little consensus as to the methodology for segmenting a sentence into words .
1312
The disagreement is not only because of the different functions of blank spaces as mentioned above , but also because Vietnamese is not an inflectional language like English or Japanese , where morphological forms can be useful clues for word segmentation .
The disagreement occurs not only because of the different functions of blank spaces ( as mentioned above ) , but also because Vietnamese is not an inflectional language , as is the case for English or Japanese , for which morphological forms can provide useful clues for word segmentation .
1313
While the similar problems also happen with Chinese word segmentation ( Xia , 2000b ) , Vietnamese word segmentation may be more diffcult because the modern Vietnamese writing system is based on Latin characters , which represents the pronunciation but not the meaning of words .
While similar problems also occur with Chinese word segmentation ( Xia , 2000b ) , Vietnamese word segmentation may be more difficult , because the modern Vietnamese writing system is based on Latin characters , which represent the pronunciation , but not the meaning of words .
1314
All these characteristics make it diffcult to perform word segmentation for Vietnamese both manually and automatically , and have resulted in different criteria for word segmenation .
All of these characteristics make it diffcult to perform word segmentation for Vietnamese , both manually and automatically , and have thus resulted in different criteria for word segmentation .
1315
However , so far there have been few studies on the challenges in word segmentation , and the comparison of different word segmentation criteria .
However , so far , there have been few studies on the challenges in word segmentation , and the comparison of different word segmentation criteria .
1316
The rest , which can be considered as the most diffcult and controversial cases of word segmentation , were used to create different versions of the VTB corpus representing different word segmentation criteria .
The rest , which can be considered as the most difficult and controversial instances of word segmentation , were used to create different versions of the VTB corpus , representing different word segmentation criteria .
1317
Finally , we evaluated these criteria in automatic word segmentation , and its application in text classification and English-Vietnamese statistical machine translation in Section 4 .
Finally , we evaluated these criteria in automatic word segmentation , and its application in text classification and English-Vietnamese statistical machine translation , in Section 4 .
1318
This study also promotes the computational linguistic studies on how to transfer methods developed for a popular language like English to a language that has not yet intensively studied .
This study also promotes the computational linguistic studies on how to transfer methods developed for a popular language , like English , to a language that has not yet been intensively studied .
1319
Word segmentation in VTB aims to found a standard for word segmentation in a context of multi-level language processing .
Word segmentation in VTB aims at establishing a standard for word segmentation in a context of multi-level language processing .
1320
VTB specifies 12 types of units that should be identified as words ( Table 1 ) ( Nguyen et al ., a ) , which can be divided into three groups : single , compound , and special `` words '' .
VTB specifies 12 types of units that should be identified as words ( Table 1 ) ( Nguyen et al ., a ) , which can be divided up into three groups : single , compound , and special `` words '' .
1321
The terminology tokens refers to text spans separated with each other by blank spaces .
The terminology tokens refers to text spans that are separated from each other by blank spaces .
1322
Special `` words '' can be idioms , locutions , proper names , date times , numbers , symbols , sentence marks , foreign words , or abbreviations .
Special `` words '' include idioms , locutions , proper names , date times , numbers , symbols , sentence marks , foreign words , or abbreviations .
1323
The segmentation of these types of words forms a basis for the POS tagging , with 18 different POS tags shown in Table 2 ( Nguyen et al ., c ) .
The segmentation of these types of words forms a basis for the POS tagging , with 18 different POS tags , as shown in Table 2 ( Nguyen et al ., c ) .
1324
Each unit in Table 1 goes with several example words of which English translations are given in parentheses .
Each unit in Table 1 goes with several example words ; English translations are provided in parentheses .
1325
Besides , we added a translation for each token when possible , so that the readers unfamiliar with Vietnamese can have an intuitive idea of how the compound words are formed .
Furthermore , we added a translation for each token , where possible , so that readers who are unfamiliar with Vietnamese can have an intuitive idea as to how the compound words are formed .
1326
However , for some tokens , we could not find any appropriate English translation , so we give it an empty translation marked with an asterisk .
However , for some tokens , we could not find any appropriate English translation , so we gave it an empty translation , marked with an asterisk .
1327
Note that a Vietnamese word or a token in context can have other meanings in addition to the given translations .
Note that a Vietnamese word or a token in context can have other meanings , in addition to the given translations .
1328
A special type of words in Vietnamese is classifer noun , denoted by the part-of-speech Nc in Table 2 .
A classifier noun , denoted by the part-of-speech Nc in Table 2 , is a special type of word in Vietnamese .
1329
Classifier nouns are specific to several Southeast Asian languages like Vietnamese and Thai .
Classifier nouns are specific to several Southeast Asian languages , like Vietnamese and Thai .
1330
For example , the common noun `` bàn '' means tables in general , while `` cái bàn '' means a specific table similar to the table in English .
For example , the common noun `` bàn '' generally means tables , while `` cái bàn '' means a specific table , similar to the table in English .
1331
Our analysis is based on two types of inconsistency : variation and structural inconsistency , whose definitions and details are given below .
Our analysis is based on two types of inconsistencies : variation and structural inconsistency , which are defined below .
1332
Variation inconsistency : is a sequence of tokens which have more than one way of seg-mentation in the corpus .
Variation inconsistency : is a sequence of tokens , which has more than one way of segmentation in the corpus .
1333
For example , `` con gái/girl '' can remain as one word , or be segmented into two words `` con '' and `` gái '' .
For example , `` con gái/girl '' can remain as one word , or be segmented into two words , `` con '' and `` gái '' .
1334
A variation can be an annotation inconsistency , or an ambiguity inVietnamese .
A variation can be an annotation inconsistency , or an ambiguity in Vietnamese .
1335
For example , `` con gái/girl '' and `` con trai/boy '' have similar structures , a combination of a classifier noun and a common noun Nc + N , so when `` con gái/girl '' is splitted and `` con trai/boy '' is not , it is considered as a structural inconsistency of Nc .
For example , `` con gái/girl '' and `` con trai/boy '' have similar structures : a combination of a classifier noun and a common noun , Nc + N , so when `` con gái/girl '' is split , and `` con trai/boy '' is not , it is considered as a structural inconsistency of Nc .
1336
It is likely that structural inconsistency in word segmentation level makes the higher levels of processing , POS tagging and bracketing , become more complicated .
It is likely that structural inconsistency at the word segmentation level complicates the higher levels of processing , including POS tagging and bracketing .
1337
The detection method for variation inconsistency is based on N-gram sequences and the phrase structures in VTB treebank , following the definition of variation inconsistency above .
The detection method for variation inconsistency is based on N-gram sequences and the phrase structures in the VTB , following the definition for variation inconsistency , above .
1338
Table 3 shows the overall statistics of the variation inconsistency detected by the above method .
Table 3 shows the overall statistics of the variation inconsistency detected by the method described above .
1339
This ratio of 2-gram variations is much higher than the evarage ratio of two-token words in Vietnamese reported in ( Nguyen et al., 2009a ) , which is 80% percent .
This ratio of 2-gram variations is much higher than the average ratio of two-token words in Vietnamese , as reported in ( Nguyen et al., 2009a ) , which is 80% .
1340
Variations have lengths of three and four tokens occupy 6 .1% and 1 .0% , respectively .
Variations that have lengths of three and four tokens occupy 6 .1% and 1 .0% , respectively .
1341
We estimated the precision of our method by randomly selected 130 2-gram variation instances extracted from the above method , and manually checked whether they are true inconsistency .
We estimated the precision of our method by randomly selecting 130 2-gram variation instances , extracted from the method described above , and manually checked whether the inconsistencies are true .
1342
Only one instance is an ambiguous sequence giá c , which is one word when it means price , and two words giá / price c / all in đàu có giá c / all have ( their own ) price .
Only one instance of inconsistency was an ambiguous sequence giá c , which is one word when it means price , and two words giá / price c / all in đàu có giá c / all have ( their own ) price .
1343
The precision of our method is high enough so that so we can use the extracted variations to study the insights of word segmentation problem .
The precision for our method is high , so we can use the extracted variations to provide insights on the word segmentation problem .
1344
There are totally 54 patterns of POS sequence , of which top 10 confusing patterns , a long with their counts of 2-gram variations , and examples are shown in Table 4 .
There are a total of 54 patterns of POS sequences . The top 10 confusing patterns , their counts of 2-gram variations , and examples are depicted in Table 4 .
1345
Table 5 and Table 6 show the POS patterns which a specific POS tag appearing at the beginning or ending of the sequence .
Table 5 and Table 6 show the POS patterns that are a specific POS tag , appearing at the beginning or ending of the sequence .
1346
Investigating the inconsistent 2-grams extracted , we found that most of them are compound words according to the VTB guidelines ( Section 2 ) .
Investigating the inconsistent 2-grams extracted , we found that most of them are compound words , according to the VTB guidelines ( Section 2 ) .
1347
This problem seems to have caused a lot of trouble for the annotators of VTB .
This scenario has proven to be problematic for the annotators of VTB .
1348
Furthermore , observing the POS patterns in Table 5 and Table 6 , we can see the potential of structural inconsistency , in particular for closed-set POS tags .
Furthermore , by observing the POS patterns in Table 5 and Table 6 , we can see the potential for structural inconsistency , particularly for closed-set POS tags .
1349
First , we collected all affxes and classifier nouns in the VTB corpus . Then , extracted 2-grams containing these affxes or classifier nouns , which also are the structural inconsistencies .
We collected all affixes and classifier nouns in the VTB corpus , and then extracted 2-grams containing these affixes or classifier nouns , which are also structural inconsistencies .
1350
Note that even though the sequence " con trai " is always splitted into two words throughout the corpus , it can still be an inconsistency if we consider similar structures such as " con gái " .
Even though the sequence , " con trai " is always split into two words throughout the corpus , it can still be an inconsistency , if we consider similar structures such as " con gái " .
1351
In other words , by this method , we extract sequences that may be consistent at the surface level , but are not consistent if we consider the higher analysis levels , POS tagging .
In other words , by this method , we extract sequences that may be consistent at the surface level , but are not consistent , if we consider the higher analysis levels , POS tagging .
1352
According to the VTB POS-tagging annotation guidelines ( Nguyen et al., c ) , classifier nouns should be separated from the words they modify .
According to the VTB POS-tagging annotation guidelines ( Nguyen et al., c ) , classifier nouns should be separated from the words that they modify .
1353
However , in practice it is confusing when the classifier noun can be stand alone as a single word .
However , in practice , it is confusing when the classifier noun can be standalone as a single word .
1354
For example a classifier noun , e.g. , " con " in " con trai ( boy ) " , or " con gái ( girl ) " , can also be a simple word which means " I ( first person pronoun used by a child when talking to his / her parents ) " , or part of a complex noun " con cái ( children ) " .
For example a classifier noun , e.g. , " con " in " con trai ( boy ) " , or " con gái ( girl ) " , can also be a simple word , which means " I ( first person pronoun used by a child when talking to his / her parents ) " , or part of a complex noun " con cái ( children ) " .
1355
Therefore , in our experiments , we want to evaluate the " splitting " and " combining " of these diffcult cases , to see whether the solution is fruitful for applications of the corpus .
Therefore , in our experiments , we want to evaluate the " splitting " and " combining " of these cases , in order to see whether the solution is successful for applications of the corpus .
1356
Examing the variations extracted by the variation inconsistency detection , we found that there are cases when a special character like percentage % in " 30% " , is splitted or combined with " 30 " .
By examining the variations extracted by the variation inconsistency detection , we found that there are cases when a special character like a percentage ( % ) in " 30% " , is split or combined with " 30 " .
1357
Checking structural inconsistency of these special characters including percentage% , hyphen - , and so on , we found quite a significant amount of inconsistent annotations .
By checking structural inconsistencies of these special characters , including percentages ( % ) , hyphens ( - ) , and other symbols , we found quite a significant number of inconsistent annotations .
1358
For example , the character % in " 30% " is splitted but is combined with the number in " 50 % " , which is considered as a structural inconsistency .
For example , the character , % , in " 30% " is split , but is combined with a number in " 50 % " , which is considered to be a structural inconsistency .
1359
Note that although it can be argued that whether " N% " can be splitted into two words or combined in one word is dependent on the blank space in between N and " % " .
Note that it can be argued that splitting " N% " into two words or combined in one word is dependent on the blank space in-between N and " % " .
1360
It does matter higher-levels of annotation such as POS tagging because we may need one or two different POS tags for different ways of annotation .
Higher-levels of annotation such as POS tagging is significant , because we may need one or two different POS tags for the different methods of annotation .
1361
Therefore , we think it is better to carefully preprocess text and segment these special characters in a consistent way .
Therefore , we think that it is better to carefully preprocess text and segment these special characters in a consistent way .
1362
Automatically modification is diffcult since we must check the semantics of the special characters in their contexts .
Automatically modification is diffcult , since we must check the semantics of the special characters in their contexts .
1363
For example , hyphens in date expressions like " 5-4-1975 " , which means the date " April the fifth , 1975 , " are combined with the numbers .
For example , hyphens in date expressions like " 5-4-1975 " , which refers to the date , " the fifth of April , 1975 , " are combined with the numbers .
1364
However , when the hypen has a meaning of " ( from ) to " or " around .
However , when the hyphen indicates " ( from ) to " or " around .
1365
or " , as in " 2-3 gi░ sáng " meaning " around 2 or 3 o’clock in the morning " , we decided to separate it from the surrounding numbers .
or " , as in " 2-3 gi░ sáng " , meaning " around 2 or 3 o’clock in the morning " , we decided to separate it from the surrounding numbers .
1366
The variation inconsistency and structural inconsistency found in Section 3 above can also be seen as representatives of different word segmentation criteria for Vietnamese .
The variation inconsistency and structural inconsistency found in Section 3 can also be seen as representatives of different word segmentation criteria for Vietnamese .
1367
These data sets are used in our experiments as illustrated in Figure 1 .
These data sets are used in our experiments , as illustrated in Figure 1 .
1368
Label of each token is determined based on the lexical features of two preceding words and two following words of that token .
The label of each token is determined based on the lexical features of two preceding words , and the two following words of that token .
1369
Text classification is defined as a task of determining for an input document the most suitable topic from the predefined topics .
Text classification is defined as a task of determining the most suitable topic from the predefined topics , for an input document .
1370
The difference is that we performed for document level , not for sentence level .
The difference is that we performed the task at the document level , instead of at the sentence level .
1371
In our experiment for comparison of different word segmentation criteria in topic classification , we only vary the word segmentation model used for this task , while fixing other configurations .
In our experiment , for comparison of different word segmentation criteria in topic classification , we only vary the word segmentation model used for this task , while fixing other configurations .
1372
A	phrase-based SMT system for English-Vietnamese translation was implemented .
A	phrase-based SMT system for English-Vietnamese translation was implemented .
1373
Translation results are evaluated using BLUE score ( Papineni et al., 2002 ) .
Translation results are evaluated using the BLUE score ( Papineni et al., 2002 ) .
1374
There are two important conclusions can be drawn from these tables : ( 1 ) Quality of the treebank strongly affects the applications since our BASE model and most of other enhanced models improved the performance of TC and SMT systems ; ( 2 ) " Splitting " seems to be a good solution for word segmentation of controversial cases , including the split of variations , affxes , and classifier nouns .
There are two important conclusions that can be drawn from these tables : ( 1 ) The quality of the treebank strongly affects the applications , since our BASE model and most of the other enhanced models improved the performance of TC and SMT systems ; ( 2 ) " Splitting " seems to be a good solution for word segmentation for controversial cases , including the split of variations , affxes , and classifier nouns .
1375
Except for STRUCT_NC , all the modifications to the original VTB corpus increase the performance of WS .
With the exception of STRUCT_NC , all of the modifications to the original VTB corpus increase the performance of WS .
1376
In both SMT and TC experiments , the BASE model which is based on the manually-modified inconsistency of special characters , achieved better results than the ORG model .
In both SMT and TC experiments , the BASE model , which is based on the manually-modified inconsistency of special characters , achieved better results than the ORG model .
1377
Among them , the best model VAR_SPLIT achieved 36 .91 BLEU score , which is 0 .55 higher than ORG .
Among them , the best-performing model , VAR_SPLIT achieved 36 .91 BLEU score , which is 0 .55 higher than ORG .
1378
Additionally , because our automatic methods for inconsistency detection could not cover all types of inconsistency in word segmentation annotation , further improvement of corpus quality is demanded .
Additionally , because our automatic methods for inconsistency detection could not cover all of the types of inconsistencies in word segmentation annotation , further improvement of corpus quality is demanded .
1379
Comparing the results of STRUCT_AFFIX and STRUCT_NC with BASE in WS , TC , and SMT , we can observe that combining affxes with their head nouns resulted in slightly better results for WS , TC , and does not change the performance of SMT .
Comparing the results of STRUCT_AFFIX and STRUCT_NC with BASE in WS , TC , and SMT , we can observe that combining affxes with their head nouns resulted in slightly better results for WS and TC , and did not change the performance of SMT .
1380
Another intention of our experiment is to compare two solutions for controversial cases of word segmentation , splitting and combining .
Another part of the scope of our experiment is to compare two solutions for controversial cases of word segmentation , splitting and combining .
1381
Splitting and combining variations are reflected by VAR_COMB and VAR_SPLIT , while STRUCT_AFFIX and STRUCT_NC represent the combination of affxes or classifier nouns with the words they modify .
Splitting and combining variations are reflected by VAR_COMB and VAR_SPLIT , while STRUCT_AFFIX and STRUCT_NC represent the combination of affixes or classifier nouns with the words that they modify .
1382
Based on the analysis , we automatically created data representing the different word segmentation criteria , and evaluated the criteria indirectly through their applications .
Based on the analysis , we automatically created data that represent the different word segmentation criteria , and evaluated the criteria indirectly through their applications .
1383
Our experimental results showed that manual modification done for annotation of spe-cial characters and most of other word segmentation criteria significantly improved the performances of automatic word segmentation , text classification and statistical machine translation , comparing with the use of the original VTB corpus .
Our experimental results showed that manual modification , done for annotation of special characters , and most other word segmentation criteria , significantly improved the performances of automatic word segmentation , text classification and statistical machine translation , in comparison with the use of the original VTB corpus .
1384
Since the VTB corpus is the first effort in building a treebank for Vietnamese , and is the only corpus publicly available for NLP research , this study contributes to further improvement of the corpus quality , which is essential for building effcient NLP systems .
Since the VTB corpus is the first effort in building a treebank for Vietnamese , and is the only corpus that is publicly available for NLP research , this study contributes to further improvement of the corpus quality , which is essential for building efficient NLP systems .
1385
Although there are several approaches proposed to cope with this problem , their extremely high computational cost limits their scalability on largescale video datasets that may contain millions faces of hundreds characters .
Although several approaches have been proposed to deal with this problem , their extremely high computational cost limits their scalability to large-scale video datasets that may contain millions of faces of hundreds of characters .
1386
To utilize the variability of face appearances in video , we use a set of face images called face-track to represent for the appearance of a character in a video shot .
To utilize the variability of face appearances in video , we use a set of face images called face track to represent the appearance of a character in a video shot .
1387
Our first proposal is an approach for extracting face-tracks .
Our first proposal is an approach to extracting face tracks .
1388
We use a point tracker for exploring the connections between detected faces belonging to the same character , then grouping them into one face-track .
We use a point tracker to explore the connections between detected faces belonging to the same character and , then group them into one face track .
1389
In the second proposal , we introduce an efficient approach to match face-tracks for retrieval .
In the second proposal , we introduce an efficient approach to matching face tracks for retrieval .
1390
Instead of using all faces in face-tracks to compute their similarity , our approach select representative faces for each face-track .
Instead of using all the faces in the face tracks to compute their similarity , our approach selects representative faces for each face track .
1391
The representative faces are sampled from the original face-track .
The representative faces are sampled from the original face track .
1392
As a result , we significantly reduce the computational cost for face-track matching while taking into account variability of faces in face-tracks for high matching accuracy .
As a result , we significantly reduce the computational cost of face-track matching while taking into account the variability of faces in face tracks to achieve high matching accuracy .
1393
Experiments are conducted on two face-track datasets extracted from real-world news videos , .
Experiments are conducted on two face-track datasets extracted from real-world news videos , of such .
1394
Their scales have not been considered in literature ever .
scales that have never been considered in the literature .
1395
One dataset contains 1,497 face-tracks of 41 characters extracted from 370 hours of TRECVID videos .
One dataset contains 1,497 face tracks of 41 characters extracted from 370 hours of TRECVID videos .
1396
The other dataset provides 5,567 face-tracks of 111 characters observed from television news program ( NHK News 7 ) channel in 11 years .
The other dataset provides 5,567 face tracks of 111 characters observed from a television news program ( NHK News 7 ) over 11 years .
1397
News videos play an important role in our sources of information nowadays because of their rich and important contents .
News videos play an important role as a source of information nowadays because of their rich and relevant contents .
1398
Since most of the news is related to human , human face retrieval , which is defined as the task of extracting and returning faces relevant to a given query , obviously becomes an important task .
Because most news are related to people , human face retrieval , which is defined as the task of extracting and returning faces relevant to a given query , obviously becomes an important task .
1399
With the list , important events related to the character can be detected or summarized.
With such a list , important events related to the character can be found or summarized.
1400
On the other hand , efficiency is also an issue of such a face retrieval system beside its accuracy since scales of available datasets are getting larger rapidly , for instance , exceeding thousands hours of videos with millions faces of hundreds character .
Besides accuracy , efficiency is also an issue in such a face retrieval system because the scales of available datasets are rapidly getting larger , for instance , exceeding thousands of hours of videos with millions of faces of hundreds of characters .
1401
Generally , there are two principle steps in a face retrieval system .
Generally , a face retrieval system consists of two principal steps .
1402
And , the second step is matching the extracted ones with a given query to return a rank list .
, The second step is matching the extracted appearances with a given query so as to return a rank list .
1403
While conventional approaches consider single face images as the basic units for extracting and matching \CITE , recently proposed approaches sifted towards sets of face images called face-tracks .
Whereas conventional approaches consider single face images as the basic units in extracting and matching \CITE , recently proposed approaches shifted toward the use of sets of face images called face tracks .
1404
A face-track contains multiple face images belonging to the same individual character within a video shot .
A face track contains multiple face images belonging to the same individual character within a video shot .
1405
Face images in a face-track may present the corresponding character under different viewpoints and facial expressions ( as shown in Figure 1 ) .
The face images in a face track may present the corresponding character from different viewpoints and with different facial expressions ( as shown in Figure 1 ) .
1406
By exploiting the plenteous information from multiple exemplar faces in face-tracks , face-track based approaches are expected to achieve more robust and stable performance.
By exploiting the plenteous information from the multiple exemplar faces in the face tracks , face track-based approaches are expected to achieve a more robust and stable performance.
1407
Once all face-tracks in video shots are extracted , they are matched with the query to return a ranked list as the output of the face retrieval system .
Once all the face tracks in the video shots are extracted , they are matched with the query to return a ranked list as the output of the face retrieval system .
1408
Since each face-track is a set of face images , matching face-tracks essentially can be thought of as a problem of matching image sets .
Because each face track is a set of face images , matching face tracks can essentially be thought of as a problem of matching image sets .
1409
There are several approaches introduced to deal with this problem \CITE .
Several approaches have been introduced to deal with this problem \CITE .
1410
In these works , image set has been modeled in different way , such as distributions \CITE , subspaces \CITE , convex geometric region in feature space \CITE , or more general manifolds \CITE .
Using these approaches , the image set has been modeled in different ways , including as distributions \CITE , subspaces \CITE , a convex geometric region in a feature space \CITE , or more general manifolds \CITE .
1411
Although these approaches shown promising results on benchmark datasets , they require high computational costs to characterize the representation of face-tracks , such as computing the convex geometric region in \CITE , the probability in \CITE , and the eigenvectors in \CITE .
Although these approaches have shown promising results in benchmark datasets , they require high computational costs to characterize the representation of face tracks , such as computing the convex geometric region in \CITE , the probability in \CITE , and the eigenvectors in \CITE .
1412
Their complexity in modeling facetracks and estimating similarity between face-tracks limits their practicability on large-scale datasets.
Their complexity in modeling face tracks and estimating the similarity between face tracks limits their practicability in large-scale datasets.
1413
Working toward solving the above problems , our contributions in this paper is three-fold.
This paper provides a threefold contribution toward solving the above problems , .
1414
To enhance the performance of face-track matching , face-tracks should be first extracted accurately .
To enhance the performance of face-track matching , face tracks should first be extracted accurately .
1415
, We introduce an approach for this purpose .
For this purpose , we introduce an approach .
1416
Our approach is motivated by a study of Everingham et al .
motivated by a study of Everingham et al .
1417
, In constrast to the approach in \CITE , which is failed to deal with specific problems of news video caused by sudden illumination change and partial occlusion , our approach is incorporated techniques to overcome the problems .
Our approach incorporates techniques to overcome specific problems with news video caused by sudden illumination change and partial occlusion , in contrast to the approach in \CITE , which failed to deal with , these problems .
1418
Evaluations on a collection of real-world news videos showed that our proposed face-track extraction approach achieved approximately 95% accuracy , a significant improvement compare the approach in \CITE .
Evaluations of a collection of real-world news videos showed that our proposed face-track extraction approach achieved approximately 95% accuracy , a significant improvement compared to the approach in \CITE .
1419
We introduce an approach which significantly reduces the computational cost for face-track matching while maintaining a competitive performance compare to those of the state-of-the-art approaches .
We introduce an approach that significantly reduces the computational cost for face-track matching while maintaining a competitive performance with state-of-the-art approaches .
1420
Based on the observation that face-tracks obtained by tracking provide highly similar faces in consecutive frames , we argue that it is redundant to use all faces in a face-track for learning the variation of faces .
Based on the observation that face tracks obtained by tracking provide highly similar faces in consecutive frames , we argue that it is redundant to use all the faces in a face track for learning the variation of faces .
1421
Thus , a set of faces is sampled from the original face-track for matching .
Thus , a set of faces is sampled from the original face track for matching .
1422
The size of the set is much smaller than the size of original face-track .
The size of the set is much smaller than that of the original face track .
1423
Then , the mean face of sampled faces in the set is computed .
The , mean face of the sampled faces in the set is then computed .
1424
The similarity between two face-tracks is the distance between their mean faces.
The similarity between two face tracks is the distance between their mean faces.
1425
We investigated the problem of face-retrieval on news video datasets whose scales have not been considered in literature ever .
We investigated the problem of face retrieval in news video datasets whose scales have never been considered in the literature .
1426
Our first dataset is from 370 hours TRECVID news videos which contains 405,887 detected faces belonging to 41 individuals .
Our first dataset is from 370 hours of TRECVID news videos and contains 405,887 detected faces belonging to 41 individuals .
1427
The second dataset is observed from NHK News7 channel in 11 years .
The second dataset includes 1.2 million faces of 111 individuals observed in the NHK News 7 program over 11 years .
1428
In this dataset , 1.2 millions faces of 111 individuals are provided .
, .
1429
The total number of available face-track is 5,567 .
The total number of available face tracks is 5,567 .
1430
Section 5 presents our experimental settings , .
Section 5 presents our experimental settings , and Section 6 provides our .
1431
Conclusion is given in the final Section 6.
conclusions.
1432
Existing studies on automatic face-track extraction follow a standard paradigm that consists of two basic steps , detecting faces in frames and grouping faces of the same character into face-tracks .
The existing studies on automatic face-track extraction follow a standard paradigm that consists of two basic steps , detecting faces in frames and grouping faces of the same character into face tracks .
1433
Then , in the second step , detected faces of the same character will be grouped by using either clustering approaches \CITE or tracking approaches \CITE .
, In the second step , the detected faces of the same character are grouped by using either clustering \CITE or tracking approaches \CITE .
1434
Limitations of this approach includes the expensive computational cost for constructing and clustering high dimensional representation feature vectors; and , its dependence on determining a reasonable threshold for the clustering algorithm to ensure no group contains faces of multiple characters and groups are not over-fragmented.
The limitations of this approach include its high computational cost for constructing and clustering high-dimensional representation feature vectors and , its dependence on determining a reasonable threshold for the clustering algorithm to ensure that no group contains faces of multiple characters and that groups are not over-fragmented.
1435
This tracker can develop tracks on deforming objects , where the between frame region deformation can be modelled by an affine geometric transformation plus perturbations .
This tracker can develop tracks on deforming objects , where the between-frame region deformation can be modeled by an affine geometric transformation plus perturbations .
1436
The disadvantage of this tracker is the computational cost for locating and tracking affine covariance regions .
The disadvantage of this tracker is its high computational cost for locating and tracking affine covariance regions .
1437
in \CITE , .
in \CITE , in which .
1438
The authors employ Kanade-Lucas-Tomasi ( KLT ) tracker to create a set of point tracks starting at some frame in a shot and continuing until some later frame .
they used a Kanade-Lucas-Tomasi ( KLT ) tracker to create a set of point tracks starting at some frame in a shot and continuing until some later frame .
1439
There are two major categories of approaches target to employ multiple-exemplar of faces in face-tracks ( i.e. , sets of face images ) for robust face matching and recognition .
There are two major categories of approaches to using multiple exemplars of faces in face tracks ( i.e. , sets of face images ) for robust face matching and recognition .
1440
Approaches in the first category \CITE make use of both face images and temporal order of their appearances .
The approaches in the first category \CITE make use of both face images and the temporal order of their appearances .
1441
In the training face , they create a HMM model for each character to learn the statistics and temporal dynamics using the eigen-face image sequence .
In the training face , they created a HMM for each character to learn the statistics and temporal dynamics using the eigen-face image sequence .
1442
Without relying on temporal coherence between consecutive images , approaches in the second category uses multiple face images only .
Without relying on temporal coherence between consecutive images , the approaches in the second category use multiple face images only and .
1443
They treat the problem as a set matching problem .
treat the problem as a set-matching problem .
1444
Cevikalp and Triggs \CITE claimed a face sequence was a set of points and discovered a convex geometric region expanded by these points .
Cevikalp and Triggs \CITE claimed that a face sequence is a set of points and discovered a convex geometric region expanded by these points .
1445
To evaluate performance of face matching approaches , most of recent works on face retrieval in video uses two benchmark datasets Mobo ( Motion of Body ) \CITE and Honda / UCSD \CITE .
In evaluating the performance of face-matching approaches , most of the recent works on face retrieval in video use two benchmark datasets: Mobo ( Motion of Body ) \CITE and Honda / UCSD \CITE .
1446
Scales of these datasets are limited , they are varying from hundreds to thousands face images of tens individual characters .
The scales of these datasets are limited , varying from hundreds to thousands of face images of tens of individual characters .
1447
One of the largest available face dataset recently is the Youtube Faces dataset \CITE , .
One of the largest face datasets recently available is the YouTube Faces dataset \CITE , which .
1448
It provides 3,425 videos of 1,595 individual characters .
provides 3,425 videos of 1,595 individual characters .
1449
Because of all above mentioned reasons , we prepare new datasets for evaluating the approaches.
In view of all the above-mentioned considerations , we prepare new datasets for evaluating the approaches.
1450
In the offline stage , face-tracks in all shots of videos are extracted using our face-track extraction approach ( described in Section 4 ) .
In the off-line stage , the face tracks in all video shots are extracted using our face-track extraction approach ( described in Section 4 ) .
1451
One extracted face-track contains multiple face images of one individual character , varied under different viewpoints , illumination conditions , and expressions within a shot .
Each extracted face track contains multiple face images of one individual character , varied under different viewpoints , illumination conditions , and expressions within a shot .
1452
A single face image in a face-track is represented by a feature vector .
Each single face image in a face track is represented by a feature vector .
1453
Our contribution here is to make the face-track extraction approach robust to sudden illumination changes , scattered appearance of characters , and occlusions.
Our contribution here is making the face-track extraction approach robust to sudden illumination changes , scattered appearances of characters , and occlusions.
1454
Given a face-track as an input retrieval query , the online stage of our system starts by using our proposed face-track matching algorithm ( described in Section 5 ) to estimate the similarity between a query face-track and each face-track in the retrieved set containing all face-tracks extracted from the dataset in the offline stage .
Given a face track as an input retrieval query , the online stage of our system starts by using our proposed face-track matching algorithm ( described in Section 5 ) to estimate the similarity between a query face track and each face track in the retrieved set containing all face tracks extracted from the dataset in the offline stage .
1455
A ranked list of the evaluated face-tracks is returned as retrieval results of the online stage .
A ranked list of the evaluated face tracks is returned as the retrieval result of the online stage .
1456
Since the retrieved set is huge , our approach targets an extremely efficient face-track matching strategy while maintaining competitive performance with state-ofthe-art approaches.
Because the retrieved set is huge , our approach targets an extremely efficient face-track matching strategy while maintaining a competitive performance with state-of-the-art approaches.
1457
Such sets of face images are called face-tracks ( sometimes called face sequences ) .
Such sets of face images are called face tracks ( sometimes called face sequences ) .
1458
A common strategy of existing approaches for face-track extraction consists of detecting faces in frames and grouping detected faces of the same character .
A common strategy in the existing approaches to face-track extraction consists in detecting faces in frames and grouping detected faces of the same character .
1459
Its problems as it is applied to news video and our proposed solutions to overcome the problems is then presented.
We then present the problems with this approach as applied to news video and our proposed solutions.
1460
To group detected faces into face-tracks , connections between faces belonging to the same character in different frames should be established .
To group detected faces into face tracks , connections should be established between faces belonging to the same character in different frames .
1461
in \CITE propose to use KLT tracker for this purpose .
in \CITE proposed the use of a KLT tracker for this purpose .
1462
Points which can not be propagated from one frame to the next are eliminated and replaced with new points .
Points that cannot be propagated from one frame to the next are eliminated and replaced with new points .
1463
Given two faces in different frames , if the number of point tracks passing through both faces is larger than half of the total number of point tracks which are not in common to both faces , they are grouped into one face-track.
Given two faces in different frames , if the number of point tracks passing through both faces is larger than half of the total number of point tracks that are not common to both faces , the faces are grouped into one face track.
1464
has demonstrated its efficiency and robustness on drama videos \CITE , directly applying the approach to news videos results poor performances due to following issues.
has shown its efficiency and robustness with drama videos \CITE , directly applying the approach to news videos results in poor performance due to the following issues.
1465
The flash breaks all connections between faces in frames before and after its occurrence.
The flash breaks all connections between faces in the frames before and after its occurrence.
1466
As a result , a face , which does not appear in the aforementioned frames , may not contain any point .
As a result , a face that , does not appear in the aforementioned frames , may not contain any point .
1467
It results in face connection failure .
resulting in face connection failure .
1468
But , they become meaningless to determine the connection between faces.
However , they become meaningless in determining the connection between faces.
1469
Based on above observed limitations of the approach in \CITE on news videos , we integrate techniques to bypass these liminations in our proposed approach for face-track extraction on news videos.
Based on the observed limitations of the approach in \CITE when applied to news videos , we integrate techniques to bypass these restrictions in our proposed approach to face-track extraction in news videos.
1470
Firstly , \CITE , our approach does not compare all possible pairs of faces in a shot for face grouping as in \CITE .
First , unlike in \CITE , our approach does not compare all possible pairs of faces in a shot for face grouping\CITE; .
1471
Instead of that , we group faces into face-track following temporal order of their appearances .
Instead , we group faces into face tracks according to the temporal order of their appearances .
1472
A detected face in the current frame is considered to group into existing face-tracks formed by previously detected faces only .
A detected face in the current frame is considered for grouping into existing face tracks formed by previously detected faces only .
1473
Secondly , as our first observation , a sudden illumination change in any frame make the KLT tracker failed to track points properly .
Second , as described in our first observation , a sudden illumination change in any frame causes the KLT tracker to fail to track points properly .
1474
Because such illumination changes are very common and they mostly appear together with important character in a news , a solution to this problem is vital .
Because such illumination changes are very common and mostly occur simultaneously with important characters in a news video , finding a solution to this problem is vital .
1475
And , faces appeared in those frames are less informative for recognition since most of the facial identity characteristics are loss due to overlighting .
and that the , faces that appear in those frames are less informative for recognition because most of the facial identity characteristics are lost due to over-lighting .
1476
, They can not enrich information of its corresponding face-track , but may add noise .
Thus , the faces cannot enrich the information on its corresponding face track , but may only add noise .
1477
Therefore , our solution is to detect and skip all frames contain sudden illumination changes , .
Therefore , our solution is to detect and skip all frames containing sudden illumination changes , which .
1478
We call such frames as flashframes.
we call flash frames.
1479
To indetify flash-frames , we measures the brightness of frames in the video shot .
To identify flash frames , we measure the brightness of the frames in the video shot .
1480
If the brightness of a frame significantly increases compared with those of its neighbors , the frame is declared as a flash-frame and is skipped for processing .
If the brightness of a frame is significantly increased compared with its neighbors , the frame is declared a flash frame and skipped in processing .
1481
If L( \SYM ) > L( \SYM ) and L( \SYM ) > L( \SYM ) , \SYM is defined as flash-frames regarding a predefined brightness sensitive threshold \SYM .
If L( \SYM ) > L( \SYM ) and L( \SYM ) > L( \SYM ) , \SYM is defined as flash frames according to a predefined brightness sensitive threshold \SYM .
1482
In our experiments , we found that \SYM = 1:25 and W = {1; 2; 3} are optimal for detecting all flash-frames with a low false alarm rate.
In our experiments , we found that \SYM = 1:25 and W = {1; 2; 3} are optimal for detecting all flash frames with a low false alarm rate.
1483
All point tracking and face grouping processes are initialized from this frame , not at the first frame of the shot as in \CITE .
All point-tracking and face-grouping processes are initialized from this frame , not at the first frame of the shot as in \CITE .
1484
This helps us to save computational cost as well as to avoid tracking errors caused by transition effects between shots .
This helps us to save on computational cost and avoid tracking errors caused by transition effects between shots .
1485
Each face now becomes the first face of a corresponding newly formed face-track.
Each face now becomes the first face of a corresponding newly formed face track.
1486
After the initialization , we sequentially process each frame afterwards , knowing all flash-frames will be skipped .
After the initialization , we sequentially process each frame , knowing all flash frames will be skipped .
1487
At a given frame , points from the previous frame are tracked by the KLT tracker to update their locations .
In a given frame , the points from the previous frame are tracked by the KLT tracker to update their locations .
1488
If there are faces detected , each face is checked against all existing facetracks formed in the previous frames to find out which facetrack it belongs to .
If there are faces detected , each face is checked against all the existing face tracks formed in the previous frames to find out to which face track the face belongs .
1489
Checking between a face and a facetrack is based on enumerating points shared by both the face and the last appeared face of the face-track .
The checking between a face and a face track is based on enumerating the points shared by both the face and the last face that appeared on the face track .
1490
If the enumerated number is larger than half of the total number of points which are not in common to both faces , the faces is grouped into the face-track .
If the enumerated number is larger than half of the total number of points that are not common to both faces , the face is grouped into the face track .
1491
Our grouping criterion here is similar to \CITE .
Our grouping criterion here is similar to that in \CITE .
1492
A face which can not be grouped into any face-track is treated as an initial face of a new face-track .
A face that cannot be grouped into any face track is treated as the initial face of a new face track .
1493
We can ensure that there are always track points for all faces appear in the shot .
We can ensure that there are track points for all faces that appear in the shot .
1494
In other case , when a face in the current frame is grouped to an existing face-track , we prepare points for further tracking .
In other cases , when a face in the current frame is grouped into an existing face track , we prepare points for further tracking .
1495
We remove all points which are inside the last appeared face of the face-track but not inside the current face , and vice versa .
We remove all points that are inside the last face that appeared on the face track but are not inside the current face , and vice versa .
1496
When a face is partly and slowly occluded , our approach can discard incorrectly tracked points as well as reproduce points for the face after being occluded .
When a face is partly and slowly occluded , our approach can discard incorrectly tracked points and reproduce points for the face after it has been occluded .
1497
Our approach continuously process the next frame until reaching the end of the shot .
Our approach continuously processes the next frame until the end of the shot is reached .
1498
There are several approaches have been proposed for matching face-tracks ( as presented in Section 2 ) .
Several approaches to matching face tracks have been proposed ( as presented in Section 2 ) .
1499
, Although these existing approaches achive high accuracy on benchmark datasets , their expensive computational costs limits their practical applications on large-scale datasets .
However , although these approaches have shown high accuracy in benchmark datasets , their high computational costs limit their practical applications in large-scale datasets .
1500
This motivate us to target an matching approach which is balanced between accuracy and computational cost .
This motivates us to target a matching approach that provides a good balance between accuracy and computational cost .
1501
The approach should be extremely efficient while archiving competitive performance compare to state-of-the-art approaches�f.
The approach should be extremely efficient while achieving a competitive performance with state-of-the-art approaches.
1502
In order to maintain a competitive accuracy , we still employ plenteous information from multiple faces of a facetrack to enrich its representation .
To maintain competitive accuracy , we still use the plenteous information from the multiple faces of a face track to enrich the representation .
1503
However , instead of using all faces in a face-track , we propose to subsample the faces .
However , instead of using all the faces in a face track , we propose taking a subsample of faces .
1504
By doing that , the require computational cost can be reduced while a sufficient amount of information is kept for improving accuracy .
In doing so , the required computational cost can be reduced while keeping the amount of information sufficient to improve accuracy .
1505
We called our approach as k-Faces.
We call our approach k-Faces.
1506
Given a specific value of k , which indicates the expected size of the sub-sampled set of a face-track , the approach starts by dividing each face-track into k parts following its temporal order .
Given a specific value of k , which indicates the expected size of the subsampled set of a face track , the approach starts by dividing each face track into k parts according to the temporal order of appearances .
1507
The similarity between two face-tracks is now the distance between their mean faces.
The similarity between two face tracks is now the distance between their mean faces.
1508
Let denote mA = {\SYM; \SYM; : :; \SYM} and mB = {\SYM ; \SYM; : :; \SYM} are two mean faces of two face-track A and B , respectively , with N imposes the number of dimension of the feature space .
Let mA = {\SYM; \SYM; : :; \SYM} and mB = {\SYM ; \SYM; : :; \SYM} denote the mean faces of face tracks A and B , respectively , with N representing the number of dimensions of the feature space .
1509
An illustration of our k-Faces , is shown in Figure 4 .
Figure 4 illustrates our k-Faces , with the following .
1510
Its pseudo-code is presented as follows .
pseudo-code: .
1511
Clearly , the higher value of k is selected , the more faces in each face-track are selected to compute the representative face of the face track .
Clearly , the higher the value of k selected , the more faces in each face track selected to compute the representative face and the .
1512
And , better approximations , may result in higher accuracies .
, better the approximations , which may result in higher accuracies .
1513
By using k as a predefined parameter , k-Faces provides flexibility for users in balancing their expected accuracy and the cost which they can afford ( or time they can wait for the result ).
By using k as a predefined parameter , k-Faces provides users with flexibility in balancing the accuracy they expect and the cost they can afford ( or the time they can spend waiting for the result ).
1514
Besides that , since k-Faces averages multiple faces for a representative face of a face-track , the effects of noisy or outliers faces on estimating the similarity of face-tracks will be substantially reduced.
Besides , because k-Faces averages multiple faces for the representative face of a face track , the effects of noisy or outlier faces on estimating the similarity of face tracks will be substantially reduced.
1515
The experiments are divided into two parts .
The experiments are divided into two parts; .
1516
In the first part , we evaluate the performance of the proposed approach for face-track extraction , .
the first , evaluates the performance of the proposed approach in face-track extraction , and the second in .
1517
Evaluation of the proposed approach for face-track matching is given in the second part.
face-track matching.
1518
Ground-truth information on face-tracks in videos is manually prepared .
Ground-truth information on the face tracks in videos is manually prepared .
1519
A face-track of one character appearing in a video shot is annotated by indexes of the frames which the first face and the last face of that character occur .
Each face track of a character appearing in a video shot is annotated by indexes of the frames in which the first face and the last face of that character occur .
1520
An approach is called exactly extracting a face-track if it provides precise starting and ending frame indexes of the face-track , compared to ground-truth annotation .
An approach is considered as exactly extracting a face track if it provides precise starting and ending frame indexes of the face track , compared to ground-truth annotation .
1521
Note that if a character moves out of the frame then moves in again , annotators will divide the appearance of that character into two independent face-tracks in our ground-truth .
Note that if a character moves out of the frame and then moves back into it again , annotators will divide the appearance of that character into two independent face tracks in ground-truth annotation .
1522
The number of frames , faces , and face tracks are shown in Table 1 .
Table 1 shows the number of frames , faces , and face tracks .
1523
As shown in Table 2 , by detecting flash-frames , our approach successfully overcomes the problem of face-track fragmentation due to illumination changes .
As shown in Table 2 , by detecting flash frames , our approach successfully overcomes the problem of face-track fragmentation due to illumination changes .
1524
is almost failed to do that .
almost completely fails to do that .
1525
in handling problem caused by partial occlusion and appearance of character in the middle of a shot .
in handling problems caused by partial occlusion and the appearance of a character in the middle of a shot .
1526
All face-tracks which we could not extract exactly are those fully occluded at some frames during their occurences .
The only face tracks that we could not extract exactly are those fully occluded in some frames during their occurrences .
1527
One can apply visual information based clustering to group the fragmented face-track , as in \CITE , .
One can apply visual information-based clustering to group the fragmented face track , as in \CITE , but this .
1528
Obviously , extra cost is required .
obviously , requires extra cost .
1529
However , we observe that fully occlusion is rarely happened in news video since characters reported in the news are recorded with care , especially with important and well-known character .
Nevertheless , we observe that full occlusion rarely happens in news video because the characters featured in the news are recorded with care , especially the important and well-known ones .
1530
In terms of speed , our approach is approximately 2 times slower than the approach of Everingham .
In terms of speed , our approach is approximately 2 times slower than that of Everingham et al .
1531
However , our complexity is somehow linear to total number of face , because we consequently enlarge face-tracks following temporal order by checking new faces with only one last appeared face of each face-track .
However , our complexity is somehow linear to the total number of faces , because we consequently enlarge face tracks according to the temporal order by checking new faces with only the last face that appeared on each face track .
1532
If this number is getting larger , the gap in speed between our approach and the approach by Everingham et al .
If the number of faces increases , the gap in speed between our approach and that by Everingham et al .
1533
Because all presented problems here , such as those due to flash , occlusion , and in-the-middle face appearance , are practically observed , overcoming them is vital for practical application .
Because all the problems presented here , such as those due to flash , occlusion , and in-the-middle face appearance , are practically observed , overcoming them is vital for the practical application of our approach .
1534
In this experiment , we show that our proposed techniques and solutions for the problems are robust and efficient enough for extracting face-tracks in real-world news videos by successfully extracting 94% of all face-tracks .
In this experiment , we show that our proposed techniques and solutions to the problems are robust and efficient enough for extracting face tracks in real-world news videos by successfully extracting 94% of all face tracks .
1535
From our observations , one can use other complex techniques to handle the problems .
Based on our observations , other complex techniques can be applied to handle the problems .
1536
However , a trade-o_ between completely obtaining 6% remaining face-tracks and an overly expensive computational cost should be considered with care.
However , the trade-off between obtaining the 6% remaining face tracks and incurring an overly high computational cost should be considered with care.
1537
Face-tracks in videos of the datasets are extracted by using our proposed approach for face-track extraction ( see section 4.2 ) .
Face tracks are extracted from videos of the datasets by using our proposed approach to face-track extraction ( see section 4.2 ) .
1538
Identity of the character associated with each extracted face-track is given by annotators .
The identity of the character associated with each extracted face track is given by annotators .
1539
Since our approach extract face-tracks in each video shot , shot boundaries for videos are required .
Because our approach extracts face tracks in each video shot , the shot boundaries of videos are required .
1540
We filtered out short face tracks that had less than ten faces , .
We filtered out short face tracks that had less than 10 faces , which .
1541
This resulted in 35,836 face tracks .
resulted in 35,836 face tracks .
1542
This dataset is observed from NHKNews7 channel in 11 years .
This dataset consists of observations from the NHK News 7 program over 11 years .
1543
The total number of face-tracks is 5,567 .
The total number of face tracks is 5,567 .
1544
Each character has from 4 to 550 face-tracks .
Each character has from 4 to 550 face tracks .
1545
In this dataset , we discard facetracks with fewer than 100 faces and more than 500 faces .
In this dataset , we discard face tracks with fewer than 100 faces and more than 500 faces .
1546
Compared to the TRECVID dataset , NHKNews7 dataset is much more challenging.
Compared to the TRECVID dataset , the NHKNews7 dataset is much more challenging.
1547
In the Table 4 , we compare our datasets with some public benchmark datasets .
Table 4 shows a , comparison between our datasets and some public benchmark datasets .
1548
, It is obvious that our datasets are extremely higher than datasets , such as MoBo and Honda / UCSD , on all statistical terms , including the number of videos , characters , and average length of face-track .
Based on the results , it is obvious that our datasets are superior over the other datasets , such as MoBo and Honda / UCSD , on all statistical terms , including number of videos , number of characters , and average face-track length .
1549
Compared to Youtube Faces dataset , although ours have less number of character ( or subjects ) , we provide much more face-tracks ( or video shots ) per character , .
Compared to the YouTube Faces dataset , , we provide much more face tracks ( or video shots ) per character , although our datasets have smaller numbers of characters ( or subjects ) .
1550
Thus , ours are more relevant for evaluating retrieval system.
Thus , our datasets are more relevant in evaluating a face retrieval system.
1551
Statistical information of our datasets is given in the Figure 5 .
Figure 5 presents statistical information on our datasets .
1552
However , due to copyright issues , face images in face-tracks can not be published .
However , due to copyright issues , the face images in the face tracks cannot be published .
1553
A feature vector of a face is extracted by computing descriptors of the local appearance of the face around each of the located facial features .
The feature vector of a face is extracted by computing the descriptors of the local appearance of the face around each of the located facial features .
1554
They estimate an affine transformation , which transform the located facial feature points to a canonical set of feature positions .
An affine transformation is estimated , which transforms the located facial feature points to a canonical set of feature positions .
1555
The final feature representation of the face is formed by concatenating all descriptors of its facial features.
The final feature representation of the face is formed by concatenating all the descriptors of its facial features.
1556
We compare k-Faces with several approaches , including approaches based on pair-wise distances , MSM \CITE and CMSM \CITE.
We compared k-Faces with several approaches , including those based on pair-wise distances , MSM \CITE and CMSM \CITE.
1557
Given two face-tracks having multiple face images represented as feature vectors , pair-wise based approaches compute distances between each possible pair of feature vectors in two face-tracks .
Given two face tracks having multiple face images represented as feature vectors , pair-wise-based approaches compute the distances between each possible pair of feature vectors in two face tracks .
1558
They then use the maximum distance , the minimum distance , or the mean distance of the computed pair-wise distances as the similarity measurement between two face-tracks .
The maximum distance , the minimum distance , or the mean distance of the computed pair-wise distances is the used as the similarity measurement between two face tracks .
1559
We denote the approaches as pair:max , pair:min , and pair:mean , respectively ( see Figure 6 for illustration ) .
We refer to the approaches as pair:max , pair:min , and pair:mean , respectively ( see Figure 6 for the illustration ) .
1560
By doing that , the subspaces are expected to be better separatable .
In doing so , the subspaces are expected to be more separable .
1561
All of these approaches had been shown their robustness on benchmark datasets , such as MoBo , HondaUCSD , and Youtube Faces .
All of these approaches have shown their robustness in benchmark datasets , such as MoBo , HondaUCSD , and YouTube Faces .
1562
Besides evaluating k-Faces with different values of k as well as different types of distance ( e.g. , Euclidean , L1 , cosine ) , we try another criterion to select k representative faces in a face-track .
Besides evaluating k-Faces with different values of k and different types of distance ( e.g. , Euclidean , L1 , and cosine ) , we try another criterion for selecting k representative faces in a face track .
1563
In the original way , we proposed to select these faces by partitioning the face-track following temporal order and selecting the middle face of each partition .
In the original way , we proposed selecting these faces by partitioning the face track according to the temporal order and choosing the middle face of each partition .
1564
However , an yet another criterion can be applied to select these representative faces is based on clustering .
However , another criterion that is based on clustering can be applied in selecting these representative faces .
1565
In this new way , all faces in a face-track will be clustered in to k groups by a clustering algorithm .
In this new way , all the faces in a face track will be clustered to k groups by using a clustering algorithm .
1566
Then , the mean of k centroids is used as the representative face for the face-track .
Then , the mean of k centroids is used as the representative face for the face track .
1567
We denote the former k-Faces as k-Faces.Temporal and the latter k-Faces as k-Faces.KMeans.
We refer to the former k-Faces as k-Faces.Temporal and to the latter k-Faces as k-Faces.KMeans.
1568
We evaluate performance of a face-track matching approach by computing the average precision on the rank list returned by the approach .
We evaluate the performance of a face-track matching approach by computing the average precision of the rank list that it returned .
1569
In particular , for each dataset , each face-track is alternatively picked out as a query facetrack , while the remaining face-tracks are used as the retrieved database .
In particular , in each dataset , a face track is alternatively picked out as a query face track , while the remaining face tracks are used as the retrieved database .
1570
, Average precision of the returned ranked list is computed , given a query .
Given a query , the average precision of the returned ranked list is computed , .
1571
Finally , the mean of all average precision ( MAP ) from all query is reported as the overall evaluation metric for the approach on the database.
Finally , the mean of all average precision ( MAP ) values for all queries is reported as the overall evaluation metric for the approach with the given database.
1572
Let denote r as a rank in the returned face-track list , Pre( r ) as is the precision at the rank r of the list , Nl as the length of the list , Nhit as the total number of face-tracks matched with the query face-track q , and I sMatched( k ) as a binary function returning 1 if the face-track at rank r is matched with q ( based on ground-truth annotations ) , zero otherwise .
Let r denote a rank in the returned face-track list , Pre( r ) the precision at rank r of the list , Nl the length of the list , Nhit the total number of face tracks matched with the query face track q , and I sMatched( k ) a binary function returning 1 if the face track at rank r is matched with q ( based on ground-truth annotations ) and , zero otherwise .
1573
Besides MAP , we record processing times of the approaches on each dataset for efficiency comparison.
Besides the MAP , we record the processing times of the approaches in each dataset to compare their efficiency.
1574
Generally , all MAPs vary from 64.61% to 76.54% on Trecvid dataset .
Generally , all the MAPs vary from 64.61% to 76.54% in the Trecvid dataset .
1575
Meanwhile , , the best MAP is 60.99% , and the worst MAP is 42.75% on NHKNews7 dataset .
Meanwhile , in the NHKNews7 dataset , the best MAP is 60.99% , and the worst is 42.75% .
1576
The gap of MAPs between two datasets can be explained by following reasons .
The difference in the MAPs between the two datasets can be explained by following reasons .
1577
This clearly increases the probability of mismatching face-tracks .
This clearly increases the probability of mismatching face tracks .
1578
Secondly , videos in NHKNews7 are recorded during a long time ( i.e. , 11 years ) .
Second , the videos in NHKNews7 were recorded over a long time ( i.e. , 11 years ) .
1579
Thus , besides facial variations caused by enviromental conditions at the time of recording ( e.g. , illumination , pose , viewpoint ) in each face-track , face-tracks of a character themself also contain biological variation of the character during time .
Thus , besides facial variations in each face track caused by the environmental conditions at the time of recording ( e.g. , illumination , pose , viewpoint ) , the face tracks of the character themselves also reflect the biological variations of the character over time; .
1580
Due to those reasons , matching faces in NHKNews7 becomes more challenging , .
For these reasons , matching faces in NHKNews7 becomes more challenging , which .
1581
It results in drops of MAP( s ) of all evaluated approaches.
resulted in decreased MAP( s ) for all the evaluated approaches.
1582
A clear and consistent observation from both datasets is that pair:min ( i.e. , min-min ) always achieves the best MAPs , which are 76.54% and 60.99% on two dataset , respectively .
A clear and consistent observation from both datasets is that pair:min ( i.e. , min-min ) always achieves the best MAPs , which are 76.54% and 60.99% in the two datasets , respectively .
1583
Among several distance types , L1 is the optimal one to be used with pair:min .
Among the distance types , L1 is the optimal for use with pair:min .
1584
A reasonable replacement can be Euclidean distance .
A reasonable replacement is the Euclidean distance .
1585
However , there is a minor accuracy gap between pair:min using L1 and pair:min using Euclidean .
However , there is a minor accuracy gap between pair:min using L1 and pair:min using the Euclidean distance .
1586
And , computing Euclidean distance between two feature vectors is more expensive than computing their L1 distance .
In addition , computing the Euclidean distance between two feature vectors is more expensive than computing their L1 distance .
1587
This is because pair:mean uses the mean of all pair-wise distances between two face-tracks as their similarity score .
This is because pair:mean uses the mean of all pair-wise distances between two face tracks as the similarity score .
1588
At the same time , it eliminates the influence of pairs containing identical faces , which can help to instantly determine they are belong to the same character .
At the same time , it eliminates the influence of pairs containing identical faces , which can help to instantly determine that the faces belong to the same character .
1589
Thus , discriminative power of the computed similarity score is reduced , compared to one computed by pair:min .
Thus , the discriminative power of the computed similarity score is reduced , compared to that computed by pair:min .
1590
It causes the gap of MAPs between pair:min and pair:min .
This causes the difference in MAPs between pair:min and pair:min .
1591
Since the average length of face-tracks on NHKNews7 is longer ( i.e. , each face-track contains more sample faces of a character ) , there is more chance that two face-tracks of the same character contain identical faces.
Because the average length of face tracks on NHKNews7 is longer ( i.e. , each face track contains more sample faces of a character ) , there is a greater chance that two face tracks of the same character contain identical faces.
1592
About our k-Faces , its MAP increases when k increases .
Regarding our k-Faces , its MAP increases when k increases .
1593
Since k-Faces.KMeans always use all faces in a facetrack for clustering and selecting centroids for representative faces , the final mean face is less sensitive to k .
Because k-Faces.KMeans always uses all the faces in a face track for clustering and selecting centroids for representative faces , the final mean face is less sensitive to k .
1594
On the contrary , k plays an important role in k-Faces.Temporal .
In contrast , k plays an important role in k-Faces.Temporal .
1595
The higher k is set , the more representative faces of each facetrack are selected .
The higher the k set , the more representative faces of each face track selected .
1596
Thus , the final mean face of each facetrack becomes more reliable and accurate .
Thus , the final mean face of each face track becomes more reliable and accurate .
1597
Meanwhile , its disadvantage is the expensive computational cost to perform clustering faces on a high dimensional feature space ( i.e. , 1937 dimensions ) .
However , its disadvantage is the high computational cost of clustering faces on a high-dimensional feature space ( i.e. , 1,937 dimensions ) .
1598
On both datasets , when k increases from 2 to 20 , MAPs of k-Faces approaches grow rapidly .
In both datasets , when k increases from 2 to 20 , the MAPs of k-Faces approaches grow rapidly .
1599
However , theirs MAPs become stable from 20 afterwards .
However , the MAPs become stable from k = 20 upward .
1600
Since keep increasing k does not help to obtain imporant accuracy improvement but expensive computational cost , we select k = 20 to investigate the trade-off between accuracy and computational costs of k-Faces approaches compared to others .
Because further increasing k does not help improve accuracy but increases the computational cost , we select k = 20 for investigating the trade-off between the accuracy and computational cost of k-Faces approaches in comparison to others .
1601
We report MAP and processing time of each approach in the Table 5 .
Table 5 shows the MAP and processing time of each approach .
1602
Processing time is separated into two parts , corresponding to preprocessing time and matching time .
Processing time is divided into two parts , preprocessing and matching .
1603
Preprocessing time presents time required for preprocessing face-tracks before matching .
The preprocessing time refers to the time required to preprocess face tracks before matching .
1604
With k-Faces approaches , preprocessing facetracks includes selecting representative faces and computing their mean face .
In k-Faces approaches , the preprocessing of face tracks includes selecting representative faces and computing their mean face .
1605
In MSM and CMSM , it indicates time for computing subspaces for face-tracks .
In MSM and CMSM , preprocessing includes computing subspaces for face tracks .
1606
Time unit is second.
The time unit used is seconds.
1607
According to Table 5 , k-Faces.KMeans and k- Faces.Temporal achieve almost equal accuracy and consume the same amount of time for one query on both datasets .
As shown in Table 5 , k-Faces.KMeans and k- Faces.Temporal achieve almost equal accuracy and consume the same amount of time for one query in both datasets .
1608
However , k-Faces.Temporal is hundreds times ( 240 times on Trecvid and 360 times on NHKNews7 ) faster than k-Faces.Temporal in the preprocessing phase .
However , k-Faces.Temporal is hundreds of times ( 240 times in Trecvid and 360 times in NHKNews7 ) faster than k-Faces.Temporal in the preprocessing phase .
1609
This suggest that , selecting presentative faces based on tempo .
This suggests that in terms of both accuracy and efficiency , selecting representative faces based on temporal sampling is better than that based on clustering .
1610
ral sampling is better than one based on clustering , in both terms of accuracy and efficiency.
,
1611
Compared to state-of-the-art approaches , our k- Faces.Temporal is thousands times faster than the best approach , which is pair:min , and hundred times faster than MSM and CMSM on both datasets .
Compared to state-of-the-art approaches , our k- Faces.Temporal is thousands of times faster than the best approach , which is pair:min , and hundreds of times faster than MSM and CMSM in both datasets .
1612
In terms of accuracy , k-Faces take second place , with 73.65% on Trevid dataset , after pair:min .
In terms of accuracy , k-Faces takes second place , with 73.65% in the Trevid dataset , after pair:min .
1613
The gap with pair:min is 2.89% difference in MAP .
The difference in MAP between our approach and pair:min is 2.89% .
1614
Meanwhile , it is significantly better than MSM and CMSM , which respectively achieve 69.20% and 64.62% .
Meanwhile , k- Faces.Temporal is significantly better than MSM and CMSM , which respectively achieved 69.20% and 64.62% accuracy .
1615
On NHKNews7 dataset , our k-Faces.Temporal is still better than CMSM , but is worse than pair:min and MSM .
In the NHKNews7 dataset , k-Faces.Temporal is better than CMSM , but worse than pair:min and MSM .
1616
One may concern that why MSM perform poorly on Trecvid dataset , but it is superior to our k-Faces.Temporal on NHKNews7 .
One may question why MSM performed poorly in the Trecvid dataset , but was superior to k-Faces.Temporal in NHKNews7 .
1617
This is due to the fact that face-tracks on NHKNews7 dataset is larger than those on Trecvid dataset .
The reason for this is the fact that the face tracks in the NHKNews7 dataset are larger than those in the Trecvid dataset .
1618
Therefore , more sample faces in each face-track can be used to obtain a reliable subspace .
Therefore , more sample faces in each face track can be used to obtain a reliable subspace .
1619
Firstly , we presented practical problems when a tracker is used to extract face-tracks in news videos .
First , we present the practical problems encountered when a tracker is used to extract face tracks in news videos .
1620
Based on that , we introduce techniques and solutions to bypass the problems for robust face-track extraction .
Based on these , we introduce techniques and solutions to overcome these problems to achieve robust face-track extraction .
1621
Thirdly , we prepare , evaluate state-of-the-art face retreival approaches , and publish real-world face-track datasets whose scale have not been considered in literature ever.
Third , we prepare datasets , evaluate state-of-the-art face retrieval approaches , and publish real-world face-track datasets of such scales that have never been considered in the literature.
1622
This paper presents a novel recommendation system , named Recommend-Me , to faciliate users in searching and exploring images of an unknown image database .
This paper presents a novel recommendation system , named Recommend-Me , to facilitate users in searching and exploring images in unknown image databases .
1623
So that , users can make their own decisions before any actual search .
In this way , users can make their own decisions before any actual search .
1624
We introduce an efficient approach for Recommend-Me to deal with quantifying occurences of multiple candidate items over images of the database .
We describe an efficient approach for Recommend-Me to deal with quantifying occurrences of multiple candidate items in the images of the database .
1625
Instead of scanning the database for each candidate item repspectively , the approach enumerate occurences of multiple candidate items simultaneously by investigating pairs of highly similar regions , knowing one pair is formed by a region in the intial image and a region in an image of the database .
Instead of scanning the database for each candidate item , the approach enumerate occurrences of multiple candidate items simultaneously by investigating pairs of highly similar regions , knowing one pair is formed by a region in the initial image and a region in an image of the database .
1626
Experiments conducted on a real-life and publicly available dataset demonstrate the efficiency , the robustness and a promissing application of our system .
Experiments conducted on a real-life and publicly available dataset demonstrate the efficiency , robustness , and promising application of our system .
1627
With the advances of modern technology , a large amount of digital images nowadays can be created and stored easily .
Thanks to the advances of modern technology , a large amount of digital images can be easily created and stored nowadays .
1628
As a result , the exponential growth of image repositories creates the urgent needs for searching images . Because of its importance and wide applications , image search has attracted more interest in recent years .
The resulting exponential growth of image repositories , however , has created an urgent need for effective ways of searching images .
1629
In a typical scenario of image search , users supply a query item which is usually represented by a region cropped from an image .
Moreover , image search has gained interest in recent years because of its importance and wide range of applications . In a typical scenario , users supply a query item , which is usually a region cropped from an image .
1630
Several extensive works have been conducted with great interest on improving search performance \CITE .
Extensive studies have been conducted with an eye to improving the performance of this sort of search \CITE .
1631
A normal user without prior knowledge about the retrieved database has no choice but search by trial-and-error .
A normal user without prior knowledge about a database has no choice but to search it by trial-and-error .
1632
We tackle this problem to facilitate users in searching and exploring images of such unknown database .
We decided to tackle this problem to help users in searching and exploring images in unknown databases .
1633
Each recommended item is assigned a number to clarify how many images of the database it occurs .
Each recommended item is assigned a number to show in how many images of the database it occurs .
1634
No extra information or knowledge is required for input but an initial query image and a retrieved database .
No extra information or knowledge is required for an input besides an initial query image and a database . //<" and the name of the database " ? ? Or " and the location and name of the database " ? ?>
1635
First , there is a huge pool of candidate items in the initial query image .
First , there tends to be a huge pool of candidate items in the initial query image .
1636
Examining all of them requires enormous computational cost .
Examining all of them would incur an enormous computational cost .
1637
Second , even if a candidate item is known , enumerating its occurrences in the database is not trivial because it is subject to many variations such as viewpoint and scale changes , rotation or occlusion .
Second , even if a candidate item is known , enumerating its occurrences in the database is a not trivial task because it is subject to many variations in viewpoint , scale , rotation , occlusion , etc.
1638
Furthermore , scanning over all regions in images of the database will inevitably be prohibitive , if not infeasible for practical purposes .
Furthermore , the cost of scanning all regions of the images of the database will inevitably be prohibitive for practical purposes .
1639
In this paper , we employ state-of-the-art techniques such as SIFT and Bag-of-Words ( BoW ) model to handle matching regions under variations .
In this paper , we employ state-of-the-art techniques such as SIFT and the Bag-of-Words ( BoW ) model to handle the task of matching regions with the above variations .
1640
Our main focus is an efficient approach for quantifying occurences of candidate items over the database to generate recommendations .
Our main focus is to devise an efficient approach for quantifying occurrences of candidate items in the database in order to generate recommendations .
1641
The efficiency advantages of our approach come from various methodologies .
The advantage in efficiency comes from our use of various methodologies .
1642
Based on an observation that users are mostly interested in object-like items , we use a selective search approach proposed by Van de Sande et al. \CITE to sample regions bounding object-like items in all images as a preprocessing step .
Based on the observation that users are mostly interested in object-like items , we decided to use a selective search approach proposed by Van de Sande et al. \CITE to sample regions bounding object-like items in all images as a preprocessing step .
1643
By applying the approach instead of other naive sampling approach such as sliding windows , the number of items ( i.e. regions ) that need to be processed in each image dramatically reduces .
By applying this approach instead of a naive sampling approach such as sliding windows , we were able to dramatically reduce the number of items ( i.e. regions ) that need to be processed in each image .
1644
Given two sets of regions , one contains regions of candidate items in the initial query image and the other contains regions of items in images of the database .
Given two sets of regions , one containing regions of candidate items in the initial query image and the other containing regions of items in images of the database , our task is to find occurrences of all candidate items in the database .
1645
Finding occurences of all candidate items in the database can be equally treated as finding pairs of matched regions , knowing a pair is formed by a region in one of the sets with a region in the other .
This task can be equivalently treated as finding pairs of matched regions , knowing that a pair is formed by a region in one of the sets with a region in the other .
1646
Based on these insights , we make an yet another efficiency boost by formulating the problem as an optimization problem which can be solved by applying a branh-and-bound algorithm .
Based on this insight , we can boost efficiency yet again by formulating the problem as an optimization problem that can be solved by applying a branch-and-bound algorithm .
1647
In order to do that , we introduce a novel representation based on hierarchical structure to describe a set of region pairs and a corresponding function bounding the similarity scores of pairs over such a set .
In order to do that , we introduce a novel representation based on a hierarchical structure describing a set of region pairs and a corresponding function bounding the similarity scores of pairs over such a set .
1648
With respect to discovering common items , Recommend-Me is related to recent studies on mining common items in image databases such as \CITE .
On the topic of discovering common items , Recommend-Me is related to recent studies on mining common items in image databases such as \CITE .
1649
However , in contrast to these studies , Recommend-Me targets items which are shared by both an image database and user interest limited in an input initial image .
However , in contrast to these studies , Recommend-Me targets items which are shared by both an image database and the user 's particular interest inthe input initial image .
1650
One can employ these techniques to our problem by firstly figuring out common items among images of the database , then looking them up in the initial query image again for recommendations .
One can employ these techniques to solve our problem by first identifying common items among the images of the database , then looking them up in the initial query image again to make recommendations .
1651
However , by doing that , extra costs for mining unnecessary items , which appear in the database but the initial query image , arise accordingly .
However , doing that incurs the extra cost of mining unnecessary items that appear in the database , but not in the initial query image .
1652
One of the most related works to Recommend-Me for query suggestion is proposed by Zha et al in \CITE .
One of the most related studies to ours is that of Zha et al in \CITE .
1653
They introduced a system called Visual Query Suggestion ( VQS ) which simultanously provides both keyword and image suggestions for users .
They introduced a system , called Visual Query Suggestion ( VQS ) , that simultaneously provides both keyword and image suggestions to users .
1654
VQS requires an initial text query for suggestion formulation and its suggestions are both keywords and images .
VQS requires an initial text query for formulating the suggestion , and its suggestions are both keywords and images .
1655
On the other hand , Recommend-Me takes an image as input and its outputs are regions in the image .
On the other hand , Recommend-Me takes an image as input , and its outputs are regions in the image .
1656
Above all , although both Recommend-Me and VQS aim at facilitating users in searching images , the targeted problems are different .
Above all , although both Recommend-Me and VQS aim at helping users search for images , their targeted problems are different .
1657
VQS proposes to help users to overcome query ambiguity formulation by precisely expressing search intents , assuming relevant items are always available .
VQS proposes to help users to overcome their tendency to formulate ambiguous queries by precisely expressing search intents , assuming the relevant items are always available .
1658
To the best of our knowledge , Recommend-Me is the first attempt towards its targeted suggestion scheme .
To the best of our knowledge , Recommend-Me is the first attempt at this sort of targeted suggestion scheme .
1659
However , ours is differentiated in the way we represent sets of region pairs , instead of sets of regions only .
However , ours is differentiated from the other studies in that we represent sets of region pairs , instead of only sets of regions .
1660
Meanwhile , we utilize hierarchical structures in order to do that , since our regions are discrete .
In contrast , we utilize hierarchical structures in order to do that , since our regions are discrete .
1661
Although coordinate intervals as in ESS ( or ESR ) can be extended to represent set of region pairs , such criterion may suffer the branch-and-bound algorithm from curse-of-dimensionality problem since the number of dimension required is at least doubled .
Although coordinate intervals as in ESS ( or ESR ) can be extended to represent sets of region pairs , such a criterion in the context of the branch-and-bound algorithm may suffer from the curse-of-dimensionality problem since the number of dimensions required at least doubles .
1662
Finally , ours and ESS , ESR do not share common approach to construct bounding quality function and to compute bounding values over the sets .
Finally , ESS , ESR and Recommend-Me differ in that they have different approaches to constructing a bounding quality function and to computing bounding values over the sets .
1663
Details of our proposed approaches for finding region pairs with highest similarity scores are given in Section 3 .
The details of how we find region pairs with the highest similarity scores are given in Section 3 .
1664
The framework of Recommend-Me consists of 4 main steps towards formulating final recommendations for users .
The framework of Recommend-Me consists of four main steps .
1665
Using all possible rectangular regions in images as candidate items is overly expensive for further processing .
Using all possible rectangular regions in images as candidate items is overly expensive in the subsequent processing .
1666
More importantly , human users are often get attracted by object-like items .
More importantly , users are often attracted by object-like items .
1667
Then , it performs a greedy algorithm which iteratively merges the two most similar regions together until the whole image becomes a single region .
Then , it performs a greedy search < ? ?> algorithm that iteratively merges the two most similar regions together until the whole image becomes a single region .
1668
All region throughout the hierarchy is considered as candidate items .
All regions throughout the hierarchy are considered to be candidate items .
1669
There is a pool of region pairs if we compare each region in the initial query image with each region in images of the database .
There will be a pool of region pairs if we compare each region in the initial query image with each region in images of the database .
1670
In this step , we perform our proposed approach , explained in Section 3 , to find top \MATH ( an expected number of returned region pairs ) of such pairs in the pool .
In this step , we use the approach explained in Section 3 to find the top \MATH ( the expected number of returned region pairs ) of such pairs in the pool .
1671
However , there are several regions highly overlap each other due to merging in Step 1 .
However , there are likely several regions that overlap each other due to the merging done in Step 1 .
1672
They are perceived as the same item by human being .
These regions would be perceived as the same item by users .
1673
Thus , we propose to use maximal clique analysis technique to group such regions for consistent recommendations .
Thus , we propose to use maximal clique analysis to group such regions so that the recommendations will be consistent .
1674
Using those numbers , we rank all groups and then introduce them to users as our recommendations .
Using those numbers , we rank all groups and show them as recommendations to users .
1675
Representative of each group is a rectangular region located by averaging coordinates of all member regions of the group .
A representative of each group is a rectangular region located by averaging the coordinates of all member regions of the group .
1676
With a similarity function \MATH , we have to solve the following optimization problem in order to find the region pair \MATH with the highest similarity score .
By using the similarity function \MATH , we have to solve the following optimization problem in order to find the region pair \MATH with the highest similarity score .
1677
We propose to use a branch-and-bound algorithm \CITE for the problem .
We hence propose to use a branch-and-bound algorithm \CITE to solve the problem .
1678
Once \MATH is found , we can obtain the other top region pairs by continuing the search processs with the remaining search spaces , in which found top pairs eliminated .
Once \MATH is found , we can obtain the other top region pairs by continuing the search process with the remaining search space , in which the found top pairs have been eliminated .
1679
A general branch-and-bound algorithm works by hierarchically dividing the parameter space into disjoint parts , known as branching step .
A general branch-and-bound algorithm works by hierarchically dividing the parameter space into disjoint parts ; this is called the branching step .
1680
In the bounding step , each part is assigned an upper bound value that the quality function could take on any of the members of the part .
In the bounding step , each part is assigned an upper bound for which the quality function could take on any of the members of the part . //<The rewrite is grammatical but I don 't know what " the quality function could take on any of the members of the part " . Inparticular what are these members and can they be computed in a function ?>
1681
Parts of the parameter space with higher upper bound values are examined first .
Those parts of the parameter space with higher upper bound values are examined first .
1682
Adapting to our problem , the parameter space is the set of all region pairs \MATH , and the quality function is the similarity function \MATH .
In our problem , the parameter space is the set of all region pairs \MATH , and the quality function is the similarity function \MATH .
1683
- if each node is repsented by a histgoram \MATH with \MATH bins , the value at each bin of a child node is constrainted to be equal or smaller the value at the same bin of its parent node .
- if each node is represented by a histogram \MATH with \MATH bins , the value in each bin of a child node is constrained to be equal or smaller than the value in the same bin of its parent node .
1684
Given such structures , we show in the following how a branch-and-bound algorithm applied to our problem .
Given such structures , we show in what follows how the branch-and-bound algorithm can be used to solve our problem .
1685
And , \MATH denotes the set containing all leaf nodes explored from \MATH .
And let \MATH denote the set containing all leaf nodes explored from \MATH .
1686
Given \MATH indicates the set of node pairs formed by paring nodes in \MATH with nodes in \MATH , we have : \MATH
Letting \MATH indicate the set of node pairs formed by pairing nodes in \MATH with nodes in \MATH , we get : \MATH . //<the rewrite is a guess .>
1687
Dividing the search space ( i.e. set of region pairs ) covered by \MATH is straightforward by utilizing the hierarchical structures \MATH , \MATH at certain nodes \MATH , \MATH .
Dividing up the search space ( i.e. set of region pairs ) covered by \MATH can be done straightforwardly by utilizing the hierarchical structures \MATH , \MATH at certain nodes \MATH , \MATH . //<The rewrite is better if it is correct .>
1688
Selecting which way to divide can be based on sizes of \MATH and \MATH .
The way to divide can be based on the sizes of \MATH and \MATH .
1689
We select the larger one to be divided first .
We divide the larger one first .
1690
An illustration of a branching step is given in Figure \REF .
The branching step is illustrated in Figure \REF .
1691
An essential requirement for branch-and-bound is the quality bounding function \MATH used to evaluate how necessary a part of the search space should be examined .
An essential requirement for the branch-and-bound algorithm is the quality bounding function \MATH used to determine whether a part of the search space should be examined . //<Or " determine the extent that " ? ?>
1692
Particularly , \MATH bounds the upper values of \MATH over a set of node pairs ( i.e. region pairs ) .
In particular , \MATH bounds the upper values of \MATH over a set of node pairs ( i.e. region pairs ) .
1693
Assuming we are now evaluating the upper bound of \MATH over all region pairs in \MATH .
Let us assume that we are evaluating the upper bound of \MATH over all region pairs in \MATH .
1694
Among several types of distance for estimating the similarity of two regions , we stick to Normalized Histogram Intersection ( NHI ) distance since it is well-balanced between computational efficiency and robustness~\cite{ESR} .
Among the several distance formulas for estimating the similarity of two regions , we will use the Normalized Histogram Intersection ( NHI ) distance since it is well-balanced between computational efficiency and robustness~\cite{ESR} .
1695
We then rely on NHI to define \MATH bounding the values of \MATH , with : \MATH
We will then rely on NHI to define \MATH bounding the values of \MATH , with : \MATH
1696
As a result , the bounding value \MATH over \MATH can be clearly observed as : \MATH
As a result , the bounding value \MATH over \MATH can be clearly observed as : \MATH . //<I 'm not sure what observed means in this context . Do you mean " can be derived as " ? ?>
1697
We can efficiently evaluate \MATH for the set of region pairs \MATH because \MATH is relied only on histogram representation of single rectangular regions \MATH and \MATH .
We can efficiently evaluate \MATH for the set of region pairs \MATH because \MATH relies only on the histogram representation of single rectangular regions \MATH and \MATH .
1698
And , the normalization terms , which indicate the minimum number of visual words inside any member region of \MATH , \MATH , are computed once by using integral image technique .
Moreover , the normalization terms , which indicate the minimum number of visual words inside any member region of \MATH , \MATH , are computed once by using the integral image technique .
1699
Inspired by \CITE , we form the algorithm in best-first manner .
Inspired by \CITE , we devised the algorithm to work in a best-first manner . //<The original describes the way you decided to write the algorithm . In contrast , the rewrite describes the way the algorithm works .>
1700
The algorithm examines next the set having highest bounding value \MATH .
The algorithm examines the set having the highest bounding value \MATH . //<" next " is unclear . The rewrite is a guess .>
1701
To obtain more than one region pair , we simply continue the loop in the Algorithm 1 until the expected number of region pairs \MATH have been reached .
To obtain more than one region pair , we simply repeat the loop in Algorithm 1 until the expected number of region pairs \MATH is reached .
1702
There are two type of region set for organization .
There are two type of region set .
1703
The other is set containing regions of multiple images ( i.e. database ) .
The other is a set containing regions of multiple images ( i.e. database ) .
1704
As a result , we have the constraint ( b ) satisfied .
As a result , constraint ( b ) is satisfied .
1705
The generated node is exactly the same as the non-leaf node it attach to , which now becomes a virtual node .
The generated node is exactly the same as the non-leaf node it is attached to , which now becomes a virtual node .
1706
And , all non-leaf nodes will be taken into account as candidate item regions via their attachments .
Moreover , all non-leaf nodes will be taken into account as candidate item regions via their attachments .
1707
The new hierarchical structure therefore satisfy both the constraints ( a ) and ( b ) .
The new hierarchical structure therefore satisfies both constraints .
1708
An illustration is presented in Figure X .
Figure X is an illustration of this organization .
1709
At the first stage , regions in each image are organized into a hierarchical structure as we presented above .
In the first stage , regions in each image are organized into a hierarchical structure , as presented above .
1710
Given multiple hierarchical structures returned from the first stage , we use their root nodes as initial elements to construct an yet another hierarchical structure over them by divisive clustering .
If multiple hierarchical structures are returned by the first stage , we use their root nodes as the initial elements to construct an yet another hierarchical structure over them by divisive clustering . //<the rewrite is a guess .>
1711
Then , splits are peformed recursively as one moves down the hierarcy .
Then , we perform splits recursively as one moves down the hierarchy .
1712
Once the hierchical structure is completed , we then compute histogram representation for all of its non-leaf nodes .
Once the hierarchical structure is completed , we compute a histogram representation for all of its non-leaf nodes .
1713
This is to ensure the constraint ( b ) sastified .
This is to ensure constraint ( b ) is satisfied .
1714
At last , by unifying results of both stages , we have a unique hierarchical structure over the set of regions of multiple images , which satisfies the both constraints .
Finally , by unifying the results of both stages , we have a unique hierarchical structure over the set of regions of multiple images , which satisfies both constraints .
1715
We show an illustration in Figure Y .
We illustratie this in Figure Y .
1716
Both structures are then becomes input for our proposed approach to find top region pairs with highest similarity scores for recommendation generation .
Both structures then become the input for our approach to find the top region pairs with the highest similarity scores for making recommendations .
1717
Note that , because the hierarchical for regions of images in the database is independent of query , we construct it only one time .
Note that because the hierarchy of the regions of images in the database is independent of the query , we construct it only one time .
1718
A recommendation is a good one if it exactly locates an item which exists in the database .
A recommendation is a good one if it exactly locates an item in the database .
1719
We call such recommendations as hit recommendations . Thus , a good recommendation system should accurately provide such hit recommendation to users .
We call such recommendations" hit recommendations " , and a good recommendation system should accurately provide them to users .
1720
More importantly , users always expect that hit recommendations are ranked higher than false recommendations ( if there are some of them ) on the list of all recommendations introduced by the system .
More importantly , users always expect that hit recommendations are ranked higher than false recommendations ( if there are a number of them ) on the list of the recommendations by the system .
1721
Based on those insights , we evaluate Recommend-Me system using two evaluation metrics : precision on introducing recommendation and rank of the first hit recommendation on the list .
Based on these insights , we evaluated the Recommend-Me system using two evaluation metrics : precision in pesenting recommendations and rank of the first hit recommendation on the list .
1722
Given an initial query image with ground-truth annotation indicates bounding box of an item known existed in the database , Recommend-Me is determined to precisely introduce recommendation if at least one of its recommendation is a hit recommendation .
Given an initial query image with ground-truth annotations indicating the bounding box of an item known to existin the database , Recommend-Me will provide a recommendation if at least one of its recommendations is a hit recommendation .
1723
We apply an approach used in Pascal VOC challenge to clarify whether a recommendation is a hit recommendation .
We used an approach from the Pascal VOC challenge to clarify whether a recommendation is a hit recommendation or not .
1724
Because our target is not to improve search techniques but to facilitate query selection procedure , search performance simply relies on standard techniques if users take an recommendation as a search query .
Because our target is not to improve search techniques but to facilitate query selection , the search simply relies on standard techniques if users use an recommendation as a search query .
1725
This number is then divided by the size of all possible region pairs formed by regions in the initial query image and regions in images of the database .
This number was then divided by the size of all possible region pairs formed by regions in the initial query image and regions in images of the database . //< " the size of all possible region pairs " is unclear to me . Do you mean " the average size of all possible region pairs " or " the sizes of all possible region pairs " ?>
1726
The fraction is reported as the efficiency improvement of Recommend-Me .
The fraction was taken to be the efficiency improvement of Recommend-Me .
1727
Note that , regions in images are pre-selected as in Step 1 of our framework .
Note that regions in images were pre-selected as in Step 1 of our framework .
1728
Visual words in images are located by dense grid sampling and Different-of-Gaussian( DoG ) detector .
Visual words in the images were located by using dense grid sampling and a Different-of-Gaussian ( DoG ) detector .
1729
%to cluster points on a set of random images .% Additionally , the set of interest points obtained by DoG in the query image is used to remove regions without any of such points inside .
%to cluster points on a set of random images .% Additionally , the set of points of interest obtained by the DoG in the query image was used to remove regions without any such points inside .
1730
This helps us to eliminate less meaningful regions such as a portion of the sky , solid color regions , etc for recommendation .
This helped us to eliminate less meaningful regions such as the sky , solid color regions , etc. , from the recommendations .
1731
As mentioned above , we use the approach introduced in \CITE on different color channel for region selection .
As mentioned above , we used the approach first introduced in \CITE on different color channels for the region selection .
1732
In this experiment , we used two color channels which are RGB and Hue , since regions generated on those channels can cover 99 .72\% area of the annotated item regions in our dataset .
In this experiment , we used two color channels , RGB and Hue , since the regions generated on those channels can cover 99 .72\% of the area of the annotated item regions in our dataset .
1733
In addition , rectangular regions which do not contain any visual word or are smaller than 40 x 40 pixels are discarded .% since they can form a meaningful recommendation .
In addition , the rectangular regions which did not contain any visual word or were smaller than 40 x 40 pixels were discarded .% since they can form a meaningful recommendation .
1734
Figure \REF shows our evaluation results .
Figure \REF shows the results of the evaluation .
1735
The reported numbers of precision , rank of the first hit recommendation as well as efficiency improvement are averaged as we perform Recommend-Me with 375 different initial query images and an individual value of \MATH .
The reported precision , rank of the first hit recommendation , and efficiency improvement are averages of Recommend-Me on 375 different initial query images and an individual value of \MATH .
1736
The results show that Recommend-Me can successfully introduce hit recommendations to users with high precision ( approximately 80 .27\% ) .
The results show that Recommend-Me can make hit recommendations to users with high precision ( approximately 80 .27\% ) .
1737
On the returned list of all recommendations , a hit recommendation usually takes the first two places on the list .
On the returned list of all recommendations , hit recommendations usually take the first two places on the list .
1738
We observed that there are two types of false recommendations on the top places of the list .
There were two types of false recommendation in the top places of the list .
1739
The first type consists background regions ( e.g. trees , buildings , roads ) which are easily found in many images .
The first type consisted of background regions ( e.g. trees , buildings , roads ) , which are easily found in many images .
1740
The second type is the items lacking of manual annotation such as windows , cars and humans .
The second type was items lacking manual annotations such as windows , cars , and humans .
1741
However , if users are interested in using them as hints to explore the database , they are still very much helpful .
However , if users are interested in using them as hints to explore the database , they may still be very helpful .
1742
Clearly , one can realize that the performance of Recommend-Me is under the influence of \MATH .
Clearly , one can realize that the performance of Recommend-Me is influenced by \MATH .
1743
By increasing \MATH , we obtain more region pairs with sufficient hight similarity scores .
By increasing \MATH , we can obtain more region pairs with sufficiently high similarity scores .
1744
It brings more chances to get region pairs of the annotated item , thus improves the precision .
Thisgives more chances to get region pairs of the annotated item , thus improving precision .
1745
This results in a drop of average rank of the first hit recommendation .
This results in a drop in the average rank of the first hit recommendation .
1746
When \MATH increases from 2000 to 10000 , the precision also increases from 74 .67\% to 81 .97\% ; meanwhile , the average rank of the first hit recommendation drops to 2 .27 from 1 .78 .
When \MATH increases from 2000 to 10000 , the precision increases from 74 .67\% to 81 .97\% ; meanwhile , the average rank of the first hit recommendation drops to 2 .27 from 1 .78 .
1747
It is worth noting that keeping inreasing \MATH may not always give better precision since precision relies on not only \MATH but also the robustness of the region comparision techniques .
It is worth noting that keeping increasing \MATH may not always give better precision , since precision relies on not only \MATH but also the robustness of the region comparison techniques .
1748
Recommend-Me cannot provide any hit recommendation for around 20\% of initial query images due to the fact that our region comparision technique cannot deal with significant variations of items .
Recommend-Me cannot provide any hit recommendation for around 20\% of the initial query images due to the fact that our region comparison technique cannot deal with significant variations in the items .
1749
It is the decline of efficiency improvement of Recommend-Me .
It is the decline in the efficiency improvement of Recommend-Me .
1750
Its superiority is important for practical applications .
This advantage will be important for practical applications .
1751
Figure \REF presents examples of hit recommendations returned by our Recommend-Me .
Figure \REF presents examples of hit recommendations returned byRecommend-Me .
1752
In this paper , we introduced a new system , named Recommend-Me , for visual query suggestion .
We described oursystem , named Recommend-Me , for making visual query suggestions .
1753
Given an initial query image and a retrieved database , Recommend-Me introduces recommendations that imposes which and how frequent items in the initial query image appear in the database .
Given an initial query image and a retrieved database , Recommend-Me gives recommendations that impose conditions on which and how frequent items in the initial query image appear in the database .
1754
An efficient solution to make Recommend-Me practical is presented .
An efficient solution to make Recommend-Me practical was also presented .
1755
To the best of our knowledge , Recommend-Me is the first attempt toward its targeted suggestion scheme .
To the best of our knowledge , Recommend-Me is the first attempt at developing a targeted suggestion scheme .
