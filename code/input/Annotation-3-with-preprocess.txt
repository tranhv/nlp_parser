#Sentencetypes ref sys 
#catfile vilar-cats

This paper analyzes the effect of the structural variation of sentences on parsing performance .
This paper analyzes the effects of structural variation of sentences on parsing performances .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4,5#4,5,6#para -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#stem -1#13#14#exact 


We examine the performance of both shallow and deep parsers for two sentence constructions : imperatives and questions .
We examined the performances of both shallow and deep parsers for two sentence constructions : imperatives and questions .
-1#0#0#exact -1#1#1#stem -1#2#2#exact -1#3#3#stem -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact 


The target parsers are adapted to sentences of these constructions extracted from fiction and query texts .
The target parsers are adapted to the sentences for these constructions extracted from fiction and query texts .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#7#6#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact 


Analysis of the experimental results illustrates the need to handle different sentence constructions through fundamental improvement of the parsers such as re-construction of feature designs .
The analysis of the experimental results will illustrate the necessity for handling various sentence constructions by fundamental improvement of parsers such as re-construction of feature designs .
-1#1#0#lc -1#2#1#exact -1#3#2#exact -1#4#3#exact -1#5#4#exact -1#7#5#stem -1#8#6#exact -1#9,10#7,8#para -1#11#9#stem -1#12#10#para -1#13#11#exact -1#14#12#exact -1#16#14#exact -1#17#15#exact -1#18#16#exact -1#0#17#lc -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact -1#23#22#exact -1#24#23#exact -1#25#24#exact -1#26#25#exact 


Parsing is a fundamental natural language processing task and essential to various NLP applications .
Parsing is a fundamental natural language processing task and essential for various NLP applications .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10,11#10,11#para -1#12#12#exact -1#13#13#exact -1#14#14#exact 


Recent research on parsing technologies has achieved high parsing accuracy in the same domain as the training data , but once we move to unfamiliar domains , the performance decreases to unignorable levels .
Recent research on parsing technologies has achieved high parsing accuracies on the same domains as the training data , but once we move to unfamiliar domains , the performances decrease at unignorable levels .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#stem -1#10,11,12#10,11,12#para -1#13#13#stem -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#stem -1#29#29#stem -1#31#31#exact -1#32#32#exact -1#33#33#exact 


To address this problem , previous work has focused mainly on adapting lexical or syntactic preferences to the target domain , that is , on adding lexical knowledge or adjusting probabilistic models for the target domain using available in-domain resources \CITE .
To address this problem , previous work has mainly focused on adapting lexical or syntactic preferences to the target domain , that is , on adding lexical knowledge or adjusting probabilistic models for the target domain using available in-domain resources \CITE .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8,9#8,9#para -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact -1#37#37#exact -1#38#38#exact -1#39#39#exact -1#40#40#exact -1#41#41#exact 


Underlying these approaches , there seems to be the assumption that grammatical constructions are not largely different between domains or do not affect parsing systems , and therefore the same parsing system can be applied to a novel domain .
Behind their approaches , there seems to be an assumption that grammatical constructions are not largely different among domains or do not affect parsing systems , and therefore the same parsing system can be applied to a novel domain .
-1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#28#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#para -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact -1#37#37#exact -1#38#38#exact -1#39#39#exact 


However , there are some cases where we cannot achieve such high parsing accuracy as parsing the Penn Treebank ( PTB ) merely by re-training or adaptation .
However , there are some cases where we cannot achieve as high parsing accuracies as parsing the Penn Treebank just by re-training or adaptation .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#11#11#exact -1#12#12#exact -1#13#13#stem -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#22#syn -1#20#23#exact -1#21#24#exact -1#22#25#exact -1#23#26#exact -1#24#27#exact 


For example , the parsing accuracy for the Brown corpus is significantly lower than that for the Wall Street Journal ( WSJ ) portion of the Penn Treebank , even when re-training the parser with much more in-domain training data than other successful domains .
For example , the parsing accuracy for the Brown corpus is significantly lower than for the WSJ portion of the Penn Treebank , even when re-training the parser with much more in-domain training data than other successful domains .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#15#exact -1#15#16#exact -1#16#21#exact -1#17#23#exact -1#18#24#exact -1#19#25#exact -1#20#26#exact -1#21#27#exact -1#22#28#exact -1#23#29#exact -1#24#30#exact -1#25#31#exact -1#26#32#exact -1#27#33#exact -1#28#34#exact -1#29#35#exact -1#30#36#exact -1#31#37#exact -1#32#38#exact -1#33#39#exact -1#34#40#exact -1#35#41#exact -1#36#42#exact -1#37#43#exact -1#38#44#exact 


This research attempts to identify the cause of these difficulties , and focuses on two types of sentence constructions that have not been extensively studied in recent parsing research : imperatives and questions .
This research attempts to identify the cause of these difficulties , and focuses on two types of sentence constructions which were not extensively studied in the recent parsing research : imperatives and questions .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#21#20,21#para -1#20#22#syn -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact 


In these constructions , words in certain syntactic positions disappear or the order of the words changes .
In these constructions , words in some syntactic positions disappear or the orders of words change .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#stem -1#13#13#exact -1#14#14,15#para -1#15#16#stem -1#16#17#exact 


We analyze how such sentences affect the parsing behavior and then attempt to clarify the difficulties in parsing imperatives and questions .
We analyze how such sentences affect the parsing behavior and then attempt to clarify the difficulties in parsing imperatives and questions .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11,12,13,14#11,12,13#para -1#15,16#14,15,16#para -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact 


To do so , we first prepare an annotated corpus for each of the two sentence constructions by borrowing sentences from fiction and query domains .
In order to do so , we prepare an annotated corpus for each of the two sentence constructions by borrowing sentences from fiction and query domains .
-1#2#0#lc -1#3#1#exact -1#4#2#exact -1#5#3#exact -1#6#4#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11,12#10,11,12,13#para -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact -1#23#22#exact -1#24#23#exact -1#25#24#exact -1#26#25#exact 


In the experiments , parsing accuracies of two shallow dependency parsers and a deep parser are examined for imperatives and questions , as well as the accuracy of their part-of-speech ( POS ) tagger .
In the experiments , parsing accuracies of two shallow dependency parsers and a deep parser are examined for imperatives and questions , as well as the accuracies of a part-of-speech tagger for them .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22,23,24#22,23,24,25#para -1#26#26#stem -1#27#27#exact -1#31,32#28#para -1#29#29#exact -1#30#33#exact -1#33#34#exact 


A conventional supervised adaptation technique was applied to these parsers and to the POS tagger .
A conventional supervised adaptation technique was applied to these parsers and to the POS tagger .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact 


Since domain adaptation is an extensive research area in parsing research \CITE , many ideas have been proposed , including un- or semi-supervised approaches \CITE and supervised approaches \CITE .
Since domain adaptation has been an extensive research area in parsing research \CITE , a lot of ideas have been proposed , including un- / semi-supervised approaches \CITE and supervised approaches \CITE .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3,4#3#para -1#5#4#exact -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#17#14#exact -1#18#15#exact -1#19#16#exact -1#20#17#exact -1#21#18#exact -1#22#19#exact -1#23#20#exact -1#25#22#exact -1#26#23#exact -1#27#24#exact -1#28#25#exact -1#29#26#exact -1#30#27#exact -1#31#28#exact -1#32#29#exact 


The main focus of these works is on adapting parsing models trained with a specific genre of text ( in most cases the Penn Treebank WSJ ) to other genres of text , such as biomedical research papers and broadcast news .
Their main focus was on adapting parsing models trained with a specific genre of text ( in most cases Penn Treebank WSJ ) to other genres of text , such as biomedical research papers and broadcast news .
-1#0,1#0,1#para -1#2#2#exact -1#13#3#exact -1#3#5,6#para -1#4#7#exact -1#5#8#exact -1#6#9#exact -1#7#10#exact -1#8#11#exact -1#9#12#exact -1#10#13#exact -1#11#14#exact -1#12#15#exact -1#26#16#exact -1#27#17#exact -1#15#18#exact -1#16,17,18#19,20,21,22#para -1#19#23#exact -1#20#24#exact -1#21#25#exact -1#22#26#exact -1#23#27#exact -1#24#28#exact -1#25#29#exact -1#14#31#exact -1#28#32#exact -1#29#33#exact -1#30#34#exact -1#31#35#exact -1#32#36#exact -1#33#37#exact -1#34#38#exact -1#35#39#exact -1#36#40#exact -1#37#41#exact 


The major problem tackled in such tasks is the handling of unknown words and domain-specific manners of expression .
A major problem tackled in such a task setting is the handling of unknown words and domain-specific ways of expressions .
-1#10#0#lc -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#7#6#stem -1#9#7#exact -1#11#8,9#para -1#12#10#exact -1#13#11#exact -1#14#12#exact -1#15#13#exact -1#16#14#exact -1#17#15#syn -1#18#16#exact -1#19#17#stem -1#20#18#exact 


However , parsing imperatives and questions involves a significantly different problem ; even when all words in a sentence are known , the sentence has a very different structure from declarative sentences .
However , parsing imperatives and questions involves a significantly different problem ; even when all words in a sentence are known , the sentence has a very different structure from declarative sentences .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact 


Compared to domain adaptation , structural types of sentences have received little attention to date .
Compared to domain adaptation , structural types of sentences have gained little attention to date .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact 


A notable exception is the work on QuestionBank \CITE .
A notable exception is the work on QuestionBank \CITE .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact 


This work highlighted the low accuracy of state-of-the-art parsers on questions , and proposed a supervised parser adaptation by manually creating a treebank of questions .
The work pointed out low accuracy of state-of-the-art parsers on questions , and proposed supervised parser adaptation by manually creating a treebank of questions .
-1#1#1#exact -1#0#3#lc -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#20#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact 


The question sentences are annotated with phrase structure trees in the Penn Treebank scheme , although function tags and empty categories are omitted .
The question sentences are annotated with phrase structure trees in the Penn Treebank scheme , although function tags and empty categories are omitted .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact 


QuestionBank was used for the supervised training of an LFG parser , resulting in a significant improvement in parsing accuracy .
QuestionBank was used for the supervised training of an LFG parser , and achieved a significant improvement in parsing accuracy .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#17#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact 


In this work , question sentences were collected from TREC 9-12 competitions and annotated with POS and CCG lexical categories .
They collected question sentences from TREC 9-12 competitions , and annotated these sentences with POSs and CCG lexical categories .
-1#8#3#exact -1#2#4#exact -1#3#5#exact -1#1#7#exact -1#4#8#exact -1#5#9#exact -1#6#10#exact -1#7#11#exact -1#9#12#exact -1#10#13#exact -1#13#14#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact 


The authors reported a significant improvement in CCG parsing without phrase structure annotations .
They reported a significant improvement in CCG parsing without phrase structure annotations .
-1#1#2#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact 


Our work further extends \CITE and \CITE , while covering a wider range of sentence constructions .
Our work further extends \CITE and \CITE , while covering a wider range of sentence constructions .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact 


Although QuestionBank and the resource of \CITE claim to be corpora of questions , they are biased because the sentences come from QA queries .
Although QuestionBank and the resource of \CITE are claimed to be a corpus of questions , they are biased because the sentences come from QA queries .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#8,9,10#7,8,9#para -1#12#10#syn -1#13#11#exact -1#14#12#exact -1#15#13#exact -1#16#14#exact -1#17#15#exact -1#18#16#exact -1#19#17#exact -1#20#18#exact -1#21#19#exact -1#22#20#exact -1#23#21#exact -1#24#22#exact -1#25#23#exact -1#26#24#exact 


For example , such queries rarely include yes / no questions or tag questions .
For example , such queries rarely include yes / no questions and tag questions .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact 


For our study , sentences were collected from the Brown corpus , which includes a wider range of types of questions and imperatives .
In our work , sentences are collected from the Brown corpus , which includes a wider range of types of questions and imperatives .
-1#1#1#exact -1#2#2#syn -1#3#3#exact -1#4#4#exact -1#5,6#5,6#para -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact 


In the experiments , we also used QuestionBank for comparison .
In the experiments , we will additionally use QuestionBank for comparison .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#6#5#para -1#7#6#stem -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact 


We examined the performance of two dependency parsers and a deep parser on the target text sets .
We examined the performance of two dependency parsers and a deep parser on the target text sets .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact 


All parsers assumed that the input was already POS-tagged .
All parsers assume that the input is already POS-tagged .
-1#0#0#exact -1#1#1#exact -1#2,3#2,3#para -1#4#4#exact -1#5#5#exact -1#6,7#6,7#para -1#8#8#exact -1#9#9#exact 


We used the tagger in \CITE .
We use a tagger in \CITE .
-1#0#0#exact -1#1#1#stem -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact 


The MST and Malt parsers are dependency parsers that produce non-projective dependency trees , using the spanning tree algorithm \CITE and transition-based algorithm \CITE , respectively .
The MST parser and Malt parser are dependency parsers that produce non-projective dependency trees , using the spanning tree algorithm \CITE and transition-based algorithm \CITE respectively .
-1#0#0#exact -1#1#1#exact -1#3#2#exact -1#4#3#exact -1#8#4#exact -1#6#5#exact -1#7#6#exact -1#2#7#stem -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact -1#23#22#exact -1#24#23#exact -1#25#25#exact -1#26#26#exact 


Although the publicly available implementation of each parser also has the option to restrict the output to a projective dependency tree , we used the non-projective versions because the dependency structures converted from the question sentences in the Brown corpus included many non-projective dependencies .
Although the publicly available implementation of each parser also has an option to restrict the output to be a projective dependency tree , we used the non-projective version because the dependency structures converted from the question sentences in the Brown corpus included many non-projective dependencies .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10,11#10,11#para -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact -1#23#22#exact -1#24#23#exact -1#25#24#exact -1#26#25#exact -1#27#26#stem -1#28#27#exact -1#29#28#exact -1#30#29#exact -1#31#30#exact -1#32#31#exact -1#33#32#exact -1#34#33#exact -1#35#34#exact -1#36#35#exact -1#37#36#exact -1#38#37#exact -1#39#38#exact -1#40#39#exact -1#41#40#exact -1#42#41#exact -1#43#42#exact -1#44#43#exact -1#45#44#exact 


We used the pennconverter \CITE to convert a PTB-style treebank into dependency trees .
We used pennconverter \CITE to convert a PTB-style treebank to dependency trees .
-1#0#0#exact -1#1#1#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact 


To evaluate the output from each of the parsers , we used the labeled attachment accuracy excluding punctuation .
For the evaluation of the output from each of the MST and Malt parser , we used the labeled attachment accuracy excluding the punctuations .
-1#2,3,4#1,2#para -1#5#3#exact -1#6,7,8,9#4,5,6#para -1#1#7#exact -1#13#8#stem -1#14#9#exact -1#15#10#exact -1#16#11#exact -1#17#12#exact -1#18#13#exact -1#19#14#exact -1#20#15#exact -1#21#16#exact -1#23#17#stem -1#24#18#exact 


The Enju parser \CITE is a deep parser based on the HPSG ( Head Driven Phrase Structure Grammar ) formalism .
The Enju parser \CITE is a deep parser based on the HPSG formalism .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#19#exact -1#13#20#exact 


It produces an analysis of a sentence including the syntactic structure ( i.e. , parse tree ) and the semantic structure represented as a set of predicate-argument dependencies .
It produces an analysis of a sentence that includes the syntactic structure ( i.e. , parse tree ) and the semantic structure represented as a set of predicate-argument dependencies .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7,8,9#7,8#para -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact -1#23,24,25,26#22,23,24#para -1#27#26#exact -1#28#27#exact -1#29#28#exact 


We used the toolkit distributed with the Enju parser to train the parser with a PTB-style treebank .
We used a toolkit distributed with the Enju parser for training the parser with a PTB-style treebank .
-1#0#0#exact -1#1#1#exact -1#11#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9,10#9,10#para -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact 


The toolkit initially converts a PTB-style treebank into an HPSG treebank and then trains the parser on this .
The toolkit initially converts the PTB-style treebank into an HPSG treebank and then trains the parser on it .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#18#18#exact 


The HPSG treebank converted from the test section was used as the gold-standard in the evaluation .
The HPSG treebank converted from the test section was used as the gold-standard in the evaluation .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact 


As evaluation metrics for the Enju parser , we used labeled and unlabeled precision / recall / F-score of the predicate-argument dependencies produced by the parser .
As the evaluation metrics of the Enju parser , we used labeled and unlabeled precision / recall / F-score of the predicate-argument dependencies produced by the parser .
-1#0#0#exact -1#2#1#exact -1#3#2#exact -1#5#4#exact -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact -1#23#22#exact -1#24#23#exact -1#25#24#exact -1#26#25#exact -1#27#26#exact 


This section explains how we collected the treebanks of imperatives and questions used in the experiments in Section \REF .
This section explains how we collected the treebanks of imperatives and questions , which were used in the experiments in Section \REF .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#15#12#exact -1#16#13#exact -1#17#14#exact -1#18#15#exact -1#19#16#exact -1#20#17#exact -1#21#18#exact -1#22#19#exact 


The Penn Treebank 3 contains treebanks of several genres of texts .
Penn Treebank 3 contains treebanks of several genres of texts .
-1#0#1#exact -1#1#2#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact 


Although the WSJ treebank has been used extensively for parsing experiments , we used the treebank of the Brown Corpus in our experiments .
While the Wall Street Journal ( WSJ ) treebank has extensively been used for parsing experiments , we use the treebank of the Brown Corpus in our experiments .
-1#1#1#exact -1#6#2#exact -1#8#3#exact -1#9#4#exact -1#11#5#exact -1#12#6#exact -1#10#7#exact -1#13#8#exact -1#14#9#exact -1#15#10#exact -1#16#11#exact -1#17#12#exact -1#18#13#stem -1#19#14#exact -1#20#15#exact -1#21#16#exact -1#22#17#exact -1#23#18#exact -1#24#19#exact -1#25#20#exact -1#26#21#exact -1#27#22#exact -1#28#23#exact 


As the Brown Corpus portion includes texts of literary works , it is expected to contain inherently a larger number of imperatives and questions than the WSJ portion .
Because the Brown Corpus portion includes texts of literary works , it is expected that it inherently contains a larger number of imperatives and questions than the WSJ portion .
-1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11,12,13#11,12,13,14#para -1#17#15#stem -1#16#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact -1#23#22#exact -1#24#23#exact -1#25#24#exact -1#26#25#exact -1#27#26#exact -1#28#27#exact -1#29#28#exact 


The Brown Corpus portion of the Penn Treebank 3 is annotated with phrase structure trees as in the Penn Treebank WSJ .
The Brown Corpus portion of Penn Treebank 3 is annotated with phrase structure trees as in the Penn Treebank WSJ .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#16#5#exact -1#17#6#exact -1#18#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#5#18#exact -1#6#19#exact -1#19#20#exact -1#20#21#exact 


Interrogative sentences are annotated with the phrase label " SBARQ " or " SQ " , where " SBARQ " denotes wh-questions , while " SQ " denotes yes / no questions .
Interrogative sentences are annotated with the phrase label " SBARQ " or " SQ " , where " SBARQ " represents wh-questions , while " SQ " denotes yes / no questions .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#27#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact 


Imperative sentences are annotated with the phrase label " S-IMP " .
Imperative sentences are annotated with the phrase label " S-IMP " .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact 


All sentences annotated with these phrase labels were extracted .
We extracted those sentences annotated with these phrase labels .
-1#3#1#exact -1#4#2#exact -1#5#3#exact -1#6#4#exact -1#7#5#exact -1#8#6#exact -1#1#8#exact -1#9#9#exact 


Imperatives and questions appear not only at the top level but also as embedded clauses .
Imperatives and questions appear not only at the top level but also appear as embedded clauses .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact 


We extracted such embedded questions and imperatives as well .
We extracted such embedded questions and imperatives as well .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact 


However , is these were embedded in another imperative or question , we only extracted the outermost one .
When they are embedded in another imperative or question , we only extracted the outermost one .
-1#9#1#exact -1#2#3,4#para -1#3#5#exact -1#4#6#exact -1#5#7#exact -1#6#8#exact -1#7#9#exact -1#8#10#exact -1#10#12#exact -1#11#13#exact -1#12#14#exact -1#13#15#exact -1#14#16#exact -1#15#17#exact -1#16#18#exact 


Extracted sentences were post-processed to fit the natural sentence form ; that is , with first characters capitalized and question marks or periods added as appropriate .
Extracted sentences are post-processed so that they have natural sentence forms : first characters are capitalized , and question marks or periods are added when appropriate .
-1#0#0#exact -1#1#1#exact -1#2#2#syn -1#3#3#exact -1#25#5#para -1#8#6,7#para -1#9#8#exact -1#10#9#stem -1#5#11#exact -1#21,22#12#para -1#16#13#exact -1#12#15#exact -1#13#16#exact -1#15#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#23#23#exact -1#26#26#exact 


As a result , we extracted 750 imperative sentences and 1 ,241 question sentences from 24 ,243 sentences .
As a result , we extracted 750 imperative sentences and 1 ,241 question sentences from 24 ,243 sentences .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact 


Examples of extracted sentences are shown in Figure \REF .
Examples of extracted sentences are shown in Figure \REF .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact 


The numbers of sentences for each section are given in Table \REF .
The number of sentences for each section is shown in Table \REF .
-1#0#0#exact -1#1,2#1,2#para -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#syn -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact 


Although we also applied a similar method to the WSJ portion , we only obtained 115 imperatives and 432 questions .
Although we also applied a similar method to the WSJ portion , we could obtain only 115 imperatives and 432 questions .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#15#13#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact 


This data was not used in the experiments .
We will not use this data in the experiments .
-1#4#0#lc -1#5#1#exact -1#2#3#exact -1#3#4#stem -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact 


As described below , we also used QuestionBank in the experiments .
As we will describe below , we additionally use QuestionBank in experiments .
-1#0#0#exact -1#3#1#stem -1#4#2#exact -1#5#3#exact -1#6#4#exact -1#7#5#para -1#8#6#stem -1#9#7#exact -1#10#8#exact -1#11#9,10#para -1#12#11#exact 


The advantage , however , of using the Brown treebank is that it includes annotations of function tags and empty categories , and therefore , we can apply the Penn Treebank-to-HPSG conversion program of Enju \CITE , which relies on function tags and empty categories .
However , an advantage of using the Brown treebank is that it includes annotations of function tags and empty categories . Therefore , we can apply the Penn Treebank-to-HPSG conversion program of Enju \CITE , which relies on function tags and empty categories .
-1#26#0#lc -1#3#1#exact -1#22#2#exact -1#0#3#lc -1#1#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#34#21#exact -1#40#22#exact -1#21#23#lc -1#23#25#exact -1#24#26#exact -1#25#27#exact -1#27#29#exact -1#28#30#exact -1#29#31#exact -1#30#32#exact -1#31#33#exact -1#32#34#exact -1#33#35#exact -1#35#37#exact -1#36#38#exact -1#37#39#exact -1#38#40#exact -1#39#41#exact -1#41#42,43#para -1#42#44#exact -1#43#45#exact 


Hence , we show experimental results for Enju only with the Brown data .
Hence , we will show experimental results on Enju only with the Brown data .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#4#3#exact -1#5#4#exact -1#6#5#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact 


It should also be noted that , a constituency-to-dependency converter , pennconverter \CITE , provides a more accurate conversion when function tags and empty categories are available ( see footnote 6 ) .
It should also be noted that , a constituency-to-dependency converter , pennconverter \CITE , provides more accurate conversion when function tags and empty categories are available ( See footnote 6 ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15,16#15,16,17#para -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#lc -1#28#29#exact -1#29#30#exact -1#30#31#exact -1#31#32#exact 


QuestionBank consists of question sentences as well as a small number of imperative and declarative sentences .
QuestionBank consists of question sentences as well as a small number of imperative and declarative sentences .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5,6,7#5,6,7,8#para -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact 


We extracted 3 ,859 sentences annotated with " SBARQ " or " SQ " .
We extracted 3 ,859 sentences that are annotated with " SBARQ " or " SQ " .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#7#5#exact -1#8#6#exact -1#9#7#exact -1#10#8#exact -1#11#9#exact -1#12#10#exact -1#13#11#exact -1#14#12#exact -1#15#13#exact -1#16#14#exact 


During the experiments , we found several annotation errors that caused fatal errors in the treebank conversion .
During experiments , we found several annotation errors that caused fatal errors of treebank conversion .
-1#0#0#exact -1#1#2#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#13#15#exact -1#14#16#exact -1#15#17#exact 


We manually corrected the annotations of twelve sentences .
We therefore corrected annotations of twelve sentences manually .
-1#0#0#exact -1#7#1#exact -1#2#2#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#8#8#exact 


We intend making these corrections publicly available .
We plan to make these corrections publicly available .
-1#0,1#0,1#para -1#3#2#stem -1#4#3#exact -1#5#4#exact -1#6#5#exact -1#7#6#exact -1#8#7#exact 


Examples of the annotation errors include brackets enclosing empty words and undefined or empty tags .
Examples of the annotation errors include brackets enclosing empty words and undefined or empty tags .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact 


We also found and corrected obvious inconsistencies in the corpus : character " ' " replaced by " $<$ " ( 737 sentences ) , token " ? " tagged with " ? " instead of " . " ( 2 ,051 sentences ) , and phrase labels annotated as the POS ( one sentence ) .
We also found and corrected obvious inconsistencies in the corpus : character " ' " replaced by " $<$ " ( 737 sentences ) , token " ? " tagged not with " . " but with " ? " ( 2 ,051 sentences ) , and phrase labels annotated as POS ( one sentence ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#31#30#exact -1#32#31#exact -1#38#32#exact -1#39#33#exact -1#30#34#para -1#34#36#exact -1#33#37#exact -1#37#38#exact -1#40#39#exact -1#41#40#exact -1#42#41#exact -1#43#42#exact -1#44#43#exact -1#45#44#exact -1#46#45#exact -1#47#46#exact -1#48#47#exact -1#49#48#exact -1#50#49#exact -1#51#51#exact -1#52#52#exact -1#53#53#exact -1#54#54#exact -1#55#55#exact -1#56#56#exact 


We examined the performance of the three parsers and the POS tagger with Brown imperatives and questions , and QuestionBank questions .
We examined performances of the three parsers and the POS tagger for Brown imperatives and questions , and QuestionBank questions .
-1#0#0#exact -1#1#1#exact -1#8#2#exact -1#2#3#stem -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#9#10#exact -1#10#11#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact 


By observing the effect of the parser or tagger adaptation in each domain , we can identify the difficulties in parsing imperative and question sentences .
By observing the effects of parser or tagger adaptation to each domain , we would like to see the difficulties in parsing imperative and question sentences .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3,4#3,4#para -1#18#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9,10#10,11#para -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#17#15,16#para -1#19,20#17,18,19#para -1#21#20#exact -1#22#21#exact -1#23#22#exact -1#24#23#exact -1#25#24#exact -1#26#25#exact 


We also examined the portability of sentence construction properties between two similar domains : questions in Brown and in QuestionBank .
We also examined the portability of sentence construction properties between two similar domains : questions in Brown and QuestionBank .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#19#exact -1#19#20#exact 


We created experimental datasets for five domains : WSJ , Brown overall , Brown imperatives , Brown questions , and QuestionBank questions .
We made experimental datasets for five domains : Wall Street Journal ( WSJ ) , Brown overall sentences , Brown imperatives , Brown questions , and QuestionBank questions .
-1#0#0#exact -1#1#1#syn -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#12#8#exact -1#14#9#exact -1#15#10#exact -1#16#11#exact -1#18#12#exact -1#19#13#exact -1#20#14#exact -1#21#15#exact -1#22#16#exact -1#23#17#exact -1#24#18#exact -1#25#19#exact -1#26#20#exact -1#27#21#exact -1#28#22#exact 


WSJ ( 43 ,948 sentences )
WSJ ( 43 ,948 sentences )
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact 


- Divided into three parts , for training ( Section 02 - 21 , 39 ,832 sentences ) , development test ( Section 22 , 1 ,700 sentences ) , and final test ( Section 23 , 2 ,416 sentences ) .
- Divided into three parts for training ( Section 02 - 21 , 39 ,832 sentences ) , development test ( Section 22 , 1 ,700 sentences ) , and final test ( Section 23 , 2 ,416 sentences ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#12#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#17#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#23#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#28#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact -1#35#29#exact -1#29#30#exact -1#30#31#exact -1#31#32#exact -1#32#33#exact -1#33#34#exact -1#34#35#exact -1#36#37#exact -1#37#38#exact -1#38#39#exact -1#39#40#exact -1#40#41#exact 


Brown overall ( 24 ,243 sentences )
Brown overall ( 24 ,243 sentences )
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact 


- Randomly divided into three parts for training ( 19 ,395 sentences ) , development set ( 2 ,424 sentences ) , and final test ( 2 ,424 sentences ) .
- Randomly divided into three parts for training ( 19 ,395 sentences ) , development set ( 2 ,424 sentences ) , and final test ( 2 ,424 sentences )
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact 


Brown imperatives ( 750 sentences )
Brown imperatives ( 750 sentences )
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact 


- divided into two parts : one for ten-fold cross validation test ( 65 $\times$ 10 sentences ) and the other for error analysis ( 100 sentences ) .
- divided into two parts : one for ten-folds cross validation test ( 65 $\times$ 10 sentences ) and the other for error analysis ( 100 sentences )
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#stem -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact 


Brown questions ( 1 ,241 sentences )
Brown questions ( 1 ,241 sentences )
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact 


- divided into two parts : one for ten-fold cross validation test ( 112 $\times$ 10 sentences ) and the other for error analysis ( 141 sentences ) .
- divided into two parts : one for ten-folds cross validation test ( 112 $\times$ 10 sentences ) and the other for error analysis ( 141 sentences )
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#stem -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact 


QuestionBank questions ( 3 ,859 sentences )
QuestionBank questions ( 3 ,859 sentences )
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact 


- from the top of the corpus divided into three parts for final test ( 1 ,000 sentences ) , training ( 2 ,560 sentences ) , and analysis ( 299 sentences ) .
- from the top of the corpus divided into three parts for final test ( 1 ,000 sentences ) , training ( 2 ,560 sentences ) , and analysis ( 299 sentences )
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact 


To adapt each parser and the POS tagger to a target domain , we trained the parser using combined training data for the target domain and the original parser .
In order to adapt each parser or POS tagger to a target domain , we trained the parser on combined training data for the target domain and for the original parser .
-1#2#0#lc -1#3#1#exact -1#4#2#exact -1#5#3#exact -1#26#4#exact -1#16#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#23#15#exact -1#17#16#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact -1#28#22#exact -1#24#23#exact -1#25#24#exact -1#29#26,27#para -1#30#28#exact -1#31#29#exact 


For a domain containing only a small amount of training data , we replicated the training data a certain number of times and utilized the concatenated replicas for training .
For a domain which contains only small training data , we replicated the training data for certain times and just utilized the concatenated replicas for training .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3,4#3#para -1#5#4#exact -1#6#5,6#para -1#7#8,9#para -1#8#10#exact -1#9#11#exact -1#10#12#exact -1#11#13#exact -1#12#14#exact -1#13#15#exact -1#14#16#exact -1#16#17,18#para -1#17#20,21#para -1#18#22#exact -1#20#23#exact -1#21#24#exact -1#22#25#exact -1#23#26#exact -1#24#27#exact -1#25#28#exact -1#26#29#exact 


POS tagger
POS tagger
-1#0#0#exact -1#1#1#exact 


- For Brown overall , we trained the model with the combined training data for the target domain and the original model .
- For Brown overall , we trained the model with the combined training data for the target domain and for the original model .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact -1#23#22#exact 


For Brown imperatives / questions and QuestionBank , we replicated the training data a certain number of times and utilized the concatenated replicas and WSJ training data for training .
For Brown imperatives / questions and QuestionBank , we replicated the training data for certain times and utilized the concatenated replicas and WSJ training data for training .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#14#13,14#para -1#15#16,17#para -1#16#18#exact -1#17#19#exact -1#18#20#exact -1#19#21#exact -1#20#22#exact -1#21#23#exact -1#22#24#exact -1#23#25#exact -1#24#26#exact -1#25#27#exact -1#26#28#exact -1#27#29#exact 


For the POS tagger , the number of replicas of training data was determined as either 1 , 2 , 4 , 8 , 16 , 32 , 64 , or 128 , by testing these numbers on the development test sets in three of the ten datasets for cross validation .
For POS tagger , the number of replicas of training data was determined among 1 , 2 , 4 , 8 , 16 , 32 , 64 , and 128 , by testing these numbers on development test sets in three of ten datasets of cross validation .
-1#0#0#exact -1#4#1#exact -1#1#2#exact -1#2#3#exact -1#3#4#exact -1#5,6#5,6,7#para -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#14#16#exact -1#15#17#exact -1#16#18#exact -1#17#19#exact -1#18#20#exact -1#19#21#exact -1#20#22#exact -1#21#23#exact -1#22#24#exact -1#23#25#exact -1#24#26#exact -1#25#27#exact -1#26#28#exact -1#27#29#exact -1#29#31#exact -1#30#32#exact -1#31#33#exact -1#32#34#exact -1#33#35#exact -1#34#36#exact -1#35#37#exact -1#36#38,39#para -1#37#40#exact -1#38#41#exact -1#39#42#exact -1#40#43#exact -1#41#44#exact -1#42#45,46#para -1#43#47#exact -1#45#49#exact -1#46#50#exact -1#47#51#exact 


MST and Malt parser
MST and Malt parser
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact 


- For Brown overall and QuestionBank questions , we trained the model on combined data for the target domain and the original model .
- For Brown overall and QuestionBank questions , we trained the model on combined data for the target domain and for the original model .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#21#20#exact -1#22#21#exact -1#23#22#exact -1#24#23#exact 


For Brown imperatives and questions , we replicated the training data ten times and utilized the concatenated replicas and WSJ training data for training .
For Brown imperatives and questions , we replicated the training data for ten times and utilized the concatenated replicas and WSJ training data for training .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact -1#23#22#exact -1#24#23#exact -1#25#24#exact 


Enju parser
Enju parser
-1#0#0#exact -1#1#1#exact 


- We used the toolkit in the Enju parser \CITE .
- We used a toolkit in the Enju parser \CITE
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#6#3#exact -1#4#4#exact -1#5#5#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact 


Table \REF gives the POS tagging accuracy for the target domains .
Table \REF shows the POS tagging accuracies for the target domains .
-1#0#0#exact -1#1#1#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#stem -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact 


When we applied the WSJ tagger to other domains , the tagging accuracy basically decreased .
When we applied WSJ tagger to other domains , the tagging accuracy more or less decreased .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#9#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#10#11#exact -1#11#12#exact -1#15#14#exact -1#16#15#exact 


For Brown overall , compared with the WSJ , the accuracy did not decrease much .
Among them , for Brown overall sentences , the accuracy did not decrease much from WSJ .
-1#3#0#lc -1#4#1#exact -1#5#2#exact -1#2#3#exact -1#8#6#exact -1#15#7#exact -1#7#8#exact -1#9#9,10#para -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#16#15#exact 


However , for imperatives and questions , the POS tagger accuracy decreased significantly .
However , for imperatives and questions , the POS tagger accuracy decreased significantly .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact 


The table shows that the adaptation improved the tagging accuracy to some extent , but that the improved accuracy for imperatives and questions was still below that of the adapted tagger for Brown overall .
The table shows the adaptation could improve the tagging accuracy to some extent , while the table also shows that the improved accuracy for the imperatives and questions could not reach eventhe accuracy of adapted tagger for Brown overall .
-1#15#0#lc -1#16#1#exact -1#18#2#exact -1#19#3#exact -1#20#4#exact -1#4#5#exact -1#21#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#3#16#exact -1#6#17#stem -1#22#18#exact -1#23#19#exact -1#25#20#exact -1#26#21#exact -1#27#22#exact -1#29,30#25#para -1#33#27#exact -1#24#28#exact -1#34#29#exact -1#35#30#exact -1#36#31#exact -1#37#32#exact -1#38#33#exact -1#39#34#exact 


Figure \REF shows the POS tagging accuracy for the target domains for varying sizes of the target training data .
Figure \REF shows the POS tagging accuracy for the target domains given by changing the size of the target training data .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#13#12#syn -1#14,15#13#para -1#16#14#exact -1#17#15#exact -1#18#16#exact -1#19#17#exact -1#20#18#exact -1#21#19#exact 


This graph shows that for both types of sentences , the first 300 training sentences greatly improved the accuracy , but thereafter , the effect of adding training data declined .
This graph shows that for both types of sentences , first 300 training sentences improved the accuracy rapidly , and after that , the effect of adding training corpus declined .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#15#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#16#exact -1#23#17#exact -1#16#18#exact -1#18#19#exact -1#22#22#exact -1#24,25#23,24,25#para -1#26#26#exact -1#27#27#exact -1#29#29#exact -1#30#30#exact 


To match the tagging accuracy of the WSJ tagger for the WSJ ( 97 .53\% in Table \REF ) , preparing much more training data does not appear to be enough .
In order to recover the tagging accuracy of the WSJ tagger for WSJ ( 97 .53\% in Table \REF ) , it would not seem to be enough only to prepare much more training data .
-1#2#0#lc -1#4#2#exact -1#5#3#exact -1#6#4#exact -1#7#5#exact -1#8#6#exact -1#9#7#exact -1#10#8#exact -1#11#9#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#30#20#stem -1#31#21#exact -1#32#22#exact -1#33#23#exact -1#34#24#exact -1#23,24,25#25,26,27,28#para -1#26#29#exact -1#27#30#exact -1#35#31#exact 


In particular , the problem is more serious for imperatives .
Especially , the problem would be more serious for imperatives .
-1#0#0,1#para -1#1#2#exact -1#2#3#exact -1#3#4#exact -1#4,5,6#5,6#para -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact 


Next , we explored the tagging errors in each domain to observe the types of errors from the WSJ tagger and which of these were either solved by the adapted taggers or remain unsolved .
We then explored the tagging errors in each domain in order to observe what types of errors the WSJ tagger gave and what types of errors were solved or still unsolved by the adapted taggers .
-1#0#2#lc -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#11#10#exact -1#12#11#exact -1#13,14#12,13#para -1#15#14#exact -1#16#15#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#21#20#exact -1#24#22#exact -1#26#23,24#para -1#28#25#para -1#27#26#exact -1#31#27#exact -1#32#28#exact -1#33#29#exact -1#34#30#exact -1#29#32#para -1#30#33#exact -1#35#34#exact 


Tables \REF , \REF , and \REF show the most frequent tagging errors given by the WSJ tagger / adapted tagger for Brown questions , Brown imperatives , and QuestionBank , respectively .
Table \REF , \REF , and \REF show the most frequent tagging errors given by the WSJ tagger / adapted tagger for Brown questions , Brown imperatives , and QuestionBank respectively .
-1#0#0#stem -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#31#exact -1#31#32#exact 


From the results , we found that the main errors of the WSJ tagger for the Brown domains were mistagging of verbs , that is , " VB \SPEC " .
In the tables , we could find that the major errors of the WSJ tagger for the Brown domains were the mis-tagging to verbs , that is , " VB \SPEC " .
-1#1#1#exact -1#3#3#exact -1#4#4#exact -1#6#5#syn -1#7#6#exact -1#8#7#exact -1#9#8#para -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#23#21#exact -1#24#22#exact -1#25#23#exact -1#26#24#exact -1#27#25#exact -1#28#26#exact -1#29#27#exact -1#30#28#exact -1#31#29#exact -1#32#30#exact 


We then analyzed why each of these errors had occurred .
We then analyzed why each of such errors had occurred .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact 


For Brown imperatives , the WSJ tagger gave two main tagging errors : " VB \SPEC NN( P ) " and " VB \SPEC VBP " .
For Brown imperatives , the WSJ tagger gave two major tagging errors : " VB \SPEC NN( P ) " and " VB \SPEC VBP " .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#para -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact 


These two types of errors arise from the following differences in sentence constructions between the WSJ declarative and Brown imperative sentences .
These two types of errors would respectively come from the following differences in sentence constructions between WSJ declarative and the Brown imperative sentences .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#8#6#exact -1#9#7#exact -1#10#8#exact -1#11#9#exact -1#12#10#exact -1#13#11#exact -1#14#12#exact -1#15#13#exact -1#19#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#20#18#exact -1#21#19#exact -1#22#20#exact -1#23#21#exact 


First , a declarative sentence normally begins with a noun phrase , whereas an imperative sentence normally begins with a verb phrase .
Firstly , declarative sentences normally begin with noun phrases while imperative sentences normally begin with verb phrases .
-1#0#0#stem -1#1#1#exact -1#2#3#exact -1#3#4#stem -1#4#5#exact -1#5,6#6,7#para -1#7#9#exact -1#8#10#stem -1#10#14#exact -1#11#15#stem -1#12#16#exact -1#13,14#17,18#para -1#15#20#exact -1#16#21#stem -1#17#22#exact 


Since The WSJ tagger was trained on a domain consisting mainly of declarative sentences , with the training based on N-gram sequences of words or POSs , preference was given to noun phrase-derived tags at the beginning of a sentence .
The WSJ tagger was trained on the domain mainly consisting of declarative sentences , and the training was based on N-gram sequences of words or POSs . The tagger therefore preferred to give noun phrase-derived tags to the beginning of a sentence .
-1#0#1#exact -1#1#2#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#40#7#exact -1#7#8#exact -1#9#9#exact -1#8#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#6#16#exact -1#16#17#exact -1#17,18,19#18,19#para -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#30#27#stem -1#32#29#syn -1#31#30#exact -1#33#31#exact -1#34#32#exact -1#35#33#exact -1#37,38#34,35,36,37#para -1#41#38,39#para -1#42#40#exact 


Second , the main verb in an imperative sentence takes a base form , whereas the main verb in a declarative sentence takes a form based on tense .
Secondly , main verbs in imperative sentences take base forms while main verbs in declarative sentences take the forms according to tense .
-1#0#0#stem -1#1#1#exact -1#17#2#exact -1#2#3#exact -1#3#4#stem -1#4#5#exact -1#5#7#exact -1#6#8#stem -1#7#9#stem -1#8#10,11#para -1#9#12#stem -1#11#15,16#para -1#12#17#stem -1#13#18#exact -1#14#20#exact -1#15#21#stem -1#16#22#stem -1#18#24#stem -1#21#27#exact -1#22#28#exact 


A problem arises in that , for the present tense , except for third person singular , the verb in a declarative sentence always has the same appearance as the base form , although the tags are different : VBP and VB , respectively .
The problem is that , for present tense except for third person singular , verbs in the declarative sentences always take the same appearances as the base forms , while the tags are different : VBP and VB .
-1#1#1#exact -1#2#2#para -1#15#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#16#7#exact -1#6#8#exact -1#7#9#exact -1#13#10#exact -1#8#11#exact -1#9#12#exact -1#10#13#exact -1#11#14#exact -1#12#15#exact -1#28#16#exact -1#21#17#exact -1#14#18#stem -1#17#21#exact -1#18#22#stem -1#19#23#exact -1#20#24#syn -1#30#25#exact -1#22#26#exact -1#23#27#stem -1#24#28#exact -1#25#29#exact -1#26#30#exact -1#27#31#stem -1#0#34#lc -1#31#35#exact -1#32#36#exact -1#33#37#exact -1#34#38#exact -1#35#39#exact -1#36#40#exact -1#37#41#exact -1#38#44#exact 


Since the WSJ tagger is predominantly based on declarative sentences , it prefers to give VBP tags to main verbs .
The WSJ tagger mainly based on declarative sentences therefore prefer to give VBP tags to main verbs .
-1#0#1#lc -1#1#2#exact -1#2#3#exact -1#3#5#para -1#4#6#exact -1#5#7#exact -1#6#8#exact -1#7#9#exact -1#9#11,12#para -1#10#13#exact -1#11#14#exact -1#12#15#exact -1#13#16#exact -1#14#17#exact -1#15#18#exact -1#16#19#exact -1#17#20#exact 


After adapting the tagger to Brown imperatives , the N-gram model of the tagger would have learned that the first word in a sentence tends to be a verb , and that the main verb tends to take the base form ( VB ) .
After adapting the tagger to Brown imperatives , the N-gram model of tagger would have learned that the first word in a sentence tends to be a verb , and the main verb tends to take base form ( VB ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#17#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#30#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact -1#28#29#exact -1#29#30#exact -1#31#32,33#para -1#32#34#exact -1#33#35#exact -1#34#36#exact -1#35#37#exact -1#36#39#exact -1#37#40#exact -1#38#41#exact -1#39#42#exact -1#40#43#exact -1#41#44#exact 


Table \REF shows that after adaptation the above two types of errors decreased to some extent , although a few mistags of verbs still remained .
Table \REF shows that the above two types of errors did decrease to some extent . However , we can also observe that not a few mis-tags to verbs were still left after the adaptation .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#32#4#exact -1#34#5#exact -1#4#6#exact -1#5#7#exact -1#6#8#exact -1#7#9#exact -1#8#10#exact -1#9#11#exact -1#11#12#stem -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#17#16#exact -1#24#18#exact -1#25#19#exact -1#28#22#exact -1#30#23#exact -1#15#25#exact 


By investigating the remaining errors associated with VB , we found that several errors still occurred even in simple imperative sentences such as " VB \SPEC NN " for " Charge " in " Charge something for it " , and that some errors tended to occur after a to-infinitive phrase or conjunction , such as " VB \SPEC NN " for " subtract " in " To find the estimated net farm income , subtract . . . " .
When we observe each of the left errors around VB , we found that several errors still occurred even in simple imperative sentences such as " VB \SPEC NN " for " Charge " in " Charge something for it . " , and that some errors tended to occur after to-infinitive phrase or conjunction , such as " VB \SPEC NN " for " subtract " in " To find estimated net farm income , subtract . . . "
-1#5#2#exact -1#6#3#syn -1#7#4#exact -1#9#7#exact -1#10#8#exact -1#11#9#exact -1#12#10#exact -1#13#11#exact -1#14#12#exact -1#15#13#exact -1#16#14#exact -1#17#15#exact -1#18#16#exact -1#19#17#exact -1#20#18#exact -1#21#19#exact -1#22#20#exact -1#23#21#exact -1#24#22#exact -1#25#23#exact -1#26#24#exact -1#27#25#exact -1#28#26#exact -1#29#27#exact -1#30#28#exact -1#31#29#exact -1#32#30#exact -1#33#31#exact -1#34#32#exact -1#35#33#exact -1#36#34#exact -1#37#35#exact -1#38#36#exact -1#39#37#exact -1#41#38#exact -1#42#39#exact -1#43#40#exact -1#44#41#exact -1#45#42#exact -1#46#43#exact -1#47#44#exact -1#48#45#exact -1#49#46#exact -1#50#47#exact -1#51#49#exact -1#52#50#exact -1#53#51#exact -1#54#52#exact -1#55#53#exact -1#56#54#exact -1#57#55#exact -1#58#56#exact -1#59#57#exact -1#60#58#exact -1#61#59#exact -1#62#60#exact -1#63#61#exact -1#64#62#exact -1#65#63#exact -1#66#64#exact -1#67#65#exact -1#68#66#exact -1#69#67#exact -1#70#68#exact -1#71#69,70#para -1#72#71#exact -1#73#72#exact -1#74#73#exact -1#75#74#exact -1#76#75#exact -1#77#76#exact -1#78#77#exact -1#79#78#exact -1#80#79#exact -1#40#80#exact 


The former type could be solved by increasing the training data , whereas the latter error type cannot easily be solved with a model based on a word N-gram that cannot detect the existence of long phrases .
The former type of errors might be solved by increasing the training data , while the latter type of errors would not be easily solved with the model based on word N-gram which cannot detect the existence of long phrases .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#5,6#3,4#para -1#7#5#exact -1#8#6#exact -1#9#7#exact -1#10#8#exact -1#11#9#exact -1#12#10#exact -1#13#11#exact -1#15#13#exact -1#16#14#exact -1#3,4#15#para -1#17#16#exact -1#33#17#exact -1#23#18#exact -1#22#19#exact -1#24#20#exact -1#25#21#exact -1#26,27#22,23#para -1#28#24#exact -1#29#25#exact -1#30#27#exact -1#31#28#exact -1#21#30#para -1#34#31#exact -1#35#32#exact -1#36#33#exact -1#37#34#exact -1#38#35#exact -1#39#36#exact -1#40#37#exact 


We also analyzed the errors in Brown questions and QuestionBank , and again found that many errors were due to the fact that the WSJ tagger was trained on a corpus consisting mainly of declarative sentences .
We also analyzed the errors in Brown questions and QuestionBank , and again found that the WSJ tagger seems to make many errors due to the fact that the tagger was trained on a corpus mainly consisting of declarative sentences .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#21#15#exact -1#22#16#exact -1#23,24,25,26,27#17,18,19,20,21,22#para -1#28#23#exact -1#16#24#exact -1#17#25#exact -1#30#26#exact -1#31#27#exact -1#32#28#exact -1#33#29#exact -1#34#30#exact -1#36#31#exact -1#35#32#exact -1#37#33#exact -1#38#34#exact -1#39#35#exact -1#40#36#exact 


After the adaptation , although some of the errors such as the special use of wh-words , i.e. , " WDT \SPEC WP " , were corrected , other kinds or errors related to the global change in sentence structure still remained .
After the adaptation , while some of the errors such as special usage of wh-words , i.e. , " WDT \SPEC WP " , were corrected , we found that some kinds or errors related to the global change of sentence structures still remained .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#36#11#exact -1#11#12#exact -1#12,13#13,14#para -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#38,39#28#para -1#31#29#exact -1#32#30#exact -1#33#31#exact -1#34#32#exact -1#35#33#exact -1#37#34,35#para -1#40#38#exact -1#41#39#stem -1#42#40#exact -1#43#41#exact -1#44#42#exact 


To tag words correctly both in imperatives and questions , we may have to consider richer information than only N-gram based features , such as long distance dependencies or phrases .
In order to give correct tags to words both in imperatives and questions , we might have to consider richer information than only N-gram based features , such as long distance dependencies or phrases .
-1#2#0#lc -1#7#2#exact -1#8#4#exact -1#9#5#exact -1#10#6#exact -1#11#7#exact -1#12#8#exact -1#13#9#exact -1#14#10#exact -1#15,16#11,12#para -1#17#13#exact -1#18#14#exact -1#19#15#exact -1#20#16#exact -1#21#17#exact -1#22#18#exact -1#23#19#exact -1#24#20#exact -1#25#21#exact -1#26#22#exact -1#27#23#exact -1#28#24#exact -1#29#25#exact -1#30#26#exact -1#31#27#exact -1#32#28#exact -1#33#29#exact -1#34#30#exact 


Table \REF gives the parsing accuracy of MST ( first order ) , MST ( second order ) , Malt , and the Enju parser for WSJ , Brown overall , Brown imperatives , and Brown questions .
Table \REF shows the parsing accuracies of MST( first order ) , MST( second order ) , Malt , and Enju parser for WSJ , Brown overall , Brown imperatives and Brown questions .
-1#0#0#exact -1#1#1#exact -1#3#3#exact -1#4#4#exact -1#5#5#stem -1#6#6#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#13#15#exact -1#14#16#exact -1#15#17#exact -1#16#18#exact -1#17#19#exact -1#18#20#exact -1#19#21#exact -1#20#23#exact -1#21#24#exact -1#22#25#exact -1#23#26#exact -1#24#27#exact -1#25#28#exact -1#26#29#exact -1#27#30#exact -1#28#31#exact -1#29#32#exact -1#30#34#exact -1#31#35#exact -1#32#36#exact -1#33#37#exact 


Figure \REF plots the parsing accuracy against the training data size of the four parsers for WSJ , Brown imperatives , Brown questions , and QuestionBank .
Figure \REF shows the parsing accuracies against the training data size of the four parsers for WSJ , Brown imperatives , Brown questions , and QuestionBank .
-1#0#0#exact -1#1#1#exact -1#3#3#exact -1#4#4#exact -1#5#5#stem -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact 


Note that , since the training of the MST parser ( second order ) on Brown overall , Brown questions , and QuestionBank could not be completed in our experimental environment , the corresponding parsing accuracies denoted by bracketed hyphens in Table \REF could not be measured , Consequently , we could not plot complete graphs of second order MST for Brown questions and QuestionBank in Figure \REF .
Note that , since training MST parser ( second order ) on Brown overall , Brown questions , and QuestionBank could not be completed in our experimental environments , the parsing accuracies represented by the bracketed hyphens in Table \REF could not be measured and we could not draw full graphs of second order MST for Brown questions and QuestionBank in Figure \REF .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#29#4#exact -1#4#5#exact -1#51#6#exact -1#34#7#exact -1#5#8#exact -1#6#9#exact -1#7#10#exact -1#8#11#exact -1#9#12#exact -1#10#13#exact -1#11#14#exact -1#12#15#exact -1#13#16#exact -1#14#17#exact -1#15#18#exact -1#16#19#exact -1#17#20#exact -1#18#21#exact -1#19#22#exact -1#20#23#exact -1#21#24#exact -1#22#25#exact -1#23#26#exact -1#24#27#exact -1#25#28#exact -1#26#29#exact -1#27#30#stem -1#28#31#exact -1#30#34#exact -1#31#35#exact -1#33#37#exact -1#35#38#exact -1#36#39#exact -1#37#40#exact -1#38#41#exact -1#39#42#exact -1#40#43#exact -1#41#44#exact -1#42#45#exact -1#43#46#exact -1#45#50#exact -1#46#51#exact -1#47#52#exact -1#49#54#para -1#50#55#exact -1#52#57#exact -1#53#58#exact -1#54#59#exact -1#55#60#exact -1#56#61#exact -1#57#62#exact -1#58#63#exact -1#59#64#exact -1#60#65#exact -1#61#66#exact -1#62#67#exact -1#63#68#exact 


After adaptation ( see " Adapted " column in Table \REF ) , the parser achieved two to four percent higher accuracy for each of the Brown domains compared to the WSJ parser .
When we adapted the parser model ( see fifth column in Table \REF ) , the parser could give two to four points higher accuracies for each of the Brown domains than the WSJ parser .
-1#6#2#exact -1#7#3#exact -1#2#5#lc -1#9#7#exact -1#10#8#exact -1#11#9#exact -1#12#10#exact -1#13#11#exact -1#14#12#exact -1#15#13#exact -1#16#14#exact -1#19#16#exact -1#20#17#exact -1#21#18#exact -1#23#20#exact -1#24#21#stem -1#25,26,27,28#22,23,24#para -1#3#25#exact -1#29#26#exact -1#30#27#exact -1#32#30#exact -1#33#31#exact -1#34#32#exact -1#35#33#exact 


For QuestionBank , 25 to 35 percent improvement in accuracy was observed .
For the QuestionBank , 25 to 35 points accuracy improvements were observed .
-1#0#0#exact -1#2#1#exact -1#3#2#exact -1#4#3#exact -1#5#4#exact -1#6#5#exact -1#9#7#stem -1#8#9#exact -1#10,11#10,11#para -1#12#12#exact 


Figure \REF shows that the improvement is proportional to the size of the training data and that this tendency does not seem to converge .
Figure \REF shows that , the improvements increased according to the size of the training data , and the tendencies would not seem to converge .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#5#4#exact -1#6#5#stem -1#9,10,11,12,13#8,9,10,11#para -1#18#12#exact -1#14#13#exact -1#15#14#exact -1#17#15#exact -1#19#18#stem -1#21,22,23#19,20,21,22#para -1#24#23#exact -1#25#24#exact 


This would suggest that lower accuracy than that of the WSJ parser for the WSJ could still be as a result of a lack of training data .
This would suggest that lower accuracies than the WSJ parser for WSJ would be still brought by the lack of training data .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#stem -1#6#6#exact -1#19#8#exact -1#7#9#exact -1#8#10#exact -1#9#11#exact -1#10#12#exact -1#17#13#exact -1#11#14#exact -1#12#15#para -1#14#16#exact -1#13#17#exact -1#18#21,22,23#para -1#20#24,25#para -1#21#26#exact -1#22#27#exact 


In Figure \REF , the parser accuracy for QuestionBank , for which we could use much more training data than for Brown questions , approaches or even exceeds that of the WSJ parser for WSJ .
In Figure \REF , when we focus on the QuestionBank where we could use much more training data than Brown questions , the parser accuracies were approaching the accuracies of WSJ parser for WSJ or exceeded the accuracy .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#22#4#exact -1#23#5#exact -1#37#6#exact -1#32#7#exact -1#9#8#exact -1#21#9#exact -1#10,11#10,11,12#para -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#21#exact -1#20#22#exact -1#34#24,25#para -1#35#27#stem -1#29#29#exact -1#8#30#exact -1#30#31#exact -1#31#32#exact -1#33#34#exact -1#38#35#exact 


However , as there is no more training data for Brown imperatives and questions , we need to either prepare more training data or explore approaches that enable the parsers to be adapted with small amounts of training data .
However , we have no more training data for Brown imperatives and questions . We should prepare more training data or explore approaches to enable us to sufficiently adapt parsers with small training data .
-1#0#0#exact -1#1#1#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#2#15#exact -1#15#16,17#para -1#16#19#exact -1#17#20#exact -1#18#21#exact -1#19#22#exact -1#20#23#exact -1#21#24#exact -1#22#25#exact -1#23,24#26,27#para -1#29#29#exact -1#26#30#exact -1#28#31,32#para -1#30#33#exact -1#31#34#exact -1#32#36,37#para -1#33#38#exact -1#34#39#exact 


To capture an overview of the adaptation effects , we observed the error reduction in the Malt parser .
In order to capture the outline of the adaptation effects , we observed error reduction for the Malt parser .
-1#2#0#lc -1#3#1#exact -1#6#4#exact -1#7#5#exact -1#8#6#exact -1#9#7#exact -1#10#8#exact -1#11#9#exact -1#12#10#exact -1#4#11#exact -1#13#12#exact -1#14#13#exact -1#0#14#lc -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact 


Tables \REF and \REF give the recall errors on labeled dependencies , which were observed more than ten times for 100 analysis sentences in each domain .
Table \REF and \REF show the recall errors on labeled dependencies which were observed more than ten times for 100 analysis sentences of each domain .
-1#0#0#stem -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22,23#23,24#para -1#24#25#exact -1#25#26#exact 


For each dependency shown in the first column , the second and third columns show the number of parsing errors by the WSJ parser with gold tags and the adapted parser with gold tags , respectively .
For each dependency shown in the first column , the second and third columns show the number of parsing errors by the WSJ parser with gold tags and the adapted parser with gold tags .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#36#exact 


Since ROOT dependencies , that is , heads of sentences , are critical to the construction of sentences , we focus mainly on this type of error .
Since ROOT dependencies , that is , heads of sentences would be critical to construction of sentences , we mainly focus on that type of errors .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#17#10#exact -1#10,11#11#para -1#12#12#exact -1#13#13#exact -1#14,15#14,15,16#para -1#16#17#exact -1#18#19#exact -1#20#20#exact -1#19#21#exact -1#21#22#exact -1#22,23#23,24#para -1#24#25#exact -1#25#26#stem -1#26#27#exact 


For Brown imperatives and questions , the reduction in ROOT dependencies was prominent .
For Brown imperatives and questions , we could observe that the reduction of ROOT dependency was prominent .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#10#6#exact -1#11#7#exact -1#13#9#exact -1#14#10#stem -1#15#11#exact -1#16#12#exact -1#17#13#exact 


On investigation , we found that the WSJ parser often made mistakes in parsing sentences which began or ended with the name of the person being addressed .
When we focus on this type of errors , we could find that the WSJ parser could often make mistakes in parsing sentences which began or ended with the names of persons who were talk to .
-1#3#0#lc -1#8#2#exact -1#9#3#exact -1#11#4#syn -1#12#5#exact -1#13#6#exact -1#14#7#exact -1#15#8#exact -1#17#9#exact -1#18,19#10,11#para -1#20#12#exact -1#21#13#exact -1#22#14#exact -1#23#15#exact -1#24#16#exact -1#25#17#exact -1#26#18#exact -1#27#19#exact -1#28#20#exact -1#29,30#21,22#para -1#31#23,24#para -1#36#27#exact 


For example , in Brown imperatives , for the sentence " See for yourself , Miss Zion . " , the WSJ parser mistook the name " Zion " to be ROOT , and the main verb " See " to be a modifier of the name .
For example in Brown imperatives , for the sentence " See for yourself , Miss Zion . " , the WSJ parser regarded the person name " Zion " as ROOT , and the main verb " See " as modifiers of the name .
-1#0#0#exact -1#1#1#exact -1#13#2#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#18#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#31#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#23#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#30#31#exact -1#32#33#exact -1#33#34#exact -1#34#35#exact -1#35#36#exact -1#36#37#exact -1#37#38#exact -1#38#39#exact -1#40#43#stem -1#41#44#exact -1#42#45#exact -1#43#46#exact -1#44#47#exact 


The adapted parser correctly assigned ROOT to the main verb .
The adapted parser could then correctly give ROOT to the main verb .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#5#3#exact -1#7#5#exact -1#8#6#exact -1#9#7#exact -1#10#8#exact -1#11#9#exact -1#12#10#exact 


We also found that the WSJ parser often made mistakes in parsing sentences containing quotation , exclamation , or question marks , such as " " Hang on " !! " " or " Why did you kill it " ? ? " or " " " " .
We could also often find that the WSJ parser could often make mistakes in parsing sentences containing quotation , exclamation , and question marks , such as " " Hang on " !! " " or " Why did you kill it " ? ? " or " " " " .
-1#0#0#exact -1#2#1#exact -1#4#2#syn -1#5#3#exact -1#6#4#exact -1#7#5#exact -1#8#6#exact -1#10#7#exact -1#11,12#8,9#para -1#13#10#exact -1#14#11#exact -1#15#12#exact -1#16#13#exact -1#17#14#exact -1#18#15#exact -1#19#16#exact -1#20#17#exact -1#35#18#exact -1#22#19#exact -1#23#20#exact -1#24#21#exact -1#25#22#exact -1#26#23#exact -1#27#24#exact -1#28#25#exact -1#29#26#exact -1#30#27#exact -1#31#28#exact -1#32#29#exact -1#33#30#exact -1#34#31#exact -1#46#32#exact -1#47#33#exact -1#37#34#exact -1#38#35#exact -1#39#36#exact -1#40#37#exact -1#41#38#exact -1#42#39#exact -1#43#40#exact -1#44#41#exact -1#45#42#exact -1#36#44#exact -1#48#45#exact -1#49#46#exact -1#50#47#exact -1#51#48#exact 


For such sentences , the WSJ parser regarded the first " ! " or " ? " as ROOT , and " Hang " or " did " as the modifier of the punctuation .
For such sentences , the WSJ parser regarded the first " ! " or " ? " as ROOT , and " Hang " or " did " as the modifier of the marks .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#34#34#exact 


A possible reason for this type of error could be that the Brown corpus places exclamation or question marks outside , instead of inside the quotation .
We thought that this kind of errors would partly come fromthe Brown corpus itself . The exclamation or question marks should be inside the quotation , while the Brown corpus usually put the marks outside .
-1#3#4#exact -1#4#5#para -1#5#6#exact -1#6#7#stem -1#7#8#para -1#21#9#exact -1#2#10#exact -1#23#11#exact -1#11#12#exact -1#12#13#exact -1#31#14#syn -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#34#19#exact -1#25#20#exact -1#22#23#exact -1#27#24#exact -1#24#25#exact -1#14#26#exact 


The adapted parser could handle this dubious construction and assigned ROOT to the main verbs as the corpus required .
However , the adapted parser could take in such doubtful construction and gave ROOT to the main verbs as the corpus required .
-1#2#0#lc -1#3#1#exact -1#4#2#exact -1#5#3#exact -1#9#6#syn -1#10#7#exact -1#11#8#exact -1#13#10#exact -1#14#11#exact -1#15#12#exact -1#16#13#exact -1#17#14#exact -1#18#15#exact -1#19#16#exact -1#20#17#exact -1#21#18#exact -1#22#19#exact 


On the other hand , we also observed some unsolved errors , of which we discuss two .
On the other hand , we also observed some still unsolved errors . We would show the two kinds of major errors among them .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#10#9#exact -1#11#10#exact -1#19#12#exact -1#22,23#13#para -1#13#14#lc -1#17#16#exact -1#12#17#exact 


First , Brown imperatives and questions , include many colloquial sentences , which have rather flexible constructions , especially imperatives , such as " Lift , don't shove lift! " , " Come out , come out in the meadow! " , etc.
First , Brown imperatives and questions , include many conversation sentences , and therefore rather flexible constructions could be observed especially for imperatives , such as " Lift , don't shove lift! " , " Come out , come out in the meadow! " , etc.
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#10#10#exact -1#11#11#exact -1#14#13,14#para -1#15#15#exact -1#16#16#exact -1#23#17#exact -1#20#18#exact -1#22#19#exact -1#28#20#exact -1#24#21#exact -1#25#22#exact -1#26#23#exact -1#27#24#exact -1#33#25#exact -1#29#26#exact -1#30#27#exact -1#31#28#exact -1#32#29#exact -1#37#30#exact -1#34#31#exact -1#35#32#exact -1#36#33#exact -1#44#34#exact -1#38#35#exact -1#39#36#exact -1#40#37#exact -1#41#38#exact -1#42#39#exact -1#43#40#exact -1#45#42#exact 


The parsing models based on the plausibility of constructions were not able to capture such sentences .
The parsing models based on the plausibility of constructions could hardly capture such sentences .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#11#13#exact -1#12#14#exact -1#13#15#exact -1#14#16#exact 


Second , having different sentence constructions within a single sentence , such as , where a to-infinitive phrase or subordinate clause precedes an imperative or question , often confused the parser .
Second , when the different constructions of sentences were in one sentence , such as , the case where to-infinitive phrases or subordinate clauses precede imperatives and questions , the parser would often be confused .
-1#0#0#exact -1#1#1#exact -1#4#3#exact -1#11#4#exact -1#5#5#exact -1#10#8#syn -1#7#9#stem -1#12#10#exact -1#13#11#exact -1#14#12#exact -1#15#13#exact -1#18#14#exact -1#19#16#exact -1#20#17#stem -1#21#18#exact -1#22#19#exact -1#23#20#stem -1#24#21#stem -1#25#23#stem -1#27#25#stem -1#28#26#exact -1#32#27#exact -1#34#28#exact -1#3#29#exact -1#30#30#exact -1#35#31#exact 


For example , for the imperative sentence , " To find the estimated net farm income , subtract the estimated annual farming expenditure . . . " , both the WSJ and adapted parsers regarded " find " as ROOT , because the parsers regarded the words following " find " as a that-clause complementing " find " , as in " To find [ ( that ) the estimated net farm income , subtract the estimated annual farming . . .] " .
For example , for the imperative sentence " To find estimated net farm income , subtract estimated annual farming expenditures . . . " , both of the WSJ and adapted parsers regarded " find " as ROOT , because the parsers regarded the words following " find " as a that-clause complement for the " find " , like " To find [ ( that ) estimated net farm income , subtract estimated annual farming . . .] " .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#14#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#27#11#exact -1#67#12#exact -1#68#13#exact -1#69#14#exact -1#70#15#exact -1#71#16#exact -1#72#17#exact -1#40#18#exact -1#16#19#exact -1#17#20#exact -1#18#21#exact -1#19#22#stem -1#20#23#exact -1#21#24#exact -1#22#25#exact -1#23#26#exact -1#24#27#exact -1#25#28#exact -1#43#29#exact -1#28#30#exact -1#29#31#exact -1#30#32#exact -1#31#33#exact -1#32#34#exact -1#33#35#exact -1#34#36#exact -1#35#37#exact -1#36#38#exact -1#37#39#exact -1#38#40#exact -1#39#41#exact -1#54#42#exact -1#41#43#exact -1#42#44#exact -1#44#45,46#para -1#45#47#exact -1#46#48#exact -1#47#49#exact -1#48#50#exact -1#49#51#exact -1#50#52#exact -1#51#53#exact -1#52#54#stem -1#55#55#exact -1#56#56#exact -1#57#57#exact -1#58#58#exact -1#60#61#exact -1#61#62#exact -1#62#63#exact -1#63#64#exact -1#64#65#exact -1#65#66#exact -1#66#67#exact -1#10#68,69#para -1#11#70#exact -1#12#71#exact -1#13#72#exact -1#15#74#exact -1#73#75,76#para -1#74#77#exact -1#75#78#exact -1#76#79#exact -1#77#80#exact -1#78#81#exact -1#79#82#exact -1#80#83#exact 


It would be difficult for the parsers to know which is the main clause in such complex sentences .
It would be difficult for the parsers to know where the main clause in such complex sentences .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#para -1#10,11#10,11,12#para -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact 


This type of error cannot be solved merely by increasing the training data .
This type of errors would hardly be solved only by increasing the training data .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#stem -1#6#5#exact -1#7#6#exact -1#8,9#7,8#para -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact 


Imperative or question sentences typically consist not only of a pure imperative or question clause , but also of other constructions of phrases or clauses .
Imperatives or questions sentences consist not only of pure imperative or question clause , but also of other constructions of phrases or clauses .
-1#9#0#lc -1#10#1#exact -1#11#2#exact -1#3#3#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9,10#para -1#0#11#stem -1#1#12#exact -1#2#13#stem -1#12#14#exact -1#13#15#exact -1#14#16#exact -1#15#17#exact -1#16#18#exact -1#17#19#exact -1#18#20#exact -1#19#21#exact -1#20#22#exact -1#21#23#exact -1#22#24#exact -1#23#25#exact 


These complex sentences were parsed without being partitioned into separate constructions , and as a result the parser sometimes became confused .
The parser would parse such complex sentences without partition into each construction , and therefore it would sometimes be confused .
-1#4,5#0,1#para -1#6#2#exact -1#7#5#exact -1#18#6#stem -1#8#7#stem -1#9#8#exact -1#11#10#stem -1#12#11#exact -1#13#12#exact -1#0#16#lc -1#1#17#exact -1#17#18#exact -1#19#20#exact -1#20#21#exact 


Both the Brown questions and QuestionBank are in the question domain .
Both of Brown questions and QuestionBank are in the domain of question .
-1#0#0#exact -1#8#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#11#8,9#para -1#9#10#exact -1#12#11#exact 


In this section , we examine whether a parser adapted to one domain could be ported to another domain .
In this section , we examined whether the parser adapted to one domain would be portable to the other domain .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#stem -1#6#6#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#para -1#14#14#exact -1#16#16#exact -1#19#18#exact -1#20#19#exact 


QuestionBank does not provide function tags , and therefore in training and evaluation of the parsers , abstracted dependencies were extracted from the corpus .
QuestionBankdoes not give function tags , and therefore in training and evaluation of the parsers , abstracted dependencies were extracted from the corpus .
-1#1#2#exact -1#2#3#para -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact 


As a result , a parser adapted to one domain could not provide correct dependency labels on functions for the other domain .
Therefore , the parser adapted to one domain could not give correct dependency labels on such functions for the other domain .
-1#1#3#exact -1#3#5#exact -1#4#6#exact -1#5#7#exact -1#6#8#exact -1#7#9#exact -1#8#10#exact -1#9#11#exact -1#10#12#para -1#11#13#exact -1#12#14#exact -1#13#15#exact -1#14#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact 


0
However , we would be able to expect that sentence constructions would be basically common and portable between two domains , which would contribute to give correct boundary for phrases and therefore the correct dependencies in phrases would be introduced by the adaptation .



While word segmentation is necessary for processing the Chinese and Japanese languages , its effects on Statistical Machine Translation ( SMT ) have not yet been thoroughly discussed for such languages .
While word segmentation is a necessary step to process languages like Chinese and Japanese , its effects on Statistical Machine Translation ( SMT ) have not been discussed intensively in such languages .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#5#4#exact -1#8#6,7#para -1#11#8#exact -1#12#9#exact -1#13#10#exact -1#9#11#exact -1#14#12#exact -1#15#13#exact -1#16#14#exact -1#17#15#exact -1#18#16#exact -1#19#17#exact -1#20#18#exact -1#21#19#exact -1#22#20#exact -1#23#21#exact -1#24,25,26#22,23,24,25#para -1#27#27#exact -1#30#29#exact -1#31#30#exact -1#32#31#exact 


In this paper , we investigate the effects of word segmentation methods on SMT , by comparing the evaluation results of the translation outputs , while varying word segmentation methods .
In this paper , we investigate the effects of word segmentation methods on SMT , by comparing evaluation results of translation outputs while varying word segmentation methods .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17,18#para -1#18#19#exact -1#19#20#exact -1#20#21,22#para -1#21#23#exact -1#22#25#exact -1#23#26#exact -1#24#27#exact -1#25#28#exact -1#26#29#exact -1#27#30#exact 


Additionally , meta-evaluations of evaluation metrics are also provided to investigate the validity of the metrics .
Additionally , meta-evaluations of evaluation metrics are also provided to investigate validity of the metrics .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11,12,13#11,12,13,14#para -1#14#15#exact -1#15#16#exact 


The experimental results confirmed that supervised morphological analyzers were competitive with , and performed considerably better than an unsupervised analyzer and a heuristic segmentation method .
The experiments revealed that supervised morphological analyzers were competitive , and considerably better than an unsupervised analyzer and a heuristic segmentation method .
-1#0#0#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#11#exact -1#10#12#exact -1#11#14#exact -1#12#15#exact -1#13#16#exact -1#14#17#exact -1#15#18#exact -1#16#19#exact -1#17#20#exact -1#18#21#exact -1#19#22#exact -1#20#23#exact -1#21#24#exact -1#22#25#exact 


However , a character-based segmentation achieved 10 .27 positive and 1 .95 negative differences in word-based and character-based BLEU , depending on the corpus sizes and domains .
However , a character-based segmentation has achieved 10 .27 positive and 1 .95 negative differences in word-based and character-based BLEU , depending on corpus sizes and domains .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact 


In conclusion , we discuss the problem of the comparability of evaluation metrics , and consider ways of improving word segmentation more than popular supervised morphological analyzers .
For this result we discuss the problem of the comparability of evaluation metrics and the possibility of better word segmentation than popular supervised morphological analyzers .
-1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#14#exact -1#16#17#exact -1#17#18#syn -1#18#19#exact -1#19#20#exact -1#20#22#exact -1#21#23#exact -1#22#24#exact -1#23#25#exact -1#24#26#exact -1#25#27#exact 


Several languages , including Chinese and Japanese , do not require spaces between words , in their written forms .
Several natural languages like Chinese and Japanese do not have to put spaces between words in their written forms .
-1#0#0#exact -1#2#1#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#8#exact -1#8#9#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact 


In order to process such languages , we need to tokenize each sentence .
In order to process such languages , we need to tokenize each sentence .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact 


This process is called word segmentation .
This process is called word segmentation .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact 


Since word segmentation is a fundamental process , and is therefore indispensable , it is important that we explore how word segmentation affects Natural Language Processing applications .
Since the process is fundamental and indispensable , we need to explore how word segmentation affects Natural Language Processing applications .
-1#0#0#exact -1#13#1#exact -1#14#2#exact -1#3#3#exact -1#4#5#exact -1#2#6#exact -1#7#7#exact -1#5#8#exact -1#15#9#para -1#6#11#exact -1#9#14,15#para -1#8#17#exact -1#11#18#exact -1#12#19#exact -1#16#23#exact -1#17#24#exact -1#18#25#exact -1#19#26#exact -1#20#27#exact 


Thus , we investigate how Japanese word segmentation affects SMT between English and Japanese , by comparing various word segmentation methods and evaluation metrics .
Therefore , we investigate how Japanese word segmentation affects on SMT between English and Japanese , by comparing various word segmentation methods and evaluation metrics .
-1#0#0#syn -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact -1#23#22#exact -1#24#23#exact -1#25#24#exact 


The word segmentation methods include both standard Japanese morphological analyzers and several heuristic methods .
The word segmentation methods includes both standard Japanese morphological analyzers and several heuristic methods .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#stem -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact 


In addition , we examine an unsupervised morphological analyzer , and its results .
We also examine an unsupervised morphological analyzer and its results .
-1#1#0,1#para -1#0#3#lc -1#2#4#exact -1#3#5#exact -1#4#6#exact -1#5#7#exact -1#6#8#exact -1#7#10#exact -1#8#11#exact -1#9#12#exact -1#10#13#exact 


We focus on the meta-evaluation of the current evaluation metrics and determine whether the metrics are consistent or not , when we vary word segmentation methods .
In addition , we focus on the meta-evaluation of the current evaluation metrics and find whether the metrics are consistent or not , when we vary word segmentation methods .
-1#3#0#lc -1#4#1#exact -1#5#2#exact -1#6#3#exact -1#7#4#exact -1#8#5#exact -1#9#6#exact -1#10#7#exact -1#11#8#exact -1#12#9#exact -1#13#10#exact -1#15#11,12#para -1#16#13#exact -1#17#14#exact -1#18#15#exact -1#19#16#exact -1#20#17#exact -1#21#18#exact -1#22#19#exact -1#23#20#exact -1#24#21#exact -1#25#22#exact -1#26#23#exact -1#27#24#exact -1#28#25#exact -1#29#26#exact 


Al-Haj and Lavie ( 2012 ) compared 12 heuristic word segmentation methods based on the outputs of a standard Arabic POS tagger , and found the optimum combination in terms of BLEU on English-Arabic SMT .
Al-Haj and Lavie ( 2012 ) compared 12 heuristic word segmentation methods based on outputs of a standard Arabic POS tagger , and found the optimum combination in terms of BLEU on English-Arabic SMT .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#24#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact -1#28#29#exact -1#29#30#exact -1#30#31#exact -1#31#32#exact -1#32#33#exact -1#33#34#exact -1#34#35#exact 


They acquired a 2 .3 score improvement in comparing the worst to best combinations .
They acquired the 2 .3 score improvement from the worst to the best combinations .
-1#0#0#exact -1#1#1#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#2#9#exact -1#9#10#exact -1#10#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact 


Wang et al.
Wang et al.
-1#0#0#exact -1#1#1#exact -1#2#2#exact 


( 2010 ) suggested a new short unit word segmentation standard in Chinese , which defines a more frequent string subset as a word .
( 2010 ) suggested a new short unit word segmentation standard in Chinese which defines a more frequent string subset as a word .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact 


For instance , one word  globalization was separated into two words  global and  -lization .
For instance , They separated one word "  globalization " into two words "  global " and "  -lization " .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#5#3#exact -1#6#4#exact -1#4#8#exact -1#11#9#exact -1#12#10#exact -1#13#11#exact -1#18#14#exact -1#23#17#exact 


By this standard , they obtained 1 .0 BLEU score improvement within Chinese-Japanese SMT .
By this standard , they obtained 1 .0 BLEU score improvement within Chinese-Japanese SMT .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact 


However , it has not yet been discussed whether BLEU is a good metric for such an evaluation of word segmentation .
Though , they have not discussed about BLEU is a good metric for such an evaluation of word segmentation .
-1#1#1#exact -1#8#2,3#para -1#4#4#exact -1#3#5,6#para -1#5#7#exact -1#7#9#exact -1#9,10#10,11,12#para -1#11#13#exact -1#12#14#exact -1#13#15#exact -1#14#16#exact -1#15#17#exact -1#16#18#exact -1#17#19#exact -1#18#20#exact -1#19#21#exact 


In addition , comparing morphological analyzers is necessary , because different analyzers produce different outputs to SMT .
In addition , comparison of morphological analyzers are necessary because different analyzers produce different outputs to SMT .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3,4#3#para -1#5#4#exact -1#6#5#exact -1#7,8#6,7#para -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact 


We therefore conduct several translation tasks between English and Japanese .
Therefore , we conduct several translation tasks between English and Japanese .
-1#2#0#lc -1#0#1#lc -1#3#2#exact -1#4#3#exact -1#5#4#exact -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact 


We measure the qualities of Japanese morphological analyzers and compare them with other word segmentation methods .
We measure the qualities of Japanese morphological analyzers and compare them with other word segmentation methods .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact 


We also investigate consistencies of evaluation metrics by comparing the results .
We also investigate consistencies of evaluation metrics by comparing results .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9,10#para -1#10#11#exact 


This work aims at empirically comparing representative word segmentation methods in terms of the SMT quality .
This work aims to empirically compare representative word segmentation methods in terms of SMT quality .
-1#0#0#exact -1#1#1#exact -1#2,3#2,3#para -1#4#4#exact -1#5#5#stem -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10,11,12#10,11,12,13#para -1#13#14#exact -1#14#15#exact -1#15#16#exact 


The following experiments are designed in order to answer these questions :
The following experiments are designed in order to answer these questions :
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact 


- How a variety of word segmentation methods ( supervised morphological analysis , unsupervised segmentation , and heuristic methods ) affects the SMT evaluation metrics , depending on the corpus sizes and domains .
- How a variety of word segmentation methods ( supervised morphological analysis , unsupervised segmentation , and heuristic methods ) affect SMT evaluation metrics , depending on corpus sizes and domains .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#stem -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#29#exact -1#28#30#exact -1#29#31#exact -1#30#32#exact -1#31#33#exact 


- Whether or not SMT evaluation metrics provide a consistent measure , while varying word segmentation methods .
- Whether or not SMT evaluation metrics provide a consistent measure while varying word segmentation methods .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact 


We set up word segmentation methods , corpora , and evaluation metrics , as the three parameters for our experiments , in order to observe the effects of Japanese word segmentation on SMT .
We setup word segmentation methods , corpora , and evaluation metrics as three parameters of our experiments to see the effects of Japanese word segmentation on SMT .
-1#0#0#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#13#exact -1#19#14#exact -1#12#15#exact -1#13#16#exact -1#15#18#exact -1#16#19#exact -1#20,21#22,23#para -1#18#24#para -1#14#27#exact -1#22#28#exact -1#23#29#exact -1#24#30#exact -1#25#31#exact -1#26#32#exact -1#27#33#exact 


As shown in Table 1 , the following word segmentation methods output delimiters ( | represents a delimiter ) for a given input character sequence .
As shown in Table 1 , the following word segmentation methods output delimiters ( " | " represents a delimiter ) for a given input character sequence .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#17#15#exact -1#18#16#exact -1#19#17#exact -1#20#18#exact -1#21#19#exact -1#22#20#exact -1#23#21#exact -1#24#22#exact -1#25#23#exact -1#26#24#exact -1#27#25#exact 


The most popular method for Japanese word segmentation is to apply a morphological analyzer to obtain morpheme-based segmentation .
The most popular method for Japanese word segmentation is to apply a morphological analyzer to obtain morpheme-based segmentation .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact 


It is ; however , unclear as to which analyzer works better for the SMT task .
It is , however , not clear which analyzer works better for the SMT task than the other analyzers .
-1#0#0#exact -1#1#1#exact -1#3#3#exact -1#4#4#exact -1#5,6#5#para -1#7#7,8#para -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#19#16#exact 


Therefore , we use four representative morphological analyzers and compare them :
Therefore , we use four representative morphological analyzers and compare them :
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact 


- KyTea predicts word segmentation delimiters by pointwise prediction ( Neubig et al. , 2011 ) , using linear Support Vector Machine or logistic regression .
- KyTea predicts word segmentation delimiters by pointwise prediction ( Neubig et al. , 2011 ) , using linear Support Vector Machine or logistic regression .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact 


- MeCab regards word segmentation as a sequence labeling problem .
- MeCab regards word segmentation as a sequence labeling problem .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact 


It uses Conditional Random Field for learning ( Kudo et al. , 2004 ) .
It uses Conditional Random Field for learning ( Kudo et al. , 2004 ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact 


- JUMAN also regards word segmentation as a sequence labeling problem , but it decides the minimum cost paths without machine learning , from segmentation and association costs in human annotated lexicons and automatically generated Web lexicons .
- JUMAN also regards word segmentation as a sequence labeling , but it decides the minimum cost paths without machine learning , from segmentation and association costs in human annotated lexicons and automatically generated Web lexicons .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact -1#28#29#exact -1#29#30#exact -1#30#31#exact -1#31#32#exact -1#32#33#exact -1#33#34#exact -1#34#35#exact -1#35#36#exact -1#36#37#exact 


The accuracy of supervised morphological analyzers KyTea , MeCab , and JUMAN is reported to be over 98% for news texts .
The accuracy of supervised morphological analyzers KyTea , MeCab , and JUMAN is reported to be over 98\% for news text .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#18#18#exact -1#19#19#exact -1#20#20#stem -1#21#21#exact 


On the other hand , the unsupervised method , latticelm , achieved 66 .6% accuracy ( Mochihashi et al. , 2009 ) for human annotated news texts , while the method does not have any answers for word definitions .
On the other hand , the unsupervised method latticelm achieved 66 .6% accuracy ( Mochihashi et al. , 2009 ) for human annotated news text , while the method does not have any answers of word definitions .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#17#8#exact -1#8#9#exact -1#25#10#exact -1#9#11#exact -1#10#12#exact -1#11#13#exact -1#12#14#exact -1#13#15#exact -1#14#16#exact -1#15#17#exact -1#16#18#exact -1#18#20#exact -1#19#21#exact -1#20#22#exact -1#21#23#exact -1#22#24#exact -1#23#25#exact -1#24#26#stem -1#26#28#exact -1#27#29#exact -1#28#30#exact -1#29,30,31#31,32,33,34#para -1#33#35#exact -1#35#37#exact -1#36#38#exact -1#37#39#exact 


Therefore , it is not possible to compare its result with the supervised results , even though it is fair to compare it from the SMT contribution point-of-view .
Therefore , it is not possible to compare such a result with the supervised results . Even though , it is fair to compare it with SMT contribution point of view .
-1#0#0#exact -1#1#1#exact -1#2,3,4,5,6#2,3,4,5#para -1#22#6#exact -1#23#7#exact -1#24#8#stem -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#18#14#exact -1#16#15#lc -1#17#16#exact -1#20,21#17,18,19,20#para -1#7#21#exact -1#19#22#exact -1#26#25#exact -1#27#26#exact -1#15#28#exact 


Furthermore , their policies concerning word segmentation definitions vary significantly .
Furthermore , their policies about word segmentation definitions are very much different .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#para -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#11#8#para -1#10#9#para -1#12#10#exact 


While MeCab can change its definitions by external lexicons , and JUMAN has its own internal standard , KyTea is based on the short unit standard of the Balanced Corpus of Contemporary Written Japanese , which is considered to have one of the shortest definitions of Japanese words .
While MeCab can change its definitions by external lexicons and JUMAN has its own internal standard , KyTea is based on the short unit standard of Balanced Corpus of Contemporary Written Japanese , which is considered one of the shortest definitions of Japanese words .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#16#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#32#17#exact -1#17#18#exact -1#18,19,20#19,20,21,22#para -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#21#27#exact -1#26#28#exact -1#27#29#exact -1#28#30#exact -1#29#31#exact -1#30#32#exact -1#31#33#exact -1#33,34,35#35,36,37,38#para -1#36#40#exact -1#37#41#exact -1#38#42#exact -1#39#43#exact -1#40#44#exact -1#41#45#exact -1#42#46#exact -1#43#47#exact -1#44#48#exact 


For example , if we are given a string , ( if someone sees ) , MeCab separates it into two words ,  |  and JUMAN retains the same string , but KyTea outputs it as three words ,  |  |  where every character is a word .
For example , if we are given a string " ( if someone see ) " , MeCab separates it into two words "  |  " and JUMAN keep the same string , but KyTea outputs it as three words "  |  |  " where every character is a word .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#16#9#exact -1#11#11#exact -1#12#12#exact -1#13#13#stem -1#34#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact -1#25#24#exact -1#28#26#exact -1#29#27#exact -1#30#28#syn -1#31#29#exact -1#32#30#exact -1#33#31#exact -1#35#33#exact -1#36#34#exact -1#37#35#exact -1#38#36#exact -1#39#37#exact -1#40#38#exact -1#41#39#exact -1#44#42#exact -1#45#43#exact -1#46#44#exact -1#49#46#exact -1#50#47#exact -1#51#48#exact -1#52#49#exact -1#53#50#exact -1#54#51#exact -1#55#52#exact 


For latticelm , since it has no supervised definition of words , it uses the expectation maximized length of words for every word , depending on the training data .
In the case of latticelm , as it has no supervised definition of words , it uses the expectation maximized length of words for every word depending on training data .
-1#23#0#lc -1#4#1#exact -1#5#2#exact -1#7#4#exact -1#8#5#exact -1#9#6#exact -1#10#7#exact -1#11#8#exact -1#12#9#exact -1#13#10#exact -1#14#11#exact -1#15#12#exact -1#16#13#exact -1#17#14#exact -1#18#15#exact -1#19#16#exact -1#20#17#exact -1#21#18#exact -1#22#19#exact -1#24#21#exact -1#25#22#exact -1#26#24#exact -1#27#25#exact -1#1#26#exact -1#28#27#exact -1#29#28#exact -1#30#29#exact 


In our experiments , we further investigate such morphological analysis accuracies and word definition problems .
We also investigate such morphological analysis accuracy and word definition problems in our experiments .
-1#11#0#lc -1#12#1#exact -1#13#2#exact -1#0#4#lc -1#1#5#para -1#2#6#exact -1#3#7#exact -1#4#8#exact -1#5#9#exact -1#6#10#stem -1#7#11#exact -1#8#12#exact -1#9#13#exact -1#10#14#exact -1#14#15#exact 


Chang et al.
Chang et al.
-1#0#0#exact -1#1#1#exact -1#2#2#exact 


( 2008 ) suggested that word segmentation consistency and granularity can be important factors for SMT .
( 2008 ) suggested that word segmentation consistency and granularity can be important factors for SMT .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact 


Therefore , we introduce two heuristic methods for Japanese word segmentation .
Therefore , we introduce two heuristic methods for Japanese word segmentation .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact 


One method is segmentation by character category ( CAT ) , and the other is segmentation by characters ( CHAR ) .
One is segmentation by character category ( CAT ) , and the other is segmentation by characters ( CHAR ) .
-1#0#0#exact -1#1#2#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact 


CAT places a word boundary when character categories change .
CAT puts a word boundary when character categories change .
-1#0#0#exact -1#1#1#syn -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact 


Character categories in Japanese include : Kanji ( Chinese character ) , Hiragana , Katakana , Latin alphabet , numeral digit , multi-byte alphabet , multi-byte digit , and other tokens .
Character categories in Japanese include : Kanji ( Chinese character ) , Hiragana , Katakana , Latin alphabet , numeral digit , multi-byte alphabet , multi-byte digit , and other tokens .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact 


The CHAR method considers every Unicode character as a word , as proposed by Xu et al.
The CHAR method considers every Unicode character as a word as proposed by Xu et al.
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact 


( 2004 ) .
( 2004 ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact 


We use two news corpora : Reuters corpora ( REUTERS ) and Japanese-English News Article Alignment Data ( JENAAD ) ( Utiyama and Isahara , 2003 ) .
We use two news corpora : Reuters corpora ( REUTERS ) and Japanese-English News Article Alignment Data ( JENAAD ) ( Utiyama and Isahara , 2003 ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact 


Another corpus we use in the experiments is a Wikipedia corpus : the Japanese-English Bilingual Corpus of Wikipedia 's Kyoto Articles 2 .01 ( WIKIPEDIA ) .
Another corpus we use in the experiments is a Wikipedia corpus , Japanese-English Bilingual Corpus of Wikipedia 's Kyoto Articles 2 .01 ( WIKIPEDIA ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact 


From these corpora , we prepared three data sets , as explained below .
From these corpora , we prepared three data sets as explained below .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact 


For REUTERS , we used all 56 ,282 sentences .
In the case of REUTERS , we have used all 56 ,282 sentences .
-1#4#1#exact -1#5#2#exact -1#6#3#exact -1#8#4#exact -1#9#5#exact -1#10#6#exact -1#11#7#exact -1#12#8#exact -1#13#9#exact 


Then , we split the data into three parts : the first 1 ,000 as the test , the next 500 as the development , and the remaining 55 ,282 as the training data .
Then , we split the data into three parts : the first 1 ,000 as the test , the next 500 as the development , and the rest 55 ,282 as the training data .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#syn -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact 


For this data , we combined the JENAAD and REUTERS news corpora to acquire one news corpus .
In this data , we have combined JENAAD and REUTERS news corpora to get one news corpus .
-1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#6#5#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#syn -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact 


We used all 56 ,282 and 150 ,000 sentences , respectively .
We have used all 56 ,282 and 150 ,000 sentences respectively .
-1#0#0#exact -1#2#1#exact -1#3#2#exact -1#4#3#exact -1#5#4#exact -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#10#exact -1#11#11#exact 


For each corpus , we divided the sentences into the first 1 ,000 for testing , the next 500 for development , and the remaining for training .
For each corpus , we divide it into the first 1 ,000 , the next 500 , and the rest for test , development , and training .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#stem -1#8#6#exact -1#7#8#exact -1#13#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#20#13#exact -1#21#14#stem -1#22#15#exact -1#18#16#exact -1#14#17#exact -1#15#18#exact -1#23#19,20#para -1#24#21#exact -1#25#22#exact -1#19#24#syn -1#26#26#exact -1#27#27#exact 


In total , we gathered 2000 , 1000 , and 203 ,782 sentences for test , development , and training , respectively .
We have gathered 2000 , 1000 , and 203 ,782 sentences for test , development , and training , respectively , in total .
-1#21#0#lc -1#22#1#exact -1#13#2#exact -1#0#3#lc -1#2#4#exact -1#3#5#exact -1#4#6#exact -1#5#7#exact -1#6#8#exact -1#7#9#exact -1#8#10#exact -1#9#11#exact -1#10#12#exact -1#11#13#exact -1#12#14#exact -1#20#15#exact -1#14#16#exact -1#15#17#exact -1#16#18#exact -1#17#19#exact -1#18#20#exact -1#19#21#exact -1#23#22#exact 


Since the WIKIPEDIA corpus is a multi-category XML dataset , we sorted them by the DOCID in ascending order , and by the document categories : LTT , EPR , FML , BDS , CLT , BLD , GNM , SCL , ROD , SNT , PNM , HST , RLW , and SAT .
Firstly , since the WIKIPEDIA corpus is a multi-category XML dataset , we have sorted them by the DOCID in the ascending order and by the document categories LTT , EPR , FML , BDS , CLT , BLD , GNM , SCL , ROD , SNT , PNM , HST , RLW , and SAT .
-1#2#0#lc -1#3#1#exact -1#4#2#exact -1#5#3#exact -1#6#4#exact -1#7#5#exact -1#8#6#exact -1#9#7#exact -1#10#8#exact -1#11#9#exact -1#12#10#exact -1#14#11#exact -1#15#12#exact -1#16#13#exact -1#17#14#exact -1#18#15#exact -1#19#16#exact -1#21#17#exact -1#22#18#exact -1#1#19#exact -1#23#20#exact -1#24#21#exact -1#25#22#exact -1#26#23#exact -1#27#24#exact -1#28#26#exact -1#29#27#exact -1#30#28#exact -1#31#29#exact -1#32#30#exact -1#33#31#exact -1#34#32#exact -1#35#33#exact -1#36#34#exact -1#37#35#exact -1#38#36#exact -1#39#37#exact -1#40#38#exact -1#41#39#exact -1#42#40#exact -1#43#41#exact -1#44#42#exact -1#45#43#exact -1#46#44#exact -1#47#45#exact -1#48#46#exact -1#49#47#exact -1#50#48#exact -1#51#49#exact -1#52#50#exact -1#53#51#exact -1#54#52#exact -1#55#53#exact -1#56#54#exact 


Next , we parsed it by xml .etree .ElementTree .parse of Python 2 .7 .2 , and obtained 477 ,036 sentence pairs without parsing errors .
Secondly , we parsed it by xml .etree .ElementTree .parse of Python 2 .7 .2 , and obtained 477 ,036 sentence pairs without parsing errors .
-1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact 


Then , sentence pairs that include a character | in English or Japanese were removed , because it caused a problem with Moses .
Thirdly , sentence pairs that include a character " | " in English or Japanese are removed because it caused a problem with Moses .
-1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#11#9#exact -1#12#10#exact -1#13#11#exact -1#14#12#exact -1#15#13#syn -1#16#14#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact -1#23#22#exact -1#24#23#exact 


Finally , we obtained 477 ,012 sentence pairs in total .
Finally , we obtained 477 ,012 sentence pairs in total .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact 


In order to adjust the balance of the domains , we sampled the data twice : First , we extracted the first line for every 477 lines .
In order to adjust the balance of the domains , we have sampled the data twice : First we extract the first line for every 477 lines .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4,5,6,7#4,5,6#para -1#13#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#12#11#exact -1#20#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#18#exact -1#19#19#stem -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact 


Then , we merged the remaining 476 ,012 lines , and from this extract , we extracted the first line for every 952 lines .
After this , we have merged the remaining 476 ,012 lines and from this extract the first line for every 952 lines .
-1#2#1#exact -1#3#2#exact -1#5#3#exact -1#6#4#exact -1#7#5#exact -1#8#6#exact -1#9#7#exact -1#10#8#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#17#exact -1#16#18#exact -1#17#19#exact -1#18#20#exact -1#19#21#exact -1#20#22#exact -1#21#23#exact -1#22#24#exact 


Finally , we obtained 1 ,000 test , 500 development , and 475 ,512 training data .
Finally , we have obtained 1 ,000 test , 500 development , and 475 ,512 training data .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#4#3#exact -1#5#4#exact -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact 


We have launched two word-based evaluation methods : BLEU ( Papineni et al. , 2002 ) with 4-gram setting and RIBES ( Isozaki et al. , 2010a ) , which has been reported to have a much higher correlation to human evaluation than BLEU within English-Japanese translation tasks ( Sudoh et al. , 2011 ) .
We have launched two word-based evaluation methods : BLEU ( Papineni et al. , 2002 ) with 4-gram setting and RIBES ( Isozaki et al. , 2010a ) , which has been reported to have a much higher correlation to human evaluation than BLEU within English-Japanese translation tasks ( Sudoh et al. , 2011 ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33,34,35#33,34,35,36#para -1#37#37#exact -1#38#38#exact -1#39#39#exact -1#40#40#exact -1#41#41#exact -1#42#42#exact -1#43#43#exact -1#44#44#exact -1#45#45#exact -1#46#46#exact -1#47#47#exact -1#48#48#exact -1#49#49#exact -1#50#50#exact -1#51#51#exact -1#52#52#exact -1#53#53#exact -1#54#54#exact -1#55#55#exact 


Currently , the most popular way to evaluate SMT is to use word-based evaluation metrics , such as BLEU and RIBES .
Currently , the most popular way to evaluate Statistical Machine Translation is to use word-based evaluation metrics such as BLEU and RIBES .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#11#9#exact -1#12#10#exact -1#13#11#exact -1#14#12#exact -1#15#13#exact -1#16#14#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact 


However , these word-based evaluation metrics have a problem on independency of word segmentation evaluations .
However , these word-based evaluation metrics have a problem on independency of word segmentation evaluations .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact 


If we do not have segmented reference and test data , we cannot evaluate the outputs by word-based evaluation metrics .
If we do not have segmented reference and test data , we cannot evaluate outputs by word-based evaluation metrics .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact 


For example , for English-Japanese translations , we must tokenize reference data to evaluate SMT outputs .
For example , in the case of English-Japanese translations , we must tokenize reference data to evaluate SMT outputs .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#7#4#exact -1#8#5#exact -1#9#6#exact -1#10#7#exact -1#11#8#exact -1#12#9#exact -1#13#10#exact -1#14#11#exact -1#15#12#exact -1#16#13#exact -1#17#14#exact -1#18#15#exact -1#19#16#exact 


On the other hand , for Japanese-English translations , we must tokenize test data to evaluate the outputs .
On the other hand , in the case of Japanese-English translations , we must tokenize test data to evaluate the outputs .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#9#6#exact -1#10#7#exact -1#11#8#exact -1#12#9#exact -1#13#10#exact -1#14#11#exact -1#15#12#exact -1#16#13#exact -1#17#14#exact -1#18#15#exact -1#19#16#exact -1#20#17#exact -1#21#18#exact 


As a result , we need to tokenize every sentence by word segmentation before evaluation , and it is therefore difficult to independently evaluate the effects of word segmentation on training data .
As a result , we need to tokenize every sentence by word segmentation before evaluation , and it is hard to independently evaluate the effects of word segmentation on training data .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19,20#20,21#para -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact -1#28#29#exact -1#29#30#exact -1#30#31#exact -1#31#32#exact 


It is also possible to detokenize SMT outputs first , and then tokenize them by the shared word segmentation .
It is also possible to detokenize SMT outputs first , and then tokenize them by the shared word segmentation .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact 


However , our preliminary experiments indicated that the results obtained with this method were not independent from word segmentation of the training data .
However , our preliminary experiments showed that the results obtained with this method were not independent from word segmentation of training data .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5,6#5,6#para -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20,21#para -1#21#22#exact -1#22#23#exact 


The best results were obtained when we used the same word segmentation as the training data .
And the best results were obtained when we use the same word segmentation as the training data .
-1#1#0#lc -1#2#1#exact -1#3#2#exact -1#4#3#exact -1#5#4#exact -1#6#5#exact -1#7#6#exact -1#8,9#7,8#para -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact 


Hence , if we keep our word-based evaluations , this problem remains .
Hence , this problem remains if we keep our word-based evaluations .
-1#0#0#exact -1#1#1#exact -1#5#2#exact -1#6#3#exact -1#7#4#exact -1#8#5#exact -1#9#6#exact -1#10#7#exact -1#2#9#exact -1#3#10#exact -1#4#11#exact -1#11#12#exact 


In order to manage this issue , we used one character-based metric BLEU in Characters ( De-noual and Lepage , 2005 ) with 4-gram .
In order to manage such a problem , we use one character-based metric BLEU in Characters ( De-noual and Lepage , 2005 ) with 4-gram .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#6#5#para -1#7#6#exact -1#8#7#exact -1#9#8#stem -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact -1#23#22#exact -1#24#23#exact -1#25#24#exact 


As this method evaluates the character-level information , outputs are not required to be segmented , and it is free from word segmentation variations .
As this method evaluates the character-level information , outputs are not required to be segmented and it is free from word segmentation variations .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact 


We have conducted English and Japanese machine translation in both directions , following the steps below :
We have conducted English and Japanese machine translation in both directions by the following steps :
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#13#12#exact -1#12#13#exact -1#14#14#exact -1#15#16#exact 


1 .Apply the Head-Finalization ( Isozaki et al. , 2010b ) to English text in the case of English-Japanese translation .
1Apply the Head-Finalization ( Isozaki et al. , 2010b ) to English text in the case of English-Japanese translation .
-1#1#2#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact 


2 .Run Japanese word segmentation methods and a normalization script , which was introduced by the NTCIR-9 PATMT task .
2Run Japanese word segmentation methods and a normalization script which was introduced by the NTCIR-9 PATMT task .
-1#1#2#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#11#exact -1#10#12#exact -1#11#13#exact -1#12#14#exact -1#13#15#exact -1#14#16#exact -1#15#17#exact -1#16#18#exact -1#17#19#exact 


3 .Tokenize and lowercase English texts by Moses' tokenizer and lowercase scripts .
3Tokenize and lowercase English text by Moses' tokenizer and lowercase scripts .
-1#1#2#exact -1#2#3#exact -1#3#4#exact -1#4#5#stem -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact 


4 .Create language models from target languages' training data , with SRILM 1 .5 .12 .
4Create language models from target languages' training data , with SRILM 1 .5 .12 .
-1#1#2#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact 


5 .Create translation models with Giza++ 1 .0 .5 ( 2011-09-24 ) .
5Create translation models with Giza++ 1 .0 .5 ( 2011-09-24 ) .
-1#1#2#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact 


6 .Decode source test data with Moses ( 2010-08-13 ) .
6Decode source test data with Moses ( 2010-08-13 ) .
-1#1#2#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact 


7 .Compute evaluation scores of the outputs .
7Compute evaluation scores of the outputs .
-1#1#2#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact 


We used Enju 2 .4 .2 ( Miyao and Tsujii , 2005 ) and Head Finalization ( Isozaki et al. , 2010b ) to preprocess English data .
We used Enju 2 .4 .2 ( Miyao and Tsujii , 2005 ) and Head Finalization ( Isozaki et al. , 2010b ) to preprocess English data .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact 


This method enabled more accurate translations within English-Japanese translations than with the conventional settings .
This method enabled more accurate translations within English-Japanese translations than the conventional settings .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact 


We have applied the following Head Finalization rules from ( Su-doh et al. , 2011 ) :
We have applied the following Head Finalization rules from ( Su-doh et al. , 2011 ) :
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact 


- Reverse each phrase 's word orders when the phrase does not end with a head .
- Reverse each phrase 's word orders when the phrase does not end with a head .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact 


- Exclude coordination from reversing
- Exclude coordination from reversing
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact 


- Convert plural nouns to singular forms
- Convert plural nouns to singular forms
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact 


- Remove articles a , an , and the
- Remove articles " a " , " an " , and " the "
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#6#4#exact -1#10#6#exact -1#11#7#exact 


- Insert pseudo-particles _va0 , _va1 , and _va2 .
- Insert pseudo-particles _va0 , _va1 , and _va2 .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact 


For the pseudo-particles , we use the following insertion rules ( arg1 and arg2 are swapped when the head verb 's voice is passive ) :
For the pseudo-particles , we use the following insertion rules ( arg1 and arg2 are swapped when the head verb 's voice is passive ) :
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact 


- Add _va0 after the arg1 entry of the sentence head verb
- Add _va0 after the arg1 entry of the sentence head verb
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact 


- Add _va1 after arg1 entries of other verbs
- Add _va1 after arg1 entries of other verbs
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact 


- Add _va2 after arg2 entries of all verbs
- Add _va2 after arg2 entries of all verbs
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact 


Table 2 and Table 3 show the English-Japanese and Japanese-English evaluation results .
Table 2 and Table 3 show the English-Japanese and Japanese-English evaluation results .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact 


The best scores in each evaluation metrics are highlighted for each data set .
The best scores in each evaluation metrics are highlighted for each data set .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact 


All evaluation metrics have been used in both directions between English and Japanese , to measure the consistency and sufficiency of the metrics in the language pair .
All evaluation metrics have been used in both directions between English and Japanese , to measure consistency and sufficiency of the metrics in the language pair .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3,4,5,6#3,4#para -1#22#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16,17#16,17,18#para -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#24#23,24,25#para -1#25#26#exact -1#26#27#exact 


In this case , the evaluation scores created by BLEU and RIBES are not comparative , due to the differences in the Japanese word definitions among the outputs of word segmentation methods .
In this case , the evaluation scores created by BLEU and RIBES are not comparative due to the differences of Japanese word definitions between the outputs of word segmentation methods .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#24#21#exact -1#20#22#exact -1#21#23#exact -1#22#24#exact -1#23#25,26#para -1#25#27#exact -1#26#28#exact -1#27#29#exact -1#28#30#exact -1#29#31#exact -1#30#32#exact 


Furthermore , the CHAR scores in BLEU and BLEU in Characters should be regarded as almost the same , while small changes have been introduced , due to statistical errors and the differences in the methods in how to treat space characters .
Furthermore , the CHAR scores in BLEU and BLEU in Characters should be regarded as almost same while small changes have been introduced due to statistical errors and the differences in the methods how to treat space characters .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#28#16#exact -1#16#17#exact -1#17#19#exact -1#18#20#exact -1#19#21#exact -1#20#22#exact -1#21#23#exact -1#22#24#exact -1#23#26#exact -1#24#27#exact -1#25#28#exact -1#26#29#exact -1#27#30#exact -1#29,30,31#31,32,33,34#para -1#32#35#exact -1#33,34#36,37,38#para -1#35#39#exact -1#36#40#exact -1#37#41#exact -1#38#42#exact 


We found that the three supervised morphological analyzers : KyTea , MeCab , and JUMAN were much higher than latticelm and CAT , and were competitive .
We found that the three supervised morphological analyzers KyTea , MeCab , and JUMAN were much higher than latticelm and CAT , and were competitive .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact 


For instance , on REUTERS in Table 2 , BLEU scores ranged from 27 .88 to 29 .53 , while for latticelm , the score was 15 .28 and for CAT , the score was 22 .10 .
For instance , on REUTERS in Table 2 , BLEU scores were ranged from 27 .88 to 29 .53 , while latticelm was 15 .28 and CAT was 22 .10 .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#21#exact -1#22#25#exact -1#23#26#exact -1#24#27#exact -1#25#28#exact -1#26#30#exact -1#27#34#exact -1#28#35#exact -1#29#36#exact -1#30#37#exact 


The unsupervised morphological analyzer , latticelm , and one of heuristic methods , CAT , performed worse than expectations .
The unsupervised morphological analyzer latticelm and one of heuristic methods CAT were worse than our expectations .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#5#exact -1#5#7#exact -1#6#8#exact -1#7#9#exact -1#8#10#exact -1#9#11#exact -1#10#13#exact -1#12#16#exact -1#13#17#exact -1#15#18#exact -1#16#19#exact 


These two results were the worst , in all of the settings .
These two were the worst or the second worst results in all settings .
-1#0#0#exact -1#1#1#exact -1#9#2#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#10#7#exact -1#11#8#exact -1#6#10#exact -1#12#11#exact -1#13#12#exact 


The results of CHAR were counterintuitive and are yet to be discussed .
The results of CHAR were counterintuitive and yet to be discussed .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7,8#para -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact 


The results were better than the results for the supervised morphological analyzers in BLEU .
It was relatively much better than the supervised morphological analyzers in BLEU .
-1#6#0#lc -1#4#3#exact -1#5#4#exact -1#7#9#exact -1#8#10#exact -1#9#11#exact -1#10#12#exact -1#11#13#exact -1#12#14#exact 


It was almost competitive in RIBES and BLUE in Characters .
Besides , it was almost competitive in RIBES and BLUE in Characters .
-1#2#0#lc -1#3#1#exact -1#4#2#exact -1#5#3#exact -1#6#4#exact -1#7#5#exact -1#8#6#exact -1#9#7#exact -1#10#8#exact -1#11#9#exact -1#12#10#exact 


CHAR achieved the best score in BLEU on REUTERS ( 38 .42 ) , but the second-best was KyTea ( 29 .53 ) .
For example , CHAR achieved the best 38 .42 score in BLEU on REUTERS , but the second best KyTea was 29 .53 .
-1#3#0#exact -1#4#1#exact -1#5#2#exact -1#6#3#exact -1#9#4#exact -1#10#5#exact -1#11#6#exact -1#12#7#exact -1#13#8#exact -1#7#10#exact -1#8#11#exact -1#2#13#exact -1#15#14#exact -1#16#15#exact -1#20#17#exact -1#19#18#exact -1#21#20#exact -1#22#21#exact -1#23#23#exact 


For BLEU in Characters on REUTERS , CHAR achieved 38 .61 , while the worst supervised result was KyTea 's 39 .82 .
In the case of BLEU in Characters on REUTERS , CHAR achieved 38 .61 , while the worst supervised result was KyTea 's 39 .82 .
-1#4#1#exact -1#5#2#exact -1#6#3#exact -1#7#4#exact -1#8#5#exact -1#9#6#exact -1#10#7#exact -1#11#8#exact -1#12#9#exact -1#13#10#exact -1#14#11#exact -1#15#12#exact -1#16#13#exact -1#17#14#exact -1#18#15#exact -1#19#16#exact -1#20#17#exact -1#21#18#exact -1#22#19#exact -1#23#20#exact -1#24#21#exact -1#25#22#exact 


For Japanese-English translations , the evaluation scores were generally lower than for English-Japanese translations .
In this case , the evaluation scores are lower than English-Japanese translations in general .
-1#11#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#syn -1#12,13#8#para -1#8#9#exact -1#9#10#exact -1#10#12#exact -1#14#14#exact 


This is because Japanese-English translations are conducted without Head-Finalization .
It is because Japanese-English translations are conducted without Head-Finalization .
-1#0,1#0,1#para -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact 


Again , the supervised morphological analyzers KyTea , MeCab , and JUMAN were competitive .
Again , the supervised morphological analyzers KyTea , MeCab , and JUMAN were competitive .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact 


All supervised analyzers performed better than the unsupervised and the both heuristic methods .
All supervised analyzers were better than the unsupervised and the both heuristic methods .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact 


Conversely , the unsupervised morphological analyzer latticelm and one of heuristic methods CAT performed competitively with the supervised analyzers in RIBES .
On the other hand , the unsupervised morphological analyzer latticelm and one of heuristic methods CAT were competitive to the supervised analyzers in RIBES .
-1#0,1,2,3#0#para -1#4#1#exact -1#5#2#exact -1#6#3#exact -1#7#4#exact -1#8#5#exact -1#9#6#exact -1#10#7#exact -1#11#8#exact -1#12#9#exact -1#13#10#exact -1#14#11#exact -1#15#12#exact -1#19#16#exact -1#20#17#exact -1#21#18#exact -1#22#19#exact -1#23#20#exact -1#24#21#exact 


latticelm was 62 .51 and KyTea was 62 .90 on REUTERS .
For example , latticelm was 62 .51 and KyTea was 62 .90 on REUTERS .
-1#3#0#exact -1#4#1#exact -1#5#2#exact -1#6#3#exact -1#7#4#exact -1#8#5#exact -1#9#6#exact -1#10#7#exact -1#11#8#exact -1#12#9#exact -1#13#10#exact -1#14#11#exact 


In this case , CHAR was not competitive to the supervised analyzers in total .
In this case , CHAR was not competitive to the supervised analyzers in total .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact 


The results for CHAR were the lowest scores in BLEU and RIBES on REUTERS and JENAAD+REUTERS , with the exception of the best 56 .55 BLEU in Characters on REUTERS .
The results were the worst scores in BLEU and RIBES on REUTERS and JENAAD+REUTERS . The only one exception was in the case of the best 56 .55 BLEU in Characters on REUTERS .
-1#0#0#exact -1#1#1#exact -1#2#4#exact -1#3#5#exact -1#5#7#exact -1#6#8#exact -1#7#9#exact -1#8#10#exact -1#9#11#exact -1#10#12#exact -1#11#13#exact -1#12#14#exact -1#13#15#exact -1#21#18#exact -1#18#19#exact -1#23#20#exact -1#24#21#exact -1#25#22#exact -1#26#23#exact -1#27#24#exact -1#28#25#exact -1#29#26#exact -1#30#27#exact -1#31#28#exact -1#32#29#exact -1#33#30#exact 


We found that the results of the supervised morphological analyzers were better in both English-Japanese and Japanese-English experiments .
We found the results of the supervised morphological analyzers are better in both English-Japanese and Japanese-English experiments .
-1#0#0#exact -1#1#1#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9,10#10,11#para -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact 


Furthermore , the differences in the word definition of KyTea , MeCab , and JUMAN were not substantial , especially for English-Japanese translations , although the word definition of KyTea is much shorter than for MeCab and JUMAN .
And the differences in the word definition of KyTea , MeCab , and JUMAN were not remarkable , especially in English-Japanese translations , although the word definition of KyTea is much shorter than MeCab and JUMAN .
-1#17#1#exact -1#1#2#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#para -1#22#18#exact -1#18,19#19,20#para -1#20#21#exact -1#21#22#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact -1#28#29#exact -1#29#30#exact -1#30#31#exact -1#31#32#exact -1#32#33#exact -1#33#35#exact -1#34#36#exact -1#35#37#exact -1#36#38#exact 


This result implies that phrase-based SMT can output sufficiently reasonable word / phrase alignments that can treat different word definitions , in most cases .
This result implies that phrase-based SMT can output sufficiently reasonable word / phrase alignments that can treat different word definitions in most cases .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact 


On the other hand , the unsupervised morphological analyzer latticelm and one of our heuristic methods CAT performed much poorer than the supervised morphological analyzers .
On the other hand , the unsupervised morphological analyzer latticelm and one of our heuristic methods CAT were very much worse than the supervised morphological analyzers .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#19#18#exact -1#20,21#19,20#para -1#22#21#exact -1#23#22#exact -1#24#23#exact -1#25#24#exact -1#26#25#exact 


The experiments demonstrated an unexpected result for CHAR .
The experiments demonstrated an unexpected result for CHAR .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact 


It excelled with English-Japanese translations , but not with Japanese-English translations .
It was good at English-Japanese but not at Japanese-English translations .
-1#0#0#exact -1#4#3#exact -1#9#4#exact -1#5#6#exact -1#6#7#exact -1#8#9#exact -1#10#11#exact 


We consider the possible reasons for this result in the following list :
We consider the possible reasons for this result :
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#12#exact 


- The Head Finalization of English-Japanese lead better phrase alignments .
- The Head Finalization of English-Japanese lead better phrase alignments .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact 


- Since CHAR treats a character as a word , the best combination of its phrase alignments were the best suited for the SMT decoding .
- Since CHAR treat a character as a word , the best combination of its phrase alignments were the best suited for the SMT decoding .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#stem -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact 


On the other hand , we observed the following issues from our error analysis :
On the other hand , we observed the following issues from our error analysis :
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact 


- Uncommon named entities were almost wrongly translated .
- Uncommon named entities were almost wrongly translated .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact 


( For example ,  Czech was produced instead of  Czechoslovakia . )
( For example ,  Czech was produced instead of  Czechoslovakia . )
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact 


- Long sentences were not translated as well as other word segmentation outputs .
- Long sentences were translated worse than the other word segmentation outputs .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#5#exact -1#8#6,7,8,9#para -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact 


The reasons for the CHAR results are yet to be analyzed in detail .
The reasons of the CHAR results are yet to be analyzed in details .
-1#0#0#exact -1#1,2#1,2#para -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#stem -1#13#13#exact 


However , this result indicates that there is a possibility of better word segmentation than popular supervised morphological analyzers and CHAR word segmentation .
However , this result indicates that there is a possibility of better word segmentation than popular supervised morphological analyzers and CHAR word segmentation .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5,6,7#5,6,7,8#para -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact 


We are planning to conduct further investigations in the future .
We are planning to conduct further investigation in future .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#stem -1#7#7#exact -1#8#8,9#para -1#9#10#exact 


The current evaluation metrics that we pursued in this paper were insufficient to discuss the relative advantages and disadvantages of word segmentation in detail , since the scores that were produced were inconsistent , as explained below :
The current evaluation metrics we pursued in this paper were not sufficient to discuss more accurately about the relative advantages and disadvantages of word segmentation , since they did not produce consistent scores as explained below :
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9,10,11,12#10,11,12#para -1#13#13#exact -1#17#14#exact -1#18#15#exact -1#19,20,21,22#16,17,18#para -1#23#20#exact -1#24#21#exact -1#25#24#exact -1#26#25#exact -1#32#27#exact -1#33#34#exact -1#34#35#exact -1#35#36#exact -1#36#37#exact 


- There were many contradictory figures among evaluation metrics .
- There were many contradictory figures among evaluation metrics .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact 


There was a case that BLEU was high , while other metrics were low .
There was a case that BLEU was high , while other metrics were low .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact 


Moreover , there is also a case in which RIBES and BLEU in Characters were incompatible with each other .
Moreover , there is also a case that RIBES and BLEU in Characters were incompatible with each other .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#11#7#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact 


For example , on WIKIPEDIA in Table 2 , while CHAR was the highest , and performed better than the supervised morphological analyzers in RIBES , MeCab achieved the best score and notably better than CHAR in BLEU in Characters .
For example , on WIKIPEDIA in Table 2 , while CHAR was relatively the highest and greatly better than the supervised morphological analyzers in RIBES , MeCab achieved the best score and notably better than CHAR in BLEU in Characters .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#13#12#exact -1#14#13#exact -1#25#14#exact -1#15#15#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact -1#37#37#exact -1#38#38#exact -1#39#39#exact -1#40#40#exact 


- If we compare every column in a row , there were tendencies that the best and the worst corpora were the same for every evaluation metrics .
- If we compare every column in a row , there were tendencies that the best and the worst corpora were the same for every evaluation metrics .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact 


In Table 2 , REUTERS was the best and WIKIPEDIA was the worst in terms of BLEU , but also JENAAD+REUTERS was the best and WIKIPEDIA was the worst in terms of RIBES .
In Table 2 , REUTERS was the best and WIKIPEDIA was the worst in terms of BLEU , but also JENAAD+REUTERS was the best and WIKIPEDIA was the worst in terms of RIBES .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact 


- Even when we compare every row in a column , there were no tendencies .
- Even when we compare every row in a column , there were no tendencies .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact 


For instance , in terms of BLEU in Characters , CHAR , JUMAN , and MeCab achieved the best scores in Table 3 .
For instance , in terms of BLEU in Characters , CHAR , JUMAN , and MeCab achieved the best scores in Table 3 .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact 


This work focused on how the differences in word segmentation affected SMT outputs , the quality of the unsupervised word segmentation on SMT , and the meta-evaluation of the current evaluation metrics .
This work focused on how the difference of word segmentation affects SMT outputs , the quality of the unsupervised word segmentation on SMT , and the meta-evaluation of the current evaluation metrics .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#stem -1#8#8#exact -1#9#9#exact -1#10#10#stem -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14,15,16,17#14,15,16#para -1#25#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#28#25#exact -1#26#26#exact -1#27#27#exact -1#29#28,29#para -1#30#30#exact -1#31#31#exact -1#32#32#exact 


In summary , we found that the representative morphological analyzers were competitive and much better than both the unsupervised analyzer and one of our heuristic methods .
In summary , we found that the representative morphological analyzers were competitive and much better than both unsupervised analyzer and one of our heuristic methods .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact 


0
After all , a heuristic word segmentation method CHAR achieved relatively good word-based BLEU scores and competitive character-based BLEU results , compared to the supervised analyzers .



On Contribution of Syntactic Dependencies to Word Sense Disambiguation
On Contribution of Syntactic Dependencies to Word Sense Disambiguation
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact 


Traditionally , many researchers have addressed word sense disambiguation ( WSD ) as an independent classification problem for each word .
Traditionally , many researchers have addressed word sense disambiguation ( WSD ) as an independent classification problem for each word .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact 


However , the problem with these approaches , is that they disregard the interdependencies of word senses , and that it is limited in its applicability to the word senses for which training instances are served .**[<-This sentence is a bit confusing]
However , problems with their approaches are the disregard of the interdependencies of word senses , and the limited applicability to those word senses for which training instances are served .
-1#0#0#exact -1#1#1#exact -1#7#2#exact -1#2,3#3,4#para -1#5#5,6#para -1#15#7#exact -1#6#8#syn -1#8#11#exact -1#10#12#exact -1#11#13#exact -1#12#14#exact -1#13#15#exact -1#14#16#exact -1#16#18#exact -1#25#19,20,21#para -1#18#22#exact -1#4#24#para -1#19#25#exact -1#20#26#exact -1#17#27#exact -1#22#28#exact -1#23#29#exact -1#24#30#exact -1#26#32#exact -1#27#33#exact -1#28#34#exact -1#29#35#exact 


In this paper , we propose a supervised WSD model based on the syntactic dependencies of word senses .
In this paper , we propose a supervised WSD model based on the syntactic dependencies of word senses .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact 


In particular , we assume that strong dependencies between the sense of a syntactic head and those of its dependents exist .
Particularly , we assume that there exist strong dependencies between the sense of a syntactic head and those of its dependents .
-1#0#0,1#para -1#1#2#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10,11,12#9,10,11,12#para -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#6#20#exact -1#21#21#exact 


We describe these dependencies on the tree-structured conditional random fields ( T-CRFs ) , and obtain the most appropriate assignment of senses optimized over the sentence .
We describe these dependencies on the tree-structured conditional random fields ( T-CRFs ) , and obtain the most appropriate assignment of senses optimized over the sentence .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact 


Furthermore , we define these sense dependencies in combination with various coarse-grained sense tag sets , so that our model can also work for words that do not appear in the training data ; these combined features help relieve the data sparseness problem .
Also , we define these sense dependencies in combination with various coarse-grained sense tag sets , so that our model can even work for words that do not appear in the training data , and these combined features help relieve the data sparseness problem .
-1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#0#21#lc -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#26,27,28,29#25,26,27,28,29#para -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#35#34#exact -1#36#35#exact -1#37#36#exact -1#38#37#exact -1#39#38#exact -1#40#39#exact -1#41#40#exact -1#42#41#exact -1#43#42#exact -1#44#43#exact 


In experiments , we display the appropriateness of considering the sense dependencies , as well as the advantage of [having ? Using ?] the combination of fine- and coarse-grained tag sets .
In experiments , we show the appropriateness of considering the sense dependencies , as well as the advantage of the combination of fine- and coarse-grained tag sets .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#syn -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13,14,15,16#13,14,15#para -1#19#16#exact -1#17#17#exact -1#18#18#exact -1#20#23,24#para -1#21#25#exact -1#22#26#exact -1#23#27#exact -1#24#28#exact -1#25#29#exact -1#26#30#exact -1#27#31#exact 


The performance of our model is shown to be comparable to those of state-of-the-art WSD systems .
The performance of our model is shown to be comparable to those of state-of-the-art WSD systems .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact 


We also present an in-depth analysis of the effectiveness of the sense dependency features by using intuitive examples .
We also present an in-depth analysis on the effectiveness of the sense dependency features with intuitive examples .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6,7,8,9#6,7,8,9#para -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact 


Word sense disambiguation ( WSD ) is one of the most fundamental problems in computational linguistics .
Word sense disambiguation ( WSD ) is one of the fundamental problems in computational linguistics .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6,7,8,9#6,7,8,9,10#para -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact 


The task of WSD is to resolve the inherent polysemy of words by determining the appropriate sense( s ) for each polysemous word in a given text .
The task of WSD is to resolve the inherent polysemy of words by determining the appropriate sense( s ) for each polysemous word in a given text .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact 


It is considered to be an intermediate , but necessary step for many NLP applications , including machine translation and information extraction , which[what does " which " refer to ? Machine translation ? Information extraction , or both ? Clarify] require the knowledge of word senses to perform better .
It is considered to be an intermediate , but necessary step toward many NLP applications including machine translation and information extraction , which require the knowledge of word senses to achieve better performance .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#21#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#22#26#exact -1#29#29#exact -1#25#34#para -1#23#41#exact -1#24#42#exact -1#26#44#exact -1#27#45#exact -1#28#46#exact -1#32#48#stem -1#31#49#exact -1#33#50#exact 


One major obstacle for large-scale and precise WSD is solving the data sparseness problem caused by the fine-grained nature of sense distinction .
One major obstacle to large-scale and precise WSD is the data sparseness problem caused by the fine-grainedness of the sense distinction .
-1#0#0#exact -1#1#1#exact -1#2,3#2,3#para -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#17#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact 


In recent years in order to resolve this problem , several semi-supervised approaches have been explored .
In order to resolve this problem , several semi-supervised approaches have been explored in recent years .
-1#13#0#lc -1#14#1#exact -1#15#2#exact -1#0#3#lc -1#1#4#exact -1#2#5#exact -1#3#6#exact -1#4#7#exact -1#5#8#exact -1#6#9#exact -1#7#10#exact -1#8#11#exact -1#9#12#exact -1#10#13#exact -1#11#14#exact -1#12#15#exact -1#16#16#exact 


Some researchers have addressed the scarcity of the training data directly , and have explored the methods to obtain more tagged instances , by co-training and self-training .
Some researchers have addressed directly the scarcity of the training data , and explored the methods to obtain more tagged instances , by the co-training and self-training .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#5#4#exact -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#4#10#exact -1#11#11#exact -1#12#12#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact 


Other researchers have employed useful global information , such as the domain information extracted from unannotated corpora .
Other researchers have employed useful global information , such as the domain information extracted from unannotated corpora .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact 


Although the use of global information has succeeded in dramatically increasing the performance of WSD , there is much room left to examine the effectiveness of local or syntactic information .
Although the use of the global information has succeeded in dramatically increase the performance of WSD , there are much room left to examine the effectiveness of local or syntactic information .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#5#4#exact -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11,12#10,11#para -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18,19#17,18#para -1#20#19#exact -1#21#20#exact -1#22#21#exact -1#23#22#exact -1#24#23#exact -1#25#24#exact -1#26#25#exact -1#27#26#exact -1#28#27#exact -1#29#28#exact -1#30#29#exact -1#31#30#exact 


One such information yet to be explored , is the interdependency of word senses .
One of such information yet to be explored is the interdependencies of word senses .
-1#0#0#exact -1#2#1#exact -1#3#2#exact -1#4#3#exact -1#5#4#exact -1#6#5#exact -1#7#6#exact -1#8#8#exact -1#9#9#exact -1#10#10#stem -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact 


Although the use of local and syntactic information has been common in WSD , traditional approaches to WSD are based on the individual classification framework for each word ; each word 's sense is treated independently , regardless of any interdependencies or cooccurrences of word senses .
Although the use of local and syntactic information has been common in WSD , traditional approaches to WSD are based on the individual classification framework for each word , in which each word 's sense is treated independently , regardless of any interdependencies nor cooccurrences of word senses .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#31#29#exact -1#32#30#exact -1#33#31#exact -1#34#32#exact -1#35#33#exact -1#36#34#exact -1#37#35#exact -1#38#36#exact -1#39#37#exact -1#40#38#exact -1#41#39#exact -1#42#40#exact -1#43#41#para -1#44#42#exact -1#45#43#exact -1#46#44#exact -1#47#45#exact -1#48#46#exact 


In turn , the resulting sense assignment may not be semantically consistent over the sentence .
As a result , the resulting sense assignment may not semantically consistent over the sentence .
-1#3#2#exact -1#4#3#exact -1#5#4#exact -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact 


To solve this problem is of great interest from both a practical and theoretical viewpoint .
To solve this problem is of great interest from both practical and theoretical perspectives .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10,11#10,11,12#para -1#12#13#exact -1#14#15#exact 


In this thesis , we present a WSD model that naturally handles all content words in a sentence .
In this thesis , we present a WSD model that naturally handles all content words in a sentence .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact 


We focus on using the interdependency of word senses , so that we can directly address the issue of semantic ambiguity in a whole sentence that arose from the interaction of each word 's sense ambiguity . **[ <- this part is confusing .]
We focus on the use of the interdependency of word senses , so that we can directly address the issue of semantic ambiguity of a whole sentence arose from the interaction of each word 's sense ambiguity .
-1#0#0#exact -1#1#1#exact -1#2,3,4,5#2,3#para -1#6#4#exact -1#7#5#exact -1#8#6#exact -1#9#7#exact -1#10#8#exact -1#11#9#exact -1#12#10#exact -1#13#11#exact -1#14#12#exact -1#15#13#exact -1#16#14#exact -1#17,18,19,20#15,16,17#para -1#23#18#exact -1#21#19#exact -1#22#20#exact -1#24#22#exact -1#25#23#exact -1#26#24#exact -1#27,28#25,26,27#para -1#29#28#exact -1#30#29#exact -1#31#30#exact -1#32#31#exact -1#33#32#exact -1#34#33#exact -1#35#34#exact -1#36#35#exact -1#37#36#exact 


Specifically , we assume that are strong sense dependencies between a syntactic head , and its dependents in the dependency tree , rather than between neighboring words of a sentence .
Specifically , we assume that there exist strong sense dependencies between a syntactic head and its dependents in the dependency tree , rather than between neighboring words in the sentence .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#7#5,6#para -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#21#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26,27#26,27#para -1#28,29#28,29#para -1#30#30#exact 


We confirm the validity of this assumption , by showing the superiority of the tree-structured models over the linear-chain models .
We confirm the appropriateness of this assumption by showing the superiority of the tree-structured models over the linear-chain models .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#8#exact -1#8#9#exact -1#9,10,11,12#10,11,12#para -1#16#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact 


Furthermore , we combine these sense dependency features with various coarse-grained sense tag sets .
Furthermore , we combine these sense dependency features with various coarse-grained sense tag sets .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact 


This is to relieve the data sparseness problem caused by the explosion in the number of features , which is roughly squared by the combination of two word senses .
This is to relieve the data sparseness problem caused by the explosion of the number of features , which is roughly squared by the combination of two word senses .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12,13,14,15#12,13,14,15#para -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact 


The combined features also enable our model to work , even for words that do not appear in the training data , which traditional individual classifiers cannot handle .
The combined features also enable our model to work even for those words that do not appear in the training data , which the traditional individual classifiers cannot handle .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#21#9#exact -1#9#10#exact -1#10#11#exact -1#12#12#exact -1#14,15,16,17#13,14,15,16,17#para -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#22#22#exact -1#24#23#exact -1#25#24#exact -1#26#25#exact -1#27#26#exact -1#28#27#exact -1#29#28#exact 


As a machine learning method , we adopt the tree-structured conditional random fields ( T-CRFs ) .
As a machine learning method , we adopt the tree-structured conditional random fields ( T-CRFs ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact 


We solve WSD as a labeling problem to a sentence described as a dependency tree , where the vertices correspond to the words , and the edges correspond to the sense dependencies .
We solve WSD as a labeling problem to a sentence described as a dependency tree , where the vertices correspond to words and the edges correspond to the sense dependencies .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#23#21#exact -1#21#22#exact -1#22#24#exact -1#27#25#exact -1#24#26#exact -1#25#27#exact -1#26#28#exact -1#28#29,30#para -1#29#31#exact -1#30#32#exact 


In this model , the intensities of the sense dependencies are described as the weights of edge features .
In this model , the intensities of the sense dependencies are described as the weights of edge features .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact 


T-CRFs also enable us to incorporate various sense tag sets all together into a simple framework .
T-CRFs also enable us to incorporate various sense tag sets all together in a simple framework .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact 


In our experiments , three interesting results are found : the interdependency of word senses contribute to the improvement of WSD models , the combined features with coarse-grained sense tags work effectively , and the tree-structured model outperforms the linear-chain model .
In our experiments , three interesting results are found : the interdependency of word senses contribute to the improvement of WSD models , the combined features with coarse-grained sense tags work effectively , and the tree-structured model outperforms the linear-chain model .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact -1#37#37#exact -1#38#38#exact -1#39#39#exact -1#40#40#exact -1#41#41#exact 


These results are confirmed on three data sets ( the SemCor corpus and the Senseval-2 and -3 English all-words task test sets ) , and on two sense inventories ( WordNet synsets and supersenses ) .
These results are confirmed on three data sets ( the SemCor corpus and the Senseval-2 and -3 English all-words task test sets ) and on two sense inventories ( WordNet synsets and supersenses ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact -1#28#29#exact -1#29#30#exact -1#30#31#exact -1#31#32#exact -1#32#33#exact -1#33#34#exact -1#34#35#exact 


Our final model is shown to perform comparably to state-of-the-art WSD systems .
Our final model is shown to perform comparably with state-of-the-art WSD systems .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact 


The rest of the paper is organized as follows : In Section 2 , we describe background topics related to WSD .
The rest of the paper is organized as follows : In Section 2 , we describe background topics related to WSD .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact 


In Section 3 , we describe current problems of WSD , and related works .
In Section 3 , we describe current problems of WSD , and related works .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact 


In Section 4 , we describe our model with intuitive examples , and we describe the machine learning method that we use .
In Section 4 , we describe our model with intuitive examples , and the machine learning method we use .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#17#13#exact -1#13#15#exact -1#14#16#exact -1#15#17#exact -1#16#18#exact -1#18#19,20,21#para -1#19#22#exact 


In Section 5 , 6 , and 7 , we present our experimental setup , the results , and an in-depth analysis on the contribution of the sense dependency features .
In Section 5 , 6 , and 7 , we present our experimental setup and results , and an in-depth analysis on the contribution of the sense dependency features .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#16#14#exact -1#22#15#exact -1#15#16#exact -1#14#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#23,24,25#23,24,25,26#para -1#26#27#exact -1#27#28#exact -1#28#29#exact -1#29#30#exact 


Finally , in Section 8 , we present our concluding remarks .
Finally , in Section 8 , we present concluding remarks .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact 


The WordNet is a broad-coverage machine-readable dictionary ( MRD ) for English , containing about 150 ,000 words .
The WordNet is a broad-coverage machine-readable dictionary ( MRD ) for English , which contains about 150 ,000 words .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13,14#13#para -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact 


WordNet also serves as an ontology of various kinds of meta data , relations among words and senses , and a well-organized hierarchical classification of word senses that are defined .
It also serves as an ontology , in which various kinds of meta data , relations among words and senses , and well-organized hierarchical classification of word senses are defined .
-1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#11#6#exact -1#9#7#exact -1#10#8#exact -1#25#9#exact -1#12#10#exact -1#13#11#exact -1#14#12#exact -1#15#13#exact -1#16#14#exact -1#17#15#exact -1#18#16#exact -1#19#17#exact -1#20#18#exact -1#21#19#exact -1#22#21#exact -1#23#22#exact -1#24#23#exact -1#26#25#exact -1#27#26#exact -1#28#27,28#para -1#29#29#exact -1#30#30#exact 


In this paper , we always refer to the WordNet version 2 .0 unless otherwise noted .
In this paper , we always refer to the WordNet version 2 .0 unless otherwise noted .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact 


The statistical information of the WordNet 2 .0 is shown in Table 1 and 2 .
The statistical information of the WordNet 2 .0 is shown in Table 1 and 2 .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact 


As shown in Figure 1 , in WordNet , nouns and verbs are organized into hierarchical structures with IS-A ( hypernym-hyponym ) relationships among words , .
In the WordNet , nouns and verbs are organized in hierarchical structures with IS-A ( hypernym-hyponym ) relationships among words , as shown in Figure 1 .
-1#21#0#lc -1#22#1#exact -1#23#2#exact -1#24#3#exact -1#25#4#exact -1#20#5#exact -1#9#6#exact -1#2#7#exact -1#3#8#exact -1#4#9#exact -1#5#10#exact -1#6#11#exact -1#7#12#exact -1#8#13#exact -1#10#15#exact -1#11#16#exact -1#12#17#exact -1#13#18#exact -1#14#19#exact -1#15#20#exact -1#16#21#exact -1#17#22#exact -1#18#23#exact -1#19#24#exact -1#26#26#exact 


Nouns have a far deeper structure than verbs do , while that the structure of verbs is transversely developed .
Nouns have a far deeper structure than verbs , while that of verbs is transversely developed .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#14#exact -1#12#15#exact -1#13#16#exact -1#14#17#exact -1#15#18#exact -1#16#19#exact 


All nouns and verbs , with the exception of some top-level concepts , are classified into primitive groups called supersenses , which we will describe later .
All nouns and verbs except some top-level concepts are classified into primitive groups called supersenses , which we describe later .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#15#4#exact -1#4#5,6,7,8#para -1#5#9#exact -1#6#10#exact -1#7#11#exact -1#8#13#exact -1#9#14#exact -1#10#15#exact -1#11#16#exact -1#12#17#exact -1#13#18#exact -1#14#19#exact -1#16#21#exact -1#17#22#exact -1#18#24#exact -1#19#25#exact -1#20#26#exact 


Figure 1 shows the WordNet hierarchical structure for the first sense ( financial bank ) of a noun bank , where each line indicates a synset with the list of words headed by its supersense label ; an arrow denotes that the two synsets are in an IS-A relation .
Figure 1 shows the WordNet hierarchical structure for the first sense ( financial bank ) of a noun bank , where each line shows a synset with the list of words headed by its supersense label , and an arrow denotes that two synsets are in an IS-A relation .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#syn -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#38#37#exact -1#39#38#exact -1#40#39#exact -1#41#40#exact -1#42#41,42#para -1#43#43#exact -1#44#44#exact -1#45#45#exact -1#46#46#exact -1#47#47#exact -1#48#48#exact -1#49#49#exact 


The synset {group#1 , grouping#1} is a broad semantic category that governs the supersense group noun .group .
The synset {group#1 , grouping#1} is a broad semantic category that governs the supersense noun group .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#15#14#exact -1#14#15#exact -1#16#17#exact 


The lower synsets {social group#1} , {organization#1 , organisation#3} , and {institution#1 , establishment#2} are the more specific synsets , which in this paper we call the first , second , and third general synsets .
The lower synsets {social group#1} , {organization#1 , organisation#3} , and {institution#1 , establishment#2} are the more specific synsets , which in this paper we call the first , second , and third general synsets .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact 


Note that since the organizations of adjectives and adverbs are very different from those of nouns and verbs , we use this hierarchical information for only nouns and verbs .
Note that since the organizations of adjectives and adverbs are far different from those of nouns and verbs , we use this hierarchical information for only nouns and verbs .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10,11#10,11#para -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact 


A supersense is a coarse-grained semantic category , with which each noun or verb synset in WordNet is associated .
A supersense is a coarse-grained semantic category , with which each noun or verb synset in WordNet is associated .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact 


Noun and verb synsets are associated with 26 and 15 categories , respectively .
Noun and verb synsets are associated with 26 and 15 categories , respectively .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact 


The coarse-grained sets of sense labels are easily recognizable , and enable us to build a high-performance and robust tagger with small training data .
The coarse-grained sets of sense labels are easily recognizable , and enable us to build a high-performance and robust tagger with small training data .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact 


Hence , we can expect them to act as a good smoothing feature for WSD , which would make up for the problem of the sparseness of features , commonly associated with finer-grained senses .
Hence , we can expect them to act as a good smoothing feature for WSD , which would make up for the sparseness of features associated with finer-grained senses .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6,7,8,9#6,7,8#para -1#10#9,10#para -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#23#23#exact -1#22#25#exact -1#24#27#exact -1#25#30#exact -1#26#31#exact -1#27#32#exact -1#28#33#exact -1#29#34#exact 


The effectiveness of using supersenses for WSD has recently been shown by several researchers ( e.g. , , and ) .
The effectiveness of using supersenses for WSD has recently been shown by several researchers ( e.g. , , and ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact 


The lists of supersenses are shown below .
The lists of supersenses are shown below .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact 


- Noun supersense : act , animal , artifact , attribute , body , cognition , communication , event , feeling , food , group , location , motive , object , quantity , phenomenon , plant , possession , process , person , relation , shape , state , substance , time , Tops
- Noun supersense : act , animal , artifact , attribute , body , cognition , communication , event , feeling , food , group , location , motive , object , quantity , phenomenon , plant , possession , process , person , relation , shape , state , substance , time , Tops
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact -1#37#37#exact -1#38#38#exact -1#39#39#exact -1#40#40#exact -1#41#41#exact -1#42#42#exact -1#43#43#exact -1#44#44#exact -1#45#45#exact -1#46#46#exact -1#47#47#exact -1#48#48#exact -1#49#49#exact -1#50#50#exact -1#51#51#exact -1#52#52#exact -1#53#53#exact -1#54#54#exact 


- Verb supersense : body , change , cognition , communication , competition , consumption , contact , creation , emotion , perception , possession , social , stative , weather
- Verb supersense : body , change , cognition , communication , competition , consumption , contact , creation , emotion , perception , possession , social , stative , weather
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact 


Since data sparsity has been a significant issue in WSD , the sense frequency information is necessary in achieving a good performance .
Since the data sparsity has been a significant problem in WSD , the sense frequency information is necessary to achieve good performance .
-1#0#0#exact -1#2#1#exact -1#3#2#exact -1#4#3#exact -1#5#4#exact -1#6#5#exact -1#7#6#exact -1#8,9#7,8#para -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18,19#17,18#para -1#20#19,20#para -1#21#21#exact -1#22#22#exact 


In this section , we introduce two kinds of sense frequency information .
In this section , we introduce two kinds of the sense frequency information .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact 


A sense ranking is the ranking of a sense of a word in the WordNet .
A sense ranking is the ranking of a sense of a word in the WordNet .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact 


Since senses of a word are ordered according to frequency , the sense ranking acts as a useful feature that offers a preference for frequent senses .
Since senses of a word are ordered according to frequency , the sense ranking acts as a useful feature offering a preference for frequent senses .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#20#stem -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact 


It is also important as a back-off feature , which enables our model to output the first ( most frequent ) sense when no other features are active for that word .
It is also important as a back-off feature , which enables our model to output the first ( most frequent ) sense when no other features are active for that word .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact 


The first sense classifier is known as a strong baseline in WSD , which can even be considered as a good alternative to WSD .
The first sense classifier is known as a strong baseline in WSD , which can be even considered to be a good alternative to WSD .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15,16#15,16#para -1#17,18,19,20#17,18,19#para -1#21#20#exact -1#22#21#exact -1#23#22#exact -1#24#23#exact -1#25#24#exact 


In our experiment , our first sense classifier achieved the accuracies 65 .3% for the Senseval-2 English all-words task data , and 63 .4% for the Senseval-3 English all-words task data .
In our experiment , our first sense classifier achieved the accuracies 65 .3% for the Senseval-2 English all-words task data , and 63 .4% for the Senseval-3 English all-words task data .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact 


Since the sense ranking in the WordNet is based on the word frequency in the SemCor , this baseline performs far better on the SemCor : 75 .9% for the brown1 section and 74 .3% for the brown2 section .
Since the sense ranking in the WordNet is based on the word frequency in the SemCor , this baseline performs far better on the SemCor : 75 .9% for the brown1 section and 74 .3% for the brown2 section .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7,8,9,10#7,8,9#para -1#14#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#23#14#exact -1#24#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#29#23#exact -1#15#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#36#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#37#37#exact -1#38#38#exact -1#39#39#exact 


Alternatively , we can consider incorporating the first sense of each word as a feature .
Alternatively , we can consider incorporating the first sense of each word as a feature .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact 


Instead of uniformly predicting the distribution of sense frequencies according to their sense ranking , it can capture the conditional probability of each sense over the first sense .
Instead of uniformly predicting the distribution of sense frequencies according to their sense ranking , it can capture the conditional probability of each sense over the first sense .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact 


When sufficient training data is available for every sense this method is considered to be a good feature that reflects the sense frequency information .
It is considered to be a good feature that reflects the sense frequency information when sufficient training data is available for every sense .
-1#14#0#lc -1#15#1#exact -1#16#2#exact -1#17#3#exact -1#18#4#exact -1#19#5#exact -1#20#6#exact -1#21#7#exact -1#22#8#exact -1#1#10,11#para -1#2#12#exact -1#4,5,6#13,14,15,16#para -1#7#17#exact -1#8#18#exact -1#9#19#exact -1#10#20#exact -1#11#21#exact -1#12#22#exact -1#13#23#exact -1#23#24#exact 


For such a reason , we use this first sense feature instead of the ranking feature , for the supersense-based evaluation .
For this reason , we use this first sense feature instead of the ranking feature , for the supersense-based evaluation .
-1#0#0#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact 


For the unsupervised WSD , the use of sense dependencies has been a common method .
For the unsupervised WSD , the use of sense dependencies has been a common method .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact 


introduces an unsupervised graph-based algorithm , and shows a significant improvement over the sequence labeling model over the individual label assignment .
introduces an unsupervised graph-based algorithm , and showed a significant superiority of the sequence labeling model over the individual label assignment .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#stem -1#8#8#exact -1#9#9#exact -1#16#11#exact -1#17#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#12#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact 


built a model based on various word semantic similarity measures , and graph centrality algorithms , which also used the graph structure that incorporates the word-sense dependencies .
built a model based on various word semantic similarity measures and graph centrality algorithms , which also used the graph structure incorporating the word-sense dependencies .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#14#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21,22#22,23,24#para -1#23#25#exact -1#24#26#exact -1#25#27#exact 


Thus , the effectiveness of sense dependencies for unsupervised WSD has been shown by several researches .
Thus , the effectiveness of sense dependencies for the unsupervised WSD has been shown by several researches .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact 


On the contrary , the traditional approach to supervised WSD is to solve an independent classification problem for each word .
On the other hand , the traditional approach to the supervised WSD is to solve an independent classification problem for each word .
-1#0#0#exact -1#1#1#exact -1#2,3#2#para -1#4#3#exact -1#5#4#exact -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#10#8#exact -1#11#9#exact -1#12#10#exact -1#13#11#exact -1#14#12#exact -1#15#13#exact -1#16#14#exact -1#17#15#exact -1#18#16#exact -1#19#17#exact -1#20#18#exact -1#21#19#exact -1#22#20#exact 


This approach has been developed along with research based on the lexical sample task in the Sensevals .
This approach has been developed along with the researches based on the lexical sample task in the Sensevals .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#8#7#stem -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact 


However , as described in Section 1 , this approach cannot handle the interdependencies among word senses , and may output a semantically inconsistent assignment of senses .
However , as we described in Section 1 , this approach cannot deal with the interdependencies among word senses , and may output a semantically inconsistent assignment of senses .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#4#3#exact -1#5#4#exact -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12,13,14#11,12#para -1#15#13#exact -1#16#14#exact -1#17#15#exact -1#18#16#exact -1#19#17#exact -1#20#18#exact -1#21#19#exact -1#22#20#exact -1#23#21#exact -1#24#22#exact -1#25#23#exact -1#26#24#exact -1#27#25#exact -1#28#26#exact -1#29#27#exact 


Recently , with the growing interest in the all-words task , a few supervised WSD systems have incorporated the sense dependencies .
Recently , with the growing interest on the all-words task , a few supervised WSD systems have incorporated the sense dependencies .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact 


SenseLearner and SuperSenseLearner incorporate sequential sense dependencies into the supervised WSD frameworks .
SenseLearner and SuperSenseLearner incorporate sequencial sense dependencies into the supervised WSD frameworks .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact 


They no longer treat each word sense individually , assuming the sense dependencies between adjacent words .
They no longer treat each word sense individually , assuming the sense dependencies between adjacent words .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact 


also took a sequential tagging approach for the disambiguation of WordNet supersenses . [<-This sentence is a bit confusing]
also took a sequencial tagging approach for the disambiguation of WordNet supersenses .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact 


The dependencies that they considered , however , are rather simple ones between the adjacent words , and between either WordNet synsets or supersenses .
However , the dependencies they considered are rather simple ones between the adjacent words , and between either WordNet synsets or supersenses .
-1#2#0#lc -1#3#1#exact -1#4#3#exact -1#5#4#exact -1#14#5#exact -1#0#6#lc -1#1#7#exact -1#6#8#exact -1#7#9#exact -1#8#10#exact -1#9#11#exact -1#10#12#exact -1#11#13#exact -1#12#14#exact -1#13#15#exact -1#15#17#exact -1#16#18#exact -1#17#19#exact -1#18#20#exact -1#19#21#exact -1#20#22#exact -1#21#23#exact -1#22#24#exact 


Note additionally , that they do not mention the means or the quality of contribution in improving supervised WSD .
Note additionally that they do not mention how and how much they contribute to the improvement of supervised WSD .
-1#0#0#exact -1#1#1#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#14#8#exact -1#16#13#exact -1#12#14#stem -1#15#16#stem -1#17#17#exact -1#18#18#exact -1#19#19#exact 


The exponential family model proposed by , captures the occurrences and co-occurrences of words and senses in a joint probability distribution .
One interesting model related is the exponential family model proposed by , which captures the occurrences and co-occurrences of words and senses in a joint probability distribution .
-1#5#0#lc -1#6#1#exact -1#7#2#exact -1#8#3#exact -1#9#4#exact -1#10#5#exact -1#11#6#exact -1#13#7#exact -1#14#8#exact -1#15#9#exact -1#16#10#exact -1#17#11#exact -1#18#12#exact -1#19#13#exact -1#20#14#exact -1#21#15#exact -1#22#16#exact -1#23#17#exact -1#24#18#exact -1#25#19#exact -1#26#20#exact -1#27#21#exact 


Although they focused on the use of the co-occurrences of word senses rather than that of dependencies , they clarified the contribution of sense co-occurrences to the supervised WSD .
Although they focused on the use of the co-occurrences of word senses rather than the dependencies , they clarified the contribution of sense co-occurrences to the supervised WSD .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4,5,6,7#4,5,6#para -1#14#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12,13#12,13,14,15#para -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact -1#28#29#exact 


In this context , it is of interest to note whether the sense dependencies on a syntactic structure , rather than on a linear chain , works effectively or not .**[why ?]
In this context , it is of an interest if the sense dependencies on a syntactic structure , rather than on a linear chain , works effectively or not .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#8#7#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact -1#28#29#exact 


To the extent of our knowledge , there exists no model that considers the interdependencies of word senses on a syntactic tree .
To the extent of our knowledge , there exists no model that considers the interdependencies of word senses on a syntactic tree .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact 


Furthermore , despite the approaches described above , the contribution of sense dependencies for the supervised WSD has not been explicitly examined thus far .
Also , despite the approaches described above , the contribution of sense dependencies for the supervised WSD has not explicitly examined thus far .
-1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact 


These questions are clarified by our research .
These questions are clarified by our research .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact 


In Section 1 , we presented one of the most significant issues in WSD - the data sparsity problem .
In Section 1 , we presented one of the most significant problems in WSD - the data sparsity .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11,12#11#para -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#19#exact 


This problem may even be magnified , when taking into consideration the interdependencies of word senses , since the number of features is roughly squared by the combination of two word senses .
This problem may even be magnified when we consider the interdependencies of word senses , since the number of features is roughly squared by the combination of two word senses .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#14#6#exact -1#6#7#exact -1#8#10#para -1#9#11#exact -1#10#12#exact -1#11#13#exact -1#12#14#exact -1#13#15#exact -1#15#17#exact -1#16#18#exact -1#17#19#exact -1#18#20#exact -1#19#21#exact -1#20#22#exact -1#21#23#exact -1#22#24#exact -1#23#25#exact -1#24#26#exact -1#25#27#exact -1#26#28#exact -1#27#29#exact -1#28#30#exact -1#29#31#exact -1#30#32#exact 


In order to relieve this problem , we use the hierarchical information in the WordNet , including the superordinate words and supersenses , as described in Section 2 .1 and 2 .2 .
In order to relieve this problem , we use the hierarchical information in the WordNet , including the superordinate words and supersenses , which we describe in Section 2 .1 and 2 .2 .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#25,26#24,25#para -1#27#26#exact -1#28#27#exact -1#29#28#exact -1#30#29#exact -1#31#30#exact -1#32#31#exact -1#33#32#exact 


The use of hierarchical information has been motivated by several different researches .
The use of the hierarchical information has been motivated by several researches .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#4#3#exact -1#5#4#exact -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#11#exact -1#12#12#exact 


For example , a WSD system by , ranked second in the Senseval-3 , consists of two models : the first model applied to words seen in the training data , and the second model performs a generalized disambiguation process for words unseen in the data , by using the hierarchical information in the WordNet .
For example , a WSD system by , which was ranked second in the Senseval-3 , consists of two models : the first model applied to words seen in the training data , and the second model that performs a generalized disambiguation process for words unseen in the data by using the hierarchical information in the WordNet .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#10#8#exact -1#11#9#exact -1#12#10#exact -1#13#11#exact -1#14#12#exact -1#15#13#exact -1#16#14#exact -1#17#15#exact -1#18#16#exact -1#19#17#exact -1#20#18#exact -1#21#19#exact -1#22#20#exact -1#23#21#exact -1#24#22#exact -1#25#23#exact -1#26#24#exact -1#27#25#exact -1#28#26#exact -1#29#27#exact -1#30#28#exact -1#31#29#exact -1#32#30#exact -1#33#31#exact -1#34#32#exact -1#35#33#exact -1#36#34#exact -1#38#35#exact -1#39#36#exact -1#40#37#exact -1#41#38#exact -1#42#39#exact -1#43#40#exact -1#44#41#exact -1#45#42#exact -1#46#43#exact -1#47#44#exact -1#48#45#exact -1#49#47#exact -1#50#48#exact -1#51#49#exact -1#52#50#exact -1#53#51#exact -1#54#52#exact -1#55#53#exact -1#56#54#exact -1#57#55#exact 


The fine granularity of the WordNet synsets is not just a major obstacle in achieving a high-performance WSD , but is sometimes too fine-grained even for a human to disambiguate .
The fine granularity of the WordNet synsets is not just a major obstacle to high-performance WSD , but is sometimes too fine-grained even for a human to disambiguate .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#24#15#exact -1#14#16#exact -1#15#17#exact -1#16#18#exact -1#17#19#exact -1#18#20#exact -1#19#21#exact -1#20#22#exact -1#21#23#exact -1#22#24#exact -1#23#25#exact -1#25#26,27#para -1#26#28#exact -1#27#29#exact -1#28#30#exact 


This is reflected in the low inter-annotator agreement of sense tagging ( typically around 70% ) , which implies that WSD models would be unlikely to perform better than the accuracy achieved .
This is reflected in the low inter-annotator agreement of sense tagging ( typically around 70% ) , which implies that WSD models are unlikely to perform better than this accuracy .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22,23#para -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact -1#29#29,30#para -1#30#32#exact 


Also , this fine-grained nature is reported to be inappropriate for many NLP applications .
Also , this fine-grainedness is reported to be not appropriate for many NLP applications .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8,9#9#para -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact 


For example , reported that coarse-grained sense distinctions are sufficient for several NLP applications .
For example , reported that coarse-grained sense distinctions are sufficient for several NLP applications .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact 


In particular , the use of the supersenses has recently been investigated by , and has received much attention in the WSD field .
Especially , the use of the supersenses has recently been investigated by , and receiving much attention in the WSD field .
-1#17#0#lc -1#0#1#para -1#1#2#exact -1#2,3,4,5#3,4,5#para -1#18#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#syn -1#15#17#exact -1#16#18#exact -1#19#21#exact -1#20#22#exact -1#21#23#exact 


In this case , the inter-annotator agreements have reached nearly90% .
In this case , the inter-annotator agreements are turned out to reach around 90% .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#8,9,10#7#para -1#11#8#stem -1#14#10#exact 


For this reason , we use the WordNet supersenses , as well as the synsets as our sense inventory .
For this reason , we use as our sense inventory the WordNet supersenses as well as the synsets .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#10#6#exact -1#11#7#exact -1#12#8#exact -1#13,14,15#10,11,12,13#para -1#17#14#exact -1#6#15#exact -1#7#16#exact -1#8#17#exact -1#9#18#exact -1#18#19#exact 


In Section 3 , we described two problems in the WSD field .
In Section 3 , we described two problems in the WSD field .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact 


One problem is the independent classification of each word 's sense , regardless of the sense dependencies among words .
One is the independent classification of each word 's sense regardless of the sense dependencies among words .
-1#0#0#exact -1#1#2#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#12#exact -1#11#13#exact -1#12#14#exact -1#13#15#exact -1#14#16#exact -1#15#17#exact -1#16#18#exact -1#17#19#exact 


The other problem is the scarcity of the training data that arose from the fine granularity of the sense distinction .
The other is the scarcity of the training data arose from the fine granularity of the sense distinction .
-1#0#0#exact -1#1#1#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9,10#10,11,12#para -1#11#13#exact -1#12#14#exact -1#13#15#exact -1#14#16#exact -1#15#17#exact -1#16#18#exact -1#17#19#exact -1#18#20#exact 


We address these problems by combining two methods .
We address these problems by the combination of two methods .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5,6,7#5#para -1#8#6#exact -1#9#7#exact -1#10#8#exact 


The first [method ?] is the use of the syntactic dependencies of word senses on a dependency tree .
The first is the use of the syntactic dependencies of word senses on a dependency tree .
-1#0#0#exact -1#1#1#exact -1#2#4#exact -1#3,4,5,6#5,6,7#para -1#7#9#exact -1#8#10#exact -1#9#11#exact -1#10#12#exact -1#11#13#exact -1#12#14#exact -1#13#15#exact -1#14#16#exact -1#15#17#exact -1#16#18#exact 


In particular , we assume that there are strong dependencies of word senses between a head and its dependents in the dependency tree , rather than between neighboring words in the sentence .
Particularly , we assume that there exist strong dependencies of word senses between a head and its dependents in the dependency tree , rather than between neighboring words in the sentence .
-1#18#0#lc -1#0#1#stem -1#1#2#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#7#7,8#para -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#28#19#exact -1#29#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact -1#19#30#exact -1#30#31#exact -1#31#32#exact 


Even though some models so far have considered the dependencies between adjacent words , no one has focused on the syntactic dependencies of word senses .
Even though some models so far have considered the dependencies between adjacent words , no one has focused on the syntactic dependencies of word senses .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact 


Thus , to the extent of our knowledge , our model is the first WSD model that incorporates the sense dependencies based on a syntactic tree .
Thus , to the extent of our knowledge , our model is the first WSD model that incorporates the sense dependencies based on a syntactic tree .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact 


The second [method ?] combines various coarse-grained sense tag sets with the WordNet synsets .
The second is the combination of various coarse-grained sense tag sets with the WordNet synsets .
-1#0#0#exact -1#1#1#exact -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact 


This enables our model to work for unseen words in the training data , and is expected to relieve the data sparseness problem .
This enables our model to work for unseen words in the training data , and is expected to relieve the data sparseness problem .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact 


In our experiment , these tag sets are used in two ways .
In our experiment , these tag sets are used in two ways .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact 


One way directly uses them as the sense inventory , instead of as a finer sense inventory .
One way is to use them directly as the sense inventory instead of a finer sense inventory .
-1#0#0#exact -1#1#1#exact -1#6#2#exact -1#4#3#stem -1#5#4#exact -1#7#5#exact -1#8#6#exact -1#9#7#exact -1#10#8#exact -1#11#10#exact -1#12#11#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact 


In our supersense-based model , we use the supersenses as the sense inventory , and each word sense is disambiguated at the granularity level of this tag set .
In our supersense-based model , we use the supersenses as the sense inventory , and each word sense is disambiguated at the granularity level of this tag set .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact 


This method serves us many more training instances for each coarser sense , while we can no longer distinguish finer senses .
This method serves us much more training instances for each coarser sense , while we can no longer distinguish finer senses .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14,15,16,17#14,15,16#para -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact 


The other way uses them**[<-define " them " ] in combination with finer sense tag sets .
The other is to use them in combination with finer sense tag sets .
-1#0#0#exact -1#1#1#exact -1#5#6#exact -1#6#9#exact -1#7#10#exact -1#8#11#exact -1#9#12#exact -1#10#13#exact -1#11#14#exact -1#12#15#exact -1#13#16#exact 


In our synset-based model , three coarse-grained label sets are incorporated in combination with the fine-grained WordNet synsets .
In our synset-based model , three coarse-grained label sets are incorporated in combination with the fine-grained WordNet synsets .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact 


Although sense disambiguation is still based on the finer senses , the coarser sense tags will help the discrimination of the finer senses , thereby serving generalized information for each fine-grained sense .
Although the sense disambiguation is still based on the finer senses , the coarser sense tags will help the discrimination of the finer senses , serving generalized information for each fine-grained sense .
-1#0#0#exact -1#2#1#exact -1#3#2#exact -1#4#3#exact -1#5#4#exact -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact -1#23#22#exact -1#24#23#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact 


This approach has been taken in several hierarchical WSD methods , but has never been combined with the sense dependencies in a way that have used them .
This approach has been taken in several hierarchical WSD methods , but never combined with the sense dependencies as we use .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12,13,14#para -1#13#15#exact -1#14#16#exact -1#15#17#exact -1#16#18#exact -1#17#19#exact -1#20#24,25#para -1#21#27#exact 


The process of WSD is summarized below .
The process of WSD is summarized as below .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#7#6#exact -1#8#7#exact 


At the beginning , we parse target sentences with a dependency parser , and compact the outputted trees in order to capture informative dependencies among words , as described in Section 4 .3 .
At the beginning , we parse target sentences with a dependency parser , and compact the outputted trees in order to capture informative dependencies among words , as described in Section 4 .3 .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact 


Then , the WSD task is regarded as a labeling task on the tree structures .
Then , the WSD task is regarded as a labeling task on the tree structures .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact 


By using T-CRFs , we can model this as the maximization of the probability of word sense trees , given the scores for vertices and edges .
By using T-CRFs , we can model this as the maximization of the probability of word sense trees , given scores for vertices and edges .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact 


In the training phase , all vertex features and edge features are extracted using the gold-standard senses , and the weight vectors are optimized over the training data .
In the training phase , all vertex features and edge features are extracted using the gold-standard senses , and the weight vectors for them are optimized over the training data .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#24#22#exact -1#25#23#exact -1#26#24#exact -1#27#25#exact -1#28#26#exact -1#29#27#exact -1#30#28#exact 


Finally , in the testing phase , all possible combinations of senses are evaluated for each sentence , and the most probable sense assignment is selected by evaluating the equation 3 .
Finally , in the testing phase , all possible combinations of senses are evaluated for each sentence , and the most probable sense assignment is selected by evaluating the equation 3 .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact 


Conditional Random Fields ( CRFs ) are graph-based probabilistic discriminative models proposed by .
Conditional Random Fields ( CRFs ) are graph-based probabilistic discriminative models proposed by .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact 


CRFs are state-of-the-art methods for sequence labeling problems in many NLP tasks .
CRFs are the state-of-the-art methods for sequence labeling problems in many NLP tasks .
-1#0#0#exact -1#1#1#exact -1#3#2#exact -1#4#3#exact -1#5#4#exact -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact 


CRFs construct a conditional model / MATH from a set of paired observations and label sequences .
CRFs construct a conditional model / MATH from a set of paired observations and label sequences .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact 


The conditional probability of a label sequence / MATH conditioned on a data sequence / MATH is given by / MATH	 , where / MATH and / MATH are the feature vectors for an edge and a vertex , / MATH and / MATH are the weight vectors , / MATH and / MATH are the set of components of / MATH associated with an edge / MATH and a vertex / MATH , and / MATH is the partition function that constrains the sum of all the probabilities to be 1 .
The conditional probability of a label sequence / MATH conditioned on a data sequence / MATH is given by / MATH	 , where / MATH and / MATH are the feature vectors for an edge and a vertex , / MATH and / MATH are the weight vectors for them , / MATH and / MATH are the set of components of / MATH associated with an edge / MATH and a vertex / MATH , and / MATH is the partition function which constrains the sum of all the probabilities to be 1 .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact -1#37#37#exact -1#38#38#exact -1#39#39#exact -1#40#40#exact -1#41#41#exact -1#42#42#exact -1#43#43#exact -1#44#44#exact -1#45#45#exact -1#46#46#exact -1#47#47#exact -1#50#48#exact -1#51#49#exact -1#52#50#exact -1#53#51#exact -1#54#52#exact -1#55#53#exact -1#56#54#exact -1#57#55#exact -1#58#56#exact -1#59#57#exact -1#60#58#exact -1#61#59#exact -1#62#60#exact -1#63#61#exact -1#64#62#exact -1#65#63#exact -1#66#64#exact -1#67#65#exact -1#68#66#exact -1#69#67#exact -1#70#68#exact -1#71#69#exact -1#72#70#exact -1#73#71#exact -1#74#72#exact -1#75#73#exact -1#76#74#exact -1#77#75#exact -1#78#76#exact -1#79#77#exact -1#80#78#exact -1#81#79#exact -1#82#80#exact -1#84#82#exact -1#85#83#exact -1#86#84#exact -1#87#85#exact -1#88#86#exact -1#89#87#exact -1#90#88#exact -1#91#89#exact -1#92#90#exact -1#93#91#exact -1#94#92#exact 


Tree-structured CRFs ( T-CRFs ) are different from widely used linear-chain CRFs , in that the random variables are organized in a tree structure ( acyclic graph ) .
Tree-structured CRFs ( T-CRFs ) are different from widely used linear-chain CRFs in that the random variables are organized in a tree structure ( acyclic graph ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact 


Hence , we can consider them relevant in modeling the syntactic dependencies of word senses , which cannot be represented by linear structures .
Hence , we can consider them appropriate for modeling the syntactic dependencies of word senses , which cannot be represented by linear structures .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#para -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact 


In this model , the optimal label assignment / MATH for an observation sequence / MATH is then calculated by / MATH , where / MATH denotes a vertex corresponding to a word , while / MATH denotes the vertex corresponding to its parent in the dependency tree .
In this model , the optimal label assignment / MATH for an observation sequence / MATH is then calculated by / MATH , where / MATH denotes a vertex corresponding to a word while / MATH denotes the vertex corresponding to its parent in the dependency tree .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#34#exact -1#34#35#exact -1#35#36#exact -1#36#37#exact -1#37#38#exact -1#38#39#exact -1#39#40#exact -1#40#41#exact -1#41#42#exact -1#42#43#exact -1#43#44#exact -1#44#45#exact -1#45#46#exact -1#46#47#exact -1#47#48#exact 


If we interpret / MATH as the vertex associated with the preceding word in a sentence , it delineates into a linear-chain CRF .
If we interpret / MATH as the vertex associated with the preceding word in a sentence , it reduces to a linear-chain CRF .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact 


Although T-CRFs are relatively new models , they have already been applied to several NLP tasks , such as semantic role labeling and semantic annotation , proving to be useful in modeling the semantic structure of a text .
Although T-CRFs are relatively new models , they have already been applied to several NLP tasks , such as semantic role labeling and semantic annotation , proving to be useful in modeling the semantic structure of a text .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact -1#37#37#exact -1#38#38#exact 


Our model is the first application of T-CRFs to WSD .
Our model is the first application of T-CRFs to WSD .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact 


In this section , we introduce the method of building graph structures on which CRFs are constructed .
In this section , we introduce a method to build graph structures on which CRFs are constructed .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6,7#6,7#para -1#8,9#8,9#para -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact 


First , we describe how to construct a tree used in the tree-structured model .
First , we describe how to construct a tree used in the tree-structured model .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact 


Let us consider the synset-level disambiguation of the following sentence .
Let us consider the synset-level disambiguation of the following sentence .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact 


( i ) - The man destroys confidence in banks .
( i ) - The man destroys confidence in banks .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact 


In the beginning , we parse this sentence with Sagae and Tsujii 's dependency parser , which outputs parsed trees in the CoNLL-X dependency format .
At the beginning , we parse this sentence with the Sagae and Tsujii 's dependency parser , which outputs parsed trees in the CoNLL-X dependency format .
-1#21#0#lc -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#9#21#exact -1#23#22#exact -1#24#23#exact -1#25#24#exact -1#26#25#exact 


The left-hand side of Figure 2 shows the parsed tree for Sentence ( i ) , where each child-parent edge denotes a directed dependency of words , and the labels on the edges denote the dependency types .
The left-hand side of Figure 2 shows the parsed tree for Sentence ( i ) , where each child-parent edge denotes a directed dependency of words , and the labels on the edges denote the dependency types .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact -1#37#37#exact 


This dependency tree describes dependencies among all words in a sentence , including content words and function words .
This dependency tree describes dependencies among all words in a sentence , including content words and function words .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact 


However , some of these dependencies are not informative for our WSD task , because our task does not focus on the disambiguation function words .
However , some of these dependencies are not informative for our WSD task , because our task does not focus on the disambiguation function words .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact 


For example , on the right-hand side of Figure 2 , the dependencies among confidence-in-bank are split into the two dependencies confidence-in and in-bank ; hence our model cannot capture the direct dependency between confidence and bank .
For example , on the right-hand side of Figure 2 , the dependencies among confidence-in-bank are splitted into the two dependencies confidence-in and in-bank ; Hence our model cannot capture the direct dependency between confidence and bank .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#stem -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#lc -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact -1#37#37#exact 


One way to resolve this problem is to use higher-order ( semi-Markov ) dependencies , but this may drastically increase the computational cost .
One way to resolve this problem is to use higher-order ( semi-Markov ) dependencies , but this may drastically increase the computational cost .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact 


Thus , for the synset-based model , we convert the outputted dependency tree into a tree of content words , as exemplified on the right-hand side of Figure 2 .
For this reason , for the synset-based model , we convert the outputted dependency tree into a tree of content words , as exemplified on the right-hand side of Figure 2 .
-1#3#1#exact -1#4#2#exact -1#5#3#exact -1#6#4#exact -1#7#5#exact -1#8#6#exact -1#9#7#exact -1#10#8#exact -1#11#9#exact -1#12#10#exact -1#13#11#exact -1#14#12#exact -1#15#13#exact -1#16#14#exact -1#17#15#exact -1#18#16#exact -1#19#17#exact -1#20#18#exact -1#21#19#exact -1#22#20#exact -1#23#21#exact -1#24#22#exact -1#25#23#exact -1#26#24#exact -1#27#25#exact -1#28#26#exact -1#29#27#exact -1#30#28#exact -1#31#29#exact 


In this process , the function words are removed from the tree , and their parent and child vertices are directly connected with the dependency labels of the uppermost edge in the original tree .
In this process , the function words are removed from the tree , and their parent and child vertices are directly connected with the dependency labels of the uppermost edge in the original tree .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact 


Then , on the right-hand side of Figure 2 , the dependency between confidence and bank is now described as a direct edge .
Then , on the right-hand side of Figure 2 , we can see that the dependency between confidence and bank is now described as a direct edge .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#14#10#exact -1#15#11#exact -1#16#12#exact -1#17#13#exact -1#18#14#exact -1#19#15#exact -1#20#16#exact -1#21#17#exact -1#22#18#exact -1#23#19#exact -1#24#20#exact -1#25#21#exact -1#26#22#exact -1#27#23#exact 


By the compaction of the trees , therefore , our model can capture more useful dependencies among word senses .
Thus , by the compaction of the trees , our model can capture more useful dependencies among word senses .
-1#2#0#lc -1#3#1#exact -1#4#2#exact -1#5#3#exact -1#6#4#exact -1#7#5#exact -1#8#6#exact -1#0#7#syn -1#1#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact 


For the supersense-based model , we further convert the tree into a tree of nouns and verbs , because supersenses are defined for only these two parts of speech .
Note that for the supersense-based model , we further convert the tree into a tree of nouns and verbs , because supersenses are defined for only these two parts of speech .
-1#2#0#lc -1#3#1#exact -1#4#2#exact -1#5#3#exact -1#6#4#exact -1#7#5#exact -1#8#6#exact -1#9#7#exact -1#10#8#exact -1#11#9#exact -1#12#10#exact -1#13#11#exact -1#14#12#exact -1#15#13#exact -1#16#14#exact -1#17#15#exact -1#18#16#exact -1#19#17#exact -1#20#18#exact -1#21#19#exact -1#22#20#exact -1#23#21#exact -1#24#22#exact -1#25#23#exact -1#26#24#exact -1#27#25#exact -1#28#26#exact -1#29#27#exact -1#30#28#exact -1#31#29#exact 


The inclusion of removed words and dependency relation labels are performed in the same manner as in the synset-based model ; the tree on the right hand side of Figure 2 in this case remains unchanged , because the sentence does not contain any adjectives nor adverbs .
The inclusion of removed words and dependency relation labels are performed in the same manner as in the synset-based model , and the tree on the right hand side of Figure 2 in this case remains unchanged because the sentence does not contain any adjectives nor adverbs .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#22#21#exact -1#23#22#exact -1#24#23#exact -1#25,26,27,28#24,25,26#para -1#29#28#exact -1#30#29#exact -1#31#30#exact -1#32#31#exact -1#33#32#exact -1#34#33#exact -1#35#34#exact -1#36#35#exact -1#20#36#exact -1#37#37#exact -1#38#38#exact -1#39#39#exact -1#40#40#exact -1#41#41#exact -1#42#42#exact -1#43#43#exact -1#44#44#exact -1#45#45#exact -1#46#46#exact -1#47#47#exact 


For the linear-chain models , parsing a sentence is unnecessary .
For the linear-chain models , we do not need to parse a sentence .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#10#5#stem -1#11#6#exact -1#12#7#exact -1#7#9#para -1#13#10#exact 


At first , we connect every adjacent words with an edge , and build a linear chain .
At first , we connect every adjacent words with an edge , and build a linear chain .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact 


Next , as the same reason as for the tree-structured case , we remove those words that we do not need to disambiguate from the graph , in order to capture the direct dependencies between content words ( or nouns and verbs in the supersense-based model ) .
Next , as the same reason for the tree-structured case , we remove from the graph those words that we do not need to disambiguate , in order to capture the direct dependencies between content words ( or nouns and verbs in the supersense-based model ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#16#14#exact -1#17#15#exact -1#18,19,20,21,22,23#16,17,18,19,20#para -1#28#21#exact -1#24#22#exact -1#13#23#exact -1#14#24#exact -1#15#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact -1#29#30#exact -1#30#31#exact -1#31#32#exact -1#32#33#exact -1#33#34#exact -1#34#35#exact -1#35#36#exact -1#36#37#exact -1#37#38#exact -1#38#39#exact -1#39#40#exact -1#40#41#exact -1#41#42#exact -1#42#43#exact -1#43#44#exact -1#44#45#exact -1#45#46#exact -1#46#47#exact 


Thus , the process of the tree compaction[ ? ?] is performed in the same manner , as described in Figure 3 .
Thus , the process of the tree compaction is performed in the same manner , as described in Figure 3 .
-1#0#0#exact -1#1#1#exact -1#2,3,4,5#2,3,4#para -1#11#5#exact -1#6#6#exact -1#8#10#exact -1#9#11#exact -1#10#12#exact -1#12#14#exact -1#13#15#exact -1#14#16#exact -1#15#17#exact -1#16#18#exact -1#17#19#exact -1#18#20#exact -1#19#21#exact -1#20#22#exact 


In this section , let us present an intuitive illustration of how our model works .
In this section , let us present an intuitive illustration of how our model works .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact 


Here , we focus on three words : destroy , confidence , and bank in Sentence ( I ) . For simplicity , we consider only two major senses for each word as described in Table 3 , so that the number of possible sense assignments is / MATH .
Here , we focus on three words destroy , confidence , and bank in Sentence ( i ) , and for simplicity consider only two major senses for each word as described in Table 3 , so that the number of possible sense assignments is in this case / MATH .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#lc -1#17#18#exact -1#50#19#exact -1#20#20#lc -1#21#21#exact -1#18#22#exact -1#22#24#exact -1#23#25#exact -1#24#26#exact -1#25#27#exact -1#26#28#exact -1#27#29#exact -1#28#30#exact -1#29#31#exact -1#30#32#exact -1#31#33#exact -1#32#34#exact -1#33#35#exact -1#34#36#exact -1#35#37#exact -1#36#38#exact -1#38,39,40#39,40,41,42#para -1#41#43#exact -1#42#44#exact -1#43#45#exact -1#44#46#exact -1#48#47#exact -1#49#48#exact 


After an appropriate compaction of the dependency tree , relationships among destroy , confidence , and bank , are represented as direct connections .
After an appropriate compaction of the dependency tree , relationships among destroy , confidence , and bank , are represented as direct connections .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact 


Now , our objective is to determine the correct assignment of senses to these words , given the trained weight vector for features .
Now , our objective is to determine the correct assignment of senses to these words , given the trained weight vector for features .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact 


We conduct this by evaluating the scores for all possible assignment of senses .
We conduct this by evaluating the scores for all possible assignment of senses .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact 


Let us start from the dependency between confidence and bank .
Let us start from the dependency between confidence and bank .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact 


The first intuition would be that confidence( n )#2 is strongly related to a group or an institution ( financial bank ) , but is unrelated to a natural landscape ( river bank ) , while confidence( n )#1 depends mostly on persons and not on other entities .
The first intuition would be that confidence( n )#2 is strongly related to a group or an institution ( financial bank ) but not related to natural landscape ( river bank ) , while confidence( n )#1 depends mostly on persons and not on other entities .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#32#22#exact -1#22#23#exact -1#37#24#para -1#23,24,25#25,26#para -1#26#27,28#para -1#27#29#exact -1#28#30#exact -1#29#31#exact -1#30#32#exact -1#31#33#exact -1#33#35#exact -1#34#36#exact -1#35#37#exact -1#36#38#exact -1#38#40#exact -1#39#41#exact -1#40#42#exact -1#41#43#exact -1#42#44#exact -1#43#45#exact -1#44#46#exact -1#45#47#exact -1#46#48#exact 


Because bank does not have a " person " meaning , the weight of confidence( n )#2-bank( n )#1 is expected to be higher than for other possible sense bigrams .
Because bank does not have a " person " meaning , the weight of confidence( n )#2-bank( n )#1 is expected to be higher than other possible sense bigrams .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19,20#19,20,21,22#para -1#23#23#exact -1#24#24#exact -1#25#25,26#para -1#26#27#exact -1#27#28#exact -1#28#29#exact -1#29#30#exact 


A similar argument can be made for the dependency between destroy and confidence .
A similar argument can be made for the dependency between destroy and confidence .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4,5#4,5,6,7#para -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact 


We can assume that destroy( v )#1 is usually associated with real objects , whereas destroy( v )#2 can take either a real entity or an abstract thing as its direct object .
We can assume that destroy( v )#1 is usually associated with real objects , whereas destroy( v )#2 can take either a real entity or an abstract thing as its direct object .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact 


Given confidence does not have an " object " meaning , the weights of destroy( v )#2-confidence( n )#1 and destroy( v )#2-confidence( n )#2 would be the largest [largest what ?] among others .
Given confidence does not have an " object " meaning , the weights of destroy( v )#2-confidence( n )#1 and destroy( v )#2-confidence( n )#2 would be the largest among others .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#32#exact -1#30#33#exact -1#31#34#exact 


Finally , given all scores for these sense dependencies , we can evaluate the overall score for the sentence , and see / MATHdestroy( v )#2 , confidence( n )#2 , bank( n )#1 / MATH is the most probable assignment of senses .
Finally , given all scores for these sense dependencies , we can evaluate the overall score for the sentence , and see / MATHdestroy( v )#2 , confidence( n )#2 , bank( n )#1 / MATH is the most probable assignment of senses .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact -1#37#37#exact -1#38#38#exact -1#39#39#exact -1#40#40#exact -1#41#41#exact -1#42#42#exact -1#43#43#exact 


Practically , specific bigrams of synsets such as confidence( n )#2-bank( n )#1 and destroy( v )#2-confidence( n )#2 may not appear in the training data .
Practically , specific bigrams of synsets such as confidence( n )#2-bank( n )#1 and destroy( v )#2-confidence( n )#2 may not appear in the training data .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact 


In this case , sense bigrams combined with coarser sense labels work effectively .
In this case , sense bigrams combined with coarser sense labels work effectively .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact 


For example , if there are synset bigrams such as destroy( v )#2-affection( n )#1 in the training data , the model can still perform the disambiguation process properly by considering a generalized synset-supersense bigram destroy( v )#2-noun .feeling .
For example , if there exist synset bigrams such as destroy( v )#2-affection( n )#1 in the training data , the model can still perform the disambiguation process properly by considering a generalized synset-supersense bigram destroy( v )#2-noun .feeling .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#syn -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact -1#37#37#exact -1#38#38#exact -1#39#39#exact 


The detailed description of sense bigrams are provided in Section 4 .7 .
The detailed description of sense bigrams are given in Section 4 .7 .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact 


Using the information in the WordNet , we make use of four sense labels for each word : a synset / MATH , two general synsets / MATH and / MATH , and a supersense / MATH , which we introduced in Section 2 .
Using the information in the WordNet , we make use of four sense labels for each word : a synset / MATH , two general synsets / MATH and / MATH , and a supersense / MATH , which we introduced in Section 2 .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7,8,9,10#7,8,9#para -1#11#10,11#para -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact -1#37#37#exact -1#38#38#exact -1#39#39#exact -1#40#40#exact -1#41#41#exact -1#42#42#exact -1#43#43#exact -1#44#44#exact 


These labels represent word senses at various levels , and are to be combined with the vertex and edge features .
These labels represent word senses at various levels , and to be combined with the vertex and edge features .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#11#10,11#para -1#12,13#12,13,14#para -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact 


We hereafter distinguish each sense label by putting one of the prefixes WS , G1 , G2 , and SS , as in WS :bank#1 and SS :noun .group .
We hereinafter distinguish each sense label by putting one of the prefixes WS , G1 , G2 , and SS , as in WS :bank#1 and SS :noun .group .
-1#0#0#exact -1#1#1#syn -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact 


The examples of these sense labels are shown in Table 4 .
The examples of these sense labels are shown in Table 4 .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact 


In our model , we combine the synset and supersense labels with the vertex features , and all four sense labels with the edge features .
In our model , we combine the synset and supersense labels with the vertex features , and all four sense labels with the edge features .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact 


We denote the set of sense labels for vertex features by / MATH , and the one for edge features by / MATH .
We denote the set of sense labels for vertex features by / MATH , and the one for edge features by / MATH .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact 


Each of these sense labels is combined with the contextual information in the vertex features , whereas all possible combinations of two sense labels comprise the edge features .
Each of these sense labels is combined with the contextual information in the vertex features , whereas all possible combinations of two sense labels comprise the edge features .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact 


We implement as vertex features a set of typical contextual features widely used in many supervised WSD models .
We implement as vertex features a set of typical contextual features widely used in a lot of supervised WSD models .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#17#15#exact -1#18#16#exact -1#19#17#exact -1#20#18#exact 


Most of these features are those used by with the exception of the syntactic features .
Most of these features are those used by with the exception of the syntactic features .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8,9,10,11#8,9,10,11,12#para -1#13#13#exact -1#14#14#exact -1#15#15#exact 


In order to see the efficiency of sense dependency features , we include as vertex features the word forms , lemmas , and parts of speech of both the parent and the child words in the dependency tree .
In order to see whether the sense dependency features are certainly effective or not , we include as vertex features the word forms , lemmas , and parts of speech of both the parent and the child words in the dependency tree .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#5#4#exact -1#11#5,6#para -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#14#10#exact -1#15#11#exact -1#16#12#exact -1#17#13#exact -1#18#14#exact -1#19#15#exact -1#20#16#exact -1#21#17#exact -1#22#18#exact -1#23#19#exact -1#24#20#exact -1#25#21#exact -1#26#22#exact -1#27#23#exact -1#28#24#exact -1#29#25#exact -1#30#26#exact -1#31#27#exact -1#32#28#exact -1#33#29#exact -1#34#30#exact -1#35#31#exact -1#36#32#exact -1#37#33#exact -1#38#34#exact -1#39#35#exact -1#40#36#exact -1#41#37#exact -1#42#38#exact 


These features provide the syntactic information of the parent and child words , but are not semantically disambiguated .
These features provide the syntactic information of the parent and child words , but are not semantically disambiguated .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact 


Therefore , if the sense bigram features work effectively over these features , it clearly shows that there exist instances that cannot be disambiguated without considering the interdependency of word senses .
Therefore , if the sense bigram features work effectively over these features , it clearly shows that there exist instances that cannot be disambiguated without considering the interdependency of word senses .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact 


The list of vertex features also includes the information of both the preceding and following words , which in the linear-chain model plays the same role as the parent and child information in the tree-structured model .
The list of vertex features also includes the information of both the preceding and following words , which in the linear-chain model plays the same role as the parent and child information in the tree-structured model .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact 


Below is the list of contextual information used for the vertex features in the synset-based model .
Below is the list of contextual information used for the vertex features in the synset-based model .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact 


We refer to these features as / MATH .
We refer to these features as / MATH .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact 


- Word form ( WF ) : word form as it appears in a text .
- Word form ( WF ) : word form as it appears in a text .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact 


- Global context ( GC ) : bag-of-words within a 60-word window .
- Global context ( GC ) : bag-of-words within a 60-word window .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact 


- Local PoS ( LP ) : / MATH , / MATH , / MATH , / MATH , / MATH , / MATH , and / MATH , where / MATH in / MATH denotes the relative position to the target word .
- Local PoS ( LP ) : / MATH , / MATH , / MATH , / MATH , / MATH , / MATH , and / MATH , where / MATH in / MATH denotes the relative position to the target word .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact -1#37#37#exact -1#38#38#exact -1#39#39#exact -1#40#40#exact -1#41#41#exact -1#42#42#exact -1#43#43#exact 


- Local context ( LC ) : / MATH , / MATH , / MATH , / MATH , / MATH , / MATH , / MATH , / MATH , / MATH , / MATH , / MATH , and / MATH , where / MATH denotes the word at the relative position / MATH , and / MATH the n-gram from the relative position / MATH to / MATH .
- Local context ( LC ) : / MATH , / MATH , / MATH , / MATH , / MATH , / MATH , / MATH , / MATH , / MATH , / MATH , / MATH , and / MATH , where / MATH denotes the word at the relative position / MATH , and / MATH the n-gram from the relative position / MATH to / MATH .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact -1#37#37#exact -1#38#38#exact -1#39#39#exact -1#40#40#exact -1#41#41#exact -1#42#42#exact -1#43#43#exact -1#44#44#exact -1#45#45#exact -1#46#46#exact -1#47#47#exact -1#48#48#exact -1#49#49#exact -1#50#50#exact -1#51#51#exact -1#52#52#exact -1#53#53#exact -1#54#54#exact -1#55#55#exact -1#56#56#exact -1#57#57#exact -1#58#58#exact -1#59#59#exact -1#60#60#exact -1#61#61#exact -1#62#62#exact -1#63#63#exact -1#64#64#exact -1#65#65#exact -1#66#66#exact -1#67#67#exact -1#68#68#exact -1#69#69#exact -1#70#70#exact -1#71#71#exact 


- Syntactic context ( SC ) : word forms , lemmas , and parts of speech of the parent and child words .
- Syntactic context ( SC ) : word forms , lemmas , and parts of speech of the parent and child words .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact 


Using this contextual information , and the set of vertex labels / MATH , we construct a set of features on a vertex / MATH by / MATH .
Using this contextual information and the set of vertex labels / MATH , we construct a set of features on a vertex / MATH by / MATH .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#12#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact 


Additionally , we include the sense ranking feature ( see Section 2 .3 for detail ) .
Additionally , we include the sense ranking feature ( see Section 2 .3 for detail ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact 


Note that this feature is not combined with any sense label nor with any contextual information .
Note that this feature is not combined with any sense labels nor contextual information .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#stem -1#11#11#exact -1#12#14#exact -1#13#15#exact -1#14#16#exact 


For the supersense-based model , we use vertex features based on , which include some features from the named entity recognition literature , including the word shape features , along with the standard feature set for WSD .
For the supersense-based model , we use vertex features based on , which includes some features from the named entity recognition literature such as the word shape features along with the standard feature set for WSD .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#stem -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#29#exact -1#29#30#exact -1#30#31#exact -1#31#32#exact -1#32#33#exact -1#33#34#exact -1#34#35#exact -1#35#36#exact -1#36#37#exact 


As the sense frequency information , we use the first sense feature .
As the sense frequency information , we use the first sense feature .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact 


Unlike in the synset-based model , we do not incorporate the syntactic information of the parent and child words , since it has not been reported to improve the performance .
Unlike in the synset-based model , we do not incorporate the syntactic information of the parent and child words , since it has been reported not to improve the performance .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#22,23#21,22,23,24#para -1#24#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact 


We design a set of edge features that represents the inter-word sense dependencies .
We design a set of edge features that represents the inter-word sense dependencies .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact 


For each edge , we define the sense bigram features / MATH .
For each edge , we define the sense bigram features / MATH .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact 


Moreover , in addition to these simple bigrams , we define two kinds of combined bigrams : the sense bigrams with dependency relation labels ( e.g. WS :confidence#2-( NMOD )-WS :bank#1 ) , and the sense bigrams with removed words in between ( e.g. WS :confidence#2-in-WS :bank#1 ) .
Moreover , in addition to these simple bigrams , we define two kinds of combined bigrams : the sense bigrams with dependency relation labels ( e.g. WS :confidence#2-( NMOD )-WS :bank#1 ) , and the sense bigrams with removed words in between ( e.g. WS :confidence#2-in-WS :bank#1 ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact -1#37#37#exact -1#38#38#exact -1#39#39#exact -1#40#40#exact -1#41#41#exact -1#42#42#exact -1#43#43#exact -1#44#44#exact -1#45#45#exact -1#46#46#exact -1#47#47#exact -1#48#48#exact 


Consequently , the number of features for each edge is / MATH .
Consequently , the number of features for each edge is / MATH .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact 


In this section , we introduce corpora that we have used for the evaluation .
In this section , we introduce corpora we use for the evaluation .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#8#exact -1#8#9,10#para -1#9#11#exact -1#10#12#exact -1#11#13#exact -1#12#14#exact 


SemCor is a corpus in which all content words are annotated with the WordNet synsets , and consists of balanced 352 files from the Brown Corpus .
SemCor is a corpus , in which all content words are annotated with the WordNet synsets , and consists of balanced 352 files from the Brown Corpus .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#5#4#exact -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact -1#23#22#exact -1#24#23#exact -1#25#24#exact -1#26#25#exact -1#27#26#exact 


It is divided into three parts : brown1 , brown2 , and brownv sections .
It is divided into three parts : brown1 , brown2 , and brownv sections .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact 


In brown1 and brown2 , all content words ( nouns , verbs , adjectives , and adverbs ) are semantically annotated , while in brownv only verbs are annotated .
In brown1 and brown2 , all content words ( nouns , verbs , adjectives , and adverbs ) are semantically annotated , while in brownv only verbs are annotated .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact 


Also , we use two data sets from the Senseval ( International Workshop on Evaluating Word Sense Disambiguation Systems ) exercises : the Senseval-2 English all-words task test set , consisting of three articles from the Wall Street Journal , and the Senseval-3 English all-words task test set , consisting of two articles from the Wall Street Journal and a fiction excerpt from the unannotated portion of the Brown corpus .
Also , we use two data sets from the Senseval ( International Workshop on Evaluating Word Sense Disambiguation Systems ) exercises : the Senseval-2 English all-words task test set , consisting of three articles from the Wall Street Journal , and the Senseval-3 English all-words task test set , consisting of two articles from the Wall Street Journal and a fiction excerpt from the unannotated portion of the Brown corpus .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#36,37,38#35,36,37,38#para -1#39#39#exact -1#40#40#exact -1#41#41#exact -1#42#42#exact -1#43#43#exact -1#44#44#exact -1#45#45#exact -1#46#46#exact -1#47#47#exact -1#48#48#exact -1#49#49#exact -1#50#50#exact -1#51#51#exact -1#52#52#exact -1#53#53#exact -1#55,56,57#54,55,56,57#para -1#58#58#exact -1#59#59#exact -1#60#60#exact -1#61#61#exact -1#62#62#exact -1#63#63#exact -1#64#64#exact -1#65#65#exact -1#66#66#exact -1#67#67#exact -1#68#68#exact -1#69#69#exact -1#70#70#exact 


As the data sets for evaluation , we use the brown1 and brown2 sections ( denoted as SEM ) of SemCor , and the Senseval-2 and -3 all-words task test sets ( denoted as SE2 and SE3 , respectively ) .
As the data sets for evaluation , we use the brown1 and brown2 sections ( denoted as SEM ) of SemCor , and the Senseval-2 and -3 all-words task test sets ( denoted as SE2 and SE3 , respectively ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact -1#37#37#exact -1#38#38#exact -1#39#39#exact -1#40#40#exact 


We use the converted versions annotated with WordNet 2 .0 synsets .
We use the converted versions annotated with WordNet 2 .0 synsets .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact 


These data sets are different from the originals because multi-word expressions are already segmented .
Note that these data sets are different from the originals in that multi-word expressions are already segmented .
-1#2#0#lc -1#3#1#exact -1#4#2#exact -1#5#3#exact -1#6#4#exact -1#7#5#exact -1#8#6#exact -1#9#7#exact -1#12#9#exact -1#13#10#exact -1#14#11#exact -1#15#12#exact -1#16#13#exact -1#17#14#exact 


However , our model cannot output any answers to multi-word expressions that have no directly corresponding WordNet synsets , because we treat expression as one unit in the process of WSD .
However , on the other hand , our model cannot output any answers to multi-word expressions that have no directly corresponding WordNet synsets , because we treat expression as one unit in the process of WSD .
-1#0#0#exact -1#1#1#exact -1#7#2#exact -1#8#3#exact -1#9#4#exact -1#10#5#exact -1#11#6#exact -1#12#7#exact -1#13#8#exact -1#14#9#exact -1#15#10#exact -1#16#11#exact -1#17#12#exact -1#18#13#exact -1#19#14#exact -1#20#15#exact -1#21#16#exact -1#22#17#exact -1#23#18#exact -1#24#19#exact -1#25#20#exact -1#26#21#exact -1#27#22#exact -1#28#23#exact -1#29#24#exact -1#30#25#exact -1#32,33,34#26,27,28,29#para -1#35#30#exact -1#36#31#exact 


For example , the multi-word expression tear-filled is treated as one instance , but are untagged with any WordNet synsets in the converted corpus , while in the original corpus it[define " it " ] is tagged with two WordNet synsets for tear and filled .
For example , the multi-word expression tear-filled is treated as one instance but not tagged with any WordNet synsets in the converted corpus , while in the original corpus it is tagged with two WordNet synsets for tear and filled .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#23#12#exact -1#12#13#exact -1#30#14#syn -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact -1#28#29#exact -1#29#32#exact -1#14#36#exact -1#32#37#exact -1#33#38#exact -1#34#39#exact -1#35#40#exact -1#36#41#exact -1#37#42#exact -1#38#43#exact -1#39#44#exact -1#40#45#exact 


For this reason , we exclude such instances beforehand , and evaluate our models focused on expressions that have corresponding synsets in the WordNet .
For this reason , we exclude such instances beforehand , and evaluate our models focused on expressions that have corresponding synsets in the WordNet .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact 


The resulting statistics of the data sets are shown in Table 5 .
The resulting statistics of the data sets are shown in Table 5 .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact 


The evaluation of our model is performed by splitting these corpora into training , development , and test sets .
The evaluation of our model is performed by splitting these corpora into training , development , and test sets .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact 


At first , all files in SEM are sorted according to their file names and distributed into five data sets in order ( denoted as SEM-A , SEM-B , SEM-C , SEM-D , and SEM-E ) , so that each set has almost the same distribution of domains .
At first , all files in SEM are sorted according to their file names and distributed into five data sets in order ( denoted as SEM-A , SEM-B , SEM-C , SEM-D , and SEM-E ) , so that each set has almost the same distribution of domains .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact -1#37#37#exact -1#38#38#exact -1#39#39#exact -1#40#40#exact -1#41#41#exact -1#42#42#exact -1#43#43#exact -1#44#44#exact -1#45#45#exact -1#46#46#exact -1#47#47#exact -1#48#48#exact 


Furthermore , each of these five data sets is again split into two sets : SEM-A1 , SEM-A2 , / MATH , SEM-E1 , and SEM-E2 , also according to the order of file names .
Furthermore , each of these five data sets is again split into two sets : SEM-A1 , SEM-A2 , / MATH , SEM-E1 , and SEM-E2 , also according to the order of file names .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact 


Our evaluation is based on a 5-fold cross validation scheme .
Our evaluation is based on a 5-fold cross validation scheme .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact 


In the training phase , four sets ( e.g. SEM-A , SEM-B , SEM-C , SEM-D ) in the SEM are used for training .
In the training phase , four sets ( e.g. SEM-A , SEM-B , SEM-C , SEM-D ) in the SEM are used for training .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact 


Next , for the evaluation on SemCor , one half of the rest ( e.g. SEM-E1 ) is used for development and the other half ( e.g. SEM-E2 ) is used for evaluation .
Next , for the evaluation on SemCor , one half of the rest ( e.g. SEM-E1 ) is used for development and the other half ( e.g. SEM-E2 ) is used for evaluation .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#9,10,11#8,9,10,11#para -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact 


For the evaluation on the Senseval data sets , all instances of the rest ( e.g. SEM-E ) are used for development , and one of the Senseval data sets ( SE2 or SE3 ) is used for evaluation .
For the evaluation on the Senseval data sets , all instances of the rest ( e.g. SEM-E ) is used for development and one of the Senseval data sets ( SE2 or SE3 ) is used for evaluation .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18,19#18,19#para -1#20#20#exact -1#21#21#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact -1#28#29#exact -1#29#30#exact -1#30#31#exact -1#31#32#exact -1#32#33#exact -1#33#34#exact -1#34#35#exact -1#35#36#exact -1#36#37#exact -1#37#38#exact -1#38#39#exact 


Lastly , for the comparison with state-of-the-art models , our model is trained on the whole set of SEM , and SE2 and SE3 are used for development and evaluation respectively .
Lastly , for the comparison with state-of-the-art models , our model is trained on the whole set of SEM , and SE2 and SE3 are used for development and evaluation respectively .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact 


All sentences are parsed by the Sagae and Tsujii 's dependency parser , and the T-CRF model is trained by using Amis .
All sentences are parsed by the Sagae and Tsujii 's dependency parser , and the T-CRF model is trained by using Amis .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact 


During the development phase , we tune the Gaussian parameter / MATH for the / MATH regularization term .
During the development phase , we tune the Gaussian parameter / MATH for the / MATH regularization term .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact 


As the evaluation measure , we use the standard recall measure , which is equivalent to the precision as we output answers to all instances . **[This section is a bit monotonous]
As the evaluation measure , we use the standard recall measure , which is equivalent to the precision as we output answers to all instances .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact 


The synset-based evaluation is performed based on the WordNet synsets .
The synset-based evaluation is performed based on the WordNet synsets .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact 


We evaluate the outputs of our system for all instances that are semantically tagged in the data sets .
We evaluate the outputs of our system for all instances that are semantically tagged in the data sets .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact 


Each target word is either a noun , verb , adjective , or adverb .
Each target word is either a noun , verb , adjective , or adverb .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact 


For the supersense-based evaluation , we follow most of the experimental setup in .
For the supersense-based evaluation , we follow most of the experimental setup in .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact 


As noted , in the WordNet , the labeling of supersensesis semantically inconsistent , and top level synsets are tagged as the supersense noun .Tops[ ? ?] rather than the specific supersense they govern .
As they noted , in the WordNet , there is semantically inconsistent labeling of supersenses such that top level synsets are tagged as the supersense noun .Tops rather than the specific supersense they govern .
-1#0#0#exact -1#2#1#exact -1#3#2#exact -1#4#3#exact -1#5#4#exact -1#6#5#exact -1#7#6#exact -1#23#7#exact -1#12#8#exact -1#13#9#exact -1#10#11#exact -1#11#12#exact -1#17#15#exact -1#18#16#exact -1#19#17#exact -1#20#18#exact -1#21#19#exact -1#22#20#exact -1#29#21#exact -1#24#22#exact -1#25#23#exact -1#27#27#exact -1#28#28#exact -1#30#29,30#para -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact 


For example , nouns such as peach and plum are tagged as noun .plant but their hypernym plant itself belongs to noun .Tops .
For example , nouns such as peach and plum are tagged as noun .plant but their hypernym plant itself belongs to noun .Tops .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact 


For this reason , we adopted the modification of noun supersenses in the same way as , substituting noun .Tops labels with more specific supersense labels when possible , and left some general nouns with noun .TopsoteNouns , which are left with noun .Tops are : entity , thing , anything , something , nothing , object , living thing , organism , benthos , heterotroph , life , and biont . .
For this reason , we adopted the modification of noun supersenses in the same way as , substituting noun .Tops labels with more specific supersense labels when possible , and left some general nouns with noun .TopsoteNouns which are left with noun .Tops are : entity , thing , anything , something , nothing , object , living thing , organism , benthos , heterotroph , life , and biont . .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#12,13,14,15#11,12,13,14,15#para -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact -1#46#37#exact -1#37#38#exact -1#38#39#exact -1#39#40#exact -1#40#41#exact -1#41#42#exact -1#42#43#exact -1#43#44#exact -1#44#45#exact -1#45#46#exact -1#48#47#exact -1#47#48#exact -1#50#49#exact -1#49#50#exact -1#52#51#exact -1#51#52#exact -1#54#53#exact -1#53#54#exact -1#56#55#exact -1#55#56#exact -1#59#57#exact -1#57#58#exact -1#58#59#exact -1#61#60#exact -1#60#61#exact -1#63#62#exact -1#62#63#exact -1#65#64#exact -1#64#65#exact -1#67#66#exact -1#66#67#exact -1#68#69#exact -1#69#70#exact -1#70#71#exact -1#71#72#exact 


The evaluation is based on these modified labels .
The evaluation is based on these modified labels .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact 


We ignore the adjective and adverb instances in the evaluation .**[This section is a bit confusing . Maybe break up the longer sentences to clarify]
We ignore the adjective and adverb instances in the evaluation .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#16#exact 


Table 6 is the list of models that we use for the evaluation , where FS and SR correspond to the first sense and sense ranking features respectively , and non-dependency denotes models that do not incorporate sense dependency features ( i.e.
Table 6 is the list of models we use for the evaluation , where FS and SR correspond to the first sense and sense ranking features respectively , and non-dependency denotes models that do not incorporate sense dependency features ( i.e.
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7,8#7,8,9#para -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact -1#28#29#exact -1#29#30#exact -1#30#31#exact -1#31#32#exact -1#32#33#exact -1#33#34#exact -1#34#35#exact -1#35#36#exact -1#36#37#exact -1#37#38#exact -1#38#39#exact -1#39#40#exact -1#40#41#exact 


only the vertex features ) .
only the vertex features ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact 


In this section , we focus on the contribution of the sense dependencies .
In this section , we focus on the contribution of the sense dependencies .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7,8,9#7,8,9,10#para -1#11#11#exact -1#12#12#exact -1#13#13#exact 


Table 7 shows the comparisons between the tree-structured models with sense dependencies ( dependency models ) and the models without sense dependencies ( non-dependency models ) .
Table 7 shows the comparisons between the tree-structured models with sense dependencies ( dependency models ) and the models without sense dependencies ( non-dependency models ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact 


Each figure displays the mean recall ( equivalent to the precisions ) averaged over the five trials of the cross validation , the " Diff . " rows show the differences between the dependency models and the non-dependency models , and / MATH and / MATH denote the statistical significance of / MATH and / MATH respectively .
In this section , each figure shows the mean recall ( equivalent to the precisions ) averaged over the five trials of the cross validation , the " Diff . " rows show the differences between the dependency models and the non-dependency models , and / MATH and / MATH denote the statistical significance of / MATH and / MATH respectively .
-1#4#0#lc -1#5#1#exact -1#6#2#syn -1#7#3#exact -1#8#4#exact -1#9#5#exact -1#10#6#exact -1#11#7#exact -1#12#8#exact -1#13#9#exact -1#14#10#exact -1#15#11#exact -1#16#12#exact -1#17#13#exact -1#18#14#exact -1#19#15#exact -1#20#16#exact -1#21#17#exact -1#22#18#exact -1#23#19#exact -1#24#20#exact -1#25#21#exact -1#26#22#exact -1#27#23#exact -1#28#24#exact -1#29#25#exact -1#30#26#exact -1#31#27#exact -1#32#28#exact -1#33,34,35,36#29,30,31#para -1#51#32#exact -1#37#33#exact -1#38#34#exact -1#39#35#exact -1#40#36#exact -1#41#37#exact -1#42#38#exact -1#43#39#exact -1#44#40#exact -1#45#41#exact -1#46#42#exact -1#47#43#exact -1#48#44#exact -1#49#45#exact -1#50#46#exact -1#52#47,48#para -1#53#49#exact -1#54#50#exact -1#55#51#exact -1#56#52#exact -1#57#53#exact -1#58#54#exact -1#59#55#exact -1#60#56#exact -1#61#57#exact 


From Table 7 , it can be seen that with the sense frequency information , the tree-structured models ( statistically ) significantly outperformed the non-dependency models on all the data sets .
We can see from Table 7 that with the sense frequency information , the tree-structured models ( statistically ) significantly outperformed the non-dependency models on all the data sets .
-1#3#0#lc -1#4#1#exact -1#5#2#exact -1#12#3#exact -1#1#5#exact -1#2#6,7#para -1#6#8#exact -1#7#9#exact -1#8#10#exact -1#9#11#exact -1#10#12#exact -1#11#13#exact -1#13#15#exact -1#14#16#exact -1#15#17#exact -1#16#18#exact -1#17#19#exact -1#18#20#exact -1#19#21#exact -1#20#22#exact -1#21#23#exact -1#22#24#exact -1#23#25#exact -1#24#26#exact -1#25#27#exact -1#26#28#exact -1#27#29#exact -1#28#30#exact -1#29#31#exact 


These improvements seem insignificant in figures ; however , considering that for instance the No-Dep-SS-FS model outperforms the Baseline-SS-FS model by only 0 .37% on SEM , the further improvement of 0 .21% is substantial , because it indicates that our dependency model could handle 57% more instances over the first sense baseline .
These improvements seem small in terms of figures ; However , considering for instance the No-Dep-SS-FS model outperforms the Baseline-SS-FS model only by 0 .37% on SEM , the further improvement of 0 .21% is considerable because this means our dependency model could handle 57% more instances over the first sense baseline .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#para -1#4#4#exact -1#7#5#exact -1#8#6#exact -1#9#7#lc -1#10#8#exact -1#11#9#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#22#20#exact -1#21#21#exact -1#23#22#exact -1#24#23#exact -1#25#24#exact -1#26#25#exact -1#27#26#exact -1#28#27#exact -1#29#28#exact -1#30#29#exact -1#31#30#exact -1#32#31#exact -1#33#32#exact -1#34#33#exact -1#35#34#para -1#36,37#36,37#para -1#39#40#exact -1#40#41#exact -1#41#42#exact -1#42#43#exact -1#43#44#exact -1#44#45#exact -1#45#46#exact -1#46#47#exact -1#47#48#exact -1#48#49#exact -1#49#50#exact -1#50#51#exact -1#51#52#exact -1#52#53#exact 


Note that , without the sense frequency information , the synset-based tree-structured model ( Tree-WS ) performed worse than the non-dependency model ( NoDep-WS ) on all the data sets , whereas the supersense-based model ( Tree-SS ) exhibited the robustness [of ...] regardless of the existence of the sense frequency information .
Note that , without the sense frequency information , the synset-based tree-structured model ( Tree-WS ) performed poorer than the non-dependency model ( NoDep-WS ) on all the data sets , whereas the supersense-based model ( Tree-SS ) exhibited the robustness regardless of the existence of the sense frequency information .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17,18#17,18#para -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact -1#37#37#exact -1#38#38#exact -1#39#39#exact -1#40#40#exact -1#41#43#exact -1#43,44,45,46#44,45,46,47,48#para -1#47#49#exact -1#48#50#exact -1#49#51#exact -1#50#52#exact 


These results suggest that for the synset-based model , in which most synsets do not have enough instances in the training data , the combination with sense-frequency information is necessary in order to avoid the data sparseness problem .
These results suggest that for the synset-based model , in which most synsets do not have enough instances in the training data , the combination with sense-frequency information is necessary in order to avoid the data sparseness problem .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30,31,32,33#30,31,32,33,34#para -1#35#35#exact -1#36#36#exact -1#37#37#exact -1#38#38#exact 


Similarly , Table 8 shows the comparisons between the linear-chain dependency models and the non-dependency models .
Similarly , Table 8 shows the comparisons between the linear-chain dependency models and the non-dependency models .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact 


In the supersense-based evaluation , although the differences are slightly smaller than in the tree-structured models , we confirmed that the sense dependencies with the first sense features work effectively , with the overall improvements of 0 .29% , 0 .20% , and 0 .30% for the three data sets .
In the supersense-based evaluation , although the differences are slightly smaller than in the tree-structured models , we confirmed that the sense dependencies with the first sense features work effectively , with the overall improvements of 0 .29% , 0 .20% , and 0 .30% for the three data sets .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10,11,12,13#10,11,12#para -1#20#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#24#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#32#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#46#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact -1#37#37#exact -1#38#38#exact -1#39#39#exact -1#40#40#exact -1#41#41#exact -1#42#42#exact -1#43#43#exact -1#44#44#exact -1#45#45#exact -1#47#46,47#para -1#48#48#exact -1#49#49#exact -1#50#50#exact 


However , without the first sense features , no statistically significant improvement nor deterioration is observed .
However , without the first sense features , no statistically significant improvement nor deterioration is observed .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact 


In the synset-based evaluation , the overall trend is almost same as in the tree-structured case .
In the synset-based evaluation , the overall trend is almost same as in the tree-structured case .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact 


Nonetheless , by the incorporation of the sense dependencies , the improvements with the sense ranking features was even less , and the deteriorations without them[define " them " ] were even more than in the tree-structured case .
However , by the incorporation of the sense dependencies , the improvements with the sense ranking features are even smaller , and the deteriorations without them are even larger than in the tree-structured case .
-1#0#0#syn -1#1#1#exact -1#2#2#exact -1#3,4,5,6#3,4,5#para -1#13#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#22#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#syn -1#18#18#exact -1#20#20#exact -1#21#21#exact -1#31#22#exact -1#23#23#exact -1#24#24#exact -1#25#27#exact -1#26,27#30,31#para -1#28,29#32,33#para -1#30#34#exact -1#32#36#exact -1#33#37#exact -1#34#38#exact 


These results seem to suggest that the sense dependencies on the tree structures are more robust than those on the linear chains .
These results seem to suggest that the sense dependencies on the tree structures are more robust than those on the linear chains .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact 


In this section , let us focus on the difference between the tree-structured models and the linear-chain models .
In this section , let us focus on the difference between the tree-structured models and the linear-chain models .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8,9,10,11#8,9,10#para -1#15#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact 


In the results shown in Table 9 , although some of the differences are marginal , we can see that the tree-structured models outperformed the linear-chain models , focusing on the statistically significant differences .**[<-This is a confusing sentence]
In the results shown in Table 9 , although some of the differences are marginal , we can see that the tree-structured models outperformed the linear-chain models , focusing on the statistically significant differences .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16,17,18,19,20#16,17,18,19#para -1#24#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#30#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact 


Thus , although both the dependency trees and the linear chains capture useful dependencies of word senses , the dependencies on the tree structures capture more important information .
These results suggest that although both the dependency trees and the linear chains capture useful dependencies of word senses , the dependencies on the tree structures capture more important information .
-1#19#1#exact -1#4#2#exact -1#5#3#exact -1#6#4#exact -1#7#5#exact -1#8#6#exact -1#9#7#exact -1#10#8#exact -1#11#9#exact -1#12#10#exact -1#13#11#exact -1#14#12#exact -1#15#13#exact -1#16#14#exact -1#17#15#exact -1#18#16#exact -1#20#18#exact -1#21#19#exact -1#22#20#exact -1#23#21#exact -1#24#22#exact -1#25#23#exact -1#26#24#exact -1#27#25#exact -1#28#26#exact -1#29#27#exact -1#30#28#exact 


Table 10 shows the contributions of the coarse-grained labels .
Table 10 shows the contributions of the coarse-grained labels .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact 


Whereas Tree-WS-SR and Tree-WS use all four sense labels for the edge features ( / MATH ) , Tree-WS-SR' and Tree-WS' only use the synset labels ( / MATH ) . Thus , we can see the contribution of the coarse-grained sense labels .
Whereas Tree-WS-SR and Tree-WS use all four sense labels for the edge features ( / MATH ) , Tree-WS-SR' and Tree-WS' only use the synset labels ( / MATH ) , so that we can see the contribution of the coarse-grained sense labels .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#43#30#exact -1#31#31#syn -1#30#32#exact -1#34,35,36#33,34,35,36#para -1#37#37#exact -1#38#38#exact -1#39#39#exact -1#40#40#exact -1#41#41#exact -1#42#42#exact 


Although the improvements are marginal , we can see that the coarse-grained sense labels consistently did improve the performance on all the data sets , relieving the data sparseness problem .
Although the improvements are marginal , we can see that the coarse-grained sense labels did consistently improve the performance on all the data sets , relieving the data sparseness problem .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6,7,8,9,10#6,7,8,9#para -1#17#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#15#14#exact -1#14#15#exact -1#16#16#exact -1#21#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#26#21#exact -1#27#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#22#26,27#para -1#28#28#exact -1#29#29#exact -1#30#30#exact 


Since synset-based models can directly be used as supersense taggers by a simple conversion of senses , we compared the performance of the synset-based model with that of the supersense-based model .
Since synset-based models can directly be used as supersense taggers by a simple conversion of senses , we compared the performance of the synset-based model with that of the supersense-based model .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19,20,21,22#19,20,21#para -1#28#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact 


Interestingly , when evaluated at the supersense level , the synset-based models considerably outperformed the supersense-based models , with an overall improvements of 0 .69% with the sense frequency information and 1 .41% without it , as shown in Table fcomp-ws-ss-tree .
Interestingly , when evaluated at the supersense level , the synset-based models considerably outperformed the supersense-based models , with the overall improvements of 0 .69% with the sense frequency information and 1 .41% without it , as shown in Table fcomp-ws-ss-tree .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#20#19,20#para -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact -1#37#37#exact -1#38#38#exact -1#39#39#exact -1#40#40#exact -1#41#41#exact 


Thus , even though the granularity of the supersenses is sufficient for many NLP tasks , they are too coarse-grained to capture enough information for WSD models ; therefore , for the supersense-based disambiguation , we can improve the performance by considering finer-grained senses .
These results suggest that even though the granularity of the supersenses is sufficient for many NLP tasks , they are too coarse-grained to capture enough information for WSD models ; Therefore , even for the supersense-based disambiguation , we can improve the performance by considering finer-grained senses .
-1#30#0#syn -1#31#1#exact -1#4#2#exact -1#5#3#exact -1#6#4#exact -1#7#5#exact -1#8#6#exact -1#9#7#exact -1#10#8#exact -1#11#9#exact -1#12#10#exact -1#13#11#exact -1#14#12#exact -1#15#13#exact -1#16#14#exact -1#17#15#exact -1#18#16#exact -1#19#17#exact -1#20#18#exact -1#21#19#exact -1#22#20#exact -1#23#21#exact -1#24#22#exact -1#25#23#exact -1#26#24#exact -1#27#25#exact -1#28#26#exact -1#29#27#exact -1#37#29#exact -1#33#30#exact -1#34#31#exact -1#35#32#exact -1#36#33#exact -1#38#35#exact -1#39#36#exact -1#40#37#exact -1#41#38#exact -1#42#39#exact -1#43#40#exact -1#44#41#exact -1#45#42#exact -1#46#43#exact -1#47#44#exact 


Table 12 shows the comparison of our model with the state-of-the-art WSD systems .
Table 12 shows the comparison of our model with the state-of-the-art WSD systems .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact 


The evaluation here is performed with the Senseval official scorer .
The evaluation here is performed with the Senseval official scorer .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact 


Our model Tree-WS-SR outperformed the two best systems in the Senseval-3 ( Gambl and SenseLearner ) , but lagged behind PNNL by 1 .6% .
Our model Tree-WS-SR outperformed the two best systems in the Senseval-3 ( Gambl and SenseLearner ) , but lagged behind PNNL by 1 .6% .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact 


However , taking into consideration that all systems in Table 12 except for Simil-Prime utilize other sense-annotated corpora in addition to SemCor , such as the Senseval data sets or example sentences in the WordNet , and that our model cannot handle multi-word expressions that do not exist in the WordNet as noted in Section 5 .1 , we can conclude that the performance of our T-CRF model is comparable to that of state-of-the-art WSD systems . **[This is a long sentence- shorten .]
However , considering that all systems in Table 12 except for Simil-Prime utilize other sense-annotated corpora in addition to SemCor , such as the Senseval data sets or example sentences in the WordNet , and our model cannot handle multi-word expressions that do not exist in the WordNet as noted in Section 5 .1 , we can conclude that the performance of our T-CRF model is comparable to that of state-of-the-art WSD systems .
-1#0#0#exact -1#1#1#exact -1#2#2,3,4#para -1#3#5#exact -1#4#6#exact -1#5#7#exact -1#6#8#exact -1#7#9#exact -1#8#10#exact -1#9#11#exact -1#10#12#exact -1#11#13#exact -1#12#14#exact -1#13#15#exact -1#14#16#exact -1#15#17#exact -1#16#18#exact -1#17#19#exact -1#18#20#exact -1#19#21#exact -1#20#22#exact -1#21#23#exact -1#22#24#exact -1#23#25#exact -1#24#26#exact -1#25#27#exact -1#26#28#exact -1#27#29#exact -1#28#30#exact -1#29#31#exact -1#30#32#exact -1#31#33#exact -1#32#34#exact -1#33#35#exact -1#34#36#exact -1#41#37#exact -1#35#38#exact -1#36#39#exact -1#37#40#exact -1#38#41#exact -1#39#42#exact -1#40#43#exact -1#58#44#exact -1#42#45#exact -1#43,44,45,46#46,47,48#para -1#59#49#exact -1#47#50#exact -1#48#51#exact -1#49#52#exact -1#50#53#exact -1#51#54#exact -1#52#55#exact -1#53#56#exact -1#54#57#exact -1#55#58#exact -1#56#59#exact -1#57#60#exact -1#68#61#exact -1#60#62,63#para -1#61#64#exact -1#62#65#exact -1#63#66#exact -1#64#67#exact -1#65#68#exact -1#66#69#exact -1#67#70#exact -1#69#72#exact -1#70#73#exact -1#71#74#exact -1#72#75#exact -1#73#76#exact 


Table 13 shows the list of the 15 largest-weighted sense dependency features in the tree-structured , synset-based model ( Tree-WS ) .
Table 13 shows the list of the 15 largest-weighted sense dependency features in the tree-structured , synset-based model ( Tree-WS ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3,4,5,6#3,4,5#para -1#13#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact 


The list includes features associated with verb-noun relations ( e.g. SS :verb .consumption-SS :noun .food ) and noun-noun relations ( e.g. SS :noun .communication-SS :noun .communication ) , which we will describe in detail with several examples .
The list includes features associated with verb-noun relations ( e.g. SS :verb .consumption-SS :noun .food ) and noun-noun relations ( e.g. SS :noun .communication-SS :noun .communication ) , which we will describe in detail with several examples .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact -1#37#37#exact 


Hereinafter , / MATH denotes / MATH in Equation 3 , and / MATH denotes the exponential of / MATH .
Hereinafter , / MATH denotes / MATH in Equation 3 , and / MATH denotes the exponential of / MATH .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact 


We call a feature either with a positive lambda or with an alpha larger than 1 as an excitatory feature , and those features with either with a negative lambda or an alpha smaller than 1 as an inhibitory feature .
We call a feature either with a positive lambda or with an alpha larger than 1 as an excitatory feature , while that either with a negative lambda or an alpha smaller than 1 as an inhibitory feature .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#37#23#stem -1#24#24#exact -1#23#25#exact -1#26#26,27,28#para -1#27#29#exact -1#28#30#exact -1#29#31#exact -1#30#32#exact -1#31#33#exact -1#32#34#exact -1#33#35#exact -1#34#36#exact -1#35#37#exact -1#36#38#exact -1#38#40#exact 


Also , Table 14 shows the 15 largest-weighted sense dependency features in the linear-chain , synset-based model .
Also , Table 14 shows the 15 largest-weighted sense dependency features in the linear-chain , synset-based model .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact 


When compared to the outputs of the tree-structured model , we can see that the linear-chain model captures more successive noun-noun dependencies , while the tree-structured model captures more adjective-noun and verb-object dependencies .
When compared to the outputs of the tree-structured model , we can see that the linear-chain model captures more successive noun-noun dependencies , while the tree-structured model captures more adjective-noun and verb-object dependencies .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10,11,12,13,14#10,11,12,13#para -1#24#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact 


Thus , although the difference of the recalls is small , we can assume that the sense dependency features in the tree-structured model , and those in the linear-chain model have different contributions to the results .
Thus , although the difference of the recalls is small , we can assume that the sense dependency features in the tree-structured model and those in the linear-chain model have different contributions to the results .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#13,14#11,12,13,14#para -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact -1#28#29#exact -1#29#30#exact -1#30#31#exact -1#31#32#exact -1#32#33#exact -1#33#34#exact -1#34#35#exact -1#35#36#exact 


The simultaneous use of both is of an interest from practical and semantical perspectives ; however , since it makes our model no longer a tree , the implementation is not straightforward .
The simultaneous use of both is of an interest from practical and semantical perspectives ; However , since it makes our model no longer a tree , the implementation is not straightforward .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#lc -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact 


Hence , this is left as one of our future works .
Hence , this is left as one of our future works .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact 


In this section , we present an instance-based analyses based on the first 100 instances for which the answer of the dependency model Tree-WS-SR differs from that of the non-dependency model NoDep-WS-SR in the first trial on SemCor .
In this section , we present instance-based analyses based on the first 100 instances for which the answer of the dependency model Tree-WS-SR differs from that of the non-dependency model NoDep-WS-SR in the first trial on SemCor .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact -1#28#29#exact -1#29#30#exact -1#30#31#exact -1#31#32#exact -1#32#33#exact -1#33#34#exact -1#34#35#exact -1#35#36#exact -1#36#37#exact -1#37#38#exact 


We extracted only the largest-weighted edge feature for each instance , assuming that this feature had the largest contribution to the result .
We extracted only the largest-weighted edge feature for each instance , assuming that this feature had the largest contribution to the result .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact 


These instances consist of 54 positive instances , for which Tree-WS-SR output the correct answer while NoDep-WS-SR did not , and 46 negative instances , for which Tree-WS-SR did not output the correct answer while NoDep-WS-SR did .
These instances consist of 54 positive instances , for which Tree-WS-SR output the correct answer while NoDep-WS-SR did not , and 46 negative instances , for which Tree-WS-SR did not output the correct answer while NoDep-WS-SR did .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact -1#37#37#exact 


Table 15 and 16 show the count of each edge type for these instances .
Table 15 and 16 shows the count of each edge type for these instances .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#stem -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact 


For both positive and negative instances , the verb-noun dependencies are the dominant dependencies , corresponding to 48% of all the instances .
For both positive and negative instances , the verb-noun dependencies are the dominant dependencies , corresponding to 48% of all the instances .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact 


One noteworthy point is that more number of noun-noun dependencies are found in the positive instances than in the negative instances , further suggesting that noun-noun dependencies are particularly likely to capture useful dependencies and contribute to positive instances .
One noteworthy point is that more number of noun-noun dependencies are found in the positive instances than in the negative instances , which might suggest that noun-noun dependencies are particularly likely to capture useful dependencies and contribute to positive instances .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#24,25#23,24#para -1#26#25#exact -1#27#26#exact -1#28#27#exact -1#29#28#exact -1#30#29#exact -1#31#30#exact -1#32#31#exact -1#33#32#exact -1#34#33#exact -1#35#34#exact -1#36#35#exact -1#37#36#exact -1#38#37#exact -1#39#38#exact -1#40#39#exact 


First of all , let us present two instances in which the verb-noun dependencies worked effectively .
First of all , let us present two instances in which the verb-noun dependencies worked effectively .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact 


The first sentence is :
The first sentence is
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact 


From this earth , then , while it was still virgin God took dust and fashioned the man , the beginning of humanity .
From this earth , then , while it was still virgin God took dust and fashioned the man , the beginning of humanity .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact 


Surprisingly , the verb take has as many as 42 senses in the WordNet .
The verb take has surprisingly as many as 42 senses in the WordNet .
-1#4#0#lc -1#0#2#lc -1#1#3#exact -1#2#4#exact -1#3#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact 


But fortunately , the first six senses belong to different supersenses , and our dependency model succeeded in outputting the correct sense take#4 ( SS :verb .contact , take physically ) by making use of the strong dependency SS :verb .contact-SS :noun .substance ( / MATH ) , given dust#1 belongs to noun .substance .
But , fortunatelly , the first six senses belong to different supersenses , and our dependency model succeeded in outputting the correct sense take#4 ( SS :verb .contact , take physically ) by making use of the strong dependency SS :verb .contact-SS :noun .substance ( / MATH ) , given dust#1 belongs to noun .substance .
-1#0#0#exact -1#3#2#exact -1#4#3#exact -1#5#4#exact -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact -1#23#22#exact -1#24#23#exact -1#25#24#exact -1#26#25#exact -1#27#26#exact -1#28#27#exact -1#29#28#exact -1#30#29#exact -1#31#30#exact -1#32#31#exact -1#34,35#32,33,34,35#para -1#37#36#exact -1#38#37#exact -1#39#38#exact -1#40#39#exact -1#41#40#exact -1#42#41#exact -1#43#42#exact -1#44#43#exact -1#45#44#exact -1#46#45#exact -1#47#46#exact -1#48#47#exact -1#49#48#exact -1#50#49#exact -1#51#50#exact -1#52#51#exact -1#53#52#exact -1#54#53#exact -1#55#54#exact 


The second instance is also a positive instance from the SEM-A data set .
The second instance is also a positive instance from the SEM-A data set .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact 


For a serious young man who plays golf with a serious intensity , Palmer has such an inherent sense of humor that it relieves the strain and keeps his nerves from jangling like banjo strings .
For a serious young man who plays golf with a serious intensity , Palmer has such an inherent sense of humor that it relieves the strain and keeps his nerves from jangling like banjo strings .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact 


Here , has is an ambiguous verb that has 19 senses in the WordNet .
Here , has is an ambiguous verb that has 19 senses in the WordNet .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact 


The correct sense here is have( v )#2 ( SS :verb .stative , have as a feature ) .
The correct sense here is have( v )#2 ( SS :verb .stative , have as a feature ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact 


Given sense of humor#1 belongs to the supersense noun .attribute , the correct sense was output by the strong verb-object dependency G1 :have( v )#2-( OBJ )-SS :noun .attribute ( / MATH ) .
Given sense of humor#1 belongs to the supersense noun .attribute , the correct sense was output by the strong verb-object dependency G1 :have( v )#2-( OBJ )-SS :noun .attribute ( / MATH ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact 


While this verb-object dependency had a large excitatory weight , the corresponding verb-subject dependency had an inhibitory weight ( G1 :have( v )#2-( SBJ )-SS :noun .attribute ( / MATH ) ) , which indicates that the dependency relationlabel also contributed to the result .
While this verb-object dependency had a large excitatory weight , the corresponding verb-subject dependency had an inhibitory weight ( G1 :have( v )#2-( SBJ )-SS :noun .attribute ( / MATH ) ) , which means the dependency relationlabel also contributed to the result .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#35#36#exact -1#36#37#exact -1#37#38#exact -1#38,39,40,41#39,40,41#para -1#42#42,43#para -1#43#44#exact 


Note also that this long dependency cannot be described by linear-chain models .
Note also that this long dependency cannot be described by linear-chain models .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact 


Next , let us show a typical negative example , where a verb-subject dependency worked inappropriately .
Next , let us show a typical negative example , where a verb-subject dependency worked inappropriately .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact 


The repeated efforts in Christian history to describe death as altogether the consequence of human sin show that these two aspects of death cannot be separated .
The repeated efforts in Christian history to describe death as altogether the consequence of human sin show that these two aspects of death cannot be separated .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact 


The correct sense for show here is show#2 ( verb .cognition , establish the validity ) , but the model output show#3 ( verb .communication , prove evidence for ) affected by the long dependency WS :testify( v )#2-( SBJ )-SS :noun .act ( / MATH ) between efforts and show .
The correct sense for show here is show#2 ( verb .cognition , establish the validity ) , but the model output show#3 ( verb .communication , prove evidence for ) affected by the long dependency WS :testify( v )#2-( SBJ )-SS :noun .act ( / MATH ) between efforts and show .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact -1#37#37#exact -1#38#38#exact -1#39#39#exact -1#40#40#exact -1#41#41#exact -1#42#42#exact -1#43#43#exact -1#44#44#exact -1#45#45#exact -1#46#46#exact -1#47#47#exact -1#48#48#exact -1#49#49#exact -1#50#50#exact -1#51#51#exact 


This subject information seems to be inadequate for the disambiguation of show .
This subject information seems to be not adequate for the disambiguation of show .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6,7#6#para -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact 


Next we focus on the noun-noun dependencies .
Next we focus on the noun-noun dependencies .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact 


The first example is a negative instance .
The first example is a negative instance .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact 


Philadelphia permitted him to seek a better connection after he had refused to reconsider his decision to end his career as a player .
Philadelphia permitted him to seek a better connection after he had refused to reconsider his decision to end his career as a player .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact 


The noun career has two meanings : the particular occupation for which you are trained ( career#1 ) and the general progression of your working or professional life ( career#2 ) .
The noun career has two meanings : the particular occupation for which you are trained ( career#1 ) and the general progression of your working or professional life ( career#2 ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact 


From the phrase career as a player , we can assume that the correct sense of career can be either of two senses , with the possibility that there is a preference for career#2 , as captured by the largest-weighted dependency WS :career%1%2-( NMOD )-SS :noun .person ( / MATH ) between career and player .
From the phrase career as a player , we can assume that the correct sense of career can be either of two senses , and possibly there is a preference for career#2 , as captured by the largest-weighted dependency WS :career%1%2-( NMOD )-SS :noun .person ( / MATH ) between career and player .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#10,11#8,9,10,11#para -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#25#24,25,26#para -1#26,27,28#27,28,29,30#para -1#29#31#exact -1#30#32#exact -1#31#33#exact -1#32#34#exact -1#33#35#exact -1#34#36#exact -1#35#37#exact -1#36#38#exact -1#37#39#exact -1#38#40#exact -1#39#41#exact -1#40#42#exact -1#41#43#exact -1#42#44#exact -1#43#45#exact -1#44#46#exact -1#45#47#exact -1#46#48#exact -1#47#49#exact -1#48#50#exact -1#49#51#exact -1#50#52#exact -1#51#53#exact -1#52#54#exact -1#53#55#exact 


Although there was originally the preference for the correct sense career#1 by the sense frequency features , the noun-noun dependency thus contributed to the wrong answer career#2 .
Although there was originally the preference for the correct sense career#1 by the sense frequency features , the noun-noun dependency thus contributed to the wrong answer career#2 .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact 


The determining clue for this instance seems to be the verb-object dependency end-career , which was not captured by our model .
The determining clue for this instance seems to be the verb-object dependency end-career , which was not captured by our model .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact 


Among the ten positive instances of the noun-noun dependencies , four instances were contributed by the noun-of-noun dependencies .
Among the ten positive instances of the noun-noun dependencies , four instances were contributed by the noun-of-noun dependencies .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact 


Since dependencies of this type were not observed in the negative instances , they seem to particularly contribute to the positive instances .
Since dependencies of this type were not observed in the negative instances at all , they seem to particularly contribute to the positive instances .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#14#12#exact -1#15#13#exact -1#16#14#exact -1#17#15#exact -1#18#16#exact -1#19#17#exact -1#20#18#exact -1#21#19#exact -1#22#20#exact -1#23#21#exact -1#24#22#exact 


Let us consider the following example .
Let us consider the following example .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact 


The embarrassment of these theories over the naturalness of death is an illustration of the thesis that death cannot be only a punishment , for some termination seems necessary in a life that is lived within the natural order of time and change .
The embarrassment of these theories over the naturalness of death is an illustration of the thesis that death cannot be only a punishment , for some termination seems necessary in a life that is lived within the natural order of time and change .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact -1#37#37#exact -1#38#38#exact -1#39#39#exact -1#40#40#exact -1#41#41#exact -1#42#42#exact -1#43#43#exact 


Although the correct sense time#5 ( noun .Tops , the continuum of experience in which events pass from the future through the present to the past ) is not a frequent sense , our model correctly output the correct sense by using the dependency SS :noun .object-of-WS :time%1%5 ( / MATH ) , given natural order#1 belongs to the supersense noun .object .
Although the correct sense time#5 ( noun .Tops , the continuum of experience in which events pass from the future through the present to the past ) is not a frequent sense , our model correctly output the correct sense by using the dependency SS :noun .object-of-WS :time%1%5 ( / MATH ) , given natural order#1 belongs to the supersense noun .object .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact -1#37#37#exact -1#38#38#exact -1#39#39#exact -1#40#40#exact -1#41#41#exact -1#42#42#exact -1#43#43#exact -1#44#44#exact -1#45#45#exact -1#46#46#exact -1#47#47#exact -1#48#48#exact -1#49#49#exact -1#50#50#exact -1#51#51#exact -1#52#52#exact -1#53#53#exact -1#54#54#exact -1#55#55#exact -1#56#56#exact -1#57#57#exact -1#58#58#exact -1#59#59#exact -1#60#60#exact -1#61#61#exact -1#62#62#exact 


Through our result , we observed that the noun-noun dependencies in coordination relations work remarkably well .
Another interesting result observed is that the noun-noun dependencies in coordination relations work remarkably strongly .
-1#2#2#exact -1#3#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#15#16#exact 


In the following sentence , three words nails , levels , and T squares are in a coordination relation .
In the following sentence , three words nails , levels , and T squares are in a coordination relation .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact 


0
He also bought a huge square of pegboard for hanging up his tools , and lumber for his workbench , sandpaper and glue and assorted nails , levels and T squares and plumb lines and several gadgets that he had no idea how touse or what they were for .



Generating short summary videos for rushes is a challenging task due to the difficulty in eliminating redundancy and determining the important objects and events to be placed in the summary .
Generating short summary videos for rushes is a challenging task due to difficulty in redundancy elimination and determination of important objects and events being placed in the summary .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12,13#12,13,14#para -1#14#16#exact -1#16#17#exact -1#17,18#18#para -1#26#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23,24,25#25,26,27#para -1#27#28,29#para -1#28#30#exact 


Redundancy elimination is difficult since repetitive segments , which are takes of the same scene , usually have different lengths and motion patterns .
Redundancy elimination is difficult since repetitive segments , which are takes of the same scene , usually have different lengths and motion patterns .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact 


This makes approaches using one keyframe for a shot representation fail when trying to form a cluster .
This makes approaches using one keyframe for shot representation failed in doing clustering .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#8#exact -1#8#9#exact -1#9#10#stem -1#12#16#stem -1#13#17#exact 


In addition , even repetitive segments can be precisely determined , but the summary generated by concatenating together the selected segments still takes longer than the upper limit .
In addition , even repetitive segments can be determined precisely , the summary generated by concatenating together selected segments still has longer duration than the upper limit .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#9#8#exact -1#8#9#exact -1#10#10#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#24#18#exact -1#17#19#exact -1#18#20#exact -1#19#21#exact -1#20#22#syn -1#21#23#exact -1#23#24#exact -1#25#25,26#para -1#26#27#exact -1#27#28#exact 


It is questionable to select a sub-segment so that it conveys information of the scene as much as possible .
It is questionable to select a sub-segment so that it conveys information of the scene as much as possible .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact 


,We introduce two approaches to solve these problems .
In this paper , we introduce two approaches to these problems .
-1#5#1#exact -1#6#2#exact -1#7#3#exact -1#8#4#exact -1#9#6#exact -1#10#7#exact -1#11#8#exact 


In the first approach , one keyframe is used for representing a shot when forming a cluster; and sub-segments are selected using the motion information for generating the summary .
In the first approach , one keyframe is used for shot representation in doing clustering; and sub-segments are selected using motion information for generating the summary .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#17#10#syn -1#10#12#exact -1#15#17#exact -1#16#18#exact -1#18#19,20#para -1#19#21#exact -1#24#22#exact -1#20#23#exact -1#21#24#exact -1#22#25#exact -1#23#26#exact -1#25#27,28#para -1#26#29#exact 


Meanwhile , in the second approach , all the frames of a given shot are used for clustering; and a simple skimming method is used to select the sub-segments .
Meanwhile , in the second approach , all frames of a shot are used for clustering; and a simple skimming method is used to select sub-segments .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#13#exact -1#12#14#exact -1#13#15#exact -1#14#16#exact -1#15#17#exact -1#16#18#exact -1#17#19#exact -1#18#20#exact -1#19#21#exact -1#20#22#exact -1#21#23#exact -1#22#24#exact -1#23#25#exact -1#24#26#exact -1#25#28#exact -1#26#29#exact 


The experimental results on the TRECVID 2008 dataset and a comparison between the two approaches are also reported .
Experimental results on the TRECVID 2008 dataset and comparison between the two approaches are reported .
-1#10#0#lc -1#0#1#lc -1#1#2#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9,10#para -1#9#11#exact -1#11#12,13#para -1#12#14#exact -1#13#15#exact -1#14#17#exact -1#15#18#exact 


With the availability of multimedia databases growing at an exponential rate , users are increasingly requiring assistance in accessing digital video contents .
With the availability of multimedia databases growing at an exponential rate , users are increasingly requiring assistance in accessing digital video contents .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact 


Video summarization significantly helps to meet this need by developing a condensed version of a full length digital video using only the most important contents \CITE .
Video summarization is a significant research that helps to meet these needs by developing a condensed version of a full length digital video with the most important contents \CITE .
-1#0#0#exact -1#1#1#exact -1#3,4#2#para -1#7#3#exact -1#8#4#exact -1#9#5#exact -1#11#7#stem -1#12#8#exact -1#13#9#exact -1#14#10#exact -1#15#11#exact -1#16#12#exact -1#17#13#exact -1#18#14#exact -1#19#15#exact -1#20#16#exact -1#21#17#exact -1#22#18#exact -1#24#21#exact -1#25#22#exact -1#26#23#exact -1#27#24#exact -1#28#25#exact -1#29#26#exact 


Summary videos can help users more efficiently and effectively browse and navigate through large video archives .
Summary videos can help users to browse and navigate large video archives efficiently and effectively .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#12,13#5,6,7#para -1#14#8#exact -1#6#9#exact -1#7#10#exact -1#8#11#exact -1#9#13#exact -1#10#14#exact -1#11#15#exact -1#15#16#exact 


Generating summary videos for BBC rushes \CITE is a challenging task due to the difficulty with redundancy elimination and determining the most important objects and events to be placed in the summary .
Generating summary videos for BBC rushes \CITE is a challenging task due to difficulty in redundancy elimination and determination of important objects and events being placed in the summary .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#27#13#exact -1#13#14#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18,19#19#para -1#20#22#exact -1#21#23#exact -1#22#24#exact -1#23#25#exact -1#24,25,26#27,28,29#para -1#28#30,31#para -1#29#32#exact 


Since the length of the summary is limited to 2\% duration of the original video , there is a trade-off between the recall and usability ( e.g. user friendly through smooth presentation , / being easy to understand ) .
Since the length of the summary is limited to 2\% duration of the original video , there is a trade-off between recall and usability ( e.g user friendly through smooth presentation , being easy to understand ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#26#27#exact -1#27#28#exact -1#28#29#exact -1#29#30#exact -1#30#31#exact -1#31#32#exact -1#32#34#exact -1#33#35#exact -1#34#36#exact -1#35#37#exact -1#36#38#exact -1#37#39#exact 


High recall , i.e. many objects and events ( called scenes ) included in the summary , usually reduces the number of frames for each scene .
High recall , i.e many objects and events ( called scenes ) are included in the summary , usually reduce the number of frames for each scene .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19,20#18,19#para -1#21#20#exact -1#22#21#exact -1#23#22#exact -1#24#23#exact -1#25#24#exact -1#26#25#exact -1#27#26#exact 


For example , the maximum duration for a summary of a 30 minute video is 36 seconds ( \MATH ) .
For example , the maximum duration for the summary of a 30 minute length video is 36 seconds ( \MATH ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7,8#7,8#para -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact 


If the summary consists of 20 scenes , the average duration for each scene is 1.8 seconds .
If the summary consists of 20 scenes , the average duration for each scene is 1.8 seconds .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact 


For an event such as " `Woman attacks man on bench on left and runs off with large bag .
For the event such as " `Woman attacks man on bench on left and runs off with large bag .
-1#0#0#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact 


" ', with this length constraint , it would be difficult to present it in a pleasant tempo and rhythm .
" ', with this length constraint , it is difficult to present it in a pleasant tempo and rhythm .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7,8,9,10#7,8,9,10,11#para -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact 


On the other hand , a smooth presentation of these events would consume a large number of frames , which would decrease the recall .
On the contrary , smooth presentation of events consumes a lot number of frames , that decrease the recall .
-1#0#0#exact -1#17#1#exact -1#1,2#2,3#para -1#3#4#exact -1#9#5#exact -1#4#6#exact -1#5#7#exact -1#6#8#exact -1#7#10#exact -1#8#12#stem -1#11,12#14,15,16#para -1#13#17#exact -1#14#18#exact -1#16#21#exact -1#18#23#exact -1#19#24#exact 


In general , generating summary videos consists of the following steps :
In general , generating summary videos consists of the following steps :
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact 


Video segmentation : This step breaks down the original video into segments , such as shots or sub-shots .
Video segmentation : This step decomposes the original video into segments , such shots or sub-shots .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#15#exact -1#14#16#exact -1#15#17#exact -1#16#18#exact 


Each segment should be aligned so that it is a part of a scene .
Each segment should be aligned such that it is a part of a scene .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#10,11,12#9,10,11,12#para -1#13#13#exact -1#14#14#exact 


Redundancy elimination : This step groups the segments that belong to the same take into clusters .
Redundancy elimination : This step groups segments that belong to the same take into clusters .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#10#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact 


Only one representative segment is used for the final summary video .
Only one representative segment is used for the final summary video .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact 


The others are discarded .
The others are discarded .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact 


Junk elimination : This step removes the color bars , clapboards , and the all black or all white frames that are unnecessary in the final summary video .
Junk elimination : This step removes color bars , clapboards , all black or all white frames that are unnecessary for the final summary video .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#21#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#14#exact -1#12#15#exact -1#13#16#exact -1#14#17#exact -1#15#18#exact -1#16#19#exact -1#17#20#exact -1#18#21#exact -1#19#22#exact -1#22#23,24,25#para -1#23#26#exact -1#24#27#exact -1#25#28#exact 


Summary generation : This step selects the frames from the representative segments of clusters and concatenates them to form the final summary video .
Summary generation : This step selects frames from representative segments of clusters and concatenate to form the final summary video .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#16#6#exact -1#6#7#exact -1#7#8#exact -1#8#9,10#para -1#9#11#exact -1#10#12#exact -1#11#13#exact -1#12#14#exact -1#13#15#stem -1#14#17#exact -1#15#18#exact -1#17#19,20#para -1#18#21#exact -1#19#22#exact -1#20#23#exact 


While the steps for video segmentation and junk elimination are easy to handle , the steps for redundancy elimination and summary generation are difficult .
While the steps of video segmentation and junk elimination are easy to handle , the steps of redundancy elimination and summary generation are difficult .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact 


For example , as for redundancy elimination , the question is how to represent a segment in a feature vector and how to compute the similarity between two segments having different lengths and motion patterns .
For example , as for redundancy elimination , the question is how to represent a segment into a feature vector and how to compute the similarity between two segments having different length and motion pattern .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9,10,11,12#9,10,11#para -1#22#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#stem -1#32#32#exact -1#33#33#exact -1#34#34#stem -1#35#35#exact 


In the other case , assuming that we have selected the appropriate segments , the total length of these segments is usually larger than that of the final summary .
In the other case , assume that we have selected appropriate segments , the total length of these segments are usually larger than that of the final summary .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5,6#5,6#para -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#13#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#25#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19,20#20,21#para -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#26#26,27#para -1#27#28#exact -1#28#29#exact 


The question is how to determine the most important parts of the selected segments so that they convey as much of the information of the scene as possible .
The question is how to determine the important part of the selected segment such that it conveys information of the scene as much as possible .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#8#exact -1#8,9#9,10#para -1#10#11#exact -1#11#12#exact -1#12#13#stem -1#14#15#exact -1#16#17#stem -1#21#18#exact -1#22#19#exact -1#18#20#exact -1#19#21#exact -1#17#22#exact -1#20#24,25#para -1#23#26#exact -1#24#27#exact -1#25#28#exact 


In this paper , we present two approaches for handling these difficult steps .
In this paper , we present two approaches for handling these difficult steps .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact 


The first approach represents each segment by using one key-frame and groups similar segments by clustering them on these key-frames .
The first approach represents each segment by one key-frame and groups similar segments by doing clustering on these key-frames .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#15#15#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact 


Then the portion of each segment that has the highest motion is included in the final summary .
Then the portion of each segment that has high motion is used to include into the final summary .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#15#8#exact -1#8#9#syn -1#9#10#exact -1#10#11#exact -1#11,12,13#12#para -1#16#13,14,15#para -1#17#16#exact -1#18#17#exact 


Meanwhile , the second approach uses another strategy for redundancy elimination .
Meanwhile , the second approach uses another strategy for redundancy elimination .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact 


Specifically , for each segment , a set of frames are extracted by sampling at a certain time interval ( e.g. 5 frames ) .
Specifically , for each segment , a set of frames are extracted by sampling at a certain time interval ( e.g 5 frames ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact 


The clustering process is performed on the frames of all the segments .
The clustering process is performed on the frames of all segments .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#11#exact -1#11#12#exact 


Then , segments that share a large enough number of frames with respect to their size are merged into one cluster .
Then , the segments that share a large enough number of frames with respect to their size are merged into one cluster .
-1#0#0#exact -1#1#1#exact -1#3#2#exact -1#4#3#exact -1#5#4#exact -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact 


In order to generate the final summary , with each representative segment , the middle part is selected with a skim rate of 2 frames .
In order to generate the final summary , with each representative segment , the middle part is selected with the skim rate of 2 frames .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact 


This paper is organized as follows : section \REF introduces the details of the first approach; , while section \REF presents the details of the second approach .
This paper is organized as follows : section \REF introduces details of the first approach; , while section \REF presents details of the second approach .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10,11,12#10,11,12,13#para -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20,21,22#21,22,23,24#para -1#23#25#exact -1#24#26#exact -1#25#27#exact 


Section \REF describes our experimental results on the TRECVID 2008 dataset .
Section \REF describes experimental results on the TRECVID 2008 dataset .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact 


Finally , section \REF and section \REF conclude the paper .
Finally , section \REF and section \REF conclude the paper .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact 


By definition , all rushes are unedited; therefore they must consist of hard cuts only .
From the definition , all rushes are unedited; therefore it must consist of hard cut only .
-1#2#1#exact -1#3#2#exact -1#4#3#exact -1#5#4#exact -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#10#8,9#para -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#stem -1#15#14#exact -1#16#15#exact 


The shot boundary detection algorithm in \CITE is used to determine the shot boundary and to partition the input video into shots .
The shot boundary detection algorithm in \CITE is used to determine shot boundary and partition the input video into shots .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#15#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#16#exact -1#16#18#exact -1#17#19#exact -1#18#20#exact -1#19#21#exact -1#20#22#exact 


A local color histogram is extracted by dividing a video frame into \MATH blocks .
A local color histogram is extracted by dividing a video frame into \MATH blocks .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact 


The \MATH distance is used to compute the distance between each block of frames \MATH and \MATH .
The \MATH distance is used to compute the distance between each blocks of frames \MATH and \MATH .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#stem -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact 


Next , these values are sorted into ascending order .
Next , these values are sorted into an ascending order .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact 


The sum of the middle eight of these 16 values is used to define the cut between frames \MATH and \MATH if these values exceed the threshold \MATH .
The sum of the middle eight of these 16 values are used to define a cut between frames \MATH and \MATH if these values exceed a threshold \MATH .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10,11#10,11#para -1#12#12#exact -1#13,14#13,14#para -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#26#25,26#para -1#27#27#exact -1#28#28#exact 


However , this algorithm cannot distinguish between hard cuts and the motion of large objects .
However , this algorithm cannot distinguish between hard cut and the large objects motion .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#stem -1#9#9#exact -1#10#10#exact -1#13#11#exact -1#11#12,13#para -1#12#14#exact -1#14#15#exact 


To overcome this problem , motion-based features are computed for each video frame using the Lucas-Kanade point-based tracking functions provided in the OpenCV toolkit\footnote{http : //opencvlibrary.sourceforge.net / } .
To overcome this problem , motion-based features are computed for each video frame using the Lucas-Kanade point-based tracking functions provided in the OpenCV toolkit\footnote{http : //opencvlibrary.sourceforge.net / } .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact 


The magnitude is computed from the motion vector for each frame .
The magnitude is computed from the motion vector for each frame .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact 


Therefore , if the algorithm detected a cut between frames \MATH and \MATH , whose magnitude is larger than the threshold \MATH , these cuts are rejected since they are the motions of large objects .
Therefore , if the algorithm detected a cut between frames \MATH and \MATH , whose magnitude is larger than a threshold \MATH , these cuts are rejected since they are motions from large objects .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#20#19,20#para -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30,31#para -1#32#32,33#para -1#33#34#exact -1#34#35#exact 


Finally , short shots of less than 25 frames ( 1 second ) are removed .
Finally , the short shots with less than 25 frames ( 1 second ) are removed .
-1#0#0#exact -1#1#1#exact -1#3#2#exact -1#4#3#exact -1#6,7#4,5,6#para -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact 


The sub-shot segmentation algorithm in \CITE is used to divide shots into smaller units .
The sub-shot segmentation algorithm in \CITE is used to divide shots into smaller units .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact 


The first frame of the shot is chosen as the base frame \MATH and the next frame \MATH for a comparison .
A first frame of the shot is chosen as the base frame \MATH and next frame \MATH for comparison .
-1#9#0#lc -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14,15#para -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#0#19#lc -1#18#20#exact -1#19#21#exact 


The \MATH distance used to compute the distance of the frame sequence until the sum of the sorted value of the lower eight is larger than the threshold \MATH . //[distance / length?]
The \MATH distance used to compute the distance of frame sequence until the sum of the sorted value of lower eight is larger than a threshold \MATH .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#12#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#15#13#exact -1#13#14#exact -1#14#15#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20,21#para -1#20#22#exact -1#21#23#exact -1#22#24#exact -1#23#25#exact -1#25#26,27#para -1#26#28#exact -1#27#29#exact 


The frames from \MATH to \MATH , then , form a sub-shot and frame \MATH is used as the next base frame .
The frames from \MATH to \MATH , then , form a sub-shot and frame \MATH is used as the next base frame .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact 


Finally , the short sub-shots of less than 25 frames are removed .
Finally , the short sub-shots with less than 25 frames are removed .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#6#5,6#para -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact 


We use the keyframe extraction algorithm proposed in \CITE to extract the representative keyframes from each sub-shot .
We employ a keyframe extraction algorithm proposed in \CITE to extract the representative keyframes from each sub-shot .
-1#0#0#exact -1#1#1#syn -1#11#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#12#11,12#para -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact 


In this approach , the cosine distance is used to measure the difference between neighboring frames in each sub-shot .
In this approach , cosine distance is used to measure the difference between neighboring frames in each sub-shot .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#10#4#exact -1#4#5#exact -1#5#6#exact -1#7,8,9#7,8,9,10#para -1#11#11,12#para -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact 


Keyframes are selected at the midpoints between two consecutive high curvature points where the high curvature points are detected from the curve of the cumulative frame difference .
Keyframes are selected at the midpoints between two consecutive high curvature points where the high curvature points are detected from the curve of the cumulative frame difference .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact 


The characteristics of color bars are vertically averaged , and the color histograms for each block in the same column should be similar .
The characteristics of color bars are vertically averaged , and the color histograms for each block in the same column should be similar .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact 


We used the algorithm proposed in \CITE by using the \MATH distance to compute the histogram differences between any two neighboring blocks in each column .
We employ the algorithm proposed in \CITE by using \MATH distance to compute histogram differences between any two neighboring blocks in each column .
-1#0#0#exact -1#7,8#1#para -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#1#8#syn -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#15#exact -1#14#16#exact -1#15#17#exact -1#16#18#exact -1#17#19#exact -1#18#20#exact -1#19#21#exact -1#20#22#exact -1#21#23#exact -1#22#24#exact -1#23#25#exact 


Next , we sort these values into ascending order .
Next , we sort these values into an ascending order .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact 


If the value of the \MATH is smaller than the threshold \MATH , then these sub-shots are defined as a color bar sub-shot .
If the value of the \MATH is smaller than threshold \MATH , then these sub-shot is defined as a color bar sub-shot .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9,10#para -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#stem -1#15,16#16,17#para -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact 


From the properties of a single color image , the dominant color in its global histogram is large .
From the properties of single color image , a dominant color in its global histogram is large .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#8#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#9#9,10#para -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact 


If the value of the \MATH of the global color histogram is larger than the threshold \MATH , then these sub-shots are defined as a single color sub-shot .
If the value of the \MATH of global color histogram is larger than threshold \MATH , then these sub-shots are defined as a single color sub-shot .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7,8#para -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14,15#para -1#14#16#exact -1#15#17#exact -1#16#18#exact -1#17#19#exact -1#18#20#exact -1#19#21#exact -1#20#22#exact -1#21#23#exact -1#22#24#exact -1#23#25#exact -1#24#26#exact -1#25#27#exact -1#26#28#exact 


In rushes videos , there are many types of clapper boards , but the same type of clapper board is often used in the same movie .
In rushes videos , there are many types of clapper boards , appearance but the same type of clapper boards is often used in the same movie .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#20#18,19#para -1#21#20#exact -1#22#21#exact -1#23#22#exact -1#24#23#exact -1#25#24#exact -1#26#25#exact -1#27#26#exact 


There are many types of clapper boards , such as scale , rotation , and illumination changes .
The clapper boards have many types , such as scale , rotation , and illumination changes .
-1#3#1#para -1#4#2#exact -1#5#3#exact -1#1#5#exact -1#2#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact 


The NDK algorithm , proposed in \CITE , is invariant to image scaling , translation , rotation , illumination changes , and affine or 3D projection .
The NDK algorithm , proposed in \CITE , is invariant to image scaling , translation , rotation , illumination changes , and affine or 3D projection .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact 


A set of 80 example keyframes of clapper boards were extracted from the development set and is used as a set of queries .
A set of 80 example keyframes of clapper boards are extracted from the development set and used as a set of queries .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#syn -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16,17#para -1#17,18,19,20#18,19,20#para -1#21#22#exact -1#22#23#exact 


Next , we extract the keypoints of the keyframes given from section \REF and match them with the query .
Next , we extract the keypoints of the keyframes given from section \REF and match them with the query .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact 


If the result of the NDK algorithm returns a match from a keyframe with a query then the sub-shot is defined as a clapper board sub-shot .
If a result of the NDK algorithm returns a match between a keyframe with a query then we define the sub-shot is a clapper board sub-shot .
-1#0#0#exact -1#19#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#1#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#20#18#exact -1#21#19#exact -1#17,18#20#para -1#11#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact 


The unused keyframes containing story units for the generated video summary are removed .
The unused keyframes containing of story units for generate video summary are removed .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#5#4#exact -1#6#5#exact -1#7#6#exact -1#8#8#stem -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact 


However , rushes videos containing a repetitive story , such as a retake of scenes , are unedited .
However , rushes videos containing of repetitive story , such as retake scenes , are unedited .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#12#exact -1#5#13#exact -1#12#14#exact -1#13#15#exact -1#14#16#exact -1#15#17#exact -1#16#18#exact 


To efficiently create rushes videos , the repetitive contents must be eliminated .
To create the efficiently of rushes videos , the repetitive contents must be eliminated .
-1#0#0#exact -1#3#1#exact -1#1#2#exact -1#5#3#exact -1#6#4#exact -1#7#5#exact -1#8#6#exact -1#9#7#exact -1#10#8#exact -1#11#9#exact -1#12#10#exact -1#13#11#exact -1#14#12#exact 


Generally , a group of continuous contents often share some properties .
Generally , a group of continuous contents often share some properties .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact 


With this characteristic in mind , a clustering technique can be used to separate the data into groups of similar contents .
From this characteristic , clustering technique can be used to separate the data into groups of similar contents .
-1#1#1#exact -1#2#2#exact -1#3#5#exact -1#4#7#exact -1#5#8#exact -1#6,7,8#9,10,11,12#para -1#9,10,11#13,14#para -1#12#15#exact -1#13#16#exact -1#14#17#exact -1#15#18#exact -1#16#19#exact -1#17#20#exact -1#18#21#exact 


Each group , called a cluster , consists of contents that are similar between themselves and dissimilar to the contents of other groups .
Each group , called cluster , consists of contents that are similar between themselves and dissimilar to contents of other groups .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17,18#18,19,20#para -1#19#21#exact -1#20#22#exact -1#21#23#exact 


GreedyRSC , proposed in \CITE , is used to find clusters at high precision and the number of clusters is automatically determined .
GreedyRSC , proposed in \CITE , is used to find clusters with high precision and the number of clusters is automatically determined .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11,12#11,12#para -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact 


To do clustering on keyframes , three different features , including the mean , variance , and skew , are extracted from the local color histogram .
To do the clustering on keyframes , three different features , including mean , variance , and skewness , are extracted from local color histogram .
-1#0#0#exact -1#1#1#exact -1#3#2#exact -1#4#3#exact -1#5#4#exact -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#2#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#stem -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22,23#para -1#23#24#exact -1#24#25#exact -1#25#26#exact 


These values are used to represent the keyframes content and are defined as follows :
These values are used to represent the keyframes content and defined as follows :
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10,11#10,11,12#para -1#12#13#exact -1#13#14#exact 


Figure \REF shows an example of a clustering result .
Figure \REF shows an example of clustering result .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact 


So far , we have completely removed the unused contents from rushes videos and reduced any repetition of the story contents .
So far , we completely remove the unused contents from rushes video and reduce repetition of the story contents .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#5#exact -1#5#6#stem -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11,12#12,13#para -1#13#14#stem -1#14#16#exact -1#15#17#exact -1#16#18#exact -1#17#19#exact -1#18#20#exact -1#19#21#exact 


The objective of rushes summarization at TRECVID 2008 is to generate short summaries ( the upper limit of the duration of a summary is 2\% of the original video ) , less repetitive content , and must have as many objects and events as possible .
The objective of rushes summarization at TRECVID 2008 is to generate short summaries ( the upper limit of the duration of summary is 2\% of the original video ) , less repetitive of content , and must have many objects and events as possible .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15,16,17,18#15,16#para -1#24#17#exact -1#25#18#exact -1#19#19#exact -1#20#20#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#32#25#exact -1#26#26,27#para -1#27#28#exact -1#28#29#exact -1#29#30#exact -1#30#31#exact -1#31#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact -1#37#37#exact -1#42#38#exact -1#38#39#exact -1#39#40#exact -1#40#41#exact -1#41#42#exact -1#43#43,44#para -1#44#45#exact 


To reach this objective , only the most important keyframes should be selected to generate a summary video .
To reach this objective , the important keyframes should be selected to generate summary video .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#6#exact -1#6#8#exact -1#7#9#exact -1#8#10#exact -1#9#11#exact -1#10#12#exact -1#11#13#exact -1#12#14#exact -1#13#16#exact -1#14#17#exact -1#15#18#exact 


To generate a summary , we first compute its maximum duration in seconds \MATH ,
To generate summary , we first compute its maximum duration in seconds \MATH ,
-1#0#0#exact -1#1#1#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact 


where \MATH is the maximum duration for the summary .
where \MATH is the maximum duration for the summary .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact 


Second , we compute the quota length for each cluster based on the cluster size \MATH .
Second , we compute quota length for each cluster based on the cluster size \MATH .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#11#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#12#12,13#para -1#13#14#exact -1#14#15#exact -1#15#16#exact 


Third , merge the consecutive sub-shots in each cluster into shots and compute the priority of each shot based on the priority of the shot weighted duration and shot weighted average motion magnitude using the following equation : \MATH</p>
Third , merge consecutive sub-shots in each cluster into shots and compute the priority of each shot based on priority of shot weighted duration and shot weighted average motion magnitude using the following equation : \MATH</p>
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#12#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#31#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19,20#20,21,22#para -1#21#24#exact -1#22#25#exact -1#23#26#exact -1#24#27#exact -1#25#28#exact -1#26#29#exact -1#27#30#exact -1#28#31#exact -1#29#32#exact -1#30#33#exact -1#32#34,35#para -1#33#36#exact -1#34#37#exact -1#35#38#exact 


Next , these \MATH values are sorted into descending order and the first shot is selected .
Next , these \MATH values are sorted into descending order and the first shot is selected .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact 


Fourth , sub-shots in the selected shot in descending order are sorted based on the average motion magnitude .
Forth , sort sub-shots in the selected shot in descending order based on the average motion magnitude .
-1#1#1#exact -1#3#2#exact -1#4#3#exact -1#5#4#exact -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#2#11#stem -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact 


The sub-shots are selected from top to bottom until the quota length for that shot is reached .
Select sub-shots from top to bottom until the quota length for that shot is reached .
-1#7#0#lc -1#1#1#exact -1#0#2,3#para -1#2#4#exact -1#3#5#exact -1#4#6#exact -1#5#7#exact -1#6#8#exact -1#8#9,10#para -1#9#11#exact -1#10#12#exact -1#11#13#exact -1#12#14#exact -1#13#15#exact -1#14#16#exact -1#15#17#exact 


Fifth , for each selected sub-shot , 25 frames ( 1 second ) around the middle are extracted to generate the final summary .
Fifth , for each selected sub-shot , extract 25 frames ( 1 second ) around the middle to generate the final summary .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#7#17#stem -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact 


This system has some modifications from the system developed for the same task last year \CITE .
This system is adopted with some modifications from the system developed for the same task last year \CITE .
-1#0#0#exact -1#1#1#exact -1#2#2#para -1#5#3#exact -1#6#4#exact -1#7#5#exact -1#8#6#exact -1#9#7#exact -1#10#8#exact -1#11#9#exact -1#12#10#exact -1#13#11#exact -1#14#12#exact -1#15#13#exact -1#16#14#exact -1#17#15#exact -1#18#16#exact 


Specifically , the original video is broken down into segments , which are shots with a hard cut transition .
Specifically , the original video is decomposed into segments , which are shots with hard cut transition .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15,16#para -1#15#17#exact -1#16#18#exact -1#17#19#exact 


These segments are further broken down into fragments so that each fragment represents a portion of a scene .
These segments are further decomposed into fragments so that each fragment represents a portion of a scene .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact 


In order to reduce the computation time , we only extract a subset of the frames from the original video by sampling it at a five frame interval ( i.e. extract frames 0 , 5th , 10th , and so on ) .
In order to reduce the computation time , we only extract a subset of frames from the original video by sampling at a five frame interval ( i.e extract frames 0th , 5th , 10th , and so on ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#16#14#exact -1#14#15#exact -1#15#16#exact -1#17#17,18#para -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#23#exact -1#22#24#exact -1#23#25#exact -1#24#26#exact -1#25#27#exact -1#26#28#exact -1#28#30#exact -1#29#31#exact -1#31#33#exact -1#32#34#exact -1#33#35#exact -1#34#36#exact -1#35#37#exact -1#36#38#exact -1#37#39#exact -1#38#40#exact -1#39#41#exact -1#40#42#exact 


For each frame , we use grid color moments with the same configuration as in \CITE for feature representation .
For each frame , we use grid color moments with the same configuration as in \CITE for feature representation .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact 


The segment boundary , which is located at the hard cut transition , is determined by using a loose threshold on the Euclidean distance between two consecutive frames .
The segment boundary , which is located at hard cut transition , is determined by using a loose threshold on the Euclidean distance between two consecutive frames .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#20#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact 


Meanwhile , the fragment boundary is determined by using a strict threshold to detect any dramatic motion .
Meanwhile , the fragment boundary is determined by using a strict threshold to detect dramatic motion .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact 


Instead of selecting one keyframe to represent one fragment as many other systems do , we use all the frames of each fragment for the redundancy elimination .
Instead of selecting one keyframe to represent one fragment as many other systems do , we use all frames of each fragment for redundancy elimination .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#25#exact -1#24#26#exact -1#25#27#exact 


We use GreedyRSC \CITE to do the clustering on the set of all the sampled frames extracted from the original video .
We use GreedyRSC \CITE to do clustering on the set of all sampled frames extracted from the original video .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#8#6#exact -1#6#7#exact -1#7#8#exact -1#16#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#14#exact -1#13#15#exact -1#14#16#exact -1#15#17#exact -1#17#18,19#para -1#18#20#exact -1#19#21#exact 


The number of clusters is determined automatically using this method .
The number of clusters is determined automatically by this method .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact 


Frames that belong to the same cluster are assigned the same label .
Frames that belong to the same cluster are assigned the same label .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact 


By this discretization process , we can cast one fragment as one string whose characters are the labels of its frames .
By this discretization process , we can cast one fragment as one string whose characters are labels of its frames .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16,17#para -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact 


We compute the similarity between two fragments by counting the number of shared characters between two strings and being normalized to the size of each string .
We compute the similarity value between two fragments by counting the number of shared characters between two strings and being normalized to the size of each string .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#5#4#exact -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#22,23,24#20,21,22,23#para -1#25#24#exact -1#26#25#exact -1#27#26#exact 


If this value is larger than the threshold , these two segments are merged into one cluster .
If this value is larger than a threshold , these two segments are merged into one cluster .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#7#6,7#para -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact 


We found that this approach is more effective than the approach using one keyframe for one fragment since the more keyframes that are used , the more information is available to make the right decision .
We found that this approach is more effective than the approach using one keyframe for one fragment since the more number of keyframes is used , the more information is available to make right decision .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#22#20#exact -1#23,24#22,23#para -1#25#24#exact -1#26#25#exact -1#27#26#exact -1#28#27#exact -1#29#28#exact -1#30#29#exact -1#31#30#exact -1#32#31#exact -1#33#32,33#para -1#34#34#exact -1#35#35#exact 


We select junk frames such as color bar frames , and single color ( black or white ) frames to form the reference junk frame set .
We select junk frames such as color bar frames , single color ( black or white ) frames to form the reference junk frame set .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact 


To check whether a fragment is junk , we compare the frames of this fragment to the frames of the reference junk frame set .
To check whether a fragment is a junk , we compare the frames of this fragment to the frames of the reference junk frame set .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact -1#23#22#exact -1#24#23#exact -1#25#24#exact 


The similarity between two frames is the Euclidean distance between two grid color moment feature vectors .
The similarity between two frames is the Euclidean distance between two grid color moment feature vectors .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact 


We empirically select the thresholds for each type of junk .
We empirically select thresholds for each type of junk .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#4#exact -1#4,5,6,7#5,6,7#para -1#8#9#exact -1#9#10#exact 


If the similarity between one frame in the input fragment and one frame in the reference junk frame set is lower than the predefined thresholds, the input fragment is considered junk and all the fragments of the cluster containing the junk fragment are eliminated .
If the similarity between one frame in the input fragment and one frame in the reference junk frame set is lower than the predefined thresholds, the input fragment is considered as junk and all fragments of the cluster containing junk fragment are eliminated .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19,20,21,22#19,20,21#para -1#25#22#exact -1#23#23#exact -1#24#24#exact -1#36#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#31#30#exact -1#32#31#exact -1#33#32#exact -1#34#33,34#para -1#35#35#exact -1#37#36,37#para -1#38#38#exact -1#39#40#exact -1#40#41#exact -1#41#42#exact -1#42#43#exact -1#43#44#exact 


In our system, we only check the fragments that are located at the two ends of the original video for reducing the computation time .
In our system, we only check fragments that are located at two ends of the original video for reducing computation time .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#14#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12,13#para -1#12#14#exact -1#13#15#exact -1#15#16,17#para -1#16#18#exact -1#17#19#exact -1#18#20#exact -1#19#22#exact -1#20#23#exact -1#21#24#exact 


However, by using the clustering result, junk fragments that are not checked against the reference junk frame set are also removed .
However, by using the clustering result, junk fragments that are not checked against the reference junk frame set are also removed .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact 


For each cluster, we merge adjacent fragments into longer fragments and select the longest fragment as the representative fragment to be included in the final summary .
For each cluster, we merge adjacent fragments into longer fragments and select the longest fragment as the representative fragment to be included in the final summary .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#20,21,22#19,20,21,22#para -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact 


Since the length of these fragments is still larger than the maximum length of the final summary, we use the following simple strategy to shrink these fragments .
Since the length of these fragments is still larger than the maximum length of the final summary, we employ a simple strategy to shrink these fragments as follows .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#syn -1#26,27#19,20#para -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#28#27#exact 


First, we assign a quota, which is the maximum duration, for each fragment by dividing the maximum duration for the summary to the number of clusters .
First, we assign a quota, which is the maximum duration, for each fragment by dividing the maximum duration for the summary to the number of clusters .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact 


Second, for each fragment, we extract the portion that is expanded from the central part of the fragment .
Second, for each fragment, we extract the portion which is expanded from the central of the fragment .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8,9#8,9#para -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#16#14#para -1#14#15#exact -1#15#16#exact -1#17#18#exact 


This portion covers a duration twice the size of the fragment quota by selecting the frames with a sampling rate of two frames .
This portion covers a duration twice as much as the fragment quota by selecting frames with sampling rate of 2 frames .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5,6,7,8#5,6#para -1#18#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#15#exact -1#15#16#exact -1#16#18#exact -1#17#19#exact -1#19#20,21#para -1#20#22#exact -1#21#23#exact 


Specifically, we select frames \MATH, \MATH, ..., \MATH, \MATH, ..., \MATH, \MATH, where \MATH is the middle frame of the fragment, and \MATH is half the number of frames computed from the quota\MATH and the frame rate ( 25fps ) \MATH :
Specifically, we select frames \MATH, \MATH, ..., \MATH, \MATH, ..., \MATH, \MATH, where \MATH is the middle frame of the fragment, and \MATH is half of number of frames computed from the quota\MATH and frame rate ( 25fps ) \MATH :
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#31#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#32#32#exact -1#33#33#exact -1#34#35#exact -1#35#36#exact -1#36#37#exact -1#37#38#exact -1#38#39#exact -1#39#40#exact -1#40#41#exact 


We have tested our approaches on 40 videos from the TRECVID 2008 test set .
We have tested our approaches with 40 videos of TRECVID 2008 test set .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#6#6#exact -1#7,8#7,8#para -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact 


Table \REF presents a comparison between these approaches for the measures used in evaluation of this task \CITE .
Table \REF shows a comparison between these approaches for the measures used in evaluation of this task \CITE .
-1#0#0#exact -1#1#1#exact -1#2#2#syn -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact 


The NII-2system achieves a higher recall ( IN ) than the NII-1 system because NII-1 only uses one keyframe for each sub-shot and has a shorter duration ( DU ) for summary videos .
The system NII-2 achieves higher recall ( IN ) than the system NII-1 since NII-1 only uses one keyframe for each sub-shot and has shorter duration ( DU ) for summary videos .
-1#0#0#exact -1#3#2#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#12#11#exact -1#1#12#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24,25#para -1#25#26#exact -1#26#27#exact -1#27#28#exact -1#28#29#exact -1#29#30#exact -1#30#31#exact -1#31#32#exact -1#32#33#exact 


However, NII-1 has better quality .
However, NII-1 has a better score in quality .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#4#3#exact -1#7#4#exact -1#8#5#exact 


The summary videos generated by NII-1 have less duplication ( RE ), are presented in a smoother way ( TE ), and are easy to judge for inclusions ( TT ) .
The summary videos generated by NII-1 have fewer duplications ( RE ), are presented in a smoother way ( TE ) and are easy to judge for inclusions ( TT ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#para -1#8#8#stem -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact 


In terms of efficiency, NII-2 is much better .
In terms of efficiency, NII-2 is much better .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact 


The clapper board detection process using NDK consumes around half of the processing time of NII-1, but its performance is low due to the large variations in clapper boards in the videos ( see Figure \REF ) .
The clapper board detection process using NDK consumes around half of processing time of NII-1 but performance is low due to large variations of clapper boards in videos ( see Figure \REF ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8,9,10#8,9,10,11#para -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#15#16#exact -1#16#17,18#para -1#17#19#exact -1#18#20#exact -1#19#21#exact -1#20#22#exact -1#21#23,24#para -1#22#25#exact -1#26#26#exact -1#24#27#exact -1#25#28#exact -1#27#30,31#para -1#28#32#exact -1#29#33#exact -1#30#34#exact -1#31#35#exact -1#32#36#exact -1#33#37#exact 


The comparable performance in the junk elimination of both systems suggests that simpler methods are more favorable .
The comparable performance in junk elimination of both systems suggests that simple methods are more favorable .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#syn -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact 


In addition, by using simple features and sampling frames in the original video, NII-2 significantly increases the processing time ( computed from the time the input video is taken to the time the summary video is picked ) to quasi real-time .
In addition, by using simple features and sampling frames in the original video, NII-2 significantly speeds up the processing time ( computed from the time taking the input video to the time picking the summary video ) to quasi real-time .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact -1#23#22#exact -1#24#23#exact -1#26#24#exact -1#27#25#exact -1#28#26#exact -1#25#28#syn -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#33#32#exact -1#34#33#exact -1#35#34#exact -1#32#36#stem -1#36#37#exact -1#37#38#exact -1#38#39#exact -1#39#40#exact -1#40#41#exact 


Practical summarization systems usually have a good balance between the fraction of inclusions and user-friendliness .
Practical summarization systems usually have good balance between fraction of inclusions and user-friendliness .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5,6#para -1#6#7#exact -1#7#8#exact -1#8#10#exact -1#9#11#exact -1#10#12#exact -1#11#13#exact -1#12#14#exact -1#13#15#exact 


In Table \REF, we present the performance of such systems .
In Table \REF, we show performance of such systems .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#syn -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact 


The 14 systems listed in this table have an IN score that is above the median ( 0.45 ); and other scores, such as RE and TE, are larger than half of the maximum score ( 2.5 ) .
The 14 systems listed in this table have IN score larger than the median ( 0.45 ); and other scores such as RE and TE larger than half of maximum score ( 2.5 ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#9#exact -1#9#10#exact -1#12#14#exact -1#13#15#exact -1#14#16#exact -1#15#17#exact -1#16#18#exact -1#17#19#exact -1#18#20#exact -1#20#22#exact -1#21#23#exact -1#22#24#exact -1#23#25#exact -1#10#28#exact -1#27,28#29,30,31,32#para -1#29#33#exact -1#30#34#exact -1#31#35#exact -1#32#36#exact -1#33#37#exact -1#34#38#exact 


Compared to the other systems listed in this table, our NII-2system is one of the fastest .
Compared to other systems listed in this list, our system NII-2 is one of the fastest systems .
-1#0#0#exact -1#1#1#exact -1#14#2#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#8#9#exact -1#11,12,13#11,12,13,14#para -1#15#15#exact -1#17#16#exact 


Compared to the other systems participating in this task of TRECVID 2008, NII-1 performed better in such measures as DU and TT ( see Figure \REF and Figure \REF; while NII-2 performs well in the IN measure ( see Figure \REF ) .
Compared to the other systems participating in this task of TRECVID 2008, NII-1 has good performance in measures such as DU and TT ( see Figure \REF and Figure \REF; while NII-2 achieves good performance in measure IN ( see Figure \REF ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#para -1#14#14#syn -1#16#15#exact -1#18#16#exact -1#17#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact -1#23#22#exact -1#24#23#exact -1#25#24#exact -1#26#25#exact -1#27#26#exact -1#28#27#exact -1#29#28#exact -1#30#29#exact -1#31#30#exact -1#15#31#stem -1#33#32#syn -1#35#33#exact -1#37#35#exact -1#36#36#exact -1#38#37#exact -1#39#38#exact -1#40#39#exact -1#41#40#exact -1#42#41#exact -1#43#42#exact 


One of the most difficult steps is redundancy elimination .
One of most difficult steps is redundancy elimination .
-1#0#0#exact -1#1#1#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact 


The lack of discriminative representation of the segments and robust clustering methods is the main reason \CITE .
Lack of discriminative representation of segments and robust clustering methods is the main reason \CITE .
-1#11#0#lc -1#0#1#lc -1#1#2#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#7#exact -1#6#8#exact -1#7#9#exact -1#8#10#exact -1#9#11#exact -1#10#12#exact -1#12#13,14#para -1#13#15#exact -1#14#16#exact -1#15#17#exact 


Two typical cases that usually happen in clustering results are fragmentation and outliers .
Two typical cases that usually happen in clustering result are fragmentation and outliers .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#stem -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact 


Fragmentation is where samples of one cluster are put into several different clusters .
Fragmentation is the case that samples of one cluster are put into several different clusters .
-1#0#0#exact -1#1#1#exact -1#2,3#2#para -1#5#3#exact -1#6#4#exact -1#7#5#exact -1#8#6#exact -1#9#7#exact -1#10#8#exact -1#11#9#exact -1#12#10#exact -1#13#11#exact -1#14#12#exact -1#15#13#exact 


Outliers are irrelevant and noisy samples in one cluster due to the poor determination of the cluster boundary .
Outliers are irrelevant and noisy samples in one cluster due to poor determination of cluster boundary .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11,12#para -1#12#13#exact -1#13#14#exact -1#14#15,16#para -1#15#17#exact -1#16#18#exact 


Therefore, it is necessary to develop robust methods for detecting repetitive segments .
Therefore, it is necessary to develop robust methods for detection of repetitive segments .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#stem -1#11#10#exact -1#12#11#exact -1#13#12#exact 


Using all the frames of one segment instead of using one keyframe as proposed in NII-2 is one of the current efforts being made towards this end .
Using all frames of one segment instead of using one keyframe as proposed in NII-2 is one of the efforts toward this direction .
-1#0#0#exact -1#1#1#exact -1#18#2#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15,16,17#16,17,18,19#para -1#19#21#exact -1#20#24#stem -1#21#25#exact -1#23#27#exact 


Although the results are not as high as expected, we still believe that this approach is promising .
Although the result is not very high as expected, we still believe that this approach is promising .
-1#0#0#exact -1#1#1#exact -1#2,3#2,3#para -1#4#4#exact -1#7#5#exact -1#6#6#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact 


We have presented two different approaches for generating a short summary for rushes videos .
We have presented two different approaches for generating short summary for rushes video .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8,9#para -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#stem -1#13#14#exact 


In the first approach, NII-1, clustering the set of keyframes extracted from the sub-shots helps to eliminate redundancy .
In the first approach, NII-1, redundancy elimination is done by doing clustering on the set of keyframes extracted from sub-shots .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#11#5#exact -1#13#6#exact -1#14#7#exact -1#15#8#exact -1#16#9#exact -1#17#10#exact -1#18#11#exact -1#19#13#exact -1#6#16#stem -1#5#17#exact -1#20#18#exact 


With each representative segment of each cluster, the portion with the highest degree of motion is selected to form the summary .
With each representative segment of each cluster, the portion that has high degree of motion is selected to form the summary .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#19#10#exact -1#11#11#syn -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#20#19,20#para -1#21#21#exact 


This approach has a good usability score but is not very good at recall .
This approach achieves good performance in usability score but low performance in recall .
-1#0#0#exact -1#1#1#exact -1#3#4#exact -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#12#13#exact -1#13#14#exact 


In the second approach, NII-2, all the frames of each sub-shot are used to compute the similarity among the sub-shots in the clustering process .
In the second approach, NII-2, all frames of each sub-shot are used to compute the similarity among sub-shots in clustering process .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#14#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#15#16#exact -1#16#17#exact -1#17#19#exact -1#18#20#exact -1#19#22#exact -1#20#23#exact -1#21#24#exact 


With each representative segment of each cluster, the middle part is selected to form the summary with a skipping rate of two frames .
With each representative segment of each cluster, the middle part is selected to form the summary with skipping rate of 2 frames .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#syn -1#21#22#exact -1#22#23#exact 


This approach is good for recall and has a reasonably good usability score .
This approach achieves good performance in recall and reasonable performance in usability score .
-1#0#0#exact -1#1#1#exact -1#3#3#exact -1#6#5#exact -1#7#6#exact -1#8#8,9#para -1#11#11#exact -1#12#12#exact -1#13#13#exact 


Compared to other systems participating in the TRECVID 2008 summarization task, NII-2 is among the best systems with a good balance between recall and usability .
Compared to other systems participating in TRECVID 2008 summarization task, NII-2 is among best systems that have good balance between recall and usability .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14,15#para -1#14#16#exact -1#17#17,18,19#para -1#18#20#exact -1#19#21#exact -1#20#22#exact -1#21#23#exact -1#22#24#exact -1#23#25#exact 


533
He also bought a huge square of pegboard for hanging up his tools , and lumber for his workbench , sandpaper and glue and assorted nails , levels and T squares and plumb lines and several gadgets that he had no idea how touse or what they were for .



Here , the correct sense for nail is nail#2 ( noun .artifact , a thin pointed piece of metal ) , and that for level is level#5 ( noun .artifact , indicator of the horizontal ) .
Here , the correct sense for nail is nail#2 ( noun .artifact , a thin pointed piece of metal ) and that for level is level#5 ( noun .artifact , indicator of the horizontal ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#29#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact -1#28#29#exact -1#30#31#exact -1#31#32#exact -1#32#33#exact -1#33#34#exact -1#34#35#exact -1#35#36#exact 


The relatively low frequency of these senses prevent our model from outputting the correct senses in an ordinal way .
The relatively low frequency of these senses prevent our model from outputting the correct senses in an ordinal way .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact 


However , the dependency model could capture the fact that two words in a coordination relation are quite likely to belong to the same semantic group ( SS :noun .artifact-( COORD )-SS :noun .artifact ( / MATH ) ) , and hence succeeded in the correct disambiguation of these three words .
However , the dependency model could capture the fact that two words in a coordination relation are quite likely to belong to the same semantic group ( SS :noun .artifact-( COORD )-SS :noun .artifact ( / MATH ) ) , and hence succeeded in the correct disambiguation of these three words .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact -1#37#37#exact -1#38#38#exact -1#39#39#exact -1#40#40#exact -1#41#41#exact -1#42#42#exact -1#43#43#exact -1#44#44#exact -1#45#45#exact -1#46#46#exact -1#47#47#exact -1#48#48#exact -1#49#49#exact -1#50#50#exact -1#51#51#exact 


More generally , we have observed that the coordination features for an edge that connects the same supersense all have positive weights .
More generally , we have observed that the coordination features for an edge that connects the same supersense all have positive weights .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact 


In this paper , we proposed a novel approach for the all-words WSD , focusing on the use of syntactic dependencies of word senses , and investigated the contribution of these dependencies to WSD .
In this paper , we proposed a novel approach to the all-words WSD , focusing on the use of syntactic dependencies of word senses , and investigated the contribution of these dependencies to WSD .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#16,17,18#15,16,17,18#para -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact 


Our proposals were twofold : to apply tree-structured CRFs to the dependency trees , and to use the combined bigrams of fine- and coarse-grained senses as edge features .
Our proposals were twofold : to apply tree-structured CRFs to the dependency trees , and to use the combined bigrams of fine- and coarse-grained senses as edge features .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact 


In our experiments , the sense dependency features were shown to work effectively for WSD , with a 0 .29% , 0 .64% , and 0 .30% improvement of recalls for SemCor , Senseval-2 , and Senseval-3 data sets , respectively .
In our experiments , the sense dependency features were shown to work effectively for WSD , with 0 .29% , 0 .64% , and 0 .30% improvements of recalls for SemCor , Senseval-2 , and Senseval-3 data sets respectively .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#stem -1#27#28#exact -1#28#29#exact -1#29#30#exact -1#30#31#exact -1#31#32#exact -1#32#33#exact -1#33#34#exact -1#34#35#exact -1#35#36#exact -1#36#37#exact -1#37#38#exact -1#38#40#exact -1#39#41#exact 


Despite the small improvements in overall figures , these improvements indeed correspond to 25%-57% improvements over the first sense baseline .
Despite the small improvements in terms of overall figures , these improvements indeed correspond to 25%-57% improvements over the first sense baseline .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#7#5#exact -1#8#6#exact -1#9#7#exact -1#10#8#exact -1#11#9#exact -1#12#10#exact -1#13#11#exact -1#14#12#exact -1#15#13#exact -1#16#14#exact -1#17#15#exact -1#18#16#exact -1#19#17#exact -1#20#18#exact -1#21#19#exact -1#22#20#exact 


The dependency tree structures were shown to be appropriate in modeling the dependencies of word senses , because the results of the tree-structured models outperformed the [results of ?] linear-chain models .
The dependency tree structures was shown to be appropriate for modeling the dependencies of word senses , by the results that the tree-structured models outperformed the linear-chain models .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#syn -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#18#18#exact -1#19#19#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#29#exact -1#27#30#exact -1#28#31#exact 


In the analysis section , we presented an in-depth analysis of the observed instances , and observed that the noun-noun dependencies particularly contribute to the positive instances .
In the analysis section , we presented an in-depth analysis of the observed instances , and saw that the noun-noun dependencies particularly contribute to the positive instances .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact 


In addition , the combination of coarse-grained tag sets with the sense dependency features were proved to be effective .
Also , the combination of coarse-grained tag sets with the sense dependency features were proved to be effective .
-1#0#0,1#para -1#1#2#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact 


However , our experiments showed that even when combined with the coarse-grained tag sets , the sense dependency features do not improve the performance , unless combined with proper sense frequency information . This is due to the data sparseness problem .
However , our experiments on the other hand showed that even when combined with the coarse-grained tag sets , the sense dependency features do not improve the performance unless combined with proper sense frequency information , due to the data sparseness problem .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#8#4#exact -1#9#5#exact -1#10#6#exact -1#11#7#exact -1#12#8#exact -1#13#9#exact -1#14#10#exact -1#15#11#exact -1#16#12#exact -1#17#13#exact -1#18#14#exact -1#19#15#exact -1#20#16#exact -1#21#17#exact -1#22#18#exact -1#23,24,25,26#19,20,21#para -1#5#22#exact -1#27#23#exact -1#35#24#exact -1#28#25#exact -1#29#26#exact -1#30#27#exact -1#31#28#exact -1#32#29#exact -1#33#30#exact -1#34#31#exact -1#42#32#exact -1#36#35#exact -1#37#36#exact -1#38#37#exact -1#39#38#exact -1#40#39#exact -1#41#40#exact 


The supersense-based WSD models , on the contrary , exhibited the robustness [of ...] regardless of the existence of the sense frequency information , while they are defeated by the synset-based models in recalls .
The supersense-based WSD models , on the contrary , exhibited the robustness regardless of the existence of the sense frequency information , while they are defeated by the synset-based models in recalls .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#14#exact -1#14,15,16,17#15,16,17,18,19#para -1#18#20#exact -1#19#21#exact -1#20#22#exact -1#21#23#exact -1#22#24#exact -1#23#25#exact -1#24#26#exact -1#25#27#exact -1#26#28#exact -1#27#29#exact -1#28#30#exact -1#29#31#exact -1#30#32#exact -1#31#33#exact -1#32#34#exact 


These results show the importance of fine-grained and coarse-grained sense information , and show that the combination of both enables us to build a more precise and robust WSD system .
These results show the importance of fine-grained and coarse-grained sense information , and that the combination of both enables us to build a precise and robust WSD system .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24,25#para -1#24#26#exact -1#25#27#exact -1#26#28#exact -1#27#29#exact -1#28#30#exact 


The performance of our tree-structured model was comparable to that of the state-of-the-art WSD systems .
The performance of our tree-structured model was comparable to that of the state-of-the-art WSD systems .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact 


Although our model was based on a simple framework , and was trained only on the SemCor corpus , the results that we gained were promising . They suggested that our model still has a great potential for improvement .
Although our model was based on a simple framework and trained only on the SemCor corpus , the results we gained were promising , suggesting that our model still has a great potential for improvement .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3,4,5,6#3,4,5#para -1#30#6#exact -1#7#7#exact -1#8#8#exact -1#16#9#exact -1#9#10#exact -1#21#11#syn -1#10#12#exact -1#11#13#exact -1#12#14#exact -1#13#15#exact -1#14#16#exact -1#15#17#exact -1#23#18#exact -1#17#19#exact -1#18#20#exact -1#25#21#exact -1#19#22#exact -1#20#23#exact -1#22#25#exact -1#35#26#exact -1#24#28#stem -1#26#30#exact -1#27#31#exact -1#28#32#exact -1#29#33#exact -1#31,32,33#34,35,36,37#para -1#34#38#exact 


Our next interest is to combine our framework with the recently-developed semi-supervised frameworks .
Our next interest is to combine our framework with the recently-developed semi-supervised frameworks .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact 


The combination of the local and syntactic dependencies with the global information is expected to further the WSD research .
The combination of the local and syntactic dependencies with the global information is expected to further the WSD research .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact 


Face Retrieval Improvement by the Learning of Visual Consistency
Face Retrieval Improvement by Learning Visual Consistency
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#5#exact -1#5#7#exact -1#6#8#exact 


Searching for images of people is one of the essential tasks required by users for image and video search engines .
Searching persons is one of the essential tasks required by users for image and video search engines .
-1#0#0#exact -1#11#1#exact -1#12#2#stem -1#4#3#exact -1#1,2#4,5#para -1#3#6#exact -1#5,6#7,8,9#para -1#7#10#exact -1#8#11#exact -1#9#12#exact -1#10#13#exact -1#13#16#exact -1#14#17#exact -1#15#18#exact -1#16#19#exact -1#17#20#exact 


However , the current search engines have limited capabilities for this task since they usually rely on texts associated with image and video , which are likely to return many irrelevant results .
However , the current search engines have limited capabilities for this task since they usually rely on texts associated with image and video which are likely to return many irrelevant results .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#25,26#24,25,26,27#para -1#27#28#exact -1#28#29#exact -1#29#30#exact -1#30#31#exact -1#31#32#exact 


We propose a method to effectively retrieve relevant faces for one person by learning visual consistency from results retrieved from text correlation based search engines .
In this paper , we propose a method to effectively retrieve relevant faces for one person by learning visual consistency from results retrieved from text correlation based search engines .
-1#4#0#lc -1#5#1#exact -1#6#2#exact -1#7#3#exact -1#8#4#exact -1#9#5#exact -1#10#6#exact -1#11#7#exact -1#12#8#exact -1#13#9#exact -1#14#10#exact -1#15#11#exact -1#16#12#exact -1#17#13#exact -1#18#14#exact -1#19#15#exact -1#20#16#exact -1#21#17#exact -1#22#18#exact -1#23#19#exact -1#24#20#exact -1#25#21#exact -1#26#22#exact -1#27#23#exact -1#28#24#exact -1#29#25#exact 


This problem is challenging because ( i ) there is no label provided making it difficult to use supervised-based ranking methods .
This problem is challenging because ( i ) no any label is provided leading to be difficult to use supervised-based ranking methods .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#11#8,9#para -1#8#10#exact -1#10#11#exact -1#12#12#exact -1#16,17#14,15,16#para -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact 


( ii ) current face recognition techniques are still immature with wild-face databases even with supervised learning methods .
( ii ) current face recognition techniques are still unmatured with wild-face databases even with supervised learning methods .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact 


In the proposed method , we treat this problem as a classification problem in which input faces are classified as 'person-X' ( the queried person ) or 'non-person-X' , and the faces are ranked based on their relevant score inferred from the classifier 's probability output .
In the proposed method , we treat the problem as a classification problem which input faces are classified as 'personX' ( the queried person ) or 'non-personX' and the faces are ranked based on their relevant score that is inferred from the classifier 's probability output .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7,8#7,8#para -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13,14#para -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#27#29#exact -1#28#30#exact -1#29#31#exact -1#30#32#exact -1#31#33#exact -1#32#34#exact -1#33#35#exact -1#34#36#exact -1#35#37#exact -1#36#38#exact -1#39#39#exact -1#40#40#exact -1#41#41#exact -1#42#42#exact -1#43#43#exact -1#44#44#exact -1#45#45#exact -1#46#46#exact 


To train this classifier , we use a bagging-based framework to combine results from multiple weak classifiers , which are trained using different subsets .
In order to train this classifier , we use a bagging-based framework to combine results from multiple weak classifiers which are trained using different subsets .
-1#2#0#lc -1#3#1#exact -1#4#2#exact -1#5#3#exact -1#6#4#exact -1#7#5#exact -1#8#6#exact -1#9#7#exact -1#10#8#exact -1#11#9#exact -1#12#10#exact -1#13#11#exact -1#14#12#exact -1#15#13#exact -1#16#14#exact -1#17#15#exact -1#18#16#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact -1#23#22#exact -1#24#23#exact -1#25#24#exact 


These training subsets are extracted and labeled automatically from the rank list produced from the classifier trained from the previous step .
These training subsets are extracted and labeled automatically from the rank list produced from the classifier trained from the previous step .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact 


In addition , outlier detection methods are used to produce the rank list for initialization .
In addition , outliers detection methods are used to produce the rank list for initialization .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#stem -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact 


Experimental results on various face sets retrieved from the captions of news photos show that the retrieval performance improved after each iteration with the final performance outperforming the baseline algorithms .
Experimental results on various face sets retrieved from the caption of news photos show that the retrieval performance is improved after each iteration leading the final performance outperforms the baseline algorithms .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#stem -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact -1#24,25#22,23,24#para -1#26#25#exact -1#27#26#stem -1#28#27#exact -1#29#28#exact -1#30#29#exact -1#31#30#exact 


With the rapid growth of digital technology , large image and video databases are more available than ever to users .
With the rapid growing of digital technology , large image and video databases are available easier than ever to users .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3,4#3,4#para -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#15#14,15#para -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact 


Therefore , effective and efficient tools are needed for indexing and retrieving based on visual contents .
Therefore , effective and efficient tools are strongly needed for indexing and retrieving based on visual contents .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact 


A typical example for this application is searching for a specific person by providing his or her name .
One of the typical examples for this application is to search a specific person by providing his or her name .
-1#11#0#lc -1#3#1#exact -1#4#2#stem -1#5#3#exact -1#6#4#exact -1#7#5#exact -1#8#6#exact -1#10#7#stem -1#12#9,10#para -1#13#11#exact -1#14#12#exact -1#15#13#exact -1#16#14#exact -1#17#15#exact -1#18#16#exact -1#19#17#exact -1#20#18#exact 


Usually , most current search engines use the texts associated with images or videos as significant clues for returning results .
Usually , most of current search engines use text associated with images or videos as a significant clue to return the results .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#4#3#exact -1#5#4#exact -1#6#5#exact -1#7#6#exact -1#20#7#exact -1#8#8#stem -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#16#15#exact -1#17#16#stem -1#19#18#stem -1#21#19#exact -1#22#20#exact 


However , other un-queried faces and names appear simultaneously and are aligned ( as shown in Figure \REF ) , which significantly lowers retrieval performance .
However , since it is not necessary faces and names appear simultaneously and are aligned ( as shown in Figure \REF ) , the main drawback of this approach is existence of many irrelevant results that makes the retrieval performance very low .
-1#0#0#exact -1#1#1#exact -1#7#4#exact -1#8#5#exact -1#9#6#exact -1#10#7#exact -1#11#8#exact -1#12#9#exact -1#13#10#exact -1#14#11#exact -1#15#12#exact -1#16#13#exact -1#17#14#exact -1#18#15#exact -1#19#16#exact -1#20#17#exact -1#21#18#exact -1#22#19#exact -1#38#23#exact -1#39#24#exact -1#42#25#exact 


Therefore , it is necessary to improve the retrieval performance by taking into account the visual information from the retrieved faces .
Therefore it is necessary to improve the retrieval performance by taking into account visual information from the retrieved faces .
-1#0#0#exact -1#1#2#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10,11,12#11,12,13,14#para -1#13#15#exact -1#14#16#exact -1#15#17#exact -1#16#18#exact -1#17#19#exact -1#18#20#exact -1#19#21#exact 


This problem is challenging due to the following reasons :
This problem is challenging due to the following reasons :
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact 


-Large variations in face appearance due to pose changes , illumination conditions , occlusions , and facial expressions make face recognition difficult even with state of the art techniques \CITE .
-Large variations in face appearance due to pose changes , illumination conditions , occlusions and facial expressions make face recognition difficult even with state of the art techniques \CITE .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23,24,25#24,25,26,27#para -1#27#28#exact -1#28#29#exact -1#29#30#exact 


-The fact the retrieved face set consists of faces of several people with no label makes supervised learning methods as well as unsupervised learning methods such as , \MATH -means , inapplicable .
-The fact the retrieved face set consists of faces of several persons while no any label is given makes supervised learning methods as well as unsupervised learning methods such as \MATH -means inapplicable .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11,12#para -1#13#13#exact -1#15#14#exact -1#18#15#exact -1#19#16#exact -1#20#17#exact -1#21#18#exact -1#22#19#exact -1#23#20#exact -1#24#21#exact -1#25#22#exact -1#26#23#exact -1#27#24#exact -1#28#25#exact -1#29#26#exact -1#30#28#exact -1#31#29#exact -1#32#31#exact -1#33#32#exact 


We propose a method to solve the above-mentioned problem .
In this paper , we propose a method to solve the mentioned problem .
-1#4#0#lc -1#5#1#exact -1#6#2#exact -1#7#3#exact -1#8#4#exact -1#9#5#exact -1#10#6#exact -1#12#8#exact -1#13#9#exact 


The main idea is to assume that there is visual consistency among the results returned from current text-based search engines .
The main idea is to learn visual consistency assumed to exist among the results returned from current text-based search engines .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#8#5#stem -1#10#7,8#para -1#6#9#exact -1#7#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact 


This method consists of two stages .
The method consists of two stages .
-1#0,1#0,1#para -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact 


In the first stage , we explore local density of faces to identify potential candidates for relevant faces .
In the first stage , we explore local density of faces to identify potential candidates for relevant faces .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact 


This stage is based on the observation that facial images of the queried person tend to form dense clusters while irrelevant facial images are sparse since they look different from each other .
This stage is stemmed from the observation that faces relevant to the queried person tend to form dense clusters while irrelevant faces are very sparse since they look different from each other .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#syn -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#22#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact 


We use an outlier detection method for this purpose .
We use an outliers detection method for this purpose .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#stem -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact 


The output is a rank list in which faces with larger number of neighbors within a certain distance are considered as relevant and are therefore put at the top of the list . //[What do you mean by gneighborsh ? Do you mean the un-queried faces ? ]
The output is a rank list in which faces having larger number of neighbors within a distance are predicted as relevant ones and therefore are put on the top .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#17#exact -1#17#18#exact -1#19#20#exact -1#20#21#exact -1#22#22#exact -1#24#23#exact -1#23#24#exact -1#25#25#exact -1#27#27#exact -1#28#28#exact -1#29#32#exact 


Since the above ranking method is based on the number of neighbors , it is sensitive to the specified distance .
Since the above ranking method is based on the number of neighbors , it is sensitive to the chosen distance .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5,6,7,8#5,6,7#para -1#17#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#19#19#exact -1#20#20#exact 


A second stage is necessary to improve this rank list .
It is necessary to use the second stage to improve the rank list .
-1#5,6#0,1#para -1#7#2#exact -1#0,1,2,3#3,4#para -1#8#5#exact -1#9#6#exact -1#11#8#exact -1#12#9#exact -1#13#10#exact 


We model this problem as a classification problem in which input faces are classified as person-X ( the queried person ) or non-person-X ( the irrelevant person ) .
We model this problem as a classification problem which input faces are classified as personX ( the queried person ) or non-personX ( the irrelevant person ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8,9#para -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact 


The faces are ranked based on their relevancy score that is inferred from the classifier 's probability output .
The faces are ranked based on their relevant score that is inferred from the classifier 's probability output .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#stem -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact 


Since annotation data is not available , the rank list from the previous step is used to assign labels for a subset of faces .
Since annotation data is not available , the rank list from the previous step is used to assign labels for a subset of faces .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact 


This subset then is used to train a classifier using supervised methods such as support vector machines ( SVM ) .
This subset then is used to train a classifier using a supervised method such as support vector machines ( SVM ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#11#10#exact -1#12#11#stem -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact 


The trained classifier is used to re-rank faces in the original input set .
The trained classifier is used to re-rank faces in the original input set again .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#14#13#exact 


This step is repeated a number of times to get the final rank list .
This step is repeated a number of times to get the final rank list .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact 


Since automatically assigning labels from the rank list is not reliable , the trained classifiers are weak .
Since automatically assigning labels from the rank list is not reliable , the trained classifiers are weak .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact 


In order to get the final strong classifier , we use the idea of ensemble learning \CITE in which weak classifiers trained on different subsets are combined to improve the stability and classification accuracy of single classifiers .
In order to get the final strong classifier , we employ the idea of ensemble learning \CITE in which weak classifiers trained on different subsets are combined to improve stability and classification accuracy of single classifiers .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#syn -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29,30#29,30,31#para -1#31#32#exact -1#32#33#exact -1#33#34#exact -1#34#35#exact -1#35#36#exact -1#36#37#exact 


This stage is effective for improving the rank list for the following reasons :
This stage is effective for improving the rank list due to the following reasons :
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#11,12#9,10,11#para -1#13#12#exact -1#14#13#exact 


-Supervised learning methods such , as SVMs , provide a strong theoretical background in finding optimal decision boundary even with existence of noisy data .
-Supervised learning methods such as SVM have strong theoretical background in finding optimal decision boundary even with existence of noisy data .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#5#exact -1#7#10#exact -1#8#11#exact -1#9#12#exact -1#10#13#exact -1#11#14#exact -1#12#15#exact -1#13#16#exact -1#14#17#exact -1#15#18#exact -1#16#19#exact -1#17#20#exact -1#18#21#exact -1#19#22#exact -1#20#23#exact -1#21#24#exact 


Furthermore , recent studies suggest that \CITE SVM classifiers provide probability outputs that are suitable for ranking .
Furthermore , with recent studies \CITE SVM classifiers can provide probability outputs that are suitable for ranking .
-1#0#0#exact -1#1#1#exact -1#3#2#exact -1#4#3#exact -1#12#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#13#12,13#para -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact 


-Bagging framework helps to leverage noises in the unsupervised labeling process .
-Bagging framework helps to leverage noises in the unsupervised labeling process .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact 


Our contribution is two-fold :
Our contribution is two-fold :
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact 


-We propose a general framework to boost the face retrieval performance from results retrieved from text correlation-based search engines by the learning of visual consistency .
-We propose a general framework to boost the face retrieval performance from the results retrieved from text correlation based search engines by learning visual consistency .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#19#17#exact -1#20#18#exact -1#21#19#exact -1#12#20#exact -1#22#21#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact 


It seamlessly integrates current data mining methods such as outlier detection , supervised learning , and unsupervised learning based on bagging for a practical problem . //[What or who is glearningh visual consistency ? Are the search engines learning ? ]
It integrates seamlessly current existing data mining methods such as outliers detection , supervised learning and unsupervised learning based on bagging for a practical problem .
-1#0#0#exact -1#2#1#exact -1#1#2#exact -1#3#3#exact -1#5#4#exact -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#stem -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#4#29#syn 


Our framework requires few parameters and works stably .
Our framework requires few parameters and works stably .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact 


-We demonstrate the feasibility of using tolerance of supervised learning methods when working with noisy datasets combined with ensemble learning to improve the final performance .
-We demonstrate feasibility of using tolerance of supervised learning methods when working with noisy datasets combined with ensemble learning to improve the final performance .
-1#0#0#exact -1#1#1#exact -1#21#2#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#22#22,23#para -1#23#24#exact -1#24#25#exact 


There are several more proposed approaches for general object classification than for those for face retrieval .
There are several approaches proposed for general object classification rather than for face retrieval .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#4#4#exact -1#3#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#10#10#exact -1#11#11#exact -1#12#14#exact -1#13#15#exact -1#14#16#exact 


For example , as described in \CITE , objects are retrieved by an image search engine and then are re-ranked by the learning of visual consistencies from the retrieved objects .
For example , as described in \CITE , objects are retrieved by an image search engine and then are re-ranked by learning visual consistencies from the retrieved objects .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#25#21#exact -1#21#22#exact -1#22#24#exact -1#23#25#exact -1#24#26#exact -1#26#28#exact -1#27#29#exact -1#28#30#exact 


Compared to the problem of face-based recognition , the problem of object classification is easier since classification of different object types such as airplane and non-airplane only needs to handle inter-variations between different categories , while discriminating between person-A and person-B requires handling of both intra-variations and inter-variations of the same category .
Compared to the problem of face retrieval based recognition , the problem of object classification is easier since classification of different object types such as airplane and non-airplane only needs to handle inter-variations between different categories while discriminating personA and personB requires to handle both intra-variations and inter-variations of the same category .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#8#6#exact -1#9#7#exact -1#10#8#exact -1#11#9#exact -1#12#10#exact -1#13#11#exact -1#14#12#exact -1#15#13#exact -1#16#14#exact -1#17#15#exact -1#18#16#exact -1#19#17#exact -1#20#18#exact -1#21#19#exact -1#22#20#exact -1#23#21#exact -1#24#22#exact -1#25#23#exact -1#26#24#exact -1#27#25#exact -1#28#26#exact -1#29#27#exact -1#30#28#exact -1#31#29#exact -1#32#30#exact -1#33#31#exact -1#34#32#exact -1#35#33#exact -1#36#35#exact -1#37#36#exact -1#39#39#exact -1#41#41#exact -1#48#43#exact -1#44#44#exact -1#45#45#exact -1#46#46#exact -1#47#47#exact -1#49,50#48,49,50#para -1#51#51#exact -1#52#52#exact 


Furthermore , in order to work in unsupervised mode , these approaches need a method to collect negative samples ( e.g. non-airplane ) , which are inapplicable to our problem .
Furthermore , in order to work in unsupervised mode , these approaches need a method to collect negative samples ( e.g. non-airplane ) which are inapplicable in our problem .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#27#28#exact -1#28#29#exact -1#29#30#exact 


A graph-based approach was proposed by \CITE , in which a graph is formed by faces as nodes , and the weights of edges linked between nodes are the similarity of faces , is closely related to our problem .
Working closely to our problem , in \cite{Ozkan06CVPR} , a graph based approach was proposed \CITEin which a graph is formed by faces as nodes and weights of edges linked between nodes are the similarity of faces .
-1#9#0#lc -1#12#2#exact -1#13#3#exact -1#14#4#exact -1#21#5#exact -1#5#7#exact -1#6#8#exact -1#16#9#exact -1#17#10#exact -1#18#11#exact -1#19#12#exact -1#20#13#exact -1#22#15#exact -1#23#16#exact -1#24#17#exact -1#8#18#exact -1#25#19#exact -1#33#20#exact -1#26#21#exact -1#27#22#exact -1#28#23#exact -1#29#24#exact -1#30#25#exact -1#31#26#exact -1#32#27#exact -1#34#29#exact -1#35#30#exact -1#36#31#exact -1#1#33,34#para -1#2#36#exact -1#3#37#exact -1#4#38#exact -1#37#39#exact 


Assuming that the number of faces of the queried person is larger than that of others and that these faces tend to form the most similar subset among the set of retrieved faces , this problem is considered equal to the problem of finding the densest subgraph of a full graph with an available solution . //[Do graphs have solutions ? They just provide information .]
By assuming that the number of faces of the queried person are larger than that of other persons , and these faces tend to form the most similar subset among the set of retrieved faces , this problem is considered equal to the problem of finding the densest subgraph of a full graph whose solution is available .
-1#1#0#lc -1#2#1#exact -1#3#2#exact -1#4#3#exact -1#5#4#exact -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#38#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15,16#para -1#20#18#exact -1#21#19#exact -1#22#20#exact -1#23#21#exact -1#24#22#exact -1#25#23#exact -1#26#24#exact -1#27#25#exact -1#28#26#exact -1#29#27#exact -1#30#28#exact -1#31#29#exact -1#32#30#exact -1#33#31#exact -1#34#32#exact -1#35#33#exact -1#36#34#exact -1#37#35#exact -1#55#36#exact -1#39#37#exact -1#40#38#exact -1#42,43,44#39,40,41,42#para -1#45#43#exact -1#46#44#exact -1#47#45#exact -1#48#46#exact -1#49#47#exact -1#50#48#exact -1#51#49#exact -1#52#50#exact -1#56#53#exact -1#54#54#exact -1#57#55#exact -1#11#58#para 


Although , experimental results showed the effectiveness of this method , it is still questionable whether the densest subgraph intuitively describes most of relevant faces of the queried person .
Although , experimental results showed effectiveness of this method , it is still questionable whether the densest subgraph intuitively describes most of relevant faces of the queried person .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5,6#5,6,7#para -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact -1#28#29#exact 


Furthermore , choosing an optimal threshold to convert the initial graph into a binary graph is difficult and rather ad hoc due to dimensionality .
Furthermore , choosing an optimal threshold to convert the initial graph into a binary graph is difficult and rather ad hoc due to the curse of dimensionality .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#26#23#exact -1#27#24#exact 


In another work \CITE , a clustering-based approach was proposed for associating names and faces in news photos .
In another work \CITE , a clustering-based approach was proposed to associate names and faces in news photos .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9,10#9,10#para -1#11#11#stem -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact 


To solve the problem of ambiguity between several names and one face , a modified \MATH -means clustering process was used in which faces are assigned to the closest cluster ( each cluster corresponding to one name ) after a number of iterations .
To solve the problem of ambiguity between several names and one face , a modified \MATH -means clustering process was used in which faces are assigned to the closest cluster ( each cluster corresponding to one name ) after a number of iterations .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact -1#37#37#exact -1#38#38#exact -1#39#39#exact -1#40#40#exact -1#41#41#exact -1#42#42#exact -1#43#43#exact 


Although the result was impressive , it is not easy to apply it to our problem since a large number of irrelevant faces ( more than 12% ) are eliminated manually before performing clustering .
Although the result was impressive , it is not easy to apply for our problem since a large number of irrelevant faces ( more than 12% ) are eliminated manually before doing clustering .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6,7,8,9,10#6,7,8,9#para -1#11#11#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#17,18,19#17,18,19,20#para -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact -1#28#29#exact -1#29#30#exact -1#30#31#exact -1#32#33#exact -1#33#34#exact 


This paper is organized as follows : Section \REF introduces our proposed framework .
This paper is organized as follows : Section \REF introduces our proposed framework .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact 


Section \REF briefly introduces typical outlier detection methods .
Section \REF introduce briefly typical outliers detection methods .
-1#0#0#exact -1#1#1#exact -1#3#2#exact -1#4#4#exact -1#5#5#stem -1#6#6#exact -1#7#7#exact -1#8#8#exact 


Experiments and results are described in section \REF .
Experiments and results are described in section \REF .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact 


Finally , section \REF concludes the paper .
Finally , section \REF concludes the paper .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact 


Given a set of faces returned by any text-based correlation search engine , our method is used to perform a ranking process summarized as follows :
Given a set of faces returned by any text-based correlation search engine , our method performs a ranking process summarized as follows :
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#21#15#syn -1#15#18#stem -1#16#19#exact -1#17#20#exact -1#18#21#exact -1#19#22#exact -1#20#23#exact -1#22#25#exact 


-Step 1 : Detect eye positions , and then perform face normalizations .
-Step 1 : Detect eye positions , and then perform face normalizations .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact 


-Step 2 : Compute an eigenface space and project the input faces into this subspace .
-Step 2 : Compute an eigenface space and project the input faces into this subspace .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact 


-Step 3 : Estimate ranks of faces using an outlier detection method mentioned in \REF .
-Step 3 : Estimate ranks of faces using an outliers detection method mentioned in \REF .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#stem -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact 


-Step 4 : Train an ensemble classifier \MATH using this rank list by Bag-Rank-SVM .
-Step 4 : Train a ensemble classifier \MATH using this rank list by Bag-Rank-SVM .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact 


-Step 5 : Use the classifier \MATH to estimate the probability of faces in the original set .
-Step 5 : Use the classifier \MATH to estimate the probability of faces in the original set .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact 


Rank these faces using their probability scores .
Rank these faces using their probability score .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#stem -1#7#7#exact 


-Step 6 : Repeat steps 4 and 5 $T$ times and return ranked faces produced by the last classifier \MATH to users .
-Step 6 : Repeat steps from 4 and 5 $T$ times and return ranked faces produced by the last classifier \MATH to users .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact -1#23#22#exact 


Steps 1 and 2 are typical for any face processing system and described in detail in \REF .
Steps from 1 and 2 are typical for any face processing system and described in details in \REF .
-1#0#0#exact -1#2#1#exact -1#3#2#exact -1#4#3#exact -1#5#4#exact -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#stem -1#16#15#exact -1#17#16#exact -1#18#17#exact 


Step 3 used to find initial ranks for faces described in \REF .
Step 3 used to find initial ranks for faces is described in \REF .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact 


We used a simple outlier detection method for this step .
We use a simple outliers detection method for this step .
-1#0#0#exact -1#1#1#stem -1#2#2#exact -1#3#3#exact -1#4#4#stem -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact 


The Bag-Rank-SVM algorithm is described as follows :
The Bag-Rank-SVM algorithm is described as follows :
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact 


-Step 1 : Select a set \MATH including \MATH top ranked faces and then randomly select a subset \MATH from \MATH .
-Step 1 : Select a set \MATH including \MATH top ranked faces and then randomly select a subset \MATH from \MATH .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact 


Label faces in \MATH as positive samples .
Label faces in \MATH as positive samples .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact 


-Step 2 : Select a set \MATH including \MATH bottom ranked faces and then randomly select a subset \MATH from \MATH .
-Step 2 : Select a set \MATH including \MATH bottom ranked faces and then randomly select a subset \MATH from \MATH .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact 


Label faces in \MATH as negative samples .
Label faces in \MATH as negative samples .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact 


-Step 3 : Use \MATH and \MATH to train a weak classifier \MATH using LibSVM \CITE with probability outputs .
-Step 3 : Use \MATH and \MATH to train a weak classifier \MATH using LibSVM \CITE with probability outputs .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact 


-Step 4 : Repeat steps Step 1 to Step 3 \MATH times .
-Step 4 : Repeat steps from Step 1 to Step 3 \MATH times .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact 


-Step 5 : Return \MATH .
-Step 5 : Return \MATH .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact 


Since it is not guaranteed that the top \MATH and bottom \MATH of faces in the rank list correctly correspond to the faces of the queried person-\MATH and faces of non person-\MATH as shown in Figure \REF , randomly selecting subsets to train weak classifiers , and then combining these classifiers might help reduce the risk of using noisy training sets .
Since it is not guaranteed top \MATH and bottom \MATH of faces in the rank list are correctly correspondent to faces of the queried person \MATH and faces of non person \MATH as shown in Figure \REF , selecting randomly subsets to train weak classifiers and then combining these classifiers might help to reduce risk of using noisy training sets .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#13#6#exact -1#5#7#exact -1#6#8#exact -1#7#9#exact -1#8#10#exact -1#9#11#exact -1#10#12#exact -1#11#13#exact -1#12#14#exact -1#22#15#exact -1#14#16#exact -1#15#17#exact -1#17#18#exact -1#18#19#stem -1#19#20#exact -1#20#22#exact -1#21#23#exact -1#23#25#exact -1#26#27#exact -1#27#28#exact -1#28#29#exact -1#29#30#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact -1#37#37#exact -1#39#38#exact -1#38#39#exact -1#40#40#exact -1#41#41#exact -1#42#42#exact -1#43#43#exact -1#44#44#exact -1#45#46#exact -1#46#47#exact -1#47#48#exact -1#48#49#exact -1#49#50#exact -1#50#51#exact -1#51#52#exact -1#53#53#exact -1#54,55#54,55,56#para -1#56#57#exact -1#57#58#exact -1#58#59#exact -1#59#60#exact -1#60#61#exact 


In our framework , outlier detection methods are used to initialize the rank list that is then used to label a subset of samples for training SVM classifiers .
In our framework , outliers detection methods are used to initialize the rank list that is then used to label a subset of samples for training SVM classifiers .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#stem -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact 


We introduce two common outlier detection methods , distance-based outlier detection ( DBO ) \CITE and local outlier factor-based method ( LOF ) \CITE .
We introduce here two common outliers detection methods including distance-based outliers detection( DBO ) \CITE and local outliers factor based method ( LOF ) \CITE .
-1#0#0#exact -1#1#1#exact -1#3#2#exact -1#4#3#exact -1#5#4#stem -1#6#5#exact -1#7#6#exact -1#9#8#exact -1#10#9#stem -1#21#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#stem -1#20#19#exact -1#22#21#exact -1#23#22#exact -1#24#23#exact -1#25#24#exact 


Adapting the definition from Knorr \CITE , given a set of objects \MATH , an object \MATH is considered as an outlier if there are fewer than \MATH neighboring objects in \MATH lying within a distance \MATH .
Adapting the definition \CITE , given a set of objects \MATH , an object \MATH is considered as an outliers if there are fewer than \MATH neighboring objects in \MATH lying within a distance \MATH .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#5#exact -1#4#6#exact -1#5#7#exact -1#6#8#exact -1#7#9#exact -1#8#10#exact -1#9#11#exact -1#10#12#exact -1#11#13#exact -1#12#14#exact -1#13#15#exact -1#14#16#exact -1#15#17#exact -1#16#18#exact -1#17#19#exact -1#18#20#exact -1#19#21#stem -1#20#22#exact -1#21#23#exact -1#22#24#exact -1#23#25#exact -1#24#26#exact -1#25#27#exact -1#26#28#exact -1#27#29#exact -1#28#30#exact -1#29#31#exact -1#30#32#exact -1#31#33#exact -1#32#34#exact -1#33#35#exact -1#34#36#exact -1#35#37#exact 


This outlier detection process is summarized as follows :
The outliers detection process is summarized as follows :
-1#1#1#stem -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact 


-Step 1 : Compute the distance between every pair of data objects .
-Step 1 : Compute the distance between every pair of data objects .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact 


-Step 2 : For each object , compute \MATH , which is the number of neighboring objects lying within a distance \MATH .
-Step 2 : For each object , compute \MATH which is the number of neighboring objects lying within a distance \MATH .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#11,12#10,11,12,13#para -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact 


-Step 3 : Rank objects based on their scores \MATH .
-Step 3 : Rank objects based on their scores \MATH .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact 


In our experiments , the distance between two objects is the Euclidean distance between two faces and is computed in the eigen-subspace ( described in section \REF ) .
In our experiments , the distance between two objects is Euclidean distance between two faces and is computed in the eigen-subspace ( described in section \REF ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#19#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact 


Figure \REF shows two examples of good and bad performances using this method for ranking relevant faces .
Figure \REF shows two examples of good and bad performance using this method for ranking relevant faces .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#stem -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact 


According to the method described in \CITE , the local outlier factor of an object \MATH is computed by the following steps and then used to rank faces :
According to the method described in \CITE , the local outliers factor of an object \MATH is computed by the following steps and then used to rank faces :
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#stem -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact 


-Step 1 : For each data object \MATH compute the \MATH ( the distance to the \MATH nearest neighbor ) and \MATH ( all points in a \MATH sphere ) .
-Step 1 : For each data object \MATH compute \MATH ( the distance to the \MATH nearest neighbor ) and \MATH ( all points in a \MATH sphere ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#11#9#exact -1#9#10#exact -1#10#11#exact -1#14#12#exact -1#12#13#exact -1#13#14#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact -1#28#29#exact -1#29#30#exact 


- Step 2 : Compute the reachability distance for each data object \MATH with respect to data object \MATH as : \MATH , where \MATH is the distance from data object \MATH to data object \MATH .
- Step 2 : Compute reachability distance for each data object \MATH with respect to data object \MATH as : \MATH , where \MATH is distance from data object \MATH to data object \MATH .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26,27#para -1#26#28#exact -1#27#29#exact -1#28#30#exact -1#29#31#exact -1#30#32#exact -1#31#33#exact -1#32#34#exact -1#33#35#exact -1#34#36#exact 


-Step 3 : Compute local reachability density of data object \MATH as inverse of the average reachability distance based on the \MATH ( minimum number of data objects ) of the nearest neighbors to data object \MATH .
-Step 3 : Compute local reachability density of data object \MATH as inverse of the average reachability distance based on the \MATH ( minimum number of data objects ) nearest neighbors of data object \MATH .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#31#29#exact -1#29#31#exact -1#30#32#exact -1#32#33,34#para -1#33#35#exact -1#34#36#exact -1#35#37#exact 


-Step 4 : Compute LOF of data object \MATH as the average of the ratios of the local reachability density of data object \MATH and local reachability density of \MATH of nearest neighbors .
-Step 4 : Compute LOF of data object \MATH as average of the ratios of the local reachability density of data object \MATH and local reachability density of \MATH nearest neighbors .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#12#10#exact -1#10#11#exact -1#11#12#exact -1#15#13#exact -1#13#14#exact -1#14#15#exact -1#16#16,17#para -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact -1#28#29#exact -1#29#31#exact -1#30#32#exact -1#31#33#exact 


We used the dataset described in \CITE for our experiments .
We used the dataset described in \CITE for our experiments .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact 


This dataset consisted of approximately half a million news pictures and captions from Yahoo News over a period of roughly two years .
This dataset consists of approximately half a million news pictures and captions from Yahoo News over a period of roughly two years .
-1#0#0#exact -1#1#1#exact -1#2,3#2,3#para -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact 


Using a robust face detector , 44 , 773 faces were detected and normalized to the size of 86\MATH86 pixels .
Using a robust face detector , 44 , 773 faces were detected and normalized to the size of 86\MATH86 pixels .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#15,16,17#14,15,16,17#para -1#18#18#exact -1#19#19#exact -1#20#20#exact 


After eliminating faces whose facial features were poorly detected by a rectification process and faces whose associated names were not extracted properly from the corresponding captions , 30 , 281 faces were kept .
After eliminating faces whose facial features are poorly detected by a rectification process and faces whose associated names are not extracted properly from corresponding captions , 30 , 281 faces were kept .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6,7#6,7#para -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18,19#18,19#para -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23,24#para -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact -1#28#29#exact -1#29#30#exact -1#30#31#exact -1#31#32#exact -1#32#33#exact 


Figure \REF shows an example of a news photo and its caption .
Figure \REF shows an example of a news photo and its caption .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact 


We selected sixteen government leaders including George W . Bush ( US ) , Vladimir Putin ( Russia ) , Ziang Jemin ( China ) , Tony Blair ( UK ) , Junichiro Koizumi ( Japan ) , Roh Moo-hyun ( Korea ) , Abdullah Gul ( Turkey ) , and other key individuals such as John Paul II ( the Former Pope ) and Kofi Annan and Hans Blix ( UN ) since their images appeared frequently in the dataset \CITE .
We selected sixteen celebrities who are government leaders such as George W . Bush ( US ) , Vladimir Putin ( Russia ) , Ziang Jemin ( China ) , Tony Blair ( UK ) , Junichiro Koizumi ( Japan ) , Roh Moo-hyun ( Korea ) , Abdullah Gul ( Turkey ) , and other key persons such as John Paul II ( the Former Pope ) , Kofi Annan and Hans Blix ( UN ) . These persons are selected since their appearances are highly frequent in the dataset \CITE .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#6#3#exact -1#7#4#exact -1#10#6#exact -1#11#7#exact -1#12#8#exact -1#13#9#exact -1#14#10#exact -1#15#11#exact -1#16#12#exact -1#17#13#exact -1#18#14#exact -1#19#15#exact -1#20#16#exact -1#21#17#exact -1#22#18#exact -1#23#19#exact -1#24#20#exact -1#25#21#exact -1#26#22#exact -1#27#23#exact -1#28#24#exact -1#29#25#exact -1#30#26#exact -1#31#27#exact -1#32#28#exact -1#33#29#exact -1#34#30#exact -1#35#31#exact -1#36#32#exact -1#37#33#exact -1#38#34#exact -1#39#35#exact -1#40#36#exact -1#41#37#exact -1#42#38#exact -1#43#39#exact -1#44#40#exact -1#45#41#exact -1#46#42#exact -1#47#43#exact -1#48#44#exact -1#49#45#exact -1#50#46#exact -1#51#47#exact -1#52#48#exact -1#53#49#exact -1#54#50#exact -1#55#51#exact -1#56#52#exact -1#57#53#syn -1#58#54#exact -1#60,61,62#55,56,57,58#para -1#63#59#exact -1#64#60#exact -1#65#61#exact -1#66#62#exact -1#67#63#exact -1#71#64#exact -1#69#65#exact -1#70#66#exact -1#72#68#exact -1#73#69#exact -1#74#70#exact -1#75#71#exact -1#76#72#exact -1#82#73#exact -1#83#74#exact -1#84#76#stem -1#87,88#77,78#para -1#89#79#exact -1#90#80#exact -1#91#81#exact -1#92#82#exact 


For each person , variations of his name were collected . For example , George W . Bush , President Bush , U . S . President , etc are variations of U . S . President Bush .
For each person , variations of his name are collected . For example , George W . Bush , President Bush , U . S . President , etc are variations of U . S . President Bush .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8,9#8,9#para -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact -1#37#37#exact -1#38#38#exact 


We indexed image captions and then used this index to retrieve faces associated with the captions containing names of the queried person .
We indexed image captions and then used this index to retrieve faces associated with the captions containing names of the queried person .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact 


The faces retrieved from different names of each person were merged into a set used for our ranking process .
The faces retrieved from different names of each person are merged into a set used for our ranking process .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#syn -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact 


Figure \REF shows faces retrieved when searching Mr . Kofi Annan .
Figure \REF shows faces retrieved when searching Mr . Kofi Annan .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact 


Figure \REF shows the distribution of retrieved faces from this method and the corresponding number of relevant faces for these ten individuals .
Figure \REF shows the distribution of retrieved faces from this method and the corresponding number of relevant faces for these ten persons .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#syn -1#22#22#exact 


In total , 3 , 907 faces were retrieved in which 2 , 094 faces were relevant .
In total , 3 , 907 faces are retrieved in which 2 , 094 faces are relevant .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#14,15#7#para -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#7#15#syn -1#16#16#exact -1#17#17#exact 


On average , the precision was 52.49% . //[precision / accuracy ? ]
On average , the precision is 52.49% .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#syn -1#6#6#exact -1#7#7#exact 


We used an eye detector to detect eye positions of detected faces .
We used an eye detector to detect eye positions of detected faces .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact 


These eye positions were used to align faces to a predefined canonical pose .
These eye positions were used to align faces to a predefined canonical pose .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact 


To compensate for illumination effects , the subtraction of the best-fit brightness plane followed by histogram equalization was applied .
To compensate for illumination effects , the subtraction of the bestfit brightness plane followed by histogram equalization was applied .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact 


This normalization process is shown in Figure \REF .
This normalization process is shown in Figure \REF .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact 


We then used principle component analysis \CITE to reduce the number of dimensions of the feature vector for face representation .
We then used PCA \CITE to reduce the number of dimensions of the feature vector for face representation .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#4#6#exact -1#6,7,8,9#7,8,9,10,11#para -1#10#12#exact -1#11#13#exact -1#12#14#exact -1#13#15#exact -1#14#16#exact -1#15#17#exact -1#16#18#exact -1#17#19#exact -1#18#20#exact 


Eigenfaces were computed from the original face set returned by the text-based query method .
Eigenfaces were computed from the original face set returned by the text based query method .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact 


A number of eigenfaces was selected so that 97% of the total energy was retained \CITE . //[What is that number ? ]
The number of eigenfaces was selected so that 97% of the total energy are retained \CITE .
-1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#syn -1#14#14#exact -1#15#15#exact -1#16#16#exact 


We evaluated the retrieval performance with measures that are commonly used in information retrieval such as precision , recall , and average precision .
We evaluated the retrieval performance with measures that are popularly used in information retrieval such as precision , recall and average precision .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#para -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact 


Given a queried person , assuming that \MATH is the total number of faces returned , \MATH is the number of relevant faces , \MATH is the number of relevant faces , we calculated recall and precision as follows : //[Nrel and Nhit are exactly the same here . They should be different .]
Given a queried person , assuming that \MATH is the total number of faces returned , \MATH is the number of relevant faces , \MATH is the number of relevant faces , we calculate recall and precision as follows :
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9,10,11,12#9,10,11#para -1#20#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#28#20#exact -1#29#21#exact -1#30#22#exact -1#31#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#21#29#exact -1#22#30#exact -1#23#31#exact -1#32#32#exact -1#33#33#stem -1#34#34#exact -1#35#35#exact -1#36#36#exact -1#37#37#exact -1#38#38#exact -1#39#39#exact 


Precision and recall only evaluate the quality of an unordered set of retrieved faces .
Precision and recall only evaluate the quality of an unordered set of retrieved faces .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact 


To evaluate ranked lists , average precision is used .
To evaluate ranked lists , the average precision is used .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact 


The average precision is computed by taking the average of the interpolated precision measured at the 11 recall levels of 0.0 , 0.1 , 0.2 , ... , 1.0 .
The average precision is computed by taking average of the interpolated precision measured at the 11 recall levels of 0.0 , 0.1 , 0.2 , ... , 1.0 .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#9#7#exact -1#7#8#exact -1#8#9#exact -1#14#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact -1#28#29#exact 


The interpolated precision \MATH at a certain recall level \MATH is defined as the highest precision found for any recall level \MATH :
The interpolated precision \MATH at a certain recall level \MATH is defined as the highest precision found for any recall level \MATH :
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact 


In addition , to evaluate the performance of multiple queries , we used mean average precision , which is the mean of average precisions computed from queries .
In addition , to evaluate performance of multiple queries , we used mean average precision that is the mean of average precisions computed from queries .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#17#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15,16#17,18#para -1#18#20#exact -1#19#21#exact -1#20#22#exact -1#21#23#exact -1#22#24#exact -1#23#25#exact -1#24#26#exact -1#25#27#exact 


We show in Figure \REF the retrieval performance of the outlier detection methods and the baseline method using text correlation .
We show in Figure \REF the retrieval performance of outliers detection methods and the baseline method using text correlation .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#13#9#exact -1#9#10#stem -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact 


In the baseline method , faces were sorted by the time the associated news article was published .
In the baseline method , faces are sorted by the time that the associated news article is published .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#syn -1#7#7#exact -1#8#8#exact -1#9,10,11,12#9,10,11#para -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#17#15,16#para -1#18#17#exact 


It indicated that the DBO-based method outperformed the others .
It indicates that DBO-based method outperforms the others .
-1#0#0#exact -1#1,2#1,2#para -1#6#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#stem -1#7#7,8#para -1#8#9#exact 


The baseline method performed the worst .
The baseline method performs the worst .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#stem -1#4#4#exact -1#5#5#exact -1#6#6#exact 


The LOF-based method tends to be less sensitive when the threshold is changed .
LOF-based method tends to be less sensitive when the threshold is changed .
-1#8#0#lc -1#0#1#exact -1#1#2#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#9#9,10#para -1#10#11#exact -1#11#12#exact -1#12#13#exact 


This suggests that the input face sets were quite dense .
This suggests that the input face sets are quite dense .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7,8#7,8#para -1#9#9#exact -1#10#10#exact 


We studied the effect of choosing the number of times \MATH appeared in the Bag-Rank-SVM algorithm .
We studied effect of choosing number of times \MATH in the Bag-Rank-SVM algorithm .
-1#0#0#exact -1#1#1#exact -1#10#2#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5,6#6,7,8#para -1#7#9#exact -1#8#10#exact -1#9#12#exact -1#11#14#exact -1#12#15#exact -1#13#16#exact 


We used DBO as the method for making the initial rank list from which 30 training subsets were generated and used for training SVM classifiers using linear kernels with probability output .
We used DBO as the method for making the initial rank list from which 30 training subsets were generated and used for training SVM classifiers using linear kernel with probability output .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#stem -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact 


To select one subset , we set \MATH and \MATH which means 20% of the highest ranked faces were used for \MATH and 30% of the lowest ranked faces were used for \MATH .
To select one subset , we set \MATH and \MATH which means 20% of highest ranked faces are used for \MATH and 30% of lowest ranked faces are used for \MATH .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14,15#para -1#15#16#exact -1#16#17#exact -1#17,18#18,19#para -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25,26#para -1#25#27#exact -1#26#28#exact -1#27,28#29,30#para -1#29#31#exact -1#30#32#exact -1#31#33#exact 


The subsets \MATH and \MATH were generated by randomly selecting with replacement 70% samples of \MATH and \MATH .[gWith replacementh does not make sense here . I am not sure what you want to say .]
The subsets \MATH and \MATH are generated by randomly selecting with replacement 70% samples of \MATH amd \MATH .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5,6#5,6#para -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#17#17#exact -1#18#25#exact 


Figure \REF shows the performance of single and ensemble classifiers .
Figure \REF shows performance of single classifiers and ensemble classifiers .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact 


It suggests that the performance does not change significantly after five iterations .
It suggests that the performance does not change significantly after 5 iterations .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#syn -1#11#11#exact -1#12#12#exact 


In addition , the performance of the ranking process improved when the ensemble classifier was used .
In addition , the performance of the ranking process is improved when using the ensemble classifier .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#10#9#exact -1#11#10#exact -1#13#11#exact -1#14#12#exact -1#15#13#exact -1#9#14#syn -1#12#15#stem -1#16#16#exact 


We set the number of iterations for the Bag-Rank-SVM algorithm at five and set the number of iterations of the outer loop $T=30$ to see how much the final performance changes .
We set the number of iterations for the Bag-Rank-SVM algorithm being 5 and set the number of iterations of the outer loop $T=30$ to see how much the final performance changes .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#11#11#syn -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact 


As shown in Figure \REF , the performance did not change much after five iterations .
As shown in Figure \REF , the performance does not change so much after 5 iterations .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#9,10#8,9,10#para -1#12#11#exact -1#13#12#exact -1#14#13#syn -1#15#14#exact -1#16#15#exact 


From these experiments , \MATH and \MATH are suitable values for the proposed method .
From these experiments , \MATH and \MATH are suitable values for the proposed method .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact 


The performance of different methods shown in Figure \REF indicates that our proposed method outperformed the distance-based outlier detection method and performed comparable to the supervised method using 5% annotation data .
The performance of different methods shown in Figure \REF indicates that our proposed method outperforms the distance-based outliers detection method and has comparable performance with the supervised method using 5% annotation data .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#stem -1#15#15#exact -1#16#16#exact -1#17#17#stem -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#para -1#22#22#exact -1#25#24#exact -1#26#25#exact -1#27#26#exact -1#28#27#exact -1#29#28#exact -1#30#29#exact -1#31#30#exact -1#32#31#exact 


As shown in Figures \REF , \REF , \REF , our proposed method produced better results in terms of average precision in which relevant faces were put at the top of the returned list .
As shown in Figure \REF , \REF , \REF , our proposed method produces better results in terms of average precision in which relevant faces are put on the top of the returned list .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#stem -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#stem -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#syn -1#26#26#exact -1#28,29,30,31#27,28,29,30,31#para -1#32#32#exact -1#33#33#exact -1#34#34#exact 


We presented a method for effectively ranking faces retrieved using text-based correlation methods when searching for a specific person .
We present a method to effectively rank faces retrieved by text-based correlation methods when searching a specific person .
-1#0#0#exact -1#1#1#stem -1#2#2#exact -1#3,4#3,4#para -1#5#5#exact -1#6#6#stem -1#7#7#exact -1#8#8#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact 


Using the rank list estimated from the previous steps , we automatically selected a subset of positive and negative samples to train a classifier using SVM with probability outputs . //[Since this is the conclusion , you might want to be more specific on what gthe previous stepsh are . ]
Using the rank list estimated from the previous steps , we automatically select a subset of positive and negative samples to train a classifier using SVM with probability outputs .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#stem -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact 


This classifier was used to rank input faces for the next step .
This classifier is used to rank input faces for the next step .
-1#0#0#exact -1#1#1#exact -1#2,3#2,3#para -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact 


Since the labels of training sets were still noisy , the classifiers trained from these datasets were weak .
Since labels of training sets are still noisy , the classified trained by these datasets are weak .
-1#0#0#exact -1#9#1#exact -1#1#2#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5,6#6,7#para -1#7#8#exact -1#8#9#exact -1#10#11#stem -1#11#12#exact -1#13#14#exact -1#14#15#exact -1#15#16#syn -1#16#17#exact -1#17#18#exact 


By combining multiple weak classifiers in a bagging framework , we constructed the final strong classifier , which produced good results .
By combining multiple weak classifiers in a bagging framework , the final strong classifier is constructed and produce good results .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#15#11#exact -1#10#12#exact -1#11#13#exact -1#12#14#exact -1#13#15#exact -1#17#18#stem -1#18#19#exact -1#19#20#exact -1#20#21#exact 


To obtain the initial rank for the first step , we proposed using a common outlier detection method .
To get initial rank for the first step , we propose to use common outliers detection method .
-1#0#0#exact -1#1#1#syn -1#5#2#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10,11#11#para -1#12#12#stem -1#13#13,14#para -1#14#15#stem -1#15#16#exact -1#16#17#exact -1#17#18#exact 


Face detection , tracking , and recognition for broadcast video
Face detection , tracking , and recognition for broadcast video
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact 


Human face processing techniques for broadcast video , including face detection , tracking , and recognition , have long been a topic that has attracted a lot of research interest due to its crucial value in various applications , such as in video structuring , indexing , retrieval , and summarization .
Human face processing techniques for broadcast video including face detection , tracking and recognition have long been a topic that attracts much research interest due to its crucial value in various applications including video structuring , indexing , retrieval , summarization , etc.
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#10#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#35#11#exact -1#11#12#exact -1#37#13#exact -1#12#14#exact -1#13#15#exact -1#39#16#exact -1#14#17#exact -1#15#18#exact -1#16#19#exact -1#17,18#20,21,22,23#para -1#20#24#stem -1#21#25,26#para -1#22#27,28#para -1#23#29#exact -1#24#30#exact -1#25#31#exact -1#26#32#exact -1#27#33#exact -1#28#34#exact -1#29#35#exact -1#30#36#exact -1#31#37#exact -1#41#38#exact -1#33#42#exact -1#34#43#exact -1#36#45#exact -1#38#47#exact -1#40#50#exact 


The main reason for this is that the human face provides rich information for people 's appearances , such as for a government leader in a news video , a pitcher in a sports video or a hero in a movie , and is the basis for interpreting facts .
The main reason is human face provides rich information for people 's appearance such as a government leader in a news video , a pitcher in a sport video or a hero in a movie , and is the basis for interpreting facts .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#9#3#exact -1#3#5#exact -1#38#7#exact -1#4#8#exact -1#5#9#exact -1#6#10#exact -1#7#11#exact -1#8#12#exact -1#40#13#exact -1#10#14#exact -1#11#15#exact -1#12#16#stem -1#22#17#exact -1#13#18#exact -1#14#19#exact -1#15#21#exact -1#16#22#exact -1#17#23#exact -1#18#24#exact -1#19#25#exact -1#20#26#exact -1#21#27#exact -1#35#28#exact -1#23#29#exact -1#24#30#exact -1#25#31#exact -1#26#32#exact -1#27#33#stem -1#28#34#exact -1#29#35#exact -1#30#36#exact -1#31#37#exact -1#32#38#exact -1#33#39#exact -1#34#40#exact -1#36#42#exact -1#37#43#exact -1#39#44,45#para -1#41#47#exact -1#42#48#exact -1#43#49#exact 


This article describes some state-of-the art techniques for face detection , tracking , and recognition with applications to broadcast video .
This article describes state-of-the art techniques for face detection , tracking and recognition with application to broadcast video .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#13#exact -1#12#14#exact -1#13#15#exact -1#14#16#stem -1#15#17#exact -1#16#18#exact -1#17#19#exact -1#18#20#exact 


Face detection , which is the task of localizing faces in an input image , is a fundamental part of any face processing system .
Face detection which is the task of localizing faces in an input image is fundamental for any face processing system .
-1#0#0#exact -1#1#1#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#15#exact -1#14#16,17#para -1#16#18,19,20#para -1#17#21#exact -1#18#22#exact -1#19#23#exact -1#20#24#exact 


The extracted faces can then be used for initializing face tracking or automatic face recognition .
The extracted faces can then be used for initializing of face tracking or automatic face recognition .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact 


An ideal face detector should possess the following characteristics :
An ideal face detector should possess the following characteristics :
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact 


- Robustness : it should be capable of handling appearance variations , such as pose changes , size , illuminations , occlusions , complex backgrounds , facial expressions , and low resolutions .
- Robustness : it should be capable of handling appearance variations of pose changes , size , illuminations , occlusions , complex background , facial expressions , low resolutions , etc.
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#14#11#exact -1#12#14#exact -1#13#15#exact -1#18#16#exact -1#15#17#exact -1#16#18#exact -1#17#19#exact -1#23#20#exact -1#19#21#exact -1#20#22#exact -1#21#23#exact -1#22#24#stem -1#29#25#exact -1#24#26#exact -1#25#27#exact -1#26#28#exact -1#27#30#exact -1#28#31#exact 


- Quickness : it should be fast in order to perform real-time processing , which is an important factor in processing large video archives .
- Fastness : it should be fast for real-time processing which is an important factor in processing large video archives .
-1#0#0#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#15#7#exact -1#8#11#exact -1#9#12#exact -1#10#14#exact -1#12,13#15,16,17,18#para -1#16#20#exact -1#17#21#exact -1#18#22#exact -1#19#23#exact -1#20#24#exact 


- Simplicity : the training process should be simple .
- Simplicity : The training process should be simple .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#lc -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact 


For example , the training time is short , the number of parameters is small , and training samples are collected cheaply .
For example , the training time is short , the number of parameters is small and training samples are collected without costly .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#22#22#exact 


Many approaches have been proposed for building faster and more robust face detectors \CITE .
Many approaches have been proposed for building fast and robust face detectors \CITE .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#syn -1#8#8#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact 


Among them , those using advanced learning methods , such as neural network , support vector machines and boosting , are the best .
Among them , those using advanced learning methods such as neural network , support vector machines and boosting are the best .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#12#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#20#exact -1#19#21#exact -1#20#22#exact -1#21#23#exact 


Typically , detecting the faces in an image takes the following steps :
Typically , detecting faces in an image includes the following steps :
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#8#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#9#9,10#para -1#10#11#exact -1#11#12#exact 


- Window scanning : in order to detect faces at multiple locations and sizes , a fixed window size ( e.g. 24 x 24 pixels ) is used to extract image patterns at every location and scale .
- Window scanning : in order to detect faces at multiple locations and sizes , a fixed window size ( e.g. 24x24 pixels ) is used to extract image patterns at every location and scale .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#22#24#exact -1#23#25#exact -1#24#26#exact -1#25#27#exact -1#26#28#exact -1#27#29#exact -1#28#30#exact -1#29#31#exact -1#30#32#exact -1#31#33#exact -1#32#34#exact -1#33#35#exact -1#34#36#exact -1#35#37#exact 


The number of patterns extracted from a 320 x 240 frame image is large , approximately 160 ,000 , in which only a small number of patterns contain a face .
The number of patterns extracted from one 320x240 frame image is large , approximately 160 ,000 in which only a small number of patterns containing face .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#19#6#exact -1#8#10#exact -1#9#11#exact -1#10#12#exact -1#11#13#exact -1#12#14#exact -1#13#15#exact -1#14#16#exact -1#15#17#exact -1#16#19#exact -1#17#20#exact -1#18#21#exact -1#20#22,23#para -1#21#24#exact -1#22#25#exact -1#23#26#exact -1#24#27#stem -1#25#29#exact -1#26#30#exact 


- Feature extraction : given an image pattern , the features are extracted .
- Feature extraction : given an image pattern , features are extracted .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9,10#para -1#10#11#exact -1#11#12#exact -1#12#13#exact 


The most popular feature type is the Haar wavelet because it is very fast to compute using the integral image \CITE .
The most popular feature type is Haar wavelet since it is very fast to compute using the integral image \CITE .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#16#6#exact -1#6#7#exact -1#7#8#exact -1#8,9,10#9,10,11#para -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact 


Other feature types can be listed including the pixel intensity \CITE , local binary patterns \CITE , and edge orientation histogram \CITE .
Other feature types can be listed including pixel intensity \CITE , local binary patterns \CITE and edge orientation histogram \CITE .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#17#exact -1#16#18#exact -1#17#19#exact -1#18#20#exact -1#19#21#exact -1#20#22#exact 


- Classification : the extracted features are passed through a classifier that has been previously trained to classify the input pattern associated with these features as a face or a non-face . //[trained / programmed ?]
- Classification : the extracted features is passed through a classifier which is trained beforehand to classify the input pattern associated with these features as a face or a non-face .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#syn -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#12#12,13#para -1#13#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact -1#28#29#exact -1#29#30#exact -1#30#31#exact 


- Merging overlapping detections : since the classifier is insensitive to small changes in translation and scale , there might be multiple detections around each face .
- Merging overlapping detections : since the classifier is insensitive to small changes in translation and scale , there might be multiple detections around each face .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact 


In order to return a single final detection per face , it is necessary to combine the overlapping detections into a single detection .
In order to return one final detection per face , it is necessary to combine overlapping detections into a single detection .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#18#4#exact -1#19#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10,11,12,13#11,12,13#para -1#14#14,15#para -1#15#17#exact -1#16#18#exact -1#17#19#exact -1#4#21#syn -1#20#22#exact -1#21#23#exact 


Since the vast majority of processed patterns are non-face , the single classifier based systems , such as the neural network \CITE and the support vector machines \CITE , are usually slow .
Since the number of processed patterns is large while the vast majority of them are non-face , a single classifier based systems such as neural network \CITE and support vector machines \CITE are usually slow .
-1#0#0#exact -1#1#1#exact -1#10#2#exact -1#11#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#14#7#exact -1#15#8#exact -1#16#9#exact -1#17,18#10,11#para -1#19#12#exact -1#20#13#exact -1#21#14#exact -1#22#16#exact -1#23#17#exact -1#9#18#exact -1#24#19#exact -1#25#20#exact -1#26#21#exact -1#27#22#exact -1#28#23,24#para -1#29#25#exact -1#30#26#exact -1#31#27#exact -1#32#29#exact -1#33#30#exact -1#34#31#exact -1#35#32#exact 


To overcome this problem , a combination of simple-to-complex classifiers has been proposed \CITE leading to the first real-time robust face detector in the world .
To overcome this problem , a combination of simple-to-complex classifiers has been proposed \CITE leading to the first real-time robust face detector in the world .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact 


In this structure , fast and simple classifiers are used as filters in the earliest stages to quickly reject a large number of the non-face patterns and then slower but more accurate classifiers are used for classifying the face-like patterns .
In this structure , fast and simple classifiers are used as filters at the earliest stages to quickly reject a large number of non-face patterns and slower yet more accurate classifiers are then used for classifying face-like patterns .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19,20,21,22#19,20,21,22,23#para -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#32#27#exact -1#26#28#exact -1#28#30#exact -1#29#31#exact -1#30#32#exact -1#31#33#exact -1#33#34#exact -1#34#35#exact -1#35#36#exact -1#36#38#exact -1#37#39#exact -1#38#40#exact 


In this way , the complexity of classifiers can be adapted to correspond to the increasing difficulty with the input patterns .
In this way , the complexity of classifiers can be adapted corresponding to the increasing difficulty in the input patterns .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#12#11#exact -1#11#12#stem -1#13,14#13,14,15#para -1#15#16#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact 


Training classifiers usually consist of the following steps :
Training classifiers usually consists of several steps :
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#stem -1#4#4#exact -1#6#7#exact -1#7#8#exact 


339
Nevertheless , a heuristic word segmentation method CHAR achieved relatively good word-based BLEU scores and competitive character-based BLEU results , compared to the supervised analyzers .



Additionally , as we could not always obtain consistent scores from the current evaluation metrics , the data was insufficient for discussing the relative advantages and disadvantages of word segmentation , with accuracy .
Additionally , as we could not always obtain consistent scores from the current evaluation metrics , they were not sufficient to discuss more accurately about the relative advantages and disadvantages of word segmentation .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#25#16#exact -1#16,17#18#para -1#18,19,20#19,20#para -1#21#21#stem -1#26#22,23#para -1#27,28,29,30#24,25,26#para -1#31#28#exact -1#32#29#exact -1#23#32#para -1#33#33#exact 


We have also suggested that it is possible to implement more optimized word segmentation on SMT .
We also suggested it is possible to implement more optimized word segmentation on SMT .
-1#0#0#exact -1#1#2#exact -1#2#3#exact -1#3,4#4,5,6#para -1#5#7#exact -1#6#8#exact -1#7#9#exact -1#8#10#exact -1#9#11#exact -1#10#12#exact -1#11#13#exact -1#12#14#exact -1#13#15#exact -1#14#16#exact 


- Training set preparation : Supervised learning methods require a large number of training samples to obtain accurate classifiers .
- Training set preparation : Supervised learning methods require a large number of training samples to obtain accurate classifiers .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#10,11,12#9,10,11,12#para -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact 


The training samples are patterns that must be labeled as face ( positive samples ) or non-face ( negative samples ) in advance .
The training samples are patterns that must be labeled as face ( positive sample ) or non-face ( negative sample ) in advance .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#stem -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#stem -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact 


Face patterns are manually collected from images containing faces and then are scaled to the same size and normalized to a canonical pose in which the eyes , mouth , and nose are aligned .
Face patterns are manually collected in images containing faces and then are scaled to the same size and normalized to a canonical pose which eyes , mouth and nose are aligned .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4,5#4,5#para -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#15,16,17#14,15,16,17#para -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23,24#para -1#14#25#exact -1#24#26#exact -1#25#27#exact -1#26#28#exact -1#27#30#exact -1#28#31#exact -1#29#32#exact -1#30#33#exact -1#31#34#exact 


Then these face patterns can be used to generate other artificial faces by randomly rotating the images ( about their center points ) by up to 10 degrees , scaling them between 90 and 110% , translating them up to half a pixel , and mirroring them to enlarge the number of positive samples \CITE .
Then these face patterns can be used to generate other artificial faces by randomly rotating the images ( about their center points ) up to 10 degree , scaling between 90% and 110% , translating up to half a pixel , and mirroring to enlarge the number of positive samples \CITE .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4,5,6,7#4,5,6#para -1#24#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#24#exact -1#36#25#exact -1#25#26#exact -1#26#27#stem -1#27#28#exact -1#28#29#exact -1#29#31#exact -1#31#33#exact -1#32#34#exact -1#33#35#exact -1#34#36#exact -1#35#38#exact -1#43#39#exact -1#37#40#exact -1#38#41#exact -1#39#42#exact -1#40#43#exact -1#41#44#exact -1#42#45#exact -1#44#48#exact -1#45#49#exact -1#46#50#exact -1#47#51#exact -1#48#52#exact -1#49#53#exact -1#50#54#exact -1#51#55#exact 


The collection of non-face patterns is usually done automatically by scanning through images which contain no faces .
Collecting non-face patterns are usually done automatically by scanning through images which contain no faces .
-1#0#0,1,2#para -1#1#3#exact -1#2#4#exact -1#3,4#5,6#para -1#5#7#exact -1#6#8#exact -1#7#9#exact -1#8#10#exact -1#9#11#exact -1#10#12#exact -1#11#13#exact -1#12#14#exact -1#13#15#exact -1#14#16#exact -1#15#17#exact 


The accurate classifier described in \CITE requires about five thousand original face patterns and hundreds of millions of non-face patterns extracted from 9 ,500 non-face images .
The accurate classifier described in \CITE requires about five thousand original face patterns and hundreds of million non-face patterns extracted from 9 ,500 non-face images .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16,17#para -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact 


In \CITE a smaller number of training samples can be used to build a robust face detector by using an edge orientation histogram .
In \CITE a smaller number of training samples can be used to build a robust face detector by using edge orientation histogram feature .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8,9,10,11#8,9,10#para -1#12,13#11,12,13#para -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#23#23#exact 


- Learning method selection : Basically , in an ideal situation with the proper settings , the advanced learning methods , such as the neural network , support vector machines , and AdaBoost , can perform similarly .
- Learning method selection : Basically , in the ideal case with proper settings , advanced learning methods such as neural network , support vector machines and AdaBoost produce similar performance .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8,9#8,9#para -1#11#11#exact -1#12#12,13#para -1#13#14#exact -1#14#15#exact -1#15#16,17#para -1#16#18#exact -1#17#19#exact -1#22#20#exact -1#18#21#exact -1#19#22#exact -1#20#24#exact -1#21#25#exact -1#23#27#exact -1#24#28#exact -1#25#29#exact -1#26#31#exact -1#27#32#exact -1#30#35#stem -1#29#36#stem -1#31#37#exact 


However , in practice , it is difficult to find these proper settings .
However , in practice , it is difficult to find these proper settings .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5,6,7,8#5,6,7,8,9#para -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact 


Using a neural network requires the design of layers , nodes , etc. , which is complicated .
Using neural network requires the design of layers , nodes , etc.hich is complicated .
-1#0#0#exact -1#1#2#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#12#14,15#para -1#13#16#exact -1#14#17#exact 


Therefore , it is preferable to use support vector machines because only two parameters are necessary if a RBF kernel is used and many tools are available .
Therefore , it is preferable to use support vector machines since the number of parameters is only two if using RBF kernel and many tools are available .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#16#10,11#para -1#17#12#exact -1#14#13#exact -1#25#14#exact -1#18#16#exact -1#20#18#exact -1#21#19#exact -1#15#20#exact -1#19#21#stem -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#26#25,26#para -1#27#27#exact 


Another learning method that has been widely used in many object detection systems is AdaBoost and its variants .
Another learning method which has been used widely in many object detection systems is AdaBoost and its variants .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3,4#3,4#para -1#5#5#exact -1#7#6#exact -1#6#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact 


The advantage of AdaBoost is it can be used for both selecting features and learning the classifier .
The advantage of AdaBoost is it can be used for both selecting features and learning the classifier .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6,7#6,7,8,9#para -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact 


Face tracking is the process of locating a moving face or several of them over a period of time using a camera , as illustrated in Fig. 1 .
Face tracking is the process of locating a moving face or several ones in time using a camera , as illustrated in Figure 1 .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#16#15#exact -1#14#16,17,18#para -1#15#19#exact -1#17#21#exact -1#18#22#exact -1#19#23#exact -1#20#24#exact -1#21#25#exact -1#23#27#exact -1#24#28#exact 


A given face is first initialized manually or by a face detector .
Face is first initialized manually or by a face detector .
-1#7#0#lc -1#0#2#lc -1#1#3#exact -1#2#4#exact -1#3#5#exact -1#4#6#exact -1#5#7#exact -1#6#8#exact -1#8#10#exact -1#9#11#exact -1#10#12#exact 


The face tracker then analyzes the subsequent video frames and outputs the location of the initialized face within these frames by estimating the motion parameters of the moving face .
Face tracker then analyses subsequent video frames and outputs the location of the initialized face within these frames by estimating the motion parameters of the moving face .
-1#9#0#lc -1#0#1#lc -1#1#2#exact -1#2#3#exact -1#12#5#exact -1#4#6#exact -1#5#7#exact -1#6#8#exact -1#7#9#exact -1#8#10#exact -1#20#11#exact -1#10#12#exact -1#11#13#exact -1#24#14#exact -1#13#15#exact -1#14#16#exact -1#15#17#exact -1#16#18#exact -1#17#19#exact -1#18#20#exact -1#19#21#exact -1#21#23#exact -1#22#24#exact -1#23#25#exact -1#25#27#exact -1#26#28#exact -1#27#29#exact 


This is different from face detection , the outcome of which is the position and scale of one single face in one single frame ; face tracking enables the information acquisition of multiple consecutive faces within consecutive video frames .
Different from face detection , the outcome of which is the position and scale of one single face in one single frame , face tracking enables the information acquisition of multiple consecutive faces within consecutive video frames .
-1#9#1#exact -1#0#2#lc -1#1#3#exact -1#2#4#exact -1#3#5#exact -1#4#6#exact -1#5#7#exact -1#6#8#exact -1#7#9#exact -1#8#10#exact -1#10#12#exact -1#11#13#exact -1#12#14#exact -1#13#15#exact -1#14#16#exact -1#15#17#exact -1#16#18#exact -1#17#19#exact -1#18#20#exact -1#19#21#exact -1#20#22#exact -1#21#23#exact -1#23#25#exact -1#24#26#exact -1#25#27#exact -1#26#28#exact -1#27#29#exact -1#28#30#exact -1#29#31#exact -1#30#32#exact -1#31#33#exact -1#32#34#exact -1#33#35#exact -1#34#36#exact -1#35#37#exact -1#36#38#exact -1#37#39#exact 


More important , these faces have the same identity .
More important , these faces have the same identity .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact 


Although frame-based face detection techniques have been successfully demonstrated on real images , the current ability for detecting faces from video is still primitive .
Although frame-based face detection techniques have demonstrated success on real images , the current ability on detecting faces from video is still primitive .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#20#6#syn -1#6#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#21#21,22#para -1#22#23#exact -1#23#24#exact 


The quality of the detector responses can decrease due to different reasons including occlusions , lighting conditions , and face poses .
The detector responses can decrease due to different reasons including occlusions , lighting conditions and face pose .
-1#0#3#lc -1#1#4#exact -1#2#5#exact -1#3#6#exact -1#4#7#exact -1#5#8#exact -1#6#9#exact -1#7#10#exact -1#8#11#exact -1#9#12#exact -1#10#13#exact -1#11#14#exact -1#12#15#exact -1#13#16#exact -1#14#18#exact -1#15#19#exact -1#16#20#stem -1#17#21#exact 


Without any additional information , these responses can easily be rejected , even if they indicate the presence of a face .
Without any additional information , these responses can easily be rejected even if they indicate the presence of a face .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15,16#16,17,18,19#para -1#19#20#exact -1#20#21#exact 


It is therefore important to incorporate the temporal information in a video sequence to provide more complete video segments displaying the person of interest , which is always named as / already called ? face tracking .
It is therefore important to incorporate the temporal information in a video sequence to provide more complete video segments displaying the person of interest , which is always named as face tracking .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#34#exact -1#31#35#exact -1#32#36#exact 


One of the main applications for face tracking is in the person retrieval from broadcast video , for example : " Intelligent fast-forwardsE, where the video jumps to the next scene containing a certain person / actor ; or retrieval of different TV interventions , e.g. interviews , shows , etc. , of a given person in a video or a large collection of TV broadcast videos .
One of the main applications of face tracking is person retrieval from broadcast video , for example : intelligent fast-forwards " , where the video jumps to the next scene containing a certain person / actor ; or retrieval of different TV interventions , e.g. interviews , shows , etc. , of a given person in a video or a large collection of TV broadcast videos .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#15#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#55#9#exact -1#23#10#exact -1#9#11#exact -1#10#12#exact -1#11#13#exact -1#12#14#exact -1#13#15#exact -1#14#16#exact -1#16#17,18#para -1#17#19#exact -1#20#20#exact -1#18#21#lc -1#22#23#exact -1#27#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#28#28,29#para -1#29#30#exact -1#30#31#exact -1#31#32#exact -1#32#33#exact -1#33#34#exact -1#34#35#exact -1#35#36#exact -1#36#37#exact -1#37#38#exact -1#38#39#exact -1#39#40#exact -1#40#41#exact -1#41#42#exact -1#42#43#exact -1#43#44#exact -1#44#45#exact -1#45#46#exact -1#46#47#exact -1#47#48#exact -1#48#49#exact -1#49#50#exact -1#50#51#exact -1#51#52#exact -1#52#53#exact -1#53#54#exact -1#54#55#exact -1#56#57#exact -1#57#58#exact -1#58#59#exact -1#59#60#exact -1#60#61#exact -1#61#62#exact -1#62#63#exact -1#63#64#exact -1#64#65#exact -1#65#66#exact -1#66#67#exact 


In [5] , the person retrieval system for a feature-length movie video is proposed using straightforward face tracking .
In [5] , a person retrieval system for feature-length movie video is proposed using straightforward face tracking .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3,4#3,4#para -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact 


At run time a user outlines a face in a video frame , and the face tracks within the movie are then ranked according to their similarity to the outlined query face in the same way as Google .
At run time a user outlines a face in a frame of the video , and the face tracks within the movie are then ranked according to the similarity to the outlined query face in the manner of Google .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#13#10#exact -1#10#11#exact -1#14#12#exact -1#15#13#exact -1#16#14#exact -1#17#15#exact -1#18#16#exact -1#19#17#exact -1#20#18#exact -1#21#19#exact -1#22#20#exact -1#23#21#exact -1#24#22#exact -1#25#23#exact -1#26#24#exact -1#28#26#exact -1#29#27#exact -1#30#28#exact -1#31#29#exact -1#32#30#exact -1#33#31#exact -1#34#32#exact -1#35#33#exact -1#36#35,36#para -1#38#37#exact -1#39#38#exact 


Since one face track corresponds to one identity , the workload of intra-shot face matching is greatly reduced , which is not available in frame-based face detection .
Since one face track corresponds to one identity , the workload of intra-shot face matching is greatly reduced , which is not available in frame-based face detection .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#21,22,23#19,20,21,22,23#para -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact 


In addition , face tracking provides multiple examples of the same character 's appearance to help with inter-shot face matching .
In addition , face tracking provides multiple examples of the same character 's appearance to help with inter-shot face matching .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact 


Face tracking is also used in the area of face-name association , the objective of which is to label television or movie footage with the identity of the person present in each frame of the video .
Face tracking also finds applications in the area of face-name association , the objective of which is to label television or movie footage with the identity of the person present in each frame of the video .
-1#0#0#exact -1#1#1#exact -1#16#2#exact -1#2#3#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#3#16#para -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact 


Everingham et al. [8] proposed an automatic face-name association system .
Everingham et al [8] proposed an automatic face-name association system .
-1#0#0#exact -1#1#1#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact 


This system uses a face tracker similar to the one in [5] that can extract a few hundred tracks of each particular character in a single shot .
This system uses a face tracker similar with [5] to extract a few hundred tracks of a particular character each in a single shot .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#9#7#exact -1#22#9#syn -1#20#10#exact -1#8#11#exact -1#10#14#exact -1#11#15#exact -1#12#16#exact -1#13#17#exact -1#14#18#exact -1#15#19#exact -1#19#20#exact -1#17#21#exact -1#18#22#exact -1#16#24#exact -1#23#26#exact -1#24#27#exact 


Based on the temporal information obtained from the face tracker , the textual information for TV and the movie footage including the subtitles and transcripts is employed to assign the character 's name to each face track .
Based on the temporal information obtained from the face tracker , textual information for TV and movie footage including subtitles and transcripts is employed to assign the character 's name to each face track .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#26#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#18#exact -1#17#19#exact -1#18#20#exact -1#19#22#exact -1#20#23#exact -1#21#24#exact -1#22#25#exact -1#23#26#exact -1#24#27#exact -1#25#28#exact -1#27#29,30#para -1#28#31#exact -1#29#32#exact -1#30#33#exact -1#31#34#exact -1#32#35#exact -1#33#36#exact -1#34#37#exact 


For instance , shots containing a particular person can be retrieved by a keyword like " Bush " or " Julia Roberts " instead of the use of an outlined query face as used in [5] .
For instance , shots containing a particular person can be retrieved by a keyword like " Bush " or " Julia Roberts " instead of an outlined query face as used in [5] .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#30,31#26#para -1#25#28#exact -1#26#29#exact -1#27#30#exact -1#28#31#exact -1#29#32#exact -1#32#35#exact -1#33#36#exact 


Besides broadcast video , face tracker also has important applications in the videos used in humanoid robotics , visual surveillance , human-computer interaction ( HCI ) , video conferencing , and face-based biometric person authentication among others .
Besides broadcast video , face tracker also has important applications in the video used in humanoid robotics , visual surveillance , human-computer interaction ( HCI ) , video conferencing , face-based biometric person authentication , etc.
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#stem -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#31#exact -1#31#32#exact -1#32#33#exact -1#33#34#exact 


Choosing a face tracker can be a difficult task because of the variety of face trackers currently available .
Choosing a face tracker can be a difficult task due to the variety of face trackers available .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9,10#9,10#para -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#17#exact -1#17#18#exact 


The application provider will have to decide which face tracker is best suited to his / her individual needs and , of course , the type of video that he / she wants to use as the target .
The application provider will have to decide which face tracker is best suited to his / her individual needs and , of course , the type of video that he / she wants to use as the target .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#4,5,6#3,4,5,6#para -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact -1#37#37#exact -1#38#38#exact 


Generally speaking , the important issues that should be addressed include speed , robustness , and accuracy .
Generally speaking , the important issues that should be addressed include speed , robustness and accuracy .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact 


Can the system run in real time ? Similar to many other processing tools for broadcast video , speed is not the most critical issue because offline processing is permitted in most video structuring and indexing cases .
Can the system run in real time ? Similar with many other processing tools for broadcast video , speed is not the most critical issue because offline processing is permitted in most cases of video structuring and indexing .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9,10,11#9,10,11#para -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19,20#19,20,21,22#para -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#34#32#exact -1#35#33#exact -1#36#34#exact -1#37#35#exact -1#32#36#exact -1#38#37#exact 


However , a real-time face tracker will become necessary if a target archive is established from too large a quantity of videos , e.g. 24-hour continuous video recording that needs daily structuring .
However , a real-time face tracker will become necessary if the target archive is established from too large quantities of videos , e.g. 24-hour continuous video recording that needs daily structuring .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10,11#10,11#para -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18,19#19,20#para -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact -1#28#29#exact -1#29#30#exact -1#30#31#exact -1#31#32#exact 


On the other hand , the speed of the tracker is critical in most of the application cases for non-broadcast video , e.g. HCI .
On the other hand , the speed of the tracker is critical in most cases of applications for non-broadcast video , e.g. HCI .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5,6,7#5,6,7,8#para -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12,13#12,13,14,15#para -1#14#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact 


It should be noted that there is always a tradeoff between speed and performance-related issues including the robustness and accuracy .
It should be noted that there is always a tradeoff between speed and performance-related issues including robustness and accuracy .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact 


Can the system cope with varying illuminations , facial expressions , scales , poses , camerawork , occlusion , and large head motions ? A number of illumination factors , e.g. light sources , background colors , luminance levels , and media , impact greatly on the change in appearance of a moving face , for instance , when tracking a person who is moving from an indoor to an outdoor environment .
Can the system cope with varying illumination , facial expression , scale , pose , camerawork , occlusion and large head motion ? A number of illumination factors , e.g. light sources , background colors , luminance levels , and media , impact greatly on the change in appearance of a moving face , for instance , when tracking a person who are moving from indoor to outdoor environment .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#stem -1#7#7#exact -1#8#8#exact -1#9#9#stem -1#10#10#exact -1#11#11#stem -1#12#12#exact -1#13#13#stem -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#28#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#stem -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact -1#32#29#exact -1#29#30#exact -1#30#31#exact -1#31#32#exact -1#35#33#exact -1#33#34#exact -1#34#35#exact -1#38#36#exact -1#36#37#exact -1#37#38#exact -1#41#39#exact -1#39#40#exact -1#40#41#exact -1#53#42#exact -1#42#43#exact -1#43#44#exact -1#44#45#exact -1#45#46#exact -1#46#47#exact -1#47#48#exact -1#48#49#exact -1#49#50#exact -1#50#51#exact -1#51#52#exact -1#52#53#exact -1#56#54#exact -1#54#55#exact -1#55#56#exact -1#57#58#exact -1#58#59#exact -1#59,60#60,61,62,63#para -1#63#64#exact -1#64#65#exact -1#65#67#exact -1#66#68#exact -1#67#70#exact -1#68#71#exact -1#69#72#exact 


Face tracking also tends to fail under large facial deformations of the eyes , nose , mouth , etc. due to the facial expression variation .
Face tracking also tends to fail under large facial deformations of eyes , nose , mouth , etc. due to facial expression variation .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11,12#para -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#22#exact -1#21#23#exact -1#22#24#exact -1#23#25#exact 


Different from non-broadcast video , e.g. video used for HCI , faces appearing in broadcast video vary from large close-up faces to small faces taken by a long-shot .
Different from non-broadcast video , e.g. video used for HCI , faces appearing in broadcast video varies from large close-up faces to small faces taken by a long-shot .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16,17#16,17#para -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact 


A smaller face scale always leads to a lower resolution and will reject most face trackers designed by computer vision researchers .
Small face scale always leads to low resolution and will reject most face trackers designed by computer vision researchers .
-1#0#0,1#para -1#1#2#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#8#syn -1#7#9#exact -1#8#10#exact -1#9#11#exact -1#10#12#exact -1#11#13#exact -1#12#14#exact -1#13#15#exact -1#14#16#exact -1#15#17#exact -1#16#18#exact -1#17#19#exact -1#18#20#exact -1#19#21#exact 


Pose variations , i.e. head rotations including the pitch , roll , and yaw , is another influencing factor , which can cause disappearances of parts of faces .
Pose variation , i.e. head rotations including pitch , roll and yaw , is another influencing factor , which can cause disappearance of part of the face .
-1#0#0#exact -1#1#1#stem -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#25#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#12#11#exact -1#10#12#exact -1#11#13#exact -1#17#14#exact -1#13#15#exact -1#14#16#exact -1#15#17#exact -1#16#18#exact -1#18#20#exact -1#19#21#exact -1#20#22#exact -1#21,22#23,24#para -1#23,24#25,26#para -1#26#27#stem -1#27#28#exact 


In some cases , the scale and pose variations might be caused by camerawork changes .
In some cases , the variation of scale and pose might be caused by camerawork change .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#7#5#exact -1#8#6#exact -1#9#7#exact -1#5#8#stem -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#stem -1#16#15#exact 


The partial disappearance of a face is also apt to happen due to occlusion by other objects , and motion information may be distracted by an alternate motion .
Disappearance of part of the face is also apt to happen due to occlusion by other objects , and motion information may be distracted by alternate motion of them .
-1#4#0#lc -1#0#2#lc -1#1#3#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#26#exact -1#26#27#exact -1#29#28#exact 


Moreover , the task of face tracking becomes even more difficult when the head is moving fast relative to the frame rate , so that the tracker fails to arrive in timeE.
Moreover , the task of face tracking becomes even more difficult when the head are moving fast relative to the frame rate so that the tracker fails to arrive in time " .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14,15#14#para -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact -1#29#30#exact 


How accurate is the tracking ? The first factor that affects the accuracy might be the false face detections generated when initializing the tracker by a face detector .
How accurate is the tracking ? The first factor that affects the accuracy might be the false face detections generated when initializing the tracker by a face detector .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact 


This problem is difficult to solve because it has a fixed threshold .
This problem is difficult to solve due to a fixed threshold .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6,7#6#para -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact 


Lowering the threshold of the face detector reduces the number of false rejections , but increases the number of false detections , and vice versa .
Lowering the threshold of the face detector reduces false rejections but increases the number of false detections , and vice versa .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#12#8#exact -1#13#9#exact -1#14#10#exact -1#15#11#exact -1#9#12#exact -1#17#13#exact -1#10#14#exact -1#11#15#exact -1#8#18,19#para -1#16#20#exact -1#18#22#exact -1#19#23#exact -1#20#24#exact -1#21#25#exact 


The drifting or the long sequence motion problem is another factor that might affect the accuracy .
The drifting or the long sequence motion problem is another factor that might affect the accuracy .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact 


This problem always happens due to the imperfect motion estimation technique .
This problem always happens due to the imperfect motion estimation technique .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact 


A tracker might accumulate motion errors and eventually lose track of a face , for instance , when tracking faces that change from a frontal view to a profile position .
A tracker might accumulate motion errors and eventually lose track of the face , for instance , when tracking faces that change from a frontal view to a profile position .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#23#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#27#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact 


Face tracking can be considered an algorithm that analyzes the video frames and outputs the location of moving faces within the video frame .
Face tracking can be considered as an algorithm that analyses the video frames and outputs the location of moving faces within the video frame .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact -1#23#22#exact -1#24#23#exact 


For each tracked face , three steps are involved , which are the initialization , tracking , and stopping procedures , as illustrated in Fig. 2 .
For each tracked face , three steps are involved that are initialization , tracking and a stopping procedure , as illustrated in Figure 2 .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#12#9#exact -1#9,10#10,11#para -1#11#13#exact -1#18#14#exact -1#13#15#exact -1#14#17#exact -1#16#18#exact -1#17#19#stem -1#19#21#exact -1#20#22#exact -1#21#23#exact -1#23#25#exact -1#24#26#exact 


Most of the developed methods use a face detector for the initialization of their tracking processes .
Most of the developed methods use a face detector as the initialization of their tracking process .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#stem -1#16#16#exact 


An always ignored but existing difficulty with this step lies in the control of the false face detections described above .
An always ignored but existing difficulty of this step lies in the control of false face detections described above .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14,15#para -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact 


Another problem is the difficulty in handling the appearance of new non-frontal faces .
Another problem is the difficulty in handling the appearance of new non-frontal faces .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact 


Although there have been literatures on profile or intermediate pose face detectors , this kind of work suffers from the false-detection problem far more than a frontal face detector .
Although there have been literatures in profile or intermediate pose face detector , this kind of work suffers from the false-detection problem far more than frontal face detector .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#stem -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact -1#28#29#exact 


To alleviate these two problems , Chaudhury et al. [1] used two face probability maps instead of a fixed threshold to initialize the face tracker , one for frontal views and one for profiles .
To alleviate these two problems , Chaudhury et al [1] used two face probability maps instead of a fixed threshold to initialize face tracker , one for frontal views and one for profiles .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22,23#para -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact -1#28#29#exact -1#29#30#exact -1#30#31#exact -1#31#32#exact -1#32#33#exact -1#33#34#exact 


All local maxima in these maps are chosen as the face candidates , the face probabilities of which are propagated throughout the temporal sequence .
All local maxima in these maps are chosen as the face candidates , the face probabilities of which are propagated throughout the temporal sequence .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact 


Candidates whose probabilities either go to zero or remain low over time are determined as non-face and eliminated .
Candidates whose probabilities either go to zero or remain low over time are determined as non-face and eliminated .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact 


The information from the two face probability maps is combined to represent an intermediate head pose .
The information from two face probability maps is combined to represent intermediate head pose .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#13#exact -1#12#14#exact -1#13#15#exact -1#14#16#exact 


Their experiments showed that the proposed probabilistic detector improved the accuracy more than a traditional face detector and is able to handle the head movement covering a range of 90 degrees out-of-plane rotation ( yaw ) .
Their experiments showed that the proposed probabilistic detector improved the accuracy over traditional face detector and is able to handle the head movement covering a range of 90 degrees out-of-plane rotation ( yaw ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11,12#para -1#24#13#exact -1#12#14#exact -1#13#15#exact -1#14#16#exact -1#15#17#exact -1#16#18#exact -1#17#19#exact -1#18#20#exact -1#19#21#exact -1#20#22#exact -1#21#23#exact -1#22#24#exact -1#23#25#exact -1#25#27#exact -1#26#28#exact -1#27#29#exact -1#28#30#exact -1#29#31#exact -1#30#32#exact -1#31#33#exact -1#32#34#exact -1#33#35#exact -1#34#36#exact 


After initialization , one should choose what features to track before tracking a face .
After initialization , one should choose what features to track before tracking the face .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#13#13#exact -1#14#14#exact 


The exploitation of color is one of the more common choices in order to be invariant to facial expressions , scale , and pose changes [4 , 9] .
The exploitation of color is one of the common choices in order to be invariant to facial expression , scale and pose change [4 , 9] .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4,5,6#4,5,6,7#para -1#8#8,9#para -1#9#10#exact -1#12,13#11,12,13,14#para -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#stem -1#18#19#exact -1#19#20#exact -1#24#21#exact -1#20#22#exact -1#21#23#exact -1#22#24#stem -1#23#25#exact -1#25#27#exact -1#26#28#exact 


However , color-based face trackers often depend on a learning set dedicated to the type of processed videos and are not guaranteed to be easily expendable to unknown videos with varying illumination conditions or different races .
However , color-based face trackers often depend on a learning set dedicated to the type of processed videos and are not guaranteed to be easily expendable to unknown videos with varying illumination conditions or different races .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#13,14,15#12,13,14,15#para -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact 


Also , color is susceptible to occlusion by other head-like objects .
Also , color is susceptible to occlusion by other head-like objects .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact 


Two other choices are the key-point [5 , 8] and facial features [3 , 6 , 10] , e.g. eyes , nose , mouth , etc. , both of which are more robust to varying illuminations and occlusions .
Another two choices are key-point [5 , 8] and facial features [3 , 6 , 10] , e.g. eyes , nose , mouth , etc. , both of which are more robust to varying illumination and occlusion .
-1#0,1#0,1#para -1#2#2#exact -1#3#3#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact -1#28#29#exact -1#29#30#exact -1#30#31#exact -1#31#32#exact -1#32#33#exact -1#33#34#exact -1#34#35#stem -1#35#36#exact -1#36#37#stem -1#37#38#exact 


Although the generality of key-points allows for tracking different kinds of objects , without any face-specific knowledge its discriminant power between the target and clutter might be in peril under tough conditions , e.g. strong background noise .
Although the generality of key-point allows for tracking different kinds of objects , without any face-specific knowledge its discriminant power between target and clutter might be in peril under tough conditions , e.g. strong background noise .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#stem -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21,22#para -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact -1#28#29#exact -1#29#30#exact -1#30#31#exact -1#31#32#exact -1#32#33#exact -1#33#34#exact -1#34#35#exact -1#35#36#exact -1#36#37#exact 


Facial features enable the tracking of higher-level information from a human face , but are weak in lower video quality .
Facial features enable to track higher-level information from a human face but are weak in low video quality .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#13#exact -1#12#14#exact -1#13#15#exact -1#14#16#exact -1#15#17#syn -1#16#18#exact -1#17#19#exact -1#18#20#exact 


Most facial-feature-based face trackers [6 , 10] have been tested using only non-broadcast video , e.g. webcam video , and their application potentiality to broadcast video is questionable .
Most facial-feature-based face trackers [6 , 10] are only tested by using non-broadcast video , e.g. webcam video , and their application potentiality to broadcast video is questionable .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7,8#para -1#9#9#exact -1#11#10#exact -1#8#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact 


Note that these different cues described above may be combined .
Note that these different cues described above may be combined .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact 


An appearance-based or featureless tracker matches an observation model of the entire facial appearance with the input image , instead of choosing only a few features to track .
An appearance-based or featureless tracker matches an observation model of the entire facial appearance with the input image , instead of choosing a few features to track .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22,23#22,23,24#para -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact 


One example of an appearance-based face tracker is [1] , which was introduced above .
One example of appearance-based face tracker is [1] that has been introduced above .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8,9,10#10,11#para -1#11#12#exact -1#12#13#exact -1#13#14#exact 


Another example was proposed by Li et al. [9] , which uses a multi-view face detector to detect and track faces from different poses .
Another example is proposed by Li et al [9] , which uses a multi-view face detector to detect and track faces of different poses .
-1#0#0#exact -1#1#1#exact -1#2#2#syn -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21,22#21,22#para -1#23#23#exact -1#24#24#exact 


Unsupervised Face Annotation by Mining the Web
Unsupervised Face Annotation by Mining the Web
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact 


Searching for images of people is an essential task for image and video search engines .
Searching for images of people is an essential task for image and video search engines .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact 


However , current search engines have limited capabilities for this task since they rely on text associated with images and video , and such text is likely to return many irrelevant results .
However , current search engines have limited capabilities for this task since they rely on text associated with images and video , and such text is likely to return many irrelevant results .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact 


We propose a method for retrieving relevant faces of one person by learning the visual consistency among results retrieved from text-correlation-based search engines .
We propose a method to retrieve relevant faces for one person by learning the visual consistency among results retrieved from text-correlation-based search engines .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#8#4#exact -1#5#5#stem -1#6#6#exact -1#7#7#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact 


The method consists of two steps .
The method consists of two steps .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact 


In the first step , each candidate face obtained from a text-based search engine is ranked with a score that measures the distribution of visual similarities among the faces .
In the first step , each candidate face obtained from a text-based search engine is ranked by a score that measures the distribution of visual similarities among the faces .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact 


Faces that are possibly very relevant or irrelevant are ranked at the top or bottom of the list , respectively .
Faces that are possibly very relevant or irrelevant are ranked at the top or bottom of the list .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#20#exact 


The second step improves this ranking by treating this problem as a classification problem in which input faces are classified as 'person-$X$' or 'non-person-$X$' ; and the faces are re-ranked according to their relevant score inferred from the classifier 's probability output .
The second step improves this ranking by treating this problem as a classification problem in which input faces are classified as 'person-$X$' or 'non-person-$X$' ; and the faces are re-ranked according to their relevant score inferred from the classifier 's probability output .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact -1#37#37#exact -1#38#38#exact -1#39#39#exact -1#40#40#exact -1#41#41#exact -1#42#42#exact 


To train this classifier , we use a bagging-based framework to combine results from multiple weak classifiers trained using different subsets .
To train this classifier , we use a bagging-based framework to combine results from multiple weak classifiers trained using different subsets .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact 


These training subsets are extracted and labeled automatically from the rank list produced from the classifier trained from the previous step .
These training subsets are extracted and labeled automatically from the rank list produced from the classifier trained from the previous step .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact 


In this way , the accuracy of the ranked list increases after a number of iterations .
In this way , the accuracy of the ranked list increases after a number of iterations .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4,5,6,7#4,5,6#para -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact 


Experimental results on various face sets retrieved from captions of news photos show that the retrieval performance improved after each iteration , with the final performance being higher than those of the existing algorithms .
Experimental results on various face sets retrieved from captions of news photos show that the retrieval performance improved after each iteration , with the final performance being higher than those of the existing algorithms .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact 


With the rapid growth of digital technology , large image and video databases have become more available than ever to users .
With the rapid growth of digital technology , large image and video databases have become more available than ever to users .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact 


This trend has shown the need for effective and efficient tools for indexing and retrieving visual content .
This trend has shown the need for effective and efficient tools for indexing and retrieving based on visual content .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#17#15#exact -1#18#16#exact -1#19#17#exact 


A typical application is searching for a specific person by providing his or her name .
A typical application is searching for a specific person by providing his or her name .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact 


Most current search engines use the text associated with images and video as significant clues for returning results .
Most current search engines use the text associated with images and video as significant clues for returning results .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact 


However , other un-queried faces and names may appear with the queried ones ( Figure xx ) , and this significantly lowers the retrieval performance .
However , other un-queried faces and names may appear with the queried ones ( as shown in Figure xx ) , and this significantly lowers retrieval performance .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#17#14#exact -1#18#15#exact -1#19#16#exact -1#20#17#exact -1#21#18#exact -1#22#19#exact -1#23#20#exact -1#24#21#exact -1#25#23#exact -1#26#24#exact -1#27#25#exact 


One way to improve the retrieval performance is to take into account visual information present in the retrieved faces .
One way to improve the retrieval performance is to take into account visual information present in the retrieved faces .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#9,10,11#8,9,10,11#para -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact 


This task is challenging for the following reasons :
This task is challenging for the following reasons :
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact 


-Large variations in facial appearance due to pose changes , illumination conditions , occlusions , and facial expressions make face recognition difficult even with state-of-the-art techniques\CITE ( see example in Figure xx ) .
-Large variations in facial appearance due to pose changes , illumination conditions , occlusions and facial expressions make face recognition difficult even with state-of-the-art techniques\CITE ( see an example in Figure xx ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact 


-The fact that the retrieved face set consists of faces of several people with no labels makes supervised and unsupervised learning methods inapplicable .
-The fact that the retrieved face set consists of faces of several people with no labels makes supervised and unsupervised learning methods inapplicable .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact 


We propose a method for solving the above problem .
We propose a method to solve the above problem .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4,5#4,5#para -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact 


The main idea is the assumption that there is visual consistency among the results returned from text-based search engines and this visual consistency is then learned through an interactive process .
The main idea is to assume that there is visual consistency among the results returned from text-based search engines ; and then learn this visual consistency through an interactive process .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#12#4#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#13#12,13#para -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#20#19#exact -1#23#20#exact -1#24#21#exact -1#25#22#exact -1#21#23,24#para -1#22#25#stem -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact 


This method consists of two stages .
This method consists of two stages .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact 


In the first stage , we explore the local density of faces to identify potential candidates for relevant faces and irrelevant faces .
In the first stage , we explore the local density of faces to identify potential candidates for relevant faces and irrelevant faces .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact 


This stage reflects the fact that the facial images of the queried person tend to form dense clusters , whereas irrelevant facial images are sparse since they look different from each other .
This stage reflects the fact that the facial images of the queried person tend to form dense clusters , whereas irrelevant facial images are sparse since they look different from each other .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact 


For each face , we define a score to measure the density of its neighbor set .
For each face , we define a score to measure the density of its neighbor set .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact 


This score is used to form a ranked list , in which faces with high-density scores are considered relevant and are put at the top .
This score is used to form a ranked list , in which faces having high density scores are considered relevant and are put at the top of the list .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact -1#23#22#exact -1#24#23#exact -1#25#24#exact -1#29#25#exact 


The above ranking method is weak since dense clusters have no guarantee of containing relevant faces .
The above ranking method is weak since dense clusters have no guarantee of containing relevant faces .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#10,11,12#9,10,11,12#para -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact 


Therefore , a second stage is necessary to improve this ranked list .
Therefore , a second stage is necessary to improve this ranked list .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact 


We model this problem as a classification problem in which input faces are classified as person-\MATH ( the queried person ) or non-person-\MATH ( the un-queried person ) .
We model this problem as a classification problem in which input faces are classified as person-\MATH ( the queried person ) or non-person-\MATH ( the un-queried person ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact 


The faces are ranked according to a relevancy score that is inferred from the classifier 's probability output .
The faces are ranked according to a relevancy score that is inferred from the classifier 's probability output .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact 


Since annotation data is not available , the rank list from the previous step is used to assign labels for a subset of faces .
Since annotation data is not available , the rank list from the previous step is used to assign labels for a subset of faces .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact 


This subset is then used to train a classifier using supervised methods such as a support vector machine ( SVM ) .
This subset is then used to train a classifier using supervised methods such as support vector machine ( SVM ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14,15#para -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact 


The trained classifier is used to re-rank faces in the original input set .
The trained classifier is used to re-rank faces in the original input set .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact 


This step is repeated a number of times to get the final ranked list .
This step is repeated a number of times to get the final ranked list .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact 


Since automatically assigning labels from the ranked list is not reliable , the trained classifiers are weak .
Since automatically assigning labels from the ranked list is not reliable , the trained classifiers are weak .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact 


To obtain the final strong classifier , we use the [idea / concept?] of ensemble learning \CITE in which weak classifiers trained on different subsets are combined to improve the stability and classification accuracy of single classifiers .
To get the final strong classifier , we use the idea of ensemble learning \CITE in which weak classifiers trained on different subsets are combined to improve the stability and classification accuracy of single classifiers .
-1#0#0#exact -1#1,2#1,2#para -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#11#13#exact -1#12#14#exact -1#13#15#exact -1#14#16#exact -1#15#17#exact -1#16#18#exact -1#17#19#exact -1#18#20#exact -1#19#21#exact -1#20#22#exact -1#21#23#exact -1#22#24#exact -1#23#25#exact -1#24#26#exact -1#26,27,28#27,28,29,30#para -1#29#31#exact -1#30#32#exact -1#31#33#exact -1#32#34#exact -1#33#35#exact -1#34#36#exact -1#35#37#exact 


The learned classifier can be further used for recognizing new facial images of the queried person .
The learned classifier can be further used for recognizing new facial images of the queried person .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact 


The second stage improves the ranked list and recognition performance for the following reasons :
The second stage improves the ranked list and recognition performance for the following reasons :
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact 


-Supervised learning methods , such as an SVM , provide a strong theoretical background for finding the optimal decision boundary even with noisy data .
-Supervised learning methods , such as SVM , provide a strong theoretical background for finding the optimal decision boundary even with noisy data .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact 


Furthermore , recent studies \CITE suggest that SVM classifiers provide probability outputs that are suitable for ranking .
Furthermore , recent studies \CITE suggest that SVM classifiers provide probability outputs that are suitable for ranking .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact 


-The bagging framework helps to leverage noises in the unsupervised labeling process .
-The bagging framework helps to leverage noises in the unsupervised labeling process .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact 


Our contribution is two-fold :
Our contribution is two-fold :
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact 


-We propose a general framework to boost the face retrieval performance of text-based search engines by visual consistency learning .
-We propose a general framework to boost the face retrieval performance of text-based search engines by visual consistency learning .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact 


The framework seamlessly integrates data mining techniques such as supervised learning and unsupervised learning based on bagging .
The framework seamlessly integrates data mining techniques such as supervised learning , and unsupervised learning based on bagging .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact 


-Our framework requires only a few parameters and works stably .
-Our framework requires only a few parameters and works stably .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact 


We demonstrate its feasibility with a practical web mining application .
We demonstrate its feasibility of a practical web mining application .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact 


A comprehensive evaluation on a large face dataset of many people was carried out and confirmed that our approach is promising .
A comprehensive evaluation on a large face dataset of many people was carried out and it confirmed that our approach is promising .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15,16,17#15,16#para -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact 


There are several approaches for re-ranking and learning models from web images .
There are several approaches for re-ranking and learning models from web images .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact 


Their underlying assumption is that text-based search engines return a large fraction of relevant images .
Their underlying assumption is that text-based search engines return a large fraction of relevant images .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact 


The challenge is how to model what is common in the relevant images .
The challenge is how to model what is common in the relevant images .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact 


One approach is to model this problem in a probabilistic framework in which the returned images are used to learn the parameters of the model .
One approach is to model this problem in a probabilistic framework in which the returned images are used to learn the parameters of the model .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact 


For examples , as described by Fergus et al. \CITE , [Reference numbers generally should not be grammatically part of the sentence .
For examples , as described in \CITE , [Reference numbers generally should not be grammatically part of the sentence .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4,5#4,5#para -1#6#9#exact -1#7#10#exact -1#8#11#exact -1#9#12#exact -1#10#13#exact -1#11#14#exact -1#12#15#exact -1#13#16#exact -1#14#17#exact -1#15#18#exact -1#16#19#exact -1#17#20#exact -1#18#21#exact -1#19#22#exact 


It is better to use the authorsf names .] objects retrieved using an image search engine are re-ranked by extending the constellation model .
It is better to use the authorsf names .]objects retrieved by an image search engine are re-ranked by extending the constellation model .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#9#10#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact 


Another proposal , described in \CITE , uses a non-parametric graphical model and an interactive framework to simultaneously learn object class models and collect object class datasets .
Another proposal , described in \CITE , uses a non-parametric graphical model and an interactive framework to simultaneously learn object class models and collect object class datasets .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact 


The main contribution of these approaches is probabilistic models that can be learned with a small number of training images .
The main contribution of these approaches are probabilistic models that can be learned with a small number of training images .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#10,11#6#para -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#12#11,12#para -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact 


However , these models are complicated since they require several hundred parameters for learning and are susceptible to over-fitting .
However , these models are complicated , since they require several hundred parameters for learning , and they are susceptible to over-fitting .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#16#14#exact -1#18#15#exact -1#19#16#exact -1#20#17#exact -1#21#18#exact -1#22#19#exact 


Furthermore , to obtain robust models , a small amount of supervision is required to select seed images .
Furthermore , to obtain robust models , a small amount of supervision is required to select seed images .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact 


Another study \CITE proposed a clustering-based method for associating names and faces in news photos .
Another study \CITE proposed a clustering-based method for associating names and faces in news photos .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact 


To solve the problem of ambiguity between several names and one face , a modified \MATH-means clustering process was used in which faces are assigned to the closest cluster ( each cluster corresponding to one name ) after a number of iterations .
To solve the problem of ambiguity between several names and one face , a modified \MATH-means clustering process was used in which faces are assigned to the closest cluster ( each cluster corresponding to one name ) after a number of iterations .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact -1#37#37#exact -1#38#38#exact -1#39#39#exact -1#40#40#exact -1#41#41#exact -1#42#42#exact 


Although the result was impressive , it is not easy to apply it to our problem since it is based on a strong assumption that requires a perfect alignment when a news photo only has one face and its caption only has one name .
Although the result was impressive , it is not easy to apply it to our problem since it is based on a strong assumption that requires a perfect alignment in the case that the news photo only has one face and its caption only has one name .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6,7,8,9,10#6,7,8,9#para -1#13#10#exact -1#11#11#exact -1#12#12#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#19,20#17,18,19,20#para -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#34#31#exact -1#35#32#exact -1#36#33#exact -1#37#34#exact -1#38#35#exact -1#39#36#exact -1#40#37#exact -1#41#38#exact -1#42#39#exact -1#43#40#exact -1#44#41#exact -1#45#42#exact -1#46#43#exact -1#47#44#exact 


Furthermore , a large number of irrelevant faces ( more than 12\% ) have to be manually eliminated before clustering .
Furthermore , a large number of irrelevant faces ( more than 12\% ) have to be manually eliminated before clustering .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact 


A graph-based approach was proposed by Ozkan and Duygu \CITE , in which a graph is formed from faces as nodes , and the weights of edges linked between nodes are the similarity of faces , is closely related to our problem .
A graph-based approach was proposed by \CITE , in which a graph is formed by faces as nodes , and the weights of edges linked between nodes are the similarity of faces , is closely related to our problem .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#19#7#exact -1#6#9#exact -1#7#10#exact -1#8#11#exact -1#9#12#exact -1#10#13#exact -1#11#14#exact -1#12#15#exact -1#13#16#exact -1#15#18#exact -1#16#19#exact -1#17#20#exact -1#18#21#exact -1#20#23#exact -1#21#24#exact -1#22#25#exact -1#23#26#exact -1#24#27#exact -1#25#28#exact -1#26#29#exact -1#27#30#exact -1#28#31#exact -1#29#32#exact -1#30#33#exact -1#31#34#exact -1#32#35#exact -1#33#36#exact -1#34#37#exact -1#35#38#exact -1#36#39#exact -1#37#40#exact -1#38#41#exact -1#39#42#exact 


Assuming that the number of faces of the queried person is larger than that of others and that these faces tend to form the most similar subset among the set of retrieved faces , this problem is considered equal to the problem of finding the densest subgraph of a full graph ; and can therefore , be solved by taking an available solution . //It might be unclear as to what " available solution " you are talking about . You might want to give more detail here .
Assuming that the number of faces of the queried person is larger than that of others and that these faces tend to form the most similar subset among the set of retrieved faces , this problem is considered equal to the problem of finding the densest subgraph of a full graph ; and therefore can be solved by taking an available solution .[It might be unclear as to what " available solution " you are talking about .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact -1#37#37#exact -1#38#38#exact -1#40,41,42#39,40,41,42#para -1#43#43#exact -1#44#44#exact -1#45#45#exact -1#46#46#exact -1#47#47#exact -1#48#48#exact -1#49#49#exact -1#50#50#exact -1#51#51#exact -1#52#52#exact -1#54#53#exact -1#53#54#exact -1#55#56#exact -1#56#57#exact -1#57#58#exact -1#58#59#exact -1#59#60#exact -1#60#61#exact -1#61#62#exact -1#77#63#exact -1#63#65#exact -1#64#66#exact -1#65#67#exact -1#66#68#exact -1#67#69#exact -1#68#70#exact -1#69#71#exact -1#70#72#exact -1#71#73#exact -1#72#74#exact -1#74,75,76#75,76,77,78#para -1#73#80#lc -1#39#83#exact 


Although experimental results showed the effectiveness of this method , it is still questionable whether the densest subgraph intuitively describes most of the relevant faces of the queried person and it is easy to extend for the ranking problem .
You might want to give more detail here .] Although , experimental results showed the effectiveness of this method , it is still questionable whether the densest subgraph intuitively describes most of relevant faces of the queried person and it is easy to extend for the ranking problem .
-1#9#0#exact -1#11#1#exact -1#12#2#exact -1#13#3#exact -1#14#4#exact -1#15#5#exact -1#16#6#exact -1#17#7#exact -1#18#8#exact -1#19#9#exact -1#20#10#exact -1#21#11#exact -1#22#12#exact -1#23#13#exact -1#24#14#exact -1#25#15#exact -1#26#16#exact -1#27#17#exact -1#28#18#exact -1#29#19#exact -1#30#20#exact -1#31#21#exact -1#45#22#exact -1#32#23#exact -1#33#24#exact -1#34#25#exact -1#35#26#exact -1#36#27#exact -1#37#28#exact -1#38#29#exact -1#39,40,41,42#30,31,32#para -1#3#33#exact -1#43#34#exact -1#44#35#exact -1#46#37#exact -1#47#38#exact -1#48#39#exact 


Furthermore , choosing an optimal threshold to convert the initial graph into a binary one is difficult and rather ad hoc due to dimensionality .
Furthermore , choosing an optimal threshold to convert the initial graph into a binary graph is difficult and rather ad hoc due to the curse of dimensionality .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#15#14,15#para -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#26#23#exact -1#27#24#exact 


An advantage of these methods \CITE is they are fully unsupervised .
The good point of the methods \CITE is they are fully unsupervised .
-1#3#2#exact -1#4,5#3,4#para -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact 


However , a disadvantage is that no model is learned for predicting new images of the same category .
However , the bad point is no model is learned to predict new images of the same category .
-1#0#0#exact -1#1#1#exact -1#5#4#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10,11#11#para -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact 


Furthermore , they are used for performing hard categorization on input images that are inapplicable for re-ranking . //It is not clear if " hard categorization " is inapplicable or if the " input images " are inapplicable .
Furthermore , they perform hard categorization on input images that is [It is not clear if " hard categorization " is inapplicable or if the " input images " are inapplicable .]in applicable for re-ranking .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#29#3#exact -1#33#5#exact -1#3#6#stem -1#4#7#exact -1#5#8#exact -1#6#9#exact -1#7#10#exact -1#8#11#exact -1#9#12#exact -1#10#13#syn -1#21#14#exact -1#34#16#exact -1#35#17#exact -1#12#19#exact -1#13#20#exact -1#14#21#exact -1#15#22#exact -1#16#23#exact -1#17#24#exact -1#18#25#exact -1#19#26#exact -1#20#27#exact -1#30#28#exact -1#22#29#exact -1#23#30#exact -1#24#31#exact -1#25#32#exact -1#26#33#exact -1#27#34#exact -1#28#35#exact 


The balance of recall and precision was not addressed .
The balance of recall and precision was not addressed .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact 


Typically , these approaches tend to ignore the recall to obtain high precision .
Typically , these approaches tend to ignore the recall to obtain high precision .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact 


This leads to the reduction in the number of collected images .
This leads the number of collected images is reduced .
-1#0#0#exact -1#1#1#exact -1#2#3#exact -1#7,8#4#para -1#3#5,6,7#para -1#4#8#exact -1#5#9#exact -1#6#10#exact -1#9#11#exact 


Our approach combines a number of advances over the existing approaches .
Our approach combines a number of advances over the existing approaches .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact 


Specifically , we learn a model for each query from the returned images for purposes such as re-ranking and predicting new images .
Specifically , we learn a model for each query from the returned images for purposes such as re-ranking and predicting new images .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact 


However , we used an unsupervised method to select training samples automatically , which is different from the methods proposed by Fergus et al. and Li et al. \CITE .
However , different from the methods in \cite{xx} , we used an unsupervised method to select training samples automaticallyCITE .
-1#0#0#exact -1#1#1#exact -1#9#2#exact -1#10#3#exact -1#11#4#exact -1#12#5#exact -1#13#6#exact -1#14#7#exact -1#15#8#exact -1#16#9#exact -1#17#10#exact -1#8#12#exact -1#2,3#14,15,16#para -1#4#17#exact -1#5#18#exact -1#19#29#exact 


This unsupervised method is different from the one by Ozkan and Dugyu \CITE in the modeling of the distribution of relevant images .
This unsupervised method is different from the one in \CITE in its way of modeling the distribution of relevant images .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#9#12#exact -1#10#13#exact -1#15#14#exact -1#14#15#exact -1#16,17#16,17,18,19#para -1#18#20#exact -1#19#21#exact -1#20#22#exact 


We use density-based estimation rather than the densest graph .
We use density-based estimation rather than the densest graph .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact 


Given a set of images returned by any text-based search engine for a queried person ( e.g. 'George Bush' ) , we perform a ranking process and learning of person |\MATH 's model as follows :
Given a set of images returned by any text-based search engine for a queried person ( e.g. 'George Bush' ) , we perform a ranking process and learning of person |\MATH 's model as follows :
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact 


-Step 1 : Detect faces and eye positions , and then perform face normalizations .
-Step 1 : Detect faces and eye positions , and then perform face normalizations .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact 


-Step 2 : Compute an eigenface space and project the input faces into this subspace .
-Step 2 : Compute an eigenface space and project the input faces into this subspace .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact 


-Step 3 : Estimate the ranked list of these faces by rank-by-local-density score .
-Step 3 : Estimate the ranked list of these faces by Rank-By-Local-Density-Score .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#12#13#exact 


-Step 4 : Improve this ranked list using rank-by-bagging-probSVM . //I found not hits for " rank-by-bagging-probSVM " on the Internet. You might want to double check to see if this is a standard term . The same is true for " rank-by-local-density score " . If this is your own term , you might want to specify this at some point .
-Step 4 : Improve this ranked list by Rank-By-Bagging-ProbSVM . //I found not hits for " rank-by-bagging-probSVM " on the Internet . You might want to double check to see if this is a standard term . The same is true for " rank-by-local-density score " . If this is your own term , you might want to specify this at some point .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#16#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#8#16#lc -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#22#21#exact -1#23#22#exact -1#24#23#exact -1#25#24#exact -1#26#25#exact -1#27#26#exact -1#28#27#exact -1#29#28#exact -1#30#29#exact -1#31#30#exact -1#32#31#exact -1#33#32#exact -1#34#33#exact -1#35#34#exact -1#36#35#exact -1#37#36#exact -1#38#37#exact -1#39#38#exact -1#40#39#exact -1#41#40#exact -1#42#41#exact -1#43#42#exact -1#44#43#exact -1#45#44#exact -1#46#45#exact -1#47#46#exact -1#48#47#exact -1#49#48#exact -1#50#49#exact -1#51#50#exact -1#52#51#exact -1#53#52#exact -1#54#53#exact -1#55#54#exact -1#56#55#exact -1#57#56#exact -1#58#57#exact -1#59#58#exact -1#60#59#exact -1#61#60#exact -1#62#61#exact -1#63#62#exact 


Steps 1 and 2 are typical for any face processing system , and they are described in section \REF .
Steps 1 and 2 are typical for any face processing system , and they are described in section \REF .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact 


The algorithms used in Steps 3 and 4 are described in section \REF and section \REF , respectively .
The algorithms used in Step 3 and Step 4 are described in section \REF and section \REF .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#stem -1#5#5#exact -1#6#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#18#exact 


Figure \REF illustrates the proposed framework .
Figure \REF illustrates the proposed framework .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact 


Among the faces retrieved by text-based search engines for a query of person-\MATH , as shown in Figure \REF , relevant faces usually look similar and forms the largest cluster .
Among the faces retrieved by the text-based search engines for a query of person-\MATH , as shown in Figure \REF , relevant faces usually look similar and can form the largest cluster .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact -1#23#22#exact -1#24#23#exact -1#25#24#exact -1#26#25#exact -1#28#26#stem -1#29#27#exact -1#30#28#exact -1#31#29#exact -1#32#30#exact 


One approach of re-ranking these faces is to cluster based on visual similarity .
One approach to re-rank these faces is to do clustering based on visual similarity .
-1#0#0#exact -1#1,2#1,2#para -1#3#3#stem -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#9#8#stem -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact 


However , to obtain ideal clustering results is impossible since these faces are high dimensional data and the clusters are in different shapes , sizes , and densities .
However , to get ideal clustering result is impossible , since these faces are high dimensional data and the clusters are in different shapes , sizes and densities .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#syn -1#4#4#exact -1#5#5#exact -1#6#6#stem -1#7#7#exact -1#8#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact -1#23#22#exact -1#24#23#exact -1#25#24#exact -1#9#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact 


Instead , a graph-based approach was proposed by Ozkan and Dugyu \CITE in which the nodes are faces and edge weights are the similarities between two faces .
Instead , in \cite{xx} , a graph based approach was proposed CITEin which the nodes are faces and edge weights are the similarities between two faces .
-1#0#0#exact -1#1#1#exact -1#5#2#exact -1#8#4#exact -1#9#5#exact -1#10#6#exact -1#17#9#exact -1#2#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact 


With the observation that the nodes ( faces ) of the queried person are similar to each other and different from other nodes in the graph , the densest component of the full graph ? the set of highly connected nodes in the graph ? will correspond to the face of the queried person .
With the observation that the nodes ( faces ) of the queried person are similar to each other and different from other nodes in the graph , the densest component of the full graph ? the set of highly connected nodes in the graph ? will correspond to the face of the queried person .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact -1#37#37#exact -1#38#38#exact -1#39#39#exact -1#40#40#exact -1#41#41#exact -1#42#42#exact -1#43#43#exact -1#44#44#exact -1#45#45#exact -1#46#46#exact -1#47#47#exact -1#48#48#exact -1#49#49#exact -1#50#50#exact -1#51#51#exact -1#52#52#exact -1#53#53#exact -1#54#54#exact 


The main drawback of this approach is it needs a threshold to convert the initial weighted graph to a binary graph .
The main drawback of this approach is it needs a threshold to convert the initial weighted graph to a binary graph .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact 


Choosing this threshold in high dimensional spaces is difficult since different persons might have different optimal thresholds .
Choosing this threshold in high dimensional spaces is difficult since different persons might have different optimal thresholds .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact 


We use the idea of density-based clustering described by Ester et al. and Breunig et al. \CITE to solve this problem . //idea / concept?
We use the idea of density-based clustering described in \CITE to solve this problem .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7,8#7,8#para -1#9#16#exact -1#11,12,13#17,18,19,20#para -1#14#21#exact 


Specifically , we define the local density score ( LDS ) of a point \MATH( i.e. a face ) as the average distance to its k-nearest neighbors .
Specifically , we define local density score ( LDS ) of a point \MATH( i.e. a face ) as the average distance to its k-nearest neighbors :
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#19#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#20#20,21#para -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact 


where \MATH is the set of \MATH - neighbors of \MATH , and \MATH is the similarity between \MATH and \MATH .
where \MATH is the set of \MATH - neighbors of \MATH , and \MATH is the similarity between \MATH and \MATH .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact 


Since faces are represented in high dimensional feature space , and face clusters might have different sizes , shapes , and densities , we do not directly use the Euclidean distance between two points in this feature space for \MATH .
Since faces are represented in high dimensional feature space , and face clusters might have different sizes , shapes and densities ; we do not use directly the Euclidean distance between two points in this feature space for \MATH .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#20#exact -1#20#21#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#26#26#exact -1#25#27#exact -1#27#28#exact -1#28#29#exact -1#29#30#exact -1#30#31#exact -1#31#32#exact -1#32#33#exact -1#33#34#exact -1#34#35#exact -1#35#36#exact -1#36#37#exact -1#37#38#exact -1#38#39#exact -1#39#40#exact 


Instead , we use another similarity measure defined by the number of shared neighbors between two points .
Instead , we use another similarity measure defined by the number of shared neighbors between two points .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#9,10,11#8,9,10,11#para -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact 


The efficiency of this similarity measure for density-based clustering methods was described . //There is no period here , so it is not clear if there should be a period or there should be more to this sentence that is not here . If the sentence does end here , you might want to go into more detail about who or what " described " this .
The efficiency of this similarity measure for density-based clustering methods was described . //There is no period here , so it is not clear if there should be a period or there should be more to this sentence that is not here . If the sentence does end here , you might want to go into more detail about who or what " described " this .]
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#20,21,22#19,20,21,22#para -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact -1#37#37#exact -1#38#38#exact -1#39#39#exact -1#40#40#exact -1#41#41#exact -1#42#42#exact -1#43#43#exact -1#44#44#exact -1#45#45#exact -1#46#46#exact -1#47#47#exact -1#48#48#exact -1#49#49#exact -1#50#50#exact -1#51#51#exact -1#52#52#exact -1#53#53#exact -1#54#54#exact -1#55#55#exact -1#56#56#exact -1#57#57#exact -1#58#58#exact -1#59#59#exact -1#60#60#exact -1#61#61#exact -1#62#62#exact -1#63#63#exact -1#64#64#exact -1#65#65#exact 


A high value of \MATH indicates a strong association between \MATH and its neighbors .
A high value of \MATH indicates a strong association between \MATH and its neighbors .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact 


Therefore , we can use this local density score to rank faces .
Therefore , we can use this local density score to rank faces .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact 


Faces with higher scores are considered to be potential candidates that are relevant to person-\MATH , while faces with lower scores are considered as outliers and thus are potential candidates for non-person-\MATH .
Faces with higher scores are considered to be potential candidates that are relevant to person-\MATH , while faces with lower scores are considered as outliers and thus are potential candidates for non-person-\MATH .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4,5,6,7#4,5#para -1#13#6#exact -1#21,22#7#para -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#27#21#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact 


Algorithm 1 : Rank-By-Local-Density-Score Step 1 : For each face p , compute LDS( p , k ) , where k is the number of neighbors of p and is the input of the ranking process .
Algorithm 1 : Rank-By-Local-Density-Score Step 1 : For each face p , compute LDS( p , k ) , where k is the number of neighbors of p and is the input of the ranking process .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact 


Step 2 : Rank these faces using LDS( p , k ) ( The higher the score the more relevant ) .
Step 2 : Rank these faces using LDS( p , k ) ( The higher the more relevant ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#18#exact -1#17#19#exact -1#18#20#exact -1#19#21#exact 


One limitation of the local density score based ranking is it cannot handle faces of another person strongly associated in the \MATH-neighbor set ( for example , many duplicates ) .
One limitation of the local density score based ranking is it could not handle the case that faces of another person have strong association in \MATH-neighbor set ( for example , many duplicates ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11,12#11#para -1#13#12#exact -1#17#13#exact -1#18#14#exact -1#19#15#exact -1#20#16#exact -1#22#17#stem -1#23#18#stem -1#24#19#exact -1#14#20#exact -1#25#21#exact -1#26#22#exact -1#27#23#exact -1#28#24#exact -1#29#25#exact -1#30#26#exact -1#31#27#exact -1#32#28#exact -1#33#29#exact -1#34#30#exact 


Therefore , another step is proposed for handling this case .
Therefore , another step is proposed to handle this case .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6,7#6,7#para -1#8#8#exact -1#9#9#exact -1#10#10#exact 


As a result , we have a model that can be used for both re-ranking current faces and predicting new incoming faces .
As a result , we have a model that can be used for both re-ranking current faces and predicting new incoming faces .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9,10#9,10,11,12#para -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact 


The main idea is to use a probabilistic model to measure the relevancy of a face to person-\MATH , \MATH .
The main idea is to use a probabilistic model to measure the relevancy of a face to person-\MATH , \MATH .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact 


Since the labels are not available for training , we use the input rank list found from the previous step to extract a subset of faces lying at the top and bottom of the ranked list to form the training set .
Since the labels are not available for training , we use the input rank list found from the previous step to extract a subset of faces lying at the top and bottom of the ranked list to form the training set .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#28,29,30#27,28,29,30#para -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact -1#37#37#exact -1#38#38#exact -1#39#39#exact -1#40#40#exact -1#41#41#exact 


After that , we use an SVM with probabilistic output \CITE implemented in LibSVM \CITE to learn the person-\MATH model .
After that , we use SVM with probabilistic output \CITE implemented in LibSVM \CITE to learn the person-\MATH model .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact 


This model is applied to faces of the original set , and the output probabilistic scores are used to re-rank these faces .
This model is applied to faces of the original set and the output probabilistic scores are used to re-rank these faces .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact 


Since it is not guaranteed that faces lying at two ends of the input rank list correctly correspond to the faces of person-\MATH and faces of non person-\MATH , we adopt the [idea / concept?] of a bagging framework \CITE in which randomly selecting subsets to train weak classifiers , and then combining these classifiers help reduce the risk of using noisy training sets .
Since it is not guaranteed that faces lying at two ends of the input rank list correctly correspond to the faces of person-\MATH and faces of non person-\MATH , we adopt the idea of bagging framework \CITE in which randomly selecting subsets to train weak classifiers , and then combining these classifiers help reduce the risk of using noisy training sets .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#33#35#exact -1#34#37#exact -1#35#38#exact -1#36#39#exact -1#37#40#exact -1#38#41#exact -1#39#42#exact -1#40#43#exact -1#41#44#exact -1#42#45#exact -1#43#46#exact -1#44#47#exact -1#45#48#exact -1#46#49#exact -1#47#50#exact -1#48#51#exact -1#49#52#exact -1#50#53#exact -1#51#54#exact -1#52#55#exact -1#53,54,55,56#56,57,58#para -1#57#60#exact -1#58#61#exact -1#59#62#exact -1#60#63#exact -1#61#64#exact 


The details of the Rank-By-Bagging-ProbSVM-InnerLoop method , improving an input rank list by combining weak classifiers trained from subsets annotated by that rank list , are described in Algorithm 2 .
The details of Rank-By-Bagging-ProbSVM-InnerLoop method , improving an input rank list by combining weak classifiers trained from subsets annotated by that rank list are described in Algorithm 2 .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#25#exact -1#24#26#exact -1#25#27#exact -1#26#28#exact -1#27#29#exact -1#28#30#exact 


314
However , we would expect that sentence constructions are basically common and portable between two domains , which would provide a correct boundary for phrases and therefore , the correct dependencies in phrases would be introduced by the adaptation .



Table \REF gives the parsing or tagging accuracy of each parser and the POS tagger for Brown questions and QuestionBank .
Table \REF shows the parsing or tagging accuracies of each parser and the POS tagger for Brown questions and QuestionBank .
-1#0#0#exact -1#1#1#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#stem -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact 


These results differ from those in Table \REF in that the parsers and the tagger have been adapted to another question domain .
the difference from Table \REF was that the parsers and the tagger were adapted to another question domain .
-1#1#2#stem -1#2#3#exact -1#3#6#exact -1#4#7#exact -1#6#9#exact -1#7#10#exact -1#8#11#exact -1#9#12#exact -1#10#13#exact -1#11#14#exact -1#12#15,16#para -1#13#17#exact -1#14#18#exact -1#15#19#exact -1#16#20#exact -1#17#21#exact -1#18#22#exact 


The table shows that the parsers adapted to the Brown questions improved their parsing accuracy with QuestionBank , whereas the parsers adapted to QuestionBank decreased in accuracy .
The table shows that the parsers adapted to Brown questions improved the parsing accuracies for QuestionBank , while the parsers adapted to QuestionBank decreased .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#11#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#12#13#exact -1#13#14#stem -1#15#16#exact -1#16#17#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#27#exact 


Table \REF could explain this result .
Table \REF could explain the result .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4,5#4,5#para -1#6#6#exact 


Using Brown questions , many wh-questions were learnt , which is what QuestionBank mainly contains . On the other hand , despite yes-no questions constituting more than half the Brown corpus , these were not learnt using QuestionBank for training .
With Brown questions , we could learn wh-questions which QuestionBank mainly contain , while with QuestionBank , we could not we could not learn yes-no questions which more than half of Brown corpus contain .
-1#1#1#exact -1#2#2#exact -1#3#3#exact -1#7#5#exact -1#12#8#exact -1#26#9#exact -1#9#12#exact -1#10#13#exact -1#11#14#stem -1#34#15#exact -1#16#20#exact -1#24#22#exact -1#25#23#exact -1#27,28,29,30#25,26,27,28#para -1#31#29#exact -1#32#30#exact -1#19#33,34#para -1#6#35#syn -1#15#37#exact 


A question domain contains various types of questions with various sentence constructions .
A question domain contains various types of questions and gives various sentence constructions .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#10#8,9#para -1#11#10#exact -1#12#11#exact -1#13#12#exact 


In order to parse questions correctly , we need to capture each of these correctly .
In order to parse questions correctly , we should capture each of them correctly .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8,9#para -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#13#14#exact -1#14#15#exact 


This type of problem was not so obvious when we were working mainly with declarative sentences .
This type of problem would not be noticed so much when we were working mainly on declarative sentences .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#6#4#syn -1#5#5#exact -1#8#6#exact -1#10#8#exact -1#11#9#exact -1#12#10#exact -1#13#11#exact -1#14#12#exact -1#16#14#exact -1#17#15#exact -1#18#16#exact 


Through experiments with various parsers we observed that simple supervised adaptation methods are insufficient to achieve parsing accuracy comparable with that of declarative sentences .
Through the experiments on various parsers we observed that simple supervised adaptation methods are insufficient to arrive at theparsing accuracy comparable to that of declarative sentences .
-1#0#0#exact -1#2#1#exact -1#4#3#exact -1#5#4#exact -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16,17#15#para -1#19#17#exact -1#20#18#exact -1#22#20#exact -1#23#21#exact -1#24#22#exact -1#25#23#exact -1#26#24#exact 


This observation holds both for POS tagging and syntactic parsing , and indicates that the parsers need to be fundamentally improved , such as re-constructing feature designs or changing parsing models .
This observation holds both for POS tagging and syntactic parsing , and itindicates that we need fundamental improvement of parsers , such as re-constructing feature designs or changing parsing models .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#13#13#exact -1#19#15#exact -1#15#16#exact -1#16#19#stem -1#17,18#20#para -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact -1#28#29#exact -1#29#30#exact -1#30#31#exact 


Following on from this study , future work includes investigating parsing frameworks that are robust for sentences with different sentence constructions , and / or methods that can effectively adapt a parser to different sentence constructions including imperatives and questions , among others .
Following the present work , future work should include investigating parsing frameworks that are robust for sentences with various sentence constructions , and / or methods that can effectively adapt a parser to different sentence constructions including imperatives , questions , and more .
-1#0#0#exact -1#3#4#syn -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#8#8#stem -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#33#18#exact -1#34#19#exact -1#35#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#18#33#para -1#19#34#exact -1#20#35#exact -1#36#36#exact -1#37#37#exact -1#41#38#exact -1#39#39#exact -1#40#40#exact -1#43#43#exact 


Step 1 : Train a weak classifier , hi .
Step 1 : Train a weak classifier hi .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#8#exact -1#8#9#exact 


Step 1 .1 : Select a set Spos including p% of top ranked faces and then randomly select a subset S?pos from Spos .
Step 1 .1 : Select a set Spos including p% top ranked faces and then randomly select a subset S?pos from Spos .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact 


Label faces in S?pos as positive samples .
Label faces in S?pos as positive samples .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact 


Step 1 .2 : Select a set Sneg including p% of bottom ranked faces and then randomly select a subset S? neg from Sneg .
Step 1 .2 : Select a set Sneg including p% bottom ranked faces and then randomly select a subset S? neg from Sneg .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact 


Label faces in S? neg as negative samples .
Label faces in S? neg as negative samples .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact 


Step 1 .3 : Use S?pos and S? neg to train a weak classifier , hj , using LibSVM [8] with probability outputs .
Step 1 .3 : Use S?pos and S? neg to train a weak classifier hj using LibSVM [8] with probability outputs .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#15#exact -1#15#17#exact -1#16#18#exact -1#17#19#exact -1#18#20#exact -1#19#21#exact -1#20#22#exact -1#21#23#exact 


Step 2 : Compute ensemble classifier Hi = Pij=1 hj .
Step 2 : Compute ensemble classifier Hi = Pij=1 hj .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact 


Step 3 : Apply Hi to the original face set and form the rank list , Ranki , using the output probabilistic scores .
Step 3 : Apply Hi to the original face set and form the rank list Ranki by using the output probabilistic scores .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#16#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact 


Step 4 : Repeat steps 1 to 3 until Dist2RankList( Ranki?1 ,Ranki ) <= ? .
Step 4 : Repeat steps from Step 1 to Step 3 until Dist2RankList( Ranki?1 ,Ranki ) <= ? .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#7#5#exact -1#8#6#exact -1#10#7#exact -1#11#8#exact -1#12#9#exact -1#13#10#exact -1#14#11#exact -1#15#12#exact -1#16#13#exact -1#17#14#exact -1#18#15#exact 


Step 5 : Return Hi = Pij=1 hj .
Step 5 : Return Hi = Pij=1 hj .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact 


Step 1 : Rankcur = Rank-By-Bagging-ProbSVM-InnerLoop ( Rankprev ) .
Step 1 : Rankcur = Rank-By-Bagging-ProbSVM-InnerLoop( Rankprev ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact 


Step 2 : dist = Dist2RankList ( Rankprev ,Rankcur ) .
Step 2 : dist = Dist2RankList( Rankprev ,Rankcur ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact 


Step 3 : Rankfinal = Rankcur .
Step 3 : Rankfinal = Rankcur .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact 


Step 4 : Rankprev = Rankcur .
Step 4 : Rankprev = Rankcur .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact 


Step 5 : Repeat steps 1 to 4 until dist <= ? .
Step 5 : Repeat steps from Step 1 to Step 4 until dist <= ? .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#7#5#exact -1#8#6#exact -1#10#7#exact -1#11#8#exact -1#12#9#exact -1#13#10#exact -1#14#11#exact -1#15#12#exact 


Step 6 : Return Rankfinal .
Step 5 : Return Rankfinal .
-1#0#0#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact 


Given an input ranked list , Rank-By-Bagging-ProbSVM-InnerLoop is used to improve this list .
Given an input ranked list , Rank-By-Bagging-ProbSVM-InnerLoop is used to improve this rank list .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#13#12#exact -1#14#13#exact 


We repeat the process a number of times whereby the ranked list output from the previous step is used as the input ranked list of the next step .
We repeat the process a number of times whereby the ranked list output from the previous step is used as the input ranked list of the next step .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact 


In this way , the iterations significantly improve the final ranked list .
In this way , the iterations significantly improve the final ranked list .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact 


The details are described in Algorithm 3 .
The details are described in Algorithm 3 .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact 


To determine the number of iterations of Rank-By-Bagging-ProbSVM-InnerLoop and Rank-By-Bagging-ProbSVM-OuterLoop , we use the \MATH distance \CITE , which is a metric that counts the number of pairwise disagreements between two lists .
To determine the number of iterations of Rank-By-Bagging-ProbSVM-InnerLoop and Rank-By-Bagging-ProbSVM-OuterLoop , we use the \MATH distance \CITE , which is a metric that counts the number of pairwise disagreements between two lists .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact 


The larger the distance , the more dissimilar the two lists are .
The larger the distance , the more dissimilar the two lists are .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact 


The \MATH distance between two lists , \MATH and \MATH , is defined as follows :
The \MATH distance between two list \MATH and \MATH is defined as follows :
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#stem -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#11#exact -1#10#12#exact -1#11#13#exact -1#12#14#exact -1#13#15#exact 


Since the maximum value of \MATH is \MATH , where \MATH is the number of members of the list , the normalized Kendall tau distance can be written as follows :
Since the maximum value of \MATH is \MATH where \MATH is the number of members of the list , the normalized Kendall tau distance can be written as follows :
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#18#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11,12,13,14,15,16#12,13,14,15,16#para -1#19#17#exact -1#17#18#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact -1#28#29#exact -1#29#30#exact 


Using this measure for checking when the loops stop means that if the ranked list does not change significantly after a number of iterations , it is reasonable to stop .
Using this measure for checking when the loops stop means that if the ranked list does not change significantly after a number of iterations , it is reasonable to stop .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#26,27#25,26,27,28#para -1#29#29#exact -1#30#30#exact 


We used the dataset described by Berg et al. \CITE for our experiments .
We used the dataset described in \CITE for our experiments .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4,5#4,5#para -1#6#9#exact -1#7#10#exact -1#8#11#exact -1#9#12#exact -1#10#13#exact 


This dataset consists of approximately half a million news pictures and captions from Yahoo News collected over a period of roughly two years .
This dataset consists of approximately half a million news [pictures / photos?] and captions from Yahoo News collected over a period of roughly two years .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#12#10#exact -1#13#11#exact -1#14#12#exact -1#15#13#exact -1#16#14#exact -1#17#15#exact -1#18#16#exact -1#19#17#exact -1#20#18#exact -1#21#19#exact -1#22#20#exact -1#23#21#exact -1#24#22#exact -1#25#23#exact 


This dataset is better than datasets collected from image search engines such as Google that usually limit the total number of returned images to 1 ,000 .
This dataset is better than datasets collected from image search engines such as Google that usually limit the total number of returned images to 1 ,000 .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17,18,19,20#17,18,19#para -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact 


Furthermore , it has annotations that are valuable for evaluation of methods .
Furthermore , it has annotations that are valuable for evaluation of methods .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact 


Note that these annotations are used for evaluation purpose only .
Note that these annotations are used for evaluation purpose only .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact 


Our method is fully unsupervised , so it assumes the annotations are not available at running time .
Our method is fully unsupervised , so it assumes the annotations are not available at running time .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact 


Only the front of faces were considered since current frontal face detection systems \CITE work in real time and have accuracies exceeding 95\% .
Only frontal faces were considered since current frontal face detection systems \CITE can work in real time and have accuracies exceeding 95\% .
-1#0#0#exact -1#2#4#exact -1#3#5#exact -1#4#6#exact -1#5#7#exact -1#6#8#exact -1#7#9#exact -1#8#10#exact -1#9#11#exact -1#10#12#exact -1#11#13#exact -1#13#14#exact -1#14,15,16#15,16,17,18#para -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact 


44 ,773 faces were detected and normalized to 86\MATH86 pixels .
44 ,773 faces were detected and normalized to the size of 86\MATH86 pixels .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#11#8#exact -1#12#9#exact -1#13#10#exact 


We selected fifteen government leaders , including George W. Bush ( US ) , Vladimir Putin ( Russia ) , Ziang Jemin ( China ) , Tony Blair ( UK ) , Junichiro Koizumi ( Japan ) , Roh Moo-hyun ( Korea ) , Abdullah Gul ( Turkey ) , and other key individuals , such as John Paul II ( the Former Pope ) and Hans Blix ( UN ) , because their images frequently appear in the dataset \CITE .
We selected fifteen government leaders , including George W. Bush ( US ) , Vladimir Putin ( Russia ) , Ziang Jemin ( China ) , Tony Blair ( UK ) , Junichiro Koizumi ( Japan ) , Roh Moo-hyun ( Korea ) , and Abdullah Gul ( Turkey ) , and other key individuals , such as John Paul II ( the Former Pope ) and Hans Blix ( UN ) , because their images frequently appear in the dataset \CITE .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact -1#37#37#exact -1#38#38#exact -1#39#39#exact -1#40#40#exact -1#41#41#exact -1#42#42#exact -1#43#43#exact -1#45#44#exact -1#46#45#exact -1#47#46#exact -1#48#47#exact -1#49#48#exact -1#50#49#exact -1#51#50#exact -1#52#51#exact -1#53#52#exact -1#54#53#exact -1#55#54#exact -1#56#55#exact -1#58,59,60#56,57,58,59#para -1#61#60#exact -1#62#61#exact -1#63#62#exact -1#64#63#exact -1#65#64#exact -1#66#65#exact -1#67#66#exact -1#68#67#exact -1#69#68#exact -1#70#69#exact -1#71#70#exact -1#72#71#exact -1#73#72#exact -1#74#73#exact -1#75#74#exact -1#76#75#exact -1#77#76#exact -1#78#77#exact -1#79#78#exact -1#80#79#exact -1#81#80#exact -1#82#81#exact 


Variations in each person 's name were collected .
The variations in each person 's name were collected .
-1#1#0#lc -1#2#1#exact -1#3#2#exact -1#4#3#exact -1#5#4#exact -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact 


For example , George W. Bush , President Bush , U.S. President , etc. , all refer to the current U.S. president .
For example , George W. Bush , President Bush , U.S. President , etc. , all refer to the current U.S. president .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact 


We performed simple string search in captions to check whether a caption contained one of these names .
We performed simple string search in captions to check whether a caption contains one of these names .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#stem -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact 


The faces extracted from the corresponding image associated with this caption were returned .
The faces extracted from the corresponding image associated with this caption were returned .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact 


The faces retrieved from the different name queries were merged into one set and used as input for ranking .
The faces retrieved from the different name queries were merged into one set and used as input for ranking .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact 


Figure \REF shows the distribution of retrieved faces from this method and the corresponding number of relevant faces for these fifteen individuals .
Figure \REF shows the distribution of retrieved faces from this method and the corresponding number of relevant faces for these fifteen individuals .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact 


In total , 5 ,603 faces were retrieved in which 3 ,374 faces were relevant .
In total , 5 ,603 faces were retrieved in which 3 ,374 faces were relevant .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact 


On average , the accuracy was 60 .22\% .
On average , the accuracy was 60 .22\% .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact 


We used an eye detector to detect the positions of the eyes of the detected faces .
We used an eye detector to detect the positions of the eyes in the detected faces .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7,8,9,10#7,8,9#para -1#13#10#exact -1#11#11#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact 


The eye detector , built with the same approach as that of Viola and jones \CITE , had an accuracy of more than 95\% .
The eye detector , built with the same approach as in \CITE , had an accuracy of more than 95\% .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#16#11#exact -1#11#15#exact -1#12#16#exact -1#13#17#exact -1#14#18#exact -1#15#19#exact -1#17,18#20,21,22#para -1#19#23#exact -1#20#24#exact 


If the eye positions were not detected , predefined eye locations were assigned .
If the eye positions were not detected , predefined eye locations were assigned .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact 


The eye positions were used to align faces to a predefined canonical pose .
The eye positions were used to align faces to a predefined canonical pose .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact 


To compensate for illumination effects , the subtraction of the best-fit brightness plane followed by histogram equalization was applied .
To compensate for illumination effects , the subtraction of the bestfit brightness plane followed by histogram equalization was applied .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact 


This normalization process is shown in Figure \REF .
This normalization process is shown in Figure \REF .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact 


We then used principle component analysis \CITE to reduce the number of dimensions of the feature vector for face representation .
We then used principle component analysis \CITE to reduce the number of dimensions of the feature vector for face representation .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#8,9,10,11#7,8,9,10,11#para -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact 


Eigenfaces were computed from the original face set returned using the text-based query method .
Eigenfaces were computed from the original face set returned by the text-based query method .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact 


The number of eigenfaces used to form the eigen space was selected so that 97\% of the total energy was retained \CITE . //It is not clear what you mean by " energy " in this context . This is the first time you mention this term . You might want to specify what kind of energy you are talking about .
The number of eigenfaces used to form the eigen space was selected so that 97\% of the total energy was retained \CITE .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact 


The number of dimensions of these feature spaces ranged from 80 to 500 .
The number of dimensions of these feature spaces ranged from 80 to 500 .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact 


We evaluated the retrieval performance with measures that are commonly used in information retrieval , such as precision , recall , and average precision .
We evaluated the retrieval performance with measures that are commonly used in information retrieval , such as precision , recall , and average precision .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact 


Given a queried person and letting \MATH be the total number of faces returned , \MATH the number of relevant faces , and \MATH the total number of relevant faces , recall and precision can be calculated as follows :
Given a queried person and letting \MATH be the total number of faces returned , \MATH the number of relevant faces , and \MATH the total number of relevant faces , recall and precision can be calculated as follows :
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8,9,10,11#8,9,10#para -1#18#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#24,25,26,27#16,17,18#para -1#28#19#exact -1#29#20#exact -1#30#21#exact -1#22#22#exact -1#23#23#exact -1#16#24#exact -1#17#25,26#para -1#19#28#exact -1#20#29#exact -1#21#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact -1#37#37#exact -1#38#38#exact -1#39#39#exact 


Precision and recall are only used to evaluate the quality of an unordered set of retrieved faces .
Precision and recall only evaluate the quality of an unordered set of retrieved faces .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#4#exact -1#4,5#6,7,8#para -1#6#9#exact -1#7#10#exact -1#8#11#exact -1#9#12#exact -1#10#13#exact -1#11#14#exact -1#12#15#exact -1#13#16#exact -1#14#17#exact 


To evaluate ranked lists in which both recall and precision are taken into account , average precision is usually used .
To evaluate ranked lists in which both recall and precision are taken into account , the average precision is usually used .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact 


The average precision is computed by taking the average of the interpolated precision measured at the 11 recall levels of 0 .0 , 0 .1 , 0 .2 , . . . , 1 .0 .
The average precision is computed by taking the average of the interpolated precision measured at the 11 recall levels of 0 .0 , 0 .1 , 0 .2 , . . . , 1 .0 .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#6,7,8#5,6,7,8#para -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact 


The interpolated precision \MATH at a certain recall level \MATH is defined as the highest precision found for any recall level \MATH :
The interpolated precision \MATH at a certain recall level \MATH is defined as the highest precision found for any recall level \MATH :
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact 


In addition , to evaluate the performance of multiple queries , we used mean average precision , which is the mean of average precisions computed from queries
In addition , to evaluate the performance of multiple queries , we used mean average precision , which is the mean of average precisions computed from queries
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact 


The parameters of our method include :
The parameters of our method include :
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact 


-\MATH : the fraction of faces at the top and bottom of the ranked list that are used to form a positive set \MATH and negative set \MATH for training weak classifiers in Rank-By-Bagging-ProbSVM-InnerLoop .
-\MATH : the fraction of faces lying at the top and bottom of the ranked list that are used to form a positive set \MATH and negative set \MATH for training weak classifiers in Rank-By-Bagging-ProbSVM-InnerLoop .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#8,9,10#6,7,8,9#para -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact -1#23#22#exact -1#24#23#exact -1#25#24#exact -1#26#25#exact -1#27#26#exact -1#28#27#exact -1#29#28#exact -1#30#29#exact -1#31#30#exact -1#32#31#exact -1#33#32#exact -1#34#33#exact -1#35#34#exact 


We empirically selected \MATH ( i .e 40\% samples of the rank list were used ) since a larger \MATH will increase the number of incorrect labels , and a smaller \MATH will cause over-fitting .
We empirically selected \MATH ( i .e 40\% samples of the rank list were used ) since larger \MATH will increase the number of incorrect labels and smaller \MATH will cause over-fitting .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#28#exact -1#27#29,30#para -1#28#31#exact -1#29#32#exact -1#30#33#exact -1#31#34#exact -1#32#35#exact 


In addition , \MATH consists of \MATH samples that are selected randomly with replacement from \MATH .
In addition , \MATH consists of \MATH samples that are selected randomly with replacement from \MATH .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact 


This sampling strategy is adopted from the bagging framework \CITE .
This sampling strategy is adopted from the bagging framework \CITE .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact 


The same setting was used for \MATH .
The same setting was used for \MATH .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact 


-\MATH : the maximum Kendall tau distance \MATH between two rank lists \MATH and \MATH .
-\MATH : the maximum Kendall tau distance \MATH between two rank lists \MATH and \MATH .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact 


This value is used to determine when the inner loop and the outer loop stop .
This value is used to determine when the inner loop and the outer loop are stopped .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#15#14#stem -1#16#15#exact 


We set \MATH for balancing between accuracy and processing time .
We set \MATH for balance between accuracy and processing time .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#stem -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact 


Note that a smaller \MATH requires more iterations , making the system 's speed slower .
Note that smaller \MATH requires more number of iterations making the system 's speed slower .
-1#0#0#exact -1#1#1#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#8#7#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact 


-\MATH : the kernel type is used for the SVM .
-\MATH : the kernel type is used for SVM .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#9#exact -1#9#10#exact 


The default is a linear kernel that is defined as : \MATH .
The default is linear kernel that is defined as : \MATH .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact 


We have tested other kernel types , such as RBF or polynomial , but the performance did not change much .
We have tested other kernel types such as RBF or polynomial , the performance did not change so much .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#11#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#12#14#exact -1#13#15#exact -1#14#16#exact -1#15#17#exact -1#16#18#exact -1#18#19#exact -1#19#20#exact 


Therefore , we used the linear kernel for simplicity .
Therefore , we used the linear kernel for simplicity .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact 


We performed a comparison between our proposed method with other ones .
We performed a comparison between our proposed method with other existing approaches .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#12#11#exact 


Text Based Baseline ( TBL ) : Once faces corresponding with images whose captions contain the query name are returned , they are ranked in time order .
Text Based Baseline ( TBL ) : Once faces corresponding with images whose captions contain the query name are returned , they are ranked by the time order .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#26#24,25#para -1#27#26#exact -1#28#27#exact 


This is a rather naive method in which no prior knowledge between names and faces is used .
This is very naive method in which no prior knowledge between names and faces is used .
-1#0#0#exact -1#1#1#exact -1#2#2,3#para -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact 


Distance-Based Outlier ( DBO ) : We adopted the idea of distance-based outlier detection for ranking \CITE .
Distance-Based Outlier ( DBO ) : We adopted the idea of distance-based outliers detection for ranking \CITE .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#stem -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact 


Given a threshold \MATH , for each point \MATH , we counted the number of points \MATH so that \MATH , where \MATH is the Euclidean distance between \MATH and \MATH in the feature space mentioned in section \REF .
Given a threshold \MATH , for each point \MATH , we counted the number of points \MATH so that \MATH , where \MATH is the Euclidean distance between \MATH and \MATH in the feature space mentioned in section \REF .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact -1#37#37#exact -1#38#38#exact -1#39#39#exact 


This number was then used as the score to rank faces .
This number then was used as the score to rank faces .
-1#0#0#exact -1#1#1#exact -1#3#2#exact -1#2#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact 


We selected a range of \MATH values for experiments : \MATH .}
We selected a range of \MATH values for experiments : \MATH .}
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact 


Densest Sub-Graph based Method ( DSG ) : We re-implemented the densest sub-graph based method \CITE for ranking .
Densest Sub-Graph based Method ( DSG ) : We re-implemented the densest sub-graph based method \CITE for ranking .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact 


Once the densest subgraph was found after an edge elimination process , we counted the number of surviving edges of each node ( i .e face ) and used this number as the ranking score .
Once the densest subgraph was found after an edge elimination process , we counted the number of surviving edge of each node ( i .e face ) and used this number as the score for ranking .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#stem -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#35#33#exact -1#33#34#exact -1#36#35#exact 


To form the graph , the Euclidean distance \MATH was used to assign the weight for the edge linked between node $p$ and node \MATH .
To form the graph , the Euclidean distance \MATH was used to assign the weight for the edge linked between node $p$ and node \MATH .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact 


DSG requires a threshold \MATH to convert the weighted graph to the binary graph before searching for the densest subgraph .
DSG require a threshold \MATH to convert the weighted graph to the binary graph before searching for the densest subgraph .
-1#0#0#exact -1#1#1#stem -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact 


We selected a range of \MATH values that are the same as the values used in DBO : \MATH .
We selected a range of \MATH values that are the same as the values used in DBO : \MATH .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8,9,10#8,9,10,11#para -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact 


Local Density Score ( LDS ) : This is the first stage of our proposed method .
Local Density Score ( LDS ) : This is the first stage of our proposed method .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#8,9,10#7,8,9,10#para -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact 


It requires the input value \MATH to compute the local density score .
It requires the input value \MATH to compute the local density score .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact 


Since we do not know the number of returned faces from text-based search engines , we used another input value \MATH , defined as the fraction of neighbors , and estimated \MATH by the formula : \MATH , where \MATH is the number of returned faces .
Since we do not know the number of returned faces from text based search engines , we used another input value \MATH defined as the fraction of neighbors and estimated \MATH by the formula : \MATH , where \MATH is the number of returned faces .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#36#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#29#exact -1#29#30#exact -1#30#31#exact -1#31#32#exact -1#32#33#exact -1#33#34#exact -1#34#35#exact -1#35#36#exact -1#37#38#exact -1#38#39#exact -1#39#40#exact -1#40#41#exact -1#41#42#exact -1#42#43#exact -1#43#44#exact -1#44#45#exact -1#45#46#exact 


We used a range of $fraction$ values for experiments : \MATH .
We used a range of $fraction$ values for experiments : \MATH .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact 


For a large number of returned faces , we set \MATH to the maximum value of 200 : \MATH .
In the case of large number of returned faces , we set \MATH to the maximum value of 200 : \MATH .
-1#4#2#exact -1#5#3#exact -1#6#4#exact -1#7#5#exact -1#8#6#exact -1#9#7#exact -1#10#8#exact -1#11#9#exact -1#12#10#exact -1#13#11#exact -1#14#12#exact -1#15#13#exact -1#16#14#exact -1#17#15#exact -1#18#16#exact -1#19#17#exact -1#20#18#exact -1#21#19#exact 


Unsupervised Ensemble Learning Using Local Density Score ( UEL-LDS ) : This is a combination of ranking by local density scores , and the ranked list is used for training a classifier to boost the rank list .
Unsupervised Ensemble Learning Using Local Density Score ( UEL-LDS ) : This is a combination of ranking by local density scores and then the ranked list is used for training classifier [Singular or plural?]to boost the rank list .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#13,14,15#12,13,14,15#para -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#31#exact -1#34#33#exact -1#35#34#exact -1#36#35#exact -1#37#36#exact -1#38#37#exact 


Supervised Learning ( SVM-SUP ) : We randomly selected a portion \MATH of the data with annotations to train the classifier ; and then used this classifier to re-rank the remaining faces .
Supervised Learning ( SVM-SUP ) : We randomly selected a portion \MATH of the data with annotations to train the classifier ; and then used this classifier to re-rank remaining faces .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29,30#para -1#30#31#exact -1#31#32#exact 


This process was repeated five times and the average performance was reported .
This process was repeated five times and the average performance was reported .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact 


We used a range of portion \MATH values for experiments : \MATH .
We used a range of portion \MATH values for experiments : \MATH .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact 


Figure \REF shows a performance comparison of these methods .
Figure \REF shows a performance comparison of these methods .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact 


Our proposed methods ( LDS and UEL-LDS ) outperform other unsupervised methods such as TBL , DBO , and DSG .
Our proposed methods ( LDS and UEL-LDS ) outperform other unsupervised methods such as TBL , DBO and DSG .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact 


Furthermore , the DBO and DSG methods are sensitive to the distance threshold , while the performance of our proposed method is less sensitive .
Furthermore , the performance of methods DBO and DSG are sensitive to the distance threshold ; while the performance of our proposed method is less sensitive .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#6#3#exact -1#7#4#exact -1#8#5#exact -1#5#6#exact -1#9#7#exact -1#10#8#exact -1#11#9#exact -1#12#10#exact -1#13#11#exact -1#14#12#exact -1#16#14#exact -1#17#15#exact -1#18#16#exact -1#19#17#exact -1#20#18#exact -1#21#19#exact -1#22#20#exact -1#23#21#exact -1#24#22#exact -1#25#23#exact -1#26#24#exact 


It confirms that the similarity measure using shared nearest neighbors is reliable for estimation of the local density score .
It confirms that the similarity measure using shared nearest neighbors is relieable for estimation of the local density score .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact 


The performance of UEL-LDS is slightly better than LDS since the training sets labeled automatically from the ranked list are noisy .
The performance of UEL-LDS is slightly better than LDS since the training sets labeled automatically from the ranked list are noisy .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact 


However , UEL-LDS improves significantly even when the performance of LDS is poor .
However , UEL-LDS improves the performance significantly even when the performance of LDS is poor .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#6#4#exact -1#7#5#exact -1#8#6#exact -1#9#7#exact -1#10#8#exact -1#11#9#exact -1#12#10#exact -1#13#11#exact -1#14#12#exact -1#15#13#exact 


These performances are worse than that of SVM-SUP using a small number of labeled samples .
These performances are worse than that of SVM-SUP using a small number of labeled samples .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact 


Figure \REF shows an examples of the top 50 faces ranked using the TBL , DBO , DSG , and LDS methods .
Figure \REF shows an examples of top 50 faces ranked by the methods TBL , DBO , DSG and LDS .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#11#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#19#exact -1#19#20#exact -1#12#21#exact -1#20#22#exact 


The performance of DBO is poor since a low threshold is used .
The performance of DBO is poor since a low threshold is used .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact 


This ranks irrelevant faces that are near duplicates ( rows 2 and 3 in Figure \REF( b ) ) higher than relevant faces .
This makes irrelevant faces that are near duplicates ( row 2 and row 3 in Figure \REF( b ) ) ranked higher than relevant faces .
-1#0#0#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#stem -1#10#10#exact -1#11#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#21#19#exact -1#22#20#exact -1#23#21#exact -1#24#22#exact -1#25#23#exact 


This explains the same situation with DSG .
This explains the same situation with DSG .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact 


A Text Segmentation Based Approach to Video Shot Boundary Detection
A Text Segmentation Based Approach to Video Shot Boundary Detection
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact 


Video shot boundary detection is one of the fundamental tasks of video indexing and retrieval applications .
Video shot boundary detection is one of the fundamental tasks of video indexing and retrieval applications .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4,5,6,7#4,5,6,7,8#para -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact 


Although many methods have been proposed for this task , finding a general and robust shot boundary method that is able to handle the various transition types caused by photo flashes , rapid camera movement , and object movement is still challenging .
Although many methods have been proposed for this task , finding a general and robust shot boundary method that is able to handle various transition types caused by photo flashes , rapid camera movement and object movement is still challenging .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23,24#para -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact -1#28#29#exact -1#29#30#exact -1#30#31#exact -1#31#32#exact -1#32#33#exact -1#33#34#exact -1#34#36#exact -1#35#37#exact -1#36#38#exact -1#37#39#exact -1#38#40#exact -1#39#41#exact -1#40#42#exact 


We present a novel approach for detecting video shot boundaries in which we cast the problem of shot boundary detection into the problem of text segmentation in natural language processing . //detecting / determining?
In this paper , we present a novel approach for detecting video shot boundaries in which we cast the problem of shot boundary detection into the problem of text segmentation in natural language processing .
-1#4#0#lc -1#5#1#exact -1#6#2#exact -1#7#3#exact -1#8#4#exact -1#9#5#exact -1#10#6#exact -1#11#7#exact -1#12#8#exact -1#13#9#exact -1#14#10#exact -1#15#11#exact -1#16#12#exact -1#17#13#exact -1#24,25,26,27#14,15,16#para -1#21#17#exact -1#22#18#exact -1#23#19#exact -1#18,19,20#20,21,22,23#para -1#28#24#exact -1#29#25#exact -1#30#26#exact -1#31#27#exact -1#32#28#exact -1#33#29#exact -1#34#30#exact 


This is possible by assuming that each frame is a word and then the shot boundaries are treated as text segment boundaries ( e.g. topics ) .
By the formulation that each frame is considered as a word and shot boundaries are treated as boundaries of text segments ( e .g topics ) .
-1#0#3#lc -1#3#5#exact -1#4#6#exact -1#5#7#exact -1#6#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#1#13#exact -1#12#14#exact -1#13#15#exact -1#14#16#exact -1#15#17#exact -1#16#18#exact -1#19#19#exact -1#20#20#stem -1#17#21#exact -1#21#22#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact 


The text segmentation based approaches in natural language processing can be used .
Text segmentation based approaches that have been well studied in natural language processing can be adopted .
-1#0#1#lc -1#1#2#exact -1#2#3#exact -1#3#4#exact -1#9#5#exact -1#10#6#exact -1#11#7#exact -1#12#8#exact -1#13#9#exact -1#14#10#exact -1#16#12#exact 


The experimental results from various long video sequences have proven the effectiveness of our approach .
Experimental results on various long video sequences show the effectiveness of our approach .
-1#8#0#lc -1#0#1#lc -1#1#2#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#9#syn -1#9,10#10,11,12#para -1#11#13#exact -1#12#14#exact -1#13#15#exact 


Recent advances in digital technology have made many video archives readily available .
Recent advances in digital technology have made many video archives available .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#11#exact -1#11#12#exact 


Therefore scalable , efficient , and effective tools for indexing and retrieving video are needed .
Therefore scalable , efficient and effective tools for indexing and retrieving video are needed .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact 


With a large amount of information encoded in one video , typically the first step of any video processing tools is to segment the input video into elementary shots in which each shot is defined as a continuous frame from a single camera at a given moment .
With a large amount of information encoded in one video , typically the first step of any video processing tools is to segment the input video into elementary shots in which each shot is defined as continuous frames from a single camera at a time .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#39#36#exact -1#36#37#exact -1#37#38#stem -1#38#39#exact -1#43#40#exact -1#40#41#exact -1#41#42#exact -1#42#43#exact -1#44#46#para -1#45#47#exact 


By breaking down a video into individual shots and then extracting the keyframes from these shots , a 30-minute video containing 54 ,000 frames can be represented by around 500 keyframes ( 108 times smaller ) that are easily manageable for many video applications [in / such as? / including?] indexing , browsing , summarization , and retrieval .
By decomposing a video into shots and then extracting keyframes from these shots , a 30-minute video with 54 ,000 frames can be represented by around 500 keyframes ( 108 times smaller ) which are easily manageable for many video applications in indexing , browsing , summarization , retrieval and so on .
-1#0#0#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#7#exact -1#6#8#exact -1#7#9#exact -1#8#10#exact -1#9#12#exact -1#10#13#exact -1#11#14#exact -1#12#15#exact -1#13#16#exact -1#14#17#exact -1#15#18#exact -1#16#19#exact -1#18#21#exact -1#19#22#exact -1#20#23#exact -1#21#24#exact -1#22#25#exact -1#23#26#exact -1#24#27#exact -1#25#28#exact -1#26#29#exact -1#27#30#exact -1#28#31#exact -1#29#32#exact -1#30#33#exact -1#31#34#exact -1#32#35#exact -1#33,34#36,37#para -1#35#38#exact -1#36#39#exact -1#37#40#exact -1#38#41#exact -1#39#42#exact -1#40#43#exact -1#42#50#exact -1#43#51#exact -1#44#52#exact -1#45#53#exact -1#46#54#exact -1#47#55#exact -1#49#56#exact -1#48#57#exact -1#52#58#exact 


There are many types of transitions between shots .
There are many types of transitions between shots .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact 


According to TRECVID 's categorization \CITE , shot boundaries can be classified into two main categories : cut and gradual .
According to TRECVID 's categorization \CITE , shot boundaries can be classified into two main categories : cut and gradual .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact 


A cut is an abrupt shot change that occurs in a single frame while a gradual is a slow change that occurs over a number of consecutive frames .
A cut is an abrupt shot change that occurs in a single frame while a gradual is a slow change that occurs in a number of consecutive frames .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact 


With the gradual type , fades and dissolves are common .
With the gradual type , fades and dissolves are common .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact 


A fade is usually a change in brightness with one or several solid black frames in between the key frames , while a dissolve occurs when the images in the current shot get dimmer and the images of the next shot get brighter \CITE .
A fade is usually a change in brightness with one or several solid black frames in between , while a dissolve occurs when the images in the current shot get dimmer and the images of the next shot get brighter \CITE .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#23#17#exact -1#17#20#exact -1#18#21#exact -1#19#22#exact -1#20#23#exact -1#21#24#exact -1#22#25#exact -1#32#26#exact -1#33#27#exact -1#25#28#exact -1#26#29#exact -1#27#30#exact -1#28#31#exact -1#29#32#exact -1#30#33#exact -1#31#34#exact -1#35#35#exact -1#24#36#exact -1#34#37#exact -1#36#38,39#para -1#37#40#exact -1#38#41#exact -1#39#42#exact -1#40#43#exact -1#41#44#exact 


Figure \REF shows examples of shot boundary types .
Figure \REF shows examples of shot boundary types .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact 


Many approaches have been proposed for shot boundary detection .
Many approaches have been proposed for shot boundary detection .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact 


The simplest approach is to compute the differences between the color distributions of consecutive frames and use a threshold to classify whether a hard cut occurs .
The simplest approach is to compute the differences between color distributions of consecutive frames and use a threshold to classify whether a hard cut occurs .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6,7,8#6,7,8,9#para -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact 


In order to detect gradual transitions , edge change ratios or motion vectors can be used \CITE .
In order to detect gradual transitions , edge change ratio or motion vectors can be used \CITE .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#stem -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact 


Since these approaches use threshold-based models for detection , their advantage is they are fast .
Since these approaches use threshold-based models for detection , their advantage is fast speed .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#13,14#para -1#14#15#exact 


Nevertheless , they are sensitive to changes in illumination and motion .
Nevertheless , they are sensitive to changes of illumination and motion .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6,7#6,7#para -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact 


Furthermore , they are difficult to generalize for new datasets .
Furthermore , they are difficult to generalize for new datasets .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact 


Recent works \CITE use machine learning methods for making decisions and have received impressive results on the test videos of TRECVID \CITE , which is a de-facto benchmark for evaluating the various techniques used in shot boundary detection .
Recent works \CITE use machine learning methods for making decision and show impressive results on test videos of TRECVID \CITE which is a de-facto benchmark for evaluation of various techniques in shot boundary detection .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9,10#9,10#para -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16,17#para -1#16#18#exact -1#17#19#exact -1#18#20#exact -1#19#21#exact -1#20#23#exact -1#21#24#exact -1#22#25#exact -1#23#26#exact -1#24#27#exact -1#25#28#exact -1#26,27#29#para -1#28#30,31#para -1#29#32#exact -1#30#34#exact -1#31#35#exact -1#32#36#exact -1#33#37#exact -1#34#38#exact 


In this study , we propose a new approach that was inspired by the natural language processing text segmentation techniques in which the problem of shot boundary detection is treated similarly to the problem in text segmentation .
In this study , we propose a new approach inspired from natural language processing text segmentation techniques in which the problem of shot boundary detection is treated similarly to the problem of text segmentation .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#25#10#syn -1#9#11#exact -1#19#13#exact -1#11#14#exact -1#12#15#exact -1#13#16#exact -1#14#17#exact -1#15#18#exact -1#16#19#exact -1#17#20#exact -1#18#21#exact -1#28,29,30,31#22,23,24#para -1#22#25#exact -1#23#26#exact -1#24#27#exact -1#26#28,29#para -1#27#30#exact -1#20#32,33#para -1#32#35#exact -1#33#36#exact -1#34#37#exact 


Specifically , each frame is considered a word and a set of consecutive frames , forming a shot , is considered a text segment .
Specifically , each frame is considered as a word and a set of consecutive frames , forming a shot , is considered as a text segment .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#23#21#exact -1#24#22#exact -1#25#23#exact -1#26#24#exact 


Then , the text segmentation problem can be considered a sequential tagging problem in which each word is labeled by one of the following labels :
Then , the text segmentation problem can be considered a sequential tagging problem in which each word is labeled by one of labels such as
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#24#exact 


PRESEG ( word beginning of a segment ) , INSEG ( word inside a segment ) , and POSTSEG ( word outside a segment ) .
PRESEG ( word beginning of a segment ) , INSEG ( word inside a segment ) and POSTSEG ( word outside a segment ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact 


Given a sequence of labeled words , the boundary between text segments can be identified .
Given a sequence of labeled words , the boundary between text segments can be identified .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact 


The remainder of this paper is organized as follows .
The remaining of the paper is organized as follows .
-1#0,1#0,1#para -1#2#2#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact 


In section \REF , we present an overview of our framework .
In section \REF , we present an overview of our framework .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact 


Section \REF introduces our experiments on different long video sequences from the TRECVID dataset .
Section \REF introduces experiments on different long video sequences from TRECVID dataset .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#12#exact -1#11#13#exact -1#12#14#exact 


Section \REF concludes the paper .
Section \REF concludes the paper .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact 


The shot boundary detection process for a given video is carried out through two main stages .
Given a video , the shot boundary detection process is carried out through two main stages .
-1#4#0#lc -1#5#1#exact -1#6#2#exact -1#7#3#exact -1#8#4#exact -1#1#6#exact -1#0#7#lc -1#2#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact 


In the first stage , frames are extracted and labeled with pre-defined labels .
In the first stage , frames are extracted and labeled by pre-defined labels .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact 


In the second stage , the shot boundaries are identified by grouping the labeled frames into segments .
In the second stage , shot boundaries are identified by grouping labeled frames into segments .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#13#exact -1#12#14#exact -1#13#15#exact -1#14#16#exact -1#15#17#exact 


We use the following six labels to label frames in a video : NORM -FRM ( frame of a normal shot ) , PRE -CUT ( pre-frame of a CUT transition ) , POST -CUT ( post-frame of a CUT transition ) , PRE -GRAD ( pre-frame of a GRADUAL transition ) , IN -GRAD ( frame inside a GRADUAL transition ) , and POST -GRAD ( post-frame of a GRADUAL transition ) .
We use the following six labels to label frames in video : NORM -FRM ( frame of a normal shot ) , PRE -CUT ( pre-frame of a CUT transition ) , POST -CUT ( post-frame of a CUT transition ) , PRE -GRAD ( pre-frame of a GRADUAL transition ) , IN -GRAD ( frame inside a GRADUAL transition ) , POST -GRAD ( post-frame of a GRADUAL transition ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#17#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#27#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#37#28#exact -1#38#29#exact -1#39#30#exact -1#40#31#exact -1#41#32#exact -1#32#33#exact -1#33#34#exact -1#34#35#exact -1#35#36#exact -1#36#37#exact -1#47#38#exact -1#28#39#exact -1#29#40#exact -1#30#41#exact -1#31#42#exact -1#42#43#exact -1#43#44#exact -1#44#45#exact -1#45#46#exact -1#46#47#exact -1#57#48#exact -1#58#49#exact -1#59#50#exact -1#60#51#exact -1#61#52#exact -1#52#53#exact -1#53#54#exact -1#54#55#exact -1#55#56#exact -1#56#57#exact -1#67#58#exact -1#68#59#exact -1#69#60#exact -1#70#61#exact -1#51#62#exact -1#62#64#exact -1#63#65#exact -1#64#66#exact -1#65#67#exact -1#66#68#exact -1#48#69,70#para -1#49#71#exact -1#50#72#exact -1#71#73#exact 


Given a sequence of labeled frames , the shot boundaries and transition types are identified by looking up and processing the frames marked with a non NORM -FRM label .
Given a sequence of labeled frames , shot boundaries and transition types are identified by looking up and processing frames marked by non NORM -FRM label .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#21#exact -1#20#22#exact -1#22#25#exact -1#23#26#exact -1#24#27#exact -1#25#28#exact -1#26#29#exact 


For example , if we encounter two consecutive frames respectively marked by IN-CUT and POST-CUT , we can declare that a shot boundary occurs at these frames and the transition type is a CUT .
For example , if we encounter two consecutive frames marked by IN-CUT and POST-CUT respectively , we can declare that a shot boundary occurs at these frames and the transition type is CUT .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#14#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#33#exact -1#33#34#exact 


In another case , if we encounter a number of frames marked by xxx-GRAD , we can declare that a GRADUAL shot boundary occurs at these frames .
In another case , if we encounter a number of frames marked by xxx-GRAD , we can declare a GRADUAL shot boundary occurs at these frames .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact 


Figure \REF shows an example of the labeled frames of a shot transition .
Figure \REF shows an example of labeled frames of a shot transition .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact 


To label a frame in a video , we must firstly extract the features for that frame and then use a classifier , which has been trained in advance by the annotated frames , to classify it into one of the six categories mentioned above .
To label a frame in video , firstly we extract features for that frame and then use a classifier , that has been trained by annotated frames in advance , to classify it into one of six categories mentioned above .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#17#5#exact -1#5#6#exact -1#6#7#exact -1#8#8#exact -1#7#10#exact -1#9#11#exact -1#10#12,13#para -1#11#14#exact -1#12#15#exact -1#13#16#exact -1#14#17#exact -1#15#18#exact -1#16#19#exact -1#18#21#exact -1#19#22#exact -1#20,21#23,24#para -1#22#25#exact -1#23#26#exact -1#27#27#exact -1#28#28#exact -1#24#29#exact -1#25#31#exact -1#26#32#exact -1#29#33#exact -1#30#34#exact -1#31#35#exact -1#32#36#exact -1#33,34#37,38,39,40#para -1#36#41#exact -1#37#42#exact -1#38#43#exact -1#39#44#exact -1#40#45#exact 


The feature extraction process and classifier learning using a support vector machine ( SVM ) are described in detail below .
The feature extraction process and classifier learning using support vector machine ( SVM ) are described in details below .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8,9#para -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#stem -1#18#19#exact -1#19#20#exact 


We use two typical features , which are the color moments and edge direction histogram , to represent the visual information of each frame .
We use two typical features that are color moments , edge direction histogram for representing visual information of each frame .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#9#5#exact -1#5,6#6,7,8#para -1#7#9#exact -1#8#10#exact -1#10#12#exact -1#11#13#exact -1#12#14#exact -1#14#16,17#para -1#15#19#exact -1#16#20#exact -1#17#21#exact -1#18#22#exact -1#19#23#exact -1#20#24#exact 


However , using this representation is not discriminative enough for frame categorization since the frames of a shot transition usually strongly relate to their neighboring frames .
However , using this representation is not discriminative enough for frame categorization since frames of a shot transition usually have strong relation to their neighbor frames .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#20#20#stem -1#21#21#stem -1#22#22#exact -1#23#23#exact -1#24#24#stem -1#25#25#exact -1#26#26#exact 


For example , an abrupt change in illumination between two consecutive frames is a strong cue for a hard cut , or one solid black frame in between dark and then bright frames might help to identify a fade shot transition .
For example , an abrupt change in illumination between two consecutive frames is a strong cue for a hard cut , or one solid black frames in between dark and then bright frames might help to identify a fade shot transition .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#stem -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact -1#37#37#exact -1#38#38#exact -1#39#39#exact -1#40#40#exact -1#41#41#exact 


Therefore , in this study , we do not directly use the above features .
Therefore , in this study , we do not directly use above features .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact 


Instead , we use them indirectly to model the difference and motion between the current frame and its neighboring frames .
Instead , we use them indirectly to model the difference and motion between the current frame and its neighbor frames .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#stem -1#19#19#exact -1#20#20#exact 


In particular , for each frame , we compute \MATH distances between the current frame \MATH and neighboring frames ranging from \MATH .
Specifically , for each frame , we compute \MATH distances between the current frame \MATH and neighbor frames ranging from \MATH .
-1#0#0,1#para -1#1#2#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#stem -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact 


These distances are used to form a feature vector for frame \MATH in the training and testing process later .
These distances are used to form a feature vector for frame \MATH in training and testing process later .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13,14#13,14,15#para -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact 


In this way , we can have a unified framework for the shot boundary detection and consequently avoid having to give special treatment to the different shot boundary types as described in many of the works that participated the TRECVID benchmark \CITE .
By this way , we can have a unified framework for shot boundary detection and consequently avoid to have special treatments for different shot boundary types as described in many works participated the TRECVID benchmark \CITE .
-1#28#0#lc -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#32#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#19#exact -1#18#20#syn -1#19#21#exact -1#20#22#stem -1#22#23,24,25#para -1#23#26#exact -1#24#27#exact -1#25#28#exact -1#26#29#exact -1#27#30#exact -1#29#32#exact -1#30#34,35#para -1#31#37#exact -1#33#39#exact -1#34#40#exact -1#35#41#exact -1#36#42#exact 


Color moments have been successfully used in retrieval systems and proved to be efficient and effective in representing the color distributions of images \CITE .
Color moments have been successfully used in retrieval systems and proved to be efficient and effective in representing color distributions of images \CITE .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#13,14,15#11,12,13,14,15#para -1#16#16#exact -1#17#17#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact 


The first order ( mean ) , the second order ( variance ) , and the third order ( skewness ) color moments are defined as :
The first order ( mean ) , the second order ( variance ) and the third order ( skewness ) color moments are defined as :
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact 


where \MATH is the value of the \MATH -th color component of image pixel \MATH , and \MATH is the number of pixels in the image .
where \MATH is the value of the \MATH -th color component of the image pixel \MATH , and \MATH is the number of pixels in the image .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3,4,5,6#3,4,5#para -1#12#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact -1#23#22#exact -1#24#23#exact -1#25#24#exact -1#26#25#exact -1#27#26#exact 


Edge orientation histogram has also been widely used in shot boundary detection \CITE .
Edge orientation histogram has also been used widely in shot boundary detection \CITE .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#7#6#exact -1#6#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact 


The basic steps for computing the edge orientation histogram features are as follows :
The basic steps to compute edge orientation histogram feature are as follows :
-1#0#0#exact -1#1#1#exact -1#2,3#2,3#para -1#4#4#stem -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#stem -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact 


Extract edges from the input image by using Canny edge detector .
Extract edges from the input image by using Canny edge detector .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact 


Compute a \MATH -bin histogram of edge and non-edge pixels .
Compute a \MATH -bin histogram of edge and non-edge pixels .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact 


The first \MATH bins are used to represent the edge directions quantized at a \MATH interval and the remaining bin is used for counting the non-edge pixels .
The first \MATH bins are used to represent edge directions quantized at \MATH interval and the remaining bin is used for counting non-edge pixels .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#15#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#14#exact -1#13#15#exact -1#14#16#exact -1#16#17,18#para -1#17#19#exact -1#18#20#exact -1#19#21#exact -1#20#22#exact -1#21#23#exact -1#22#25#exact -1#23#26#exact -1#24#27#exact 


The histogram is normalized by the total number of all the pixels to compensate for different image sizes .
The histogram is normalized by the number of all pixels to compensate for different image sizes .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5,6,7#5,6,7,8#para -1#8#9#exact -1#9#11#exact -1#10#12#exact -1#11#13#exact -1#12#14#exact -1#13#15#exact -1#14#16#exact -1#15#17#exact -1#16#18#exact 


We use color moments and an edge orientation histogram to compute the distances between the current frame \MATH and its neighboring frames as follows :
We use color moments and edge orientation histogram to compute distances between the current frame \MATH and it neighbor frames as follows :
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#12#11#exact -1#10#12#exact -1#11#13#exact -1#13#14,15#para -1#14#16#exact -1#15#17#exact -1#16#18#exact -1#17#19#stem -1#18#20#stem -1#19#21#exact -1#20#22#exact -1#21#23#exact -1#22#24#exact 


The input image is converted to a LUV color space ( for GCM ) or grayscale ( for EOH ) and then divided into sub-images by a \MATH grid .
The input image is converted to LUV color space ( for GCM ) or grayscale ( for EOH ) and then divided into sub-images by a \MATH grid .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#25#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#26#27#exact -1#27#28#exact -1#28#29#exact 


The color moments and edge orientation histogram are extracted from these sub-images .
The color moments and edge orientation histogram are extracted from these sub-images .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact 


For color moments , there are \MATH values .
For color moments , there are \MATH values .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact 


For the edge orientation histogram , there are \MATH values for each input frame image .
For edge orientation histogram , there are \MATH values for each input frame image .
-1#0#0#exact -1#1#2#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact 


Compute \MATH values , which are the Euclidean distances between the current frame \MATH and its neighboring frames ranging from \MATH .
Compute \MATH values which are the Euclidean distance between current frame \MATH and its neighbor frames ranging from \MATH .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7,8#8,9#para -1#9#10,11#para -1#10#12#exact -1#11#13#exact -1#12#14#exact -1#13#15#exact -1#14#16#stem -1#15#17#exact -1#16#18#exact -1#17#19#exact -1#18#20#exact -1#19#21#exact 


In other words , we compute \MATH , where \MATH .
In other words , we compute \MATH where \MATH .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact 


These values \MATH are then used to form the feature vector for frame \MATH .
These values \MATH are then used to form the feature vector for frame \MATH .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact 


Support Vector Machines ( SVM ) are a statistical learning method based on the structure risk minimization principle \CITE .
The Support Vector Machines ( SVM ) is a statistical learning method based on the structure risk minimization principle \CITE .
-1#1#0#exact -1#2#1#exact -1#3#2#exact -1#4#3#exact -1#5#4#exact -1#6#5#exact -1#7,8#6,7#para -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact 


They have been very efficiently proved to be useful in many pattern recognition applications \CITE .
It has been very efficiently proved in many pattern recognition applications \CITE .
-1#1#0,1#para -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#9#exact -1#7#10#exact -1#8#11#exact -1#9#12#exact -1#10#13#exact -1#11#14#exact -1#12#15#exact 


In the case of binary classification , the objective of the SVM is to find the best separating hyperplane with a maximum margin .
In the binary classification case , the objective of the SVM is to find a best separating hyperplane with a maximum margin .
-1#0#0#exact -1#1#1#exact -1#4#2#exact -1#8#3#exact -1#2#4#exact -1#3#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#9#10#exact -1#10#11#exact -1#11,12,13,14#12,13,14,15#para -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact 


The form of the SVM classifiers is : \MATH
The form of SVM classifiers is : \MATH
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact 


where \MATH is the d-dimensional vector of an observation example , \MATH is the class label , \MATH is the vector of the \MATH training example , \MATH is the number of training examples , and \MATH is a kernel function , \MATH is learned through the learning process .
where \MATH is the d-dimensional vector of an observation example , \MATH is a class label , \MATH is the vector of the \MATH training example , \MATH is the number of training examples , and \MATH is a kernel function , \MATH is learned through the learning process .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#19#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#22#19#exact -1#20#20#exact -1#21#21#exact -1#29#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#46#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact -1#37#37#exact -1#38#38#exact -1#39#39#exact -1#40#40#exact -1#41#41#exact -1#42#42#exact -1#43#43#exact -1#44#44#exact -1#45#45#exact -1#47#47#exact -1#48#48#exact -1#49#49#exact 


SVMs were originally designed for binary classification .
SVM were originally designed for binary classification .
-1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact 


There are two common approaches for handling multi-class classification .
To handle the case of multi-class classification , there are two common approaches .
-1#8#0#lc -1#9#1#exact -1#10#2#exact -1#11#3#exact -1#12#4#exact -1#0,1#5,6#para -1#5#7#exact -1#6#8#exact -1#13#9#exact 


The first one is the one-against-all method that combines \MATH binary classifiers , where \MATH is the number of classes .
The first one is the one-against-all method that combines \MATH binary classifiers where \MATH is the number of classes .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact 


The \MATH SVM classifier is trained using positive samples as examples of the \MATH class and negative samples as the examples of the other classes .
The \MATH SVM classifier is trained by positive samples being examples of the \MATH class and negative samples being examples of the other classes .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#7#7#exact -1#8#8#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#21#19#exact -1#19#20#exact -1#20#21#exact -1#22#22,23#para -1#23#24#exact -1#24#25#exact 


The second one is the one-against-one method that combines \MATH binary classifiers in which each classifier is trained on examples from the two classes .
The second one is the one-against-one method that combines \MATH binary classifiers in which each classifier is trained on examples of two classes .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#21#21,22#para -1#22#23#exact -1#23#24#exact 


There are seven classes in our framework : NORM FRM ( frame of a normal shot ) , PRE CUT ( pre-frame of a CUT transition ) , POST CUT ( postframe
There are seven classes in our framework : NORM FRM ( frame of a normal shot ) , PRE CUT ( pre-frame of a CUT transition ) , POST CUT ( postframe
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact 


of a CUT transition ) , PRE GRAD ( pre-frame of a GRADUAL transition ) , IN GRAD ( frame inside a GRADUALtransition ) , POST GRAD ( post-frame of a GRADUAL transition ) , and NORM-FRM ( normal frame that does not belong to any shot transitions ) .
of a CUT transition ) , PRE GRAD ( pre-frame of a GRADUAL transition ) , IN GRAD ( frame inside a GRADUALtransition ) , POST GRAD ( post-frame of a GRADUAL transition ) and NORM-FRM ( normal frame which does not belong to any shot transitions ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#35#exact -1#35#36#exact -1#36#37#exact -1#37#38#exact -1#38#39#exact -1#39,40,41,42#40,41,42,43#para -1#43#44#exact -1#44#45#exact -1#45#46#exact -1#46#47#exact -1#47#48#exact -1#48#49#exact 


To train this classifier , we manually annotated frames in the training data . //learn / learn about? / find? / educate? / develop? / train?
To learn this classifier , we manually annotate frames in the training data .
-1#0#0#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#stem -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#1#16#exact 


Using the trained classifier , we can label a sequence of frames with the tags mentioned above .
Using the trained classifier , we can label a sequence of frames with tags mentioned above .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact 


A gradual transition usually has a " ` . . . , PRE-GRAD , IN-GRAD , IN-GRAD , . . . , IN-GRAD , POS-GRAD , . . . " ' pattern and a cut transition usually has a " ` . . . , PRE-CUT , IN-CUT , . . . , IN-CUT , POST-CUT , . . . " 'pattern .
A gradual transition usually has the pattern " ` . . . , PRE-GRAD , IN-GRAD , IN-GRAD , . . . , IN-GRAD , POS-GRAD , . . . " ' and a cut transition usually has the pattern " ` . . . , PRE-CUT , IN-CUT , . . . , IN-CUT , POST-CUT , . . . " ' .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#33#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact -1#23#22#exact -1#24#23#exact -1#25#24#exact -1#26#25#exact -1#27#26#exact -1#28#27#exact -1#29#28#exact -1#30#29#exact -1#31#30#exact -1#6#31#exact -1#32#32#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact -1#37,38#37,38#para -1#40#39#exact -1#41#40#exact -1#42#41#exact -1#43#42#exact -1#44#43#exact -1#45#44#exact -1#46#45#exact -1#47#46#exact -1#48#47#exact -1#49#48#exact -1#50#49#exact -1#51#50#exact -1#52#51#exact -1#53#52#exact -1#54#53#exact -1#55#54#exact -1#56#55#exact -1#57#56#exact -1#58#57#exact -1#59#58#exact -1#60#59#exact -1#61#60#exact -1#39#61#stem -1#63#62#exact 


The shot boundary detection process is started by checking for these transition patterns in the tagged sequence .
The shot boundary detection process is started by checking these transition patterns in the tagged sequence .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact 


Once a pattern is encountered , PRE-xxx and POST-xxx tags are used to identify the shot boundary and the two ends of the shot transition .
Once a pattern is encountered , PRE-xxx and POST-xxx tags are used to identify the shot boundary and the two ends of the shot transition .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact 


Since the classifier occasionally produces false predictions due to the variations caused by photo flashes , rapid camera movement , and object movement , only using the perfect match between the predefined patterns and sub-sequences usually skips many of the true shot boundaries .
Since the classifier occasionally produce false predictions due to variations caused by photo flashes , rapid camera movement and object movement , only using the perfect match between the predefined patterns and sub-sequences usually skips many truth shot boundaries .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#stem -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#24#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#21#19#exact -1#18#20#exact -1#19#21#exact -1#20#22#exact -1#22#24#exact -1#23#25#exact -1#28#26#exact -1#25#27#exact -1#26#28#exact -1#27#29#exact -1#29#31#exact -1#30#32#exact -1#31#33#exact -1#32#34#exact -1#33#35#exact -1#34#36#exact -1#35#37#exact -1#36#40#para -1#37#41#exact -1#38#42#exact -1#39#43#exact 


Instead , we use a more flexible matching algorithm in which a match is declared if a portion of the predefined pattern is found in the input sub-sequence .
Instead , we use a more flexible matching algorithm in which a match is declared if a portion of the predefined pattern is found in the input sub-sequence .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact 


We used annotated data sets from the TRECVID 2003 test sets for the training and testing .
We used annotated data sets from TRECVID 2003 test sets for training and testing .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11,12#12,13,14#para -1#13#15#exact -1#14#16#exact 


We divided eight videos , each 30-minute long , into two sets : a training set and a test set .
We divided 8 videos , each 30-minute length , into two sets : training set and testing set .
-1#0#0#exact -1#1#1#exact -1#2#2#syn -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#para -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17,18#para -1#17#19#exact -1#18#20#exact 


The number of frames , the number of shot boundaries , and the types of these sets are shown in Table \REF .
The number of frames , the number of shot boundaries and types of these sets are shown in Table \REF .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#11#exact -1#11,12#12,13,14#para -1#13#15#exact -1#14#16#exact -1#15#17#exact -1#16#18#exact -1#17#19#exact -1#18#20#exact -1#19#21#exact -1#20#22#exact 


Note that , the number of shot boundaries is equal to the number of frames with a PRE-CUT / GRAD label and the number of frames with a PRE-CUT / GRAD label is equal to the number of frames within a POST-CUT / GRAD label .
Note that , the number of shot boundaries is equal to the number of frames with PRE-CUT / GRAD label and the number of frames with PRE-CUT / GRAD label is equal to the number of frames with POST-CUT / GRAD label .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9,10,11,12#9,10,11#para -1#22#12#exact -1#23#13#exact -1#24#14#exact -1#25#15#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#34#23#exact -1#35#24#exact -1#36#25#exact -1#37#26#exact -1#26#28#exact -1#27#29#exact -1#28#30#exact -1#29#31#exact -1#30#32#exact -1#31,32,33#33,34,35,36#para -1#13#37#exact -1#14#38#exact -1#38#41#exact -1#39#42#exact -1#40#43#exact -1#41#44#exact -1#42#45#exact 


We used \MATH grid to divide the input image into sub-images .
We used \MATH grid for dividing the input image into sub-images .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#5#4,5#para -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact 


As for the edge orientation histogram , we used 12-bins for the edge pixels and one bin for the non-edge pixels .
As for edge orientation histogram , we used 12-bins for edge pixels and one bin for non-edge pixels .
-1#0#0#exact -1#1#1#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11,12#para -1#11#13#exact -1#12#14#exact -1#13#15#exact -1#14#16#exact -1#15#17#exact -1#16#19#exact -1#17#20#exact -1#18#21#exact 


Furthermore , we used 20 neighboring frames before and after the current frame ( \MATH ) for computing the distances .
Furthermore , we used 20 neighbor frames before and after the current frame ( \MATH ) for computing the distances .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#stem -1#6#6#exact -1#7,8,9,10#7,8,9#para -1#18#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#19#18,19#para -1#20#20#exact 


These parameters were selected from our empirical studies when participating in TRECVID 's tasks .
These parameters were selected from our empirical studies when participating TRECVID 's tasks .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact 


The extracted features are normalized to zero mean and a unit standard deviation and then stored for training and testing .
The extracted features are normalized to zero mean and unit standard deviation and then stored for training and testing .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9,10#para -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact 


Specifically , the normalized vector \MATH
Specifically , the normalized vector \MATH
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact 


where \MATH is the \MATH-th element of the feature vectors \MATH , respectively , and \MATH is the number of dimensions .
where \MATH is the \MATH-th element of the feature vectors \MATH respectively , \MATH is the number of dimensions .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#12#11#exact -1#11#12#exact -1#13#15#exact -1#14#16#exact -1#15#17#exact -1#16#18#exact -1#17#19#exact -1#18#20#exact -1#19#21#exact 


In order to handle the problem of imbalanced training sets where the number of NORM-FRM frames is much larger than other frames , we randomly take the \MATH of NORM-FRM frames and 100\% of the other frames to form the training set .
In order to handle the problem of imbalanced training sets where the number of NORM-FRM frames is much larger than other frames , we randomly take \MATH of NORM-FRM frames and 100\% of the other frames to form the training set .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#33#26#exact -1#26#27#exact -1#27#28#exact -1#28#29#exact -1#29#30#exact -1#30#31#exact -1#31#32#exact -1#32#33#exact -1#38#34#exact -1#34#35#exact -1#35#36#exact -1#36#37#exact -1#37#38#exact -1#39#39,40#para -1#40#41#exact -1#41#42#exact 


We use LibSVM \CITE to train the SVM classifiers with a RBF kernel .
We use LibSVM \CITE to train SVM classifiers with RBF kernel .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#11#exact -1#10#12#exact -1#11#13#exact 


The optimal \MATH parameters are found by conducting a grid search with a 5-fold cross validation on a subset of 10 ,000 samples stratified selected from the original dataset .
The optimal \MATH parameters are found by conducting a grid search with 5-fold cross validation on a subset 10 ,000 samples stratified selected from the original dataset .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#16#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#17#18#exact -1#18#19,20#para -1#19#21#exact -1#20#22#exact -1#21#23#exact -1#22#24#exact -1#23#25#exact -1#24#26#exact -1#25#27#exact -1#26#28#exact -1#27#29#exact 


As for the multi-class classification , LibSVM used the one-against-one approach .
As for multi-class classification , LibSVM used the one-against-one approach .
-1#0#0#exact -1#1#1#exact -1#7#2#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact 


The results that were evaluated by a tool provided by TRECVID with a standard measurements , such as the precision , recall , and F1 score , clearly show that our proposed method significantly outperforms the baseline method and the combination of GCM+EOH obtains the best result .
The results that were evaluated by a tool provided by TRECVID with standard measurement such as precision , recall and F1 score clearly show that our proposed method significantly outperforms the baseline method and the combination of GCM+EOH obtains the best result .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12,13#para -1#13#14#stem -1#17#15#exact -1#14#16#exact -1#15#17#exact -1#30#18#exact -1#16#19#exact -1#18#21#exact -1#19#23#exact -1#20#24#exact -1#21#25#exact -1#22#27#exact -1#23#28#exact -1#24#29#exact -1#25#30#exact -1#26#31#exact -1#27#32#exact -1#28#33#exact -1#29#34#exact -1#34#35#exact -1#31#36#exact -1#32#37#exact -1#33#38#exact -1#39#39#exact -1#35#40#exact -1#36#41#exact -1#37#42#exact -1#38#43#exact -1#40,41#44,45,46#para -1#42#47#exact 


We evaluated the performance of our system with different choices for taking the number of NORM -FRM frames used in training process . //for / by?
We evaluated the performance of our system with different choices for taking the number of NORM -FRM frames used in training process .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact 


Specifically , we selected three sampling rates \MATH , which were \MATH and \MATH .
Specifically , we selected three sampling rates \MATH which are \MATH and \MATH .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#9#exact -1#9#10#syn -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact 


As shown in Figure \REF , the best performance was obtained at a sampling rate of \MATH .
As shown in Figure \REF , the best performance is obtained with the sampling rate of \MATH .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#syn -1#10#10#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact 


In Table \REF , we list the evaluation results when using different features to form the feature vector using the distances between the current frames and their neighbors .
In Table \REF we show the evaluation of using different features for forming the feature vector using distances between current frames and its neighbors .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#4#exact -1#5#6#exact -1#6#7#exact -1#8#9,10#para -1#9#11#exact -1#10#12#exact -1#12#14#stem -1#13#15#exact -1#14#16#exact -1#15#17#exact -1#16#18#exact -1#17#19,20#para -1#18#21#exact -1#19#22,23#para -1#20#24#exact -1#21#25#exact -1#22#26#para -1#23#27#exact -1#24#28#exact 


The first one is GCM , the second one is EOH , and the last one GCM+EOH is a combination of the distances using GCM and the distances using EOH .
The first one is GCM , the second one is EOH and the last one GCM+EOH is combination of distances using GCM and distances using EOH .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17,18#18,19,20,21#para -1#19#22#exact -1#20#23#exact -1#21#24#exact -1#22#25#exact -1#23#26,27#para -1#24#28#exact -1#25#29#exact -1#26#30#exact 


The number of dimensions of the feature vectors using GCM and EOH was 20 , while that of feature vectors using GCM+EOH was 40 .
The number of dimensions of feature vectors using GCM and EOH is 20 while that of feature vectors using GCM+EOH is 40 .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11,12#12,13#para -1#13#15#exact -1#14#16#exact -1#15#17#exact -1#16#18#exact -1#17#19#exact -1#18#20#exact -1#19#21#exact -1#20,21#22,23#para -1#22#24#exact 


We also compared the proposed method with the baseline method that computes the differences in the color histograms between two consecutive frames , and then decides the shot transition by using a predefined threshold .
We also compare the proposed method with the baseline method that computes differences in color histograms between two consecutive frames and then decides a shot transitition by using a predefined threshold .
-1#0#0#exact -1#1#1#exact -1#2#2#stem -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12,13#12,13,14#para -1#14#16#exact -1#15#17#exact -1#16#18#exact -1#17#19#exact -1#18#20#exact -1#19#21#exact -1#20#23#exact -1#21#24#exact -1#22#25#exact -1#24#27#exact -1#26#29#exact -1#27#30#exact -1#28#31#exact -1#29#32#exact -1#30#33#exact -1#31#34#exact 


In Figure \REF , we superimposed our result on the results reported in the shot boundary detection task of TRECVID 2003 .
In Figure \REF , we superimpose our result on the results reported in the shot boundary detection task of TRECVID 2003 .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#stem -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact 


Our system achieves a high precision and recall for the CUT transition and this result is comparable to the third-ranked system .
Our system achieves high precision and recall for the CUT transition and the result is comparable with the third-ranked system .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12,13#13,14#para -1#14#15#exact -1#15#16#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact 


Note that our system is general and has no special treatment for particular shot transitions .
Note that our system is general and has no special treatment for particular shot transition .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#stem -1#15#15#exact 


Many previous shot boundary detectors usually divide the system into sub-systems in which special treatments are proposed to handle different types of shot transitions .
Many previous shot boundary detectors usually divided the system into sub-systems in which special treatments were proposed to handle different types of shot transitions .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6,7#6,7#para -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#16#15,16#para -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact 


Ent-Boost : Boosting Using Entropy Measures
Ent-Boost : Boosting Using Entropy Measure
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#stem 


for Robust Object Detection
for Robust Object Detection
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact 


Recently , boosting has come to be used widely in object detection applications because of its impressive performance in both speed and accuracy .
Recently , boosting is used widely in object detection applications because of its impressive performance in both speed and accuracy .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3,4#para -1#4#5,6,7#para -1#5#8#exact -1#6#9#exact -1#7#10#exact -1#8#11#exact -1#9#12#exact -1#10#13#exact -1#11#14#exact -1#12#15#exact -1#13#16#exact -1#14#17#exact -1#15#18#exact -1#16#19#exact -1#17#20#exact -1#18#21#exact -1#19#22#exact -1#20#23#exact 


However , learning weak classifiers , which is one of the most significant tasks in using boosting , is left to users . //learning / training / identifying / finding?<--Here and throughout , I am not sure that " learning " is the best word choice . If you change it here , it should be changed throughout .
However , learning weak classifiers which is one of the most significant tasks in using boosting is left for users .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5,6,7,8,9#6,7,8,9,10,11#para -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#18#exact -1#17#19#exact -1#19#21#exact -1#20#22#exact -1#10#43#para 


In Discrete AdaBoost , weak classifiers with binary output are too weak to boost when the training data is complex .
In Discrete AdaBoost , weak classifiers with binary output are too weak to boost when the training data is complex .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact 


Meanwhile , determining the appropriate number of bins for weak classifiers learned by Real AdaBoost is a challenging task because small ones might not accurately approximate the real distribution while large ones might cause over-fitting , increase computation time , and waste storage space .
Meanwhile , determining the appropriate number of bins for weak classifiers learned by Real AdaBoost is a challenging task because small one might not well approximate the real distribution while large one might cause over-fitting , increase computation time and waste storage space .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#stem -1#22#22#exact -1#23#23#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#stem -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact -1#37#37#exact -1#38#38#exact -1#39#40#exact -1#40#41#exact -1#41#42#exact -1#42#43#exact -1#43#44#exact 


We have developed Ent-Boost , a novel method for efficiently learning weak classifiers using entropy measures . //method / boosting scheme?
This paper describes a novel method for efficiently learning weak classifiers using entropy measures , called Ent-Boost .
-1#16#3#exact -1#14#4#exact -1#3#5#exact -1#4#6#exact -1#5#7#exact -1#6#8#exact -1#7#9#exact -1#8#10#exact -1#9#11#exact -1#10#12#exact -1#11#13#exact -1#12#14#exact -1#13#15#exact -1#17#16#exact 


Class entropy information is used to automatically estimate the optimal number of bins through discretization .
The class entropy information is used to estimate the optimal number of bins automatically through discretization process .
-1#1#0#lc -1#2#1#exact -1#3#2#exact -1#4#3#exact -1#5#4#exact -1#6#5#exact -1#13#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#14#13#exact -1#15#14#exact -1#17#15#exact 


Then Kullback-Leibler divergence , which is the relative entropy between probability distributions of positive and negative samples , is used to select the best weak classifier in the weak classifier set .
Then Kullback-Leibler divergence which is the relative entropy between probability distributions of positive and negative samples is employed to select the best weak classifier in the weak classifier set .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#18#exact -1#17,18#19,20#para -1#19#21#exact -1#20#22#exact -1#21#23#exact -1#22#24#exact -1#23#25#exact -1#24#26#exact -1#25#27#exact -1#26#28#exact -1#27#29#exact -1#28#30#exact -1#29#31#exact 


Experiments showed that strong classifiers learned by Ent-Boost can achieve good performance and be stored compactly . //[be stored compactly / achieve compact storage?]
Experiments have shown that strong classifiers learned by Ent-Boost can achieve good performance , and have compact storage space .
-1#0#0#exact -1#1,2#1#para -1#3#2#exact -1#4#3#exact -1#5#4#exact -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#14#12#exact -1#17#14#syn -1#19#16#exact -1#16#22#exact 


The results of building a robust face detector using Ent-Boost showed the boosting scheme to be effective .
Results on building a robust face detector are also reported .
-1#0,1#0,1,2#para -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#15#syn -1#10#17#exact 


Building a robust and reliable classifier is always a fundamental problem of pattern recognition .
Building a robust and reliable classifier is always a fundamental problem of pattern recognition .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact 


Several kinds of classifiers , such as neural networks [1] and support vector machines [2] , have been proposed and applied successfully in many object-detection systems .
Several kinds of classifiers , such as Neural Network [1] and Support Vector Machines [2] , have been proposed and applied successfully in many object-detection systems .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#lc -1#8#8#stem -1#9#9#exact -1#10#10#exact -1#11#11#lc -1#12#12#lc -1#13#13#lc -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact 


Boosting [3] and its variants [4] ? [10] have recently gained much attention from researchers because of their excellent performance .
Boosting [3] and its variants [4] ,[5] ,[6] ,[7] ,[8] ,[9] ,[10] have recently gained a lot of attentions from researchers because of its excellent performance .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#12#8#exact -1#13#9#exact -1#14#10#exact -1#15,16#11#para -1#18#12#stem -1#19#13#exact -1#20#14#exact -1#21#15#exact -1#22#16#exact -1#23,24#17,18#para -1#25#19#exact -1#26#20#exact 


In regard to face detection , for example , the methods described in [4] , [5] , and [10] are state-of-the-art in terms of both accuracy and running speed .
In regards to face detection , for example , the methods described in works [4] ,[5] ,[10] represent the state of the art in terms of both high accuracy and running speed .
-1#0#0#exact -1#1#1#stem -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#14#13#exact -1#29#17#exact -1#17#19#syn -1#23,24,25#21,22,23,24#para -1#28#25#exact -1#30#27#exact -1#31#28#exact -1#32#29#exact 


The main idea of boosting is to combine the performance of weak classifiers to form a strong classifier .
The main idea of boosting is to combine the performance of weak classifiers to form a strong classifier .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact 


Typically , a weak classifier is any classifier whose performance is better than random guessing ( i.e. , its error rate is less than 0 .5 ) .
Typically , each weak classifier is any classifier whose performance is better than random guessing ( i.e. , error rate is less than 0 .5 ) .
-1#0#0#exact -1#1#1#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact 


The performances of these weak classifiers are integrated into the final form of a strong classifier through a learning process in which more accurate weak classifiers have larger weights in final voting .
Performances of weak classifiers are integrated into the final form of the strong classifier through a learning process in which more accurate weak classifiers have larger weights in final voting .
-1#11#0#lc -1#0#1#lc -1#1#2#exact -1#2#4#exact -1#3#5#exact -1#4#6#exact -1#5#7#exact -1#6#8#exact -1#7,8,9#9,10,11,12#para -1#15#13#exact -1#12#14#exact -1#13#15#exact -1#14#16#exact -1#16#18#exact -1#17#19#exact -1#18#20#exact -1#19#21#exact -1#20#22#exact -1#21#23#exact -1#22#24#exact -1#23#25#exact -1#24#26#exact -1#25#27#exact -1#26#28#exact -1#27#29#exact -1#28#30#exact -1#29#31#exact -1#30#32#exact 


In practical problems , designing and learning weak classifiers leave practitioners with two main challenges : computational evaluation and discriminant power .
In practical problems , designing and learning weak classifiers are left for practitioners with two main challenges : computational evaluation and discriminant power .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#10#9#syn -1#12#10#exact -1#13#11#exact -1#14#12#exact -1#15#13#exact -1#16#14#exact -1#17#15#exact -1#18#16#exact -1#19#17#exact -1#20#18#exact -1#21#19#exact -1#22#20#exact -1#23#21#exact 


Generally , for efficient computation , the dimensions of the input space of weak classifiers are reduced be to much smaller than those of the strong classifier[s?] .
Generally , for efficient computation , the dimension of the input space of weak classifiers is reduced to much lower than that of the strong classifier .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7,8#7,8#para -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#syn -1#16#16#exact -1#17#18#exact -1#18#19#exact -1#19,20#20,21#para -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#26#27#exact 


In object-detection frameworks [4] , [5] , [11] ? [13] , weak classifiers are usually constructed from one or several features .
In object-detection frameworks [4] ,[5] ,[11] ,[12] ,[13] weak classifiers are usually constructed from one or several features .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#8#11#exact -1#9#12#exact -1#10#13#exact -1#11#14#exact -1#12#15#exact -1#13#16#exact -1#14#17#exact -1#15#18#exact -1#16#19#exact -1#17#20#exact -1#18#21#exact 


For example , a weak classifier can be constructed from one Haar wavelet feature that is evaluated very rapidly through an integral image [4] .
For example , a weak classifier can be constructed from one Haar wavelet feature that is evaluated very rapidly through an integral image [4] .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact 


Given a feature type , choosing the suitable way to form a weak classifier that balances efficiency and computation is still an open problem [14] .
Given a feature type , choosing the suitable way to form a weak classifier that balance efficiency and computation is still a open problem [14] .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#stem -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#22#21,22#para -1#23#23#exact -1#24#24#exact -1#25#25#exact 


Two key trends exist for seeking the most discriminant weak classifier .
There are two key trends for seeking the most discriminant weak classifier .
-1#2#0#lc -1#3#1#exact -1#4#2#exact -1#0,1#3#para -1#5#4#exact -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact 


The first trend is dealing with the problem of how to design features for best representing the target object .
The first trend is dealing with the problem of how to design features for best representation of the target object .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6,7,8,9#6,7#para -1#16#8#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact 


Besides Haar wavelet features [4] , Gabor wavelets [5] , edge orientation histograms ( EOH ) [11] , orientation dominants [12] , scale invariant feature transform ( SIFT )-based high-level features [13] , and local binary patterns ( LBP ) [15] have also been used .
Besides Haar wavelet features [4] , Gabor wavelets [5] , edge orientation histogram ( EOH ) [11] , orientation dominants [12] , scale invariant feature transform ( SIFT )-based-high-level features [13] and local binary pattern ( LBP ) [15] have also been used .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#stem -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#29#30#exact -1#30#31#exact -1#31#33#exact -1#32#34#exact -1#33#35#exact -1#34#36#stem -1#35#37#exact -1#36#38#exact -1#37#39#exact -1#38#40#exact -1#39#41#exact -1#40#42#exact -1#41#43#exact -1#42#44#exact -1#43#45#exact 


The second trend is studying how to optimally select the best weak classifier from a weak classifier set .
The second trend is studying how to optimally select the best weak classifier from a weak classifier set .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact 


In Discrete AdaBoost [16] , weak classifiers are threshold-functions whose output is restricted to binary data. //[data / values??I think you need a noun here?binary what?]
In Discrete AdaBoost [16] , weak classifiers are threshold-functions whose the output is restricted to binary .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact 


This leads weak classifiers to be too weak to boost when handling complex data sets .
This leads weak classifiers are too weak to boost when handling complex data sets .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#7#4#exact -1#4,5#5,6#para -1#6#7#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact 


For example , in later layers of the cascaded face classifiers [4] , the error rate of weak classifiers is between 0 .4 and 0 .5 .
For example , in later layers of the cascaded face classifiers [4] , the error rate of weak classifiers is between 0 .4 and 0 .5 .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact 


Meanwhile , in Real AdaBoost [3] , a generalized version of Discrete AdaBoost , weak classifiers are piece-wise functions whose output is a real value representing the confidence-rated prediction .
Meanwhile , in Real AdaBoost [3] , a generalized version of Discrete AdaBoost , weak classifiers are piece-wise functions whose the output is a real value representing the confidence-rated prediction .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#21#20#exact -1#22#21#exact -1#23#22#exact -1#24#23#exact -1#25#24#exact -1#26#25#exact -1#27#26#exact -1#28#27#exact -1#29#28#exact -1#30#29#exact 


Normally , to construct such weak classifiers , one splits the input space \MATH into non-overlapping blocks ( or subspaces ) \MATH , \MATH , . . . , \MATH so that the predictions of the weak classifier are the same for all instances falling into the same block .
Normally , to construct such weak classifiers , one splits the input space \MATH into non-overlapping blocks ( or subspaces ) \MATH , \MATH , . . . , \MATH so that the predictions of the weak classifier are the same for all instances falling into the same block .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#33,34#32,33,34,35#para -1#36#36#exact -1#37#37#exact -1#38#38#exact -1#39#39#exact -1#40#40#exact -1#41#41#exact -1#42#42#exact -1#43#43#exact -1#44#44#exact -1#45#45#exact -1#46#46#exact -1#47#47#exact -1#48#48#exact -1#49#49#exact 


In the case of one-feature-based weak classifiers , this is equivalent to dividing the real line into intervals .
In the case of one-feature-based weak classifiers , this is equivalent to dividing the real line into intervals .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact 


Typically , most current works [5] , [6] , [8] , [10] , [17] split the data into \MATH bins that are equal in width . This method suffers from the following limitations : //[works / systems?]
Typically , most current works [5] ,[17] ,[6] ,[8] ,[10] split the data into \MATH bins that are equal width which suffers from following limitations :
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#10#14#exact -1#11#15#exact -1#12#16#exact -1#13#17#exact -1#14#18#exact -1#15#19#exact -1#16#20#exact -1#17#21#exact -1#18#22#exact -1#19#24#exact -1#21#28#exact -1#22#29#exact -1#23#30,31#para -1#24#32#exact -1#25#33#exact 


-The way to choose the appropriate number of bins is undetermined .
-Choosing the appropriate number of bins is undetermined .
-1#1#4#exact -1#2#5#exact -1#3#6#exact -1#4#7#exact -1#5#8#exact -1#6#9#exact -1#7#10#exact -1#8#11#exact 


Normally , it has been done by trial and error [6] , [17] ? a tedious task .
Normally , it has been done by trials and errors [6] ,[17] - a tedious task .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7,8#7,8#para -1#9#9#stem -1#10#10#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact 


In the training cascade of classifiers [6] , [17] , when the complexity of the training data changes over time , using the same number of bins for training every layer is not optimal .
In the training cascade of classifiers [6] ,[17] , when the complexity of the training data changes over time , using the same number of bins for training every layers is not optimal .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#19#7#exact -1#8#9#exact -1#9#10#exact -1#10,11,12,13#11,12,13#para -1#21#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#20#21#exact -1#22,23,24#22,23,24,25#para -1#25#26#exact -1#26#27#exact -1#27#28#exact -1#28#29#exact -1#29#30#stem -1#30#31#exact -1#31#32#exact -1#32#33#exact -1#33#34#exact 


-Choosing a large number of bins might cause over-fitting because of outliers in the case of noisy data [18] .
-Choosing a large number of bins might cause over-fitting because of outliers in the case of noisy data [18] .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact 


Furthermore , it might lengthen computation and training time and waste storage space , which is critical in applications with limited resources , for example , face detection on mobile phones .
Furthermore it might increase computation and training time , waste storage space which is critical in applications with limited resources , for example , face detection on mobile phones .
-1#0#0#exact -1#8#1#exact -1#1#2#exact -1#2#3#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#20#13#exact -1#12#14#exact -1#13#15#exact -1#14#16#exact -1#15#17#exact -1#16#18#exact -1#17#19#exact -1#18#20#exact -1#19#21#exact -1#23#22#exact -1#21#23#exact -1#22#24#exact -1#24#26#exact -1#25#27#exact -1#26#28#exact -1#27#29#exact -1#28#30#exact -1#29#31#exact 


Choosing a small number of bins , however , might not accurately approximate the real densities of the data distribution and could influence the selection of the best weak classifier .
Meanwhile choosing a small number of bins might not well approximate the real densities of the data distribution and thus influence selection of the best weak classifier .
-1#1#0#lc -1#2#1#exact -1#3#2#exact -1#4#3#exact -1#5#4#exact -1#6#5#exact -1#7#9#exact -1#8#10#exact -1#10#12#exact -1#11#13#exact -1#12#14#exact -1#13#15#exact -1#14#16#exact -1#15#17#exact -1#16#18#exact -1#17#19#exact -1#18#20#exact -1#20#22#exact -1#21,22#23,24,25#para -1#23#26#exact -1#24#27#exact -1#25#28#exact -1#26#29#exact -1#27#30#exact 


A deterministic method is therefore needed to automatically and optimally choose the number of bins .
It is therefore necessary to have a deterministic method to choose this number of bins automatically and optimally .
-1#6#0#lc -1#7#1#exact -1#8#2#exact -1#1#3#exact -1#2#4#exact -1#3,4#5,6#para -1#15#7#exact -1#16#8#exact -1#17#9#exact -1#10#10#exact -1#11,12#11,12#para -1#13#13#exact -1#14#14#exact -1#18#15#exact 


This problem can be formulated as a discretization problem in which subspace boundaries are found by some criteria . //[some criteria?This sounds a bit vague . Could you be more specific?]
This problem can be formulated as a discretization problem in which subspace boundaries are found by some criteria .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact 


Among discretization methods , the entropy-based method [19] has been proved most efficient . Hence , we propose using it to solve the problem .
Among discretization methods , the entropy based method [19] has been proved most efficiently ; hence , we propose using it to solve the problem .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#stem -1#25#13#exact -1#15#14#lc -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#22,23,24#20,21,22,23#para 


The entropy-based discretization method is an algorithm that automatically selects appropriate thresholds to split feature values into optimal bins by using entropy measurement .
The entropy based discretization method is an algorithm that automatically selects appropriate thresholds to split feature values into optimal bins by using entropy measurement .
-1#0#0#exact -1#3#2#exact -1#4#3#exact -1#5#4#exact -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact -1#23#22#exact -1#24#23#exact 


It is a supervised discretization method that takes into account class information and data distribution , so it is generic and can be applied to any kind of input data .
It is a supervised discretization method which takes into account class information and data distribution , so it is generic and can be applied for any kinds of input data .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6,7#6,7#para -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#25#24,25#para -1#26,27#26,27#para -1#28#28#exact -1#29#29#exact -1#30#30#exact 


Furthermore , many studies have shown that the discretization process might help to improve performance in induction tasks [18] and it can also work with a weighted data distribution . Therefore , it is most appropriate for boosting-based methods .
Furthermore , many studies have been shown that discretization process might help to improve performance in induction tasks [18] , it can also work with a weighted data distribution ; therefore , it is most appropriate for boosting-based methods .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#6#5#exact -1#7#6#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#39#29#exact -1#30#30#lc -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact -1#37#37#exact -1#38#38#exact 


Besides learning weak classifiers , selecting the best weak classifier in the large set of weak classifiers in each round of boosting is also important .
Besides learning weak classifiers , selecting the best weak classifier in the large weak classifier set in each round of boosting is also important .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#15#13#exact -1#19#14#exact -1#13#15#exact -1#14#16#stem -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact 


Following the method used in [5] , it is done by choosing the weak classifier that maximizes Kullback-Leibler ( KL ) divergence between two distributions of positive and negative samples . // [used / proposed?]
Adopting [5] , it is done by choosing the weak classifier that maximizes Kullback-Leibler ( KL ) divergence between two distributions of positive and negative samples .
-1#8#1#exact -1#1#5#exact -1#2#6#exact -1#3#7#exact -1#4#8#exact -1#5#9#exact -1#6#10#exact -1#7#11#exact -1#9#12,13#para -1#10#14#exact -1#11#15#exact -1#12#16#exact -1#13#17#exact -1#14#18#exact -1#15#19#exact -1#16#20#exact -1#17#21#exact -1#18#22#exact -1#19#23#exact -1#20#24#exact -1#21#25#exact -1#22#26#exact -1#23#27#exact -1#24#28#exact -1#25#29#exact -1#26#30#exact 


The integration of the entropy-based discretization process and optimal weak classifier selection into the current boosting framework formed a new variant of AdaBoost , called Ent-Boost .
The integration of entropy-based discretization process and optimal weak classifier selection into the current boosting framework forms a new variant of AdaBoost , called Ent-Boost .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#12#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#13#13,14#para -1#14#15#exact -1#15#16#exact -1#16#17#stem -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact 


Experiments on building a robust face detector have shown the effectiveness of this new boosting scheme .
Experiments on building a robust face detector have shown effectiveness of this new boosting scheme .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9,10#9,10,11#para -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact 


Originally , Discrete AdaBoost , proposed by Freund and Schapire [16] , was a learning method of combining weak classifiers to form a strong classier .
Originally , Discrete AdaBoost proposed by Freund and Schapire [16] is a learning method of combining weak classifiers to a strong classier .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10,11#12,13#para -1#12#14#exact -1#13#15#exact -1#14#16#exact -1#15#17#exact -1#16#18#exact -1#17#19#exact -1#18#20#exact -1#19#22#exact -1#20#23#exact -1#21#24#exact -1#22#25#exact 


Given a training set \MATH , where \MATH and \MATH , a weak classifier \MATH has the form \MATH .
Given a training set \MATH where \MATH and \MATH , a weak classifier \MATH has the form \MATH .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#9#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact 


Normally , a weak classifier is any classifier whose performance measured by error rate is less than 0 .5 .
Normally , a weak classifier is any classifier whose performance measured by error rate is less than 0 .5 .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact 


Therefore , in many applications [4] , [5] , [7] , it is simplified by associating with one feature \MATH .
Therefore , in many applications [4] ,[5] ,[7] , it is simplified by associating to one feature \MATH .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#8#6#exact -1#9#11#exact -1#10#12#exact -1#11#13#exact -1#12#14#exact -1#13#15#exact -1#15#17#exact -1#16#18#exact -1#17#19#exact -1#18#20#exact 


Through boosting processing , weak classifiers are combined into a strong classifier \MATH where \MATH are values that measure the performance of the selected weak classifier .
Through boosting processing , weak classifiers are combined into a strong classifier \MATH where \MATH are values that measure performance of the selected weak classifier .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19,20,21,22#para -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact 


In the boosting process , a distribution \MATH or set of weights over the training samples are maintained and updated so that subsequent weak classifiers focus on the strong-classified samples . //[hard / strong?]
In boosting process , a distribution \MATH or set of weights over the training samples are maintained and updated so that subsequent weak classifiers focus on the hard classified samples .
-1#0#0#exact -1#12#1#exact -1#1#2#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#26#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#29#29#exact -1#30#30#exact 


Real AdaBoost [3] is a generalized version of Discrete AdaBoost in that weak classifiers are real-valued functions instead of binary ones and \MATH is found numerically instead of by predescription . //[This method also involves?NOTE : A method cannot propose something .
Real AdaBoost [3] is a generalized version of Discrete AdaBoost in that weak classifiers are real-valued functions instead of binary ones and \MATH is found numerically in general instead of predescription .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#28#26#exact -1#29#27#exact -1#30#29#exact -1#31#30#exact 


Do you mean that the creators of this system proposed this?] designing weak classifiers that partition the input space into subspaces so that the predictions are unique in each subspace .
This method also proposes designing weak classifiers that partition the input space into subspaces so that its predictions are unique in each subspace .
-1#18#0,1#para -1#15#3#exact -1#9#4#exact -1#0#7#lc -1#4#11#exact -1#5#12#exact -1#6#13#exact -1#7#14#exact -1#8#15#exact -1#10#17#exact -1#11#18#exact -1#12#19#exact -1#13#20#exact -1#14#21#exact -1#16,17#23,24#para -1#19#25,26#para -1#20#27#exact -1#21#28#exact -1#22#29#exact -1#23#30#exact 


Such weak classifiers are used widely in current state-of-the-art object detection systems [5] , [8] , [17] .
Such weak classifiers are used widely in current state of the art object detection systems [5] ,[17] ,[8] .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#12#9#exact -1#13#10#exact -1#14#11#exact -1#15#12#exact -1#18#17#exact 


Suppose that \MATH , \MATH , . . . , \MATH is a partition of the domain \MATH on which such weak classifiers $h$ are defined .
Suppose that \MATH , \MATH , . . . , \MATH is a partition of the domain \MATH on which such weak classifiers $h$ are defined .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact 


The prediction of \MATH depends only on which block \MATH a given instance falls into .
The prediction of \MATH depends only on which block \MATH a given instance falls into .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact 


On the other hand , \MATH for all \MATH .
On the other hand , \MATH for all \MATH .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact 


In the case of one-feature-based weak classifier , the histograms of positive and negative samples are computed as follows \MATH where \MATH .
In the case of one-feature-based weak classifiers , the histograms of positive and negative samples are computed as follows \MATH where \MATH .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#stem -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact 


It is proven in [3] that the most appropriate choice for the prediction of the weak classifier on block \MATH to maximize the margin is \MATH where \MATH is a smoothed value in order to handle cases in which \MATH is very small or even zero .
It is proved in [3] that the most appropriate choice for the prediction of the weak classifier on block \MATH to maximize the margin is \MATH where \MATH is a smoothed value in order to handle cases that \MATH is very small or even zero .
-1#0#0#exact -1#1#1#exact -1#2#2#syn -1#3#3#exact -1#4#4#exact -1#6,7,8#5,6,7,8#para -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact -1#38#39#exact -1#39#40#exact -1#40#41#exact -1#41#42#exact -1#42#43#exact -1#43#44#exact -1#44#45#exact -1#45#46#exact 


A summary of the Real AdaBoost algorithm is given in Algorithm 1 .
A summary of the Real AdaBoost algorithm is given in Algorithm 1 .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact 


Real AdaBoost is easy to implement , but in practical applications , designing and learning weak classifiers depend on specific applications .
Real AdaBoost is easy to implement ; however , in practical applications , designing and learning weak classifiers depend on specific applications .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#8#6#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact 


In such face detection systems as [those described in?] [5] , [6] , [8] , and [17] , weak classifiers are usually associated with one feature .
In such face detection systems as [5] ,[6] ,[17] ,[8] , weak classifiers are usually associated with one feature .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#9#exact -1#10#10#exact -1#11#18#exact -1#12#19#exact -1#13#20#exact -1#14#21#exact -1#15#22#exact -1#16#23#exact -1#17#24#exact -1#18#25#exact -1#19#26#exact 


With a very large number of available features ? hundreds of thousands ? [there are many candidates from which to / many choices must be made to?] select one weak classifier for each round of boosting .
With a very large number of available features , hundreds of thousands , there are a lot of choices to choose one weak classifier for each round of boosting .
-1#0#0#exact -1#1#1#exact -1#2,3,4,5#2,3,4#para -1#10#5#exact -1#6#6#exact -1#7#7#exact -1#9#9#exact -1#17#10#exact -1#11#11#exact -1#14#14#exact -1#19#19#exact -1#18#22#exact -1#20#27#syn -1#21#28#exact -1#22#29#exact -1#23#30#exact -1#24#31#exact -1#25#32#exact -1#26#33#exact -1#27#34#exact -1#28#35#exact -1#29#36#exact 


Optimally selecting the suitable weak classifier makes the final strong classifier more robust and efficient .
Generally , optimally selecting the suitable weak classifier will make the final strong classifier more robust and efficient .
-1#2#0#lc -1#3#1#exact -1#4#2#exact -1#5#3#exact -1#6#4#exact -1#7#5#exact -1#9#6#stem -1#10#7#exact -1#11#8#exact -1#12#9#exact -1#13#10#exact -1#14#11#exact -1#15#12#exact -1#16#13#exact -1#17#14#exact -1#18#15#exact 


Furthermore , optimal selection can reduce the number of boosting rounds , thus directly shortening training time .
Furthermore , it can reduce the number of boosting rounds that directly shorten training time .
-1#0#0#exact -1#1#1#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#11#13#exact -1#12#14#stem -1#13#15#exact -1#14#16#exact -1#15#17#exact 


Most studies so far have been focused on how to measure the discriminant power of weak classifiers in order to select the best weak classifier .
So far , most current studies have been focused on how to measure the discriminant power of weak classifiers in order to select the best weak classifier .
-1#3#0#lc -1#5#1#exact -1#0#2#lc -1#1#3#exact -1#6#4#exact -1#7#5#exact -1#8#6#exact -1#9#7#exact -1#10#8#exact -1#11#9#exact -1#12#10#exact -1#13#11#exact -1#14#12#exact -1#15#13#exact -1#16#14#exact -1#17#15#exact -1#18#16#exact -1#19#17#exact -1#20#18#exact -1#21#19#exact -1#22#20#exact -1#23#21#exact -1#24#22#exact -1#25#23#exact -1#26#24#exact -1#27#25#exact 


Many measurements have been proposed , for example , Bhattacharyya distance [6] , Kullback-Leibler divergence [5] , and recently , Jensen-Shannon divergence [8] and mutual information [9] ( Table 1 ) .
Many measurements have been proposed ; for example , Bhattacharyya distance [6] , Kullback-Leibler divergence [5] and , recently , Jensen-Shannon divergence [8] and mutual information [9] ( cf . Table 1 .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#8#5#exact -1#6#6#exact -1#7#7#exact -1#12#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#17#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#19#16#exact -1#16#17#exact -1#18#18#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#30#28#exact -1#31#29#exact -1#29#31#exact 


Meanwhile , few studies have been made on efficiently partitioning subspaces .
Meanwhile , few studies have been made for efficiently partitioning subspaces .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact 


As shown in Figure 1 , using a fixed number of bins , strong classifiers trained by the above measures give similar performances . //[measurements / measures?]
As shown in Figure 1 , using a fixed number of bins , strong classifiers trained by above measurements give comparable performance .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#18#exact -1#18#19#stem -1#19#20#exact -1#20#21#para -1#21#22#stem -1#22#23#exact 


However , as section 5 will show , these performances are affected dramatically if different subspace splitting methods are used .
However , it will be shown in section 5 , these performances are affected seriously if different subspace splitting methods are used .
-1#0#0#exact -1#1#1#exact -1#7#3#exact -1#8#4#exact -1#3#5#exact -1#4,5#6#para -1#9#7#exact -1#10#8#exact -1#11#9#exact -1#12#10#exact -1#13#11#exact -1#14#12,13#para -1#16#14#exact -1#17#15#exact -1#18#16#exact -1#19#17#exact -1#20#18#exact -1#21#19#exact -1#22#20#exact 


The proposed boosting scheme , Ent-Boost , is an integration of adaptive entropy-based subspace splitting and the symmetric KL divergence-based weak classifier selection .
The proposed boosting scheme Ent-Boost is an integration of adaptive entropy-based subspace splitting and the symmetric KL divergence-based weak classifier selection .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#5#exact -1#5#7#exact -1#6#8#exact -1#7#9#exact -1#8#10#exact -1#9#11#exact -1#10#12#exact -1#11#13#exact -1#12#14#exact -1#13#15#exact -1#14#16#exact -1#15#17#exact -1#16#18#exact -1#17#19#exact -1#18#20#exact -1#19#21#exact -1#20#22#exact -1#21#23#exact 


In Ent-Boost , each weak classifier is constructed from one feature and trained on weighted training samples similar to [those used in?] Real AdaBoost .
In Ent-Boost , each weak classifier is constructed from one feature and trained on the weighted training samples similar to Real AdaBoost .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#22#exact -1#21#23#exact -1#22#24#exact 


However , instead of using the equal-width binning method used in Real AdaBoost [6] , [17] which has a hard time predicting the suitable number of bins in advance , we use the entropy-based discretization method [19] to split the input space into subspaces .
However , instead of using equal-width binning method like Real AdaBoost [6] ,[17] which is hard to know the suitable number of bins in advance , we use entropy-based discretization method [19] to split the input space into subspaces .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#18#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#27#9,10#para -1#9#11#exact -1#10#12#exact -1#11#13#exact -1#25#14#exact -1#13#16#exact -1#14#17,18#para -1#15#19#exact -1#34#22#exact -1#19#23#exact -1#20#24#exact -1#21#25#exact -1#22#26#exact -1#23#27#exact -1#24#28#exact -1#26#30#exact -1#35#31#para -1#28#33#exact -1#29#34#exact -1#30#35#exact -1#31#36#exact -1#32#37#exact -1#33#38#exact -1#36#41#exact -1#37#42#exact -1#38#43#exact -1#39#44#exact 


This subspace splitting process is totally automatic ; the stopping criteria of the splitting process are determined using minimum description length principles ( MDLP ) . This process will be described in greater detail in the next section .
This subspace splitting process is totally automatically in which the stopping criteria of splitting process is determined through using Minimum Description Length Principles ( MDLP ) ( see the next section ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#stem -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#28#12#exact -1#13#13#exact -1#14#14#exact -1#15,16#15,16#para -1#18#17#exact -1#19#18#lc -1#20#19#lc -1#21#20#lc -1#22#21#lc -1#23#22#exact -1#24#23#exact -1#25#24#exact -1#32#25#exact -1#7#31#exact -1#29#34,35,36#para -1#30#37#exact 


To select the best weak classifier from the input weak classifier set , we use symmetric KL divergence as in [5] , which measures the distance between two distributions as follows : \MATH where \MATH and \MATH are probability distributions of a discrete random variable .
To select the best weak classifier from the input weak classifier set , we use symmetric KL divergence as in [5] which measures the distance between two distributions as follows : \MATH where \MATH and \MATH are probability distributions of a discrete random variable .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact -1#28#29#exact -1#29#30#exact -1#30#31#exact -1#31#32#exact -1#32#33#exact -1#33#34#exact -1#34#35#exact -1#35#36#exact -1#36#37#exact -1#37#38#exact -1#38#39#exact -1#39#40#exact -1#40#41#exact -1#41#42#exact -1#42#43#exact -1#43#44#exact -1#44#45#exact 


This formula can be rewritten in entropy terms : \MATH or \MATH where \MATH and \MATH are entropy and \MATH is cross entropy of \MATH and \MATH .
This formula can be rewritten in entropy terms : \MATH or \MATH where \MATH and \MATH are entropy , and \MATH is cross entropy of \MATH and \MATH .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact -1#23#22#exact -1#24#23#exact -1#25#24#exact -1#26#25#exact -1#27#26#exact -1#28#27#exact 


The outline of Ent-Boost is shown in Algorithm 2 .
The outline of Ent-Boost is shown in Algorithm 2 .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact 


Note that the discretization process is performed in every round of boosting to adapt to new distributions of samples .
Note that the discretization process is performed in every round of boosting to adapt to new distributions of samples .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#13,14,15#12,13,14,15#para -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact 


As a result , the number of intervals of the selected weak classifier varies . //[classifier varies / classifiers vary?]
As a result , the number of intervals of selected weak classifier varies .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact 


This is different from previous methods , which fix the number of equal-width intervals in advance .
This is different from previous methods that fix the number of equal-width intervals in advance .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact 


This section briefly describes automatic subspace splitting using entropy-based discretization .
This section gives a brief introduction on automatic subspace splitting using entropy-based discretization .
-1#0#0#exact -1#1#1#exact -1#3,4#2#para -1#7#4#exact -1#8#5#exact -1#9#6#exact -1#10#7#exact -1#11#8#exact -1#12#9#exact -1#13#10#exact 


Discretization is a quantizing process that converts continuous values into discrete values . It typically consists of four steps [18] .
Basically , discretization is a quantizing process that converts continuous values into discrete values ; it typically consists of four steps [18] :
-1#2#0#lc -1#3#1#exact -1#4#2#exact -1#5#3#exact -1#6#4#exact -1#7#5#exact -1#8#6#exact -1#9#7#exact -1#10#8#exact -1#11#9#exact -1#12#10#exact -1#13#11#exact -1#15#13#lc -1#16#14#exact -1#17#15#exact -1#18#16#exact -1#19#17#exact -1#20#18#exact -1#21#19#exact 


Step 1 : Sorting the continuous values of the feature to be discretized .
Step 1 : Sorting the continuous values of the feature to be discretized .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact 


Step 2 : Evaluating candidate cut-points and selecting the best cut-point for splitting .
Step 2 : valuating candidate cut-points and selecting the best cut-point for splitting .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#syn -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact 


A cut-point is a threshold value that divides the range of continuous values into two intervals ; one interval is less than or equal to the threshold , and the other interval is greater than the threshold .
A cut-point is a threshold value that divides the range of continuous values into two intervals ; one interval is less than or equal to the threshold , and the other interval is greater than the threshold .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#33,34,35#32,33,34,35#para -1#36#36#exact -1#37#37#exact 


Step 3 : Splitting the data into two intervals using the cut-point selected in step 2 .
Step 3 : Splitting the data into two intervals using the selected cut-point in step 2 .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#12#11#exact -1#11#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact 


Step 4 : Continuing discretization with each interval until a stopping criteria is satisfied .
Step 4 : Continuing discretization with each interval until a stopping criteria is satisfied .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact 


The stopping criteria are usually selected by considering a trade-off between lower arity ( the number of intervals or the number of bins ) and its effect on the accuracy of classification tasks .
The stopping criteria are usually selected according to a trade-off between lower arity ( the number of intervals or the number of bins ) and its effect on the accuracy of classification tasks .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27,28,29,30#27,28,29#para -1#31#30,31#para -1#32#32#exact -1#33#33#exact 


A higher arity can make the complicate the understanding of an attribute , while a very low arity may damage predictive accuracy .
A higher arity can make the understanding of an attribute more difficult , while a very low arity may affect predictive accuracy negatively .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#11#6,7#para -1#6#8#exact -1#7#9#exact -1#8#10#exact -1#9#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#20#20#exact -1#21#21#exact -1#23#22#exact 


Given a set \MATH of sorted continuous values \MATH , candidate cut-points are usually selected as mid-points of every successive pair of \MATH .
Given a set \MATH of sorted continuous values \MATH , candidate cut-points are usually selected as mid-points of every successive pair of \MATH .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact 


On the other hand , candidate cut-points are \MATH .
On the other hand , candidate cut-points are \MATH .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact 


For each cut-point \MATH that splits set \MATH into two subsets \MATH , the class entropy of a subset \MATH is defined as \MATH where \MATH is the number of classes \MATH , and \MATH is the proportion of examples in \MATH that have class \MATH .
For each cut-point \MATH that splits set \MATH into two subsets \MATH , the class entropy of a subset \MATH is defined as \MATH where \MATH is the number of classes \MATH , and \MATH is the proportion of examples in \MATH that have class \MATH .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#36,37,38#35,36,37,38#para -1#39#39#exact -1#40#40#exact -1#41#41#exact -1#42#42#exact -1#43#43#exact -1#44#44#exact -1#45#45#exact -1#46#46#exact 


To evaluate the resulting class entropy after set \MATH is partitioned into two sets \MATH and \MATH , the class-information entropy of the partition induced by cut-point T is defined by taking the weighted average of their resulting class entropies \MATH he best cut-point selected in step 2 is the cut-point \MATH for which \MATH is minimal amongst all the candidate cut-points .
To evaluate the resulting class entropy after set \MATH is partitioned into two sets \MATH and \MATH , the class-information entropy of the partition induced by cut-point T is defined by taking the weighted average of their resulting class entropies \MATH he best cut-point selected in step 2 is the cut-point \MATH for which \MATH is minimal amongst all the candidate cut-points .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact -1#37#37#exact -1#38#38#exact -1#39#39#exact -1#40#40#exact -1#41#41#exact -1#42#42#exact -1#43#43#exact -1#44#44#exact -1#45#45#exact -1#46#46#exact -1#47#47#exact -1#48#48#exact -1#49#49#exact -1#50#50#exact -1#51#51#exact -1#52#52#exact -1#53#53#exact -1#54#54#exact -1#55#55#exact -1#56#56#exact -1#57#57#exact -1#58#58#exact -1#59#59#exact -1#60#60#exact -1#61#61#exact -1#62#62#exact 


Given set S and a potential binary partition \MATH , specified on S by the given cut-point \MATH , a stopping criteria is used to decide whether or not this partition should be accepted .
Given set S and a potential binary partition , \MATH , specified on S by the given cut-point \MATH , a stopping criteria is used to decide whether or not this partition should be accepted .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact -1#23#22#exact -1#24#23#exact -1#25,26#24,25,26,27#para -1#29#28#exact -1#30#29#exact -1#31#30#exact -1#32#31#exact -1#33#32#exact -1#34#33#exact -1#35#34#exact 


If the answer is YES , the discretization will continue with each partition given by \MATH ; otherwise , the discretization process will stop .
If the answer is YES , the discretization will continue with each partition given by \MATH ; otherwise , the discretization process will stop .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact 


Suppose \MATH is the probability of a \MATH answer , and \MATH is the probability of a \MATH answer .
Suppose \MATH is the probability of a \MATH answer , and \MATH is the probability of the \MATH answer .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#13,14,15,16#3,4,5,6#para -1#17#7#exact -1#18#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#3#13#exact -1#4#14#exact -1#5#15#exact -1#6#16#exact -1#7#17#exact -1#8#18#exact -1#19#19#exact 


Partition \MATH is only accepted if \MATH .
Partition \MATH is only accepted if \MATH .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact 


However , in practice , there is no easy way to estimate these probabilities directly .
However , in practice , there is no easy way to estimate these probabilities directly .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact 


Instead , Fayyad and Irani [19] proposed using MDLP to indirectly estimate them .
Instead , Fayyad and Irani [19] proposed using MDLP to indirectly estimate them .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact 


The minimum description length of an object is defined as the minimum number of bits required to uniquely specify that object out of the universe of all objects .
Originally , the minimum description length of an object is defined as the minimum number of bits required to uniquely specify that object out of the universe of all objects .
-1#2#0#lc -1#3#1#exact -1#4#2#exact -1#5#3#exact -1#6#4#exact -1#7#5#exact -1#8#6#exact -1#9#7#exact -1#10#8#exact -1#11#9#exact -1#12,13#10,11,12,13#para -1#16#14#exact -1#17#15#exact -1#18#16#exact -1#19#17#exact -1#20#18#exact -1#21#19#exact -1#22#20#exact -1#23#21#exact -1#24#22#exact -1#25#23#exact -1#26#24#exact -1#27#25#exact -1#28#26#exact -1#29#27#exact -1#30#28#exact 


To employ MDLP in choosing the stopping criteria , Fayyad and Irani formulated the above problem as a communication problem between a sender and a receiver .
To employ MDLP in choosing the stopping criteria , Fayyad and Irani formulated the above problem as a communication problem between a sender and a receiver .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact 


It is assumed that the sender has the entire set of training examples , while the receiver has the examples without their class labels .
It is assumed that the sender has the entire set of training examples , while the receiver has the examples without their class labels .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact 


The sender needs to convey needed information for the proper class labeling of the example set to the receiver .
The sender needs to convey to proper class labeling of the example set to the receiver .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#14#8#exact -1#6#9#exact -1#7#10#exact -1#8#11#exact -1#9#12#exact -1#10#13#exact -1#11#14#exact -1#12#15#exact -1#13#16#exact -1#15#18#exact -1#16#19#exact 


It says that the partition induced by a cut-point is accepted if and only if the length of the message required to be sent before the partition is more than the length of the message required to be sent after the partition .
It says that the partition induced by a cut-point is accepted if and only if the length of the message required to send before partition is more than the length of the message required to send after partition .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15,16,17,18#15,16,17#para -1#28#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22,23#para -1#23#24#exact -1#31#25#exact -1#24#26#exact -1#25#27#exact -1#26#28#exact -1#27#29#exact -1#29,30#30,31,32,33#para -1#32#34#exact -1#33#35#exact -1#34#36#exact -1#35#37,38#para -1#36#39#exact -1#37#40,41#para -1#38#42#exact 


By inferring from coding hypothesis , the stopping criteria is defined as follows : MDLP Criteria :A partition induced by cut-point \MATH for a set \MATH of \MATH examples is accepted iff :\MATH
By inferring from coding hypothesis , the stopping criteria is defined as follows : MDLP Criteria :A partition induced by cut-point \MATH for a set \MATH of \MATH examples is accepted iff :\MATH
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact 


where \MATH and \MATH where\MATH is the number of classes in \MATH Extensive experiments [18] , [19] recommended that this method should be the first choice for variable discretization because it gives a small number of cut-points while maintaining consistency .
where \MATH and \MATH \MATH is the number of classes in \MATH Extensive experiments [19] ,[18] recommended that this method should be the first choice for variable discretization because it gives small number of cut-points while maintaining consistency .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact -1#28#29#exact -1#29#30#exact -1#30#31#exact -1#31#32,33#para -1#32#34#exact -1#33#35#exact -1#34#36#exact -1#35#37#exact -1#36#38#exact -1#37#39#exact -1#38#40#exact 


For our experiments , face and non-face patterns were of size 24x24 . //[what is the unit here?]
For experiments , face and non-face patterns are of size 24x24 .
-1#0#0#exact -1#1#2#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7,8#8,9#para -1#9#10#exact -1#10#11#exact -1#11#12#exact 


A set of 10 ,000 face patterns were collected from the Internet .
A set of 10 ,000 face patterns were collected from the Internet .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact 


Another set of 10 ,000 hard non-face patterns were false positives collected by running a cascade of 17 AdaBoost classifiers at different locations and scales on 8 ,440 images with various subjects , such as rocks , trees , buildings , scenery , and flowers , containing no faces .
Another set of 10 ,000 hard non-face patterns were false positives collected by running a cascade of 17 AdaBoost classifiers at different locations and scales on 8 ,440 images with various subjects , such as rocks , trees , buildings , scenery , and flowers , containing no faces .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact -1#37#37#exact -1#38#38#exact -1#39#39#exact -1#40#40#exact -1#41#41#exact -1#42#42#exact -1#43#43#exact -1#44#44#exact -1#45#45#exact -1#46#46#exact -1#47#47#exact -1#48#48#exact -1#49#49#exact 


The 10 ,000 patterns in each set were divided into a training set of 6 ,000 patterns and a test set of 4 ,000 examples .
The 10 ,000 patterns in each set are divided into a training set of 6 ,000 patterns and a test set of 4 ,000 examples .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7,8#7,8#para -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact 


Some examples of the collected 24x24 face and non-face patterns are shown in Figure 2 .
Some examples of the collected 24x24 face and non-face patterns are shown in Figure 2 .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact 


Haar wavelet features , which have been used in many face detection systems [4] , [6] , [14] , were used in our experiments .
Haar wavelet feature that has been widely used in many face detection systems [4] ,[6] ,[14] is used in our experiments .
-1#0#0#exact -1#1#1#exact -1#2#2#stem -1#7,8#5,6,7,8#para -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#4,5#19#para -1#17#20#exact -1#18#21#exact -1#19#22#exact -1#20#23#exact -1#21#24#exact 


These consisted of four kinds of features modeled from adjacent basic rectangles with the same size and shape .
It consists of four kinds of features modeled from adjacent basic rectangles with the same size and shape .
-1#1,2#1,2#para -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#14,15,16#13,14,15,16#para -1#17#17#exact -1#18#18#exact 


The feature value was defined as the difference of the sum of the pixels within rectangles ( Figure 3 ) .
The feature value is defined as the difference of sum of the pixels within rectangles ( cf . Figure 3 ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3,4#3,4#para -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#11#9#exact -1#9#10#exact -1#10#11#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact 


In total , 134 ,736 features were used for training classifiers .
In total , 134 ,736 features were used for training classifiers .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact 


Figure 4 shows a comparison of the performances of strong classifiers trained by the different boosting schemes : AdaBoost [4] , Real AdaBoost [17] , and Ent-Boost .
Figure 4 shows a comparison of performances of strong classifiers trained by different boosting schemes that are AdaBoost [4] , Real AdaBoost [17] and Ent-Boost .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13,14#para -1#13#15#exact -1#14#16#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#25#exact -1#24#26#exact -1#25#27#exact 


Each strong classifier is a combination of 80 weak classifiers ( using more weak classifiers does not much improve the performance ) .
Each strong classifier is a combination of 80 weak classifiers ( using more weak classifiers does not improve much the performance ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#18#17#exact -1#17#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact 


For Real AdaBoost , subspace splitting is done by equal-width binning in which the number of bins is arbitrarily selected to be 64 and 128 .
As for Real AdaBoost , the subspace splitting is done by equal width binning in which the number of bins is arbitrarily selected to be 64 and 128 .
-1#1#0#lc -1#2#1#exact -1#3#2#exact -1#4#3#exact -1#6#4#exact -1#7#5#exact -1#8#6#exact -1#9#7#exact -1#10#8#exact -1#13#10#exact -1#14#11#exact -1#15#12#exact -1#16#13#exact -1#17#14#exact -1#18#15#exact -1#19#16#exact -1#20#17#exact -1#21#18#exact -1#22#19#exact -1#23#20#exact -1#24#21#exact -1#25#22#exact -1#26#23#exact -1#27#24#exact -1#28#25#exact 


The curves indicate that the performances of Real AdaBoost and Ent-Boost were better than that of AdaBoost .
The curves indicate that the performances of Real AdaBoost and Ent-Boost are better than that of AdaBoost .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11,12#11,12#para -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact 


In addition , the performance of Real AdaBoost classifiers varied when using different numbers of bins .
In addition , the performance of Real AdaBoost classifiers varies when using different number of bins .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#stem -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13,14#13,14#para -1#15#15#exact -1#16#16#exact 


Overall , Ent-Boost produced the best result .
Overall , Ent-Boost has the best result .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact 


As for storage space , the Ent-Boost-based classifier only uses 6 .79 bins on average , which is much fewer than the number used by Real AdaBoost-based classifiers .
As for storage space , the Ent-Boost based classifier only employs 6 .79 bins on average which is much smaller than that of Real AdaBoost-based classifiers .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#8#7#exact -1#9#8#exact -1#10#9#syn -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#20,21#20,21,22#para -1#23#24,25#para -1#24#26#exact -1#25#27#exact -1#26#28#exact 


Using Ent-Boost , a robust face detector was built .
Using Ent-Boost , a robust face detector was built .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact 


It was a cascade of Ent-Boost-based classifiers that were trained [through a process similar to that used in] [4] .
It was a cascade of Ent-Boost based classifiers that were trained similar to [4] .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#13#exact -1#12#14#exact -1#13#18#exact -1#14#19#exact 


The resulting cascade has 25 layers using 3 ,850 features .
The result cascade has 25 layers employing 3 ,850 features .
-1#0#0#exact -1#1#1#stem -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#syn -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact 


The performances of the AdaBoost-based face detector [4] and our Ent-Boost-based face detector on the MIT+CMU test set [1] confirmed the effectiveness of our proposed boosting scheme ( Table 2 ) .
Performances of AdaBoost-based face detector [4] and Ent-Boost based face detector on MIT+CMU test set [1] shown in Table 2 has confirmed the effectiveness of our proposed boosting scheme .
-1#22#0#lc -1#0#1#lc -1#1#2#exact -1#2#4#exact -1#3#5#exact -1#4#6#exact -1#5#7#exact -1#6#8#exact -1#25#9#exact -1#9#11#exact -1#10#12#exact -1#11#13#exact -1#12#15#exact -1#13#16#exact -1#14#17#exact -1#15#18#exact -1#21#19#exact -1#23,24#20,21,22#para -1#26#24#exact -1#27#25#exact -1#28#26#exact -1#18#28#exact -1#19#29#exact -1#29#31#exact 


Some detection results are given in Figure 5 .
Some detection results are given in Figure 5 .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact 


We have described Ent-Boost , a variant of AdaBoost , which uses entropy measures for automatic subspace splitting and optimal weak classifier selection .
We have presented Ent-Boost , a variant of AdaBoost , which uses entropy measure for automatic subspace splitting and optimal weak classifier selection .
-1#0#0#exact -1#1#1#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13,14#13,14#para -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact 


The resultant strong classifier has good performance and achieves compact storage .
The resulted strong classifier has good performance and compact storage .
-1#0#0#exact -1#1#1#stem -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact 


Furthermore , this new boosting scheme overcomes the main limitation of Real AdaBoost , which is difficulty in determining the suitable number of bins for subspace splitting .
Furthermore , it overcomes the main limitation of Real AdaBoost which is hard to determine the suitable number of bins for subspace splitting .
-1#0#0#exact -1#1#1#exact -1#3#6#exact -1#4#7#exact -1#5#8#exact -1#6#9#exact -1#7#10#exact -1#8#11#exact -1#9#12#exact -1#10#14#exact -1#11#15#exact -1#13,14#17,18#para -1#15#19#exact -1#16#20#exact -1#17#21#exact -1#18#22#exact -1#19#23#exact -1#20#24#exact -1#21#25#exact -1#22#26#exact -1#23#27#exact 


Because it considers the class information and the distribution of the input data in the splitting process , this method is generic and can be used for other applications .
By considering the class information and the distribution of the input data in splitting process , this method is generic and can be applied to other applications .
-1#1#2#stem -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14,15#para -1#14#16#exact -1#15#17#exact -1#16#18#exact -1#17#19#exact -1#18#20#exact -1#19#21#exact -1#20#22#exact -1#21,22#23,24,25,26#para -1#25#27#exact -1#26#28#exact -1#27#29#exact 


0
Experiments have shown promising results , especially in building a robust face detector .



ROBUST OBJECT DETECTION USING FAST FEATURE SELECTION FROM HUGE FEATURE SETS
ROBUST OBJECT DETECTION USING FAST FEATURE SELECTION FROM HUGE FEATURE SETS
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact 


This paper describes an efficient feature selection method which that quickly selects a small subset out of a given huge feature set ; the proposed method for will be useful for building robust object detection systems .
This paper describes an efficient feature selection method which quickly selects a small subset out of a given huge feature set for building robust object detection systems .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9,10#para -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#26#exact -1#22#31#exact -1#23#32#exact -1#24#33#exact -1#25#34#exact -1#26#35#exact -1#27#36#exact 


In this filter-based method , features are selected so that not only to maximizeing their relevance with the target class but also to minimizeing their mutual dependency .
In this filter-based method , features are selected so that not only maximizing their relevance with the target class but also minimizing their mutual dependency .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#13#stem -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#23#stem -1#22#24#exact -1#23#25#exact -1#24#26#exact -1#25#27#exact 


As a result , the selected feature set only contains only highly informative and non-redundant features , which significantly improve classification performance when combined together , significantly improve classification performance .
As a result , the selected feature set only contains highly informative and non-redundant features which when combined together , significantly improve classification performance .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10,11#para -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#19#16#exact -1#15#17#exact -1#20#18#exact -1#21#19#exact -1#22#20#exact -1#23#21#exact -1#16#22#exact -1#17#23#exact -1#18#24#exact -1#24#30#exact 


The relevance and mutual dependency of features are measured by using conditional mutual information ( CMI ), in which features and classes are treated as discrete random variables . //[ ,?<--A comma can be used here if the following describes CMI in general .]
The relevance and mutual dependency of features are measured by using conditional mutual information ( CMI ) in which features and classes are treated as discrete random variables .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact 


Experiments on different huge feature sets have shown that the proposed CMI-based feature selection can both reduce significantly the training time significantly and achieve high accuracy .
Experiments on different huge feature sets have shown that the proposed CMI-based feature selection can both reduce significantly the training time and achieve high accuracy .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact 


One of the fundamental research issues in pattern recognition is feature selection , which is the task of finding a small subset out of a given large set of features .
One of the fundamental research issues in pattern recognition is feature selection which is the task of finding a small subset out of a given large set of features .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact -1#28#29#exact -1#29#30#exact 


Improving the method of accomplishing this task is important due to the following three reasons .
It is significant due to the following three reasons .
-1#5#1#exact -1#1#7#exact -1#2#8#syn -1#3#9#exact -1#4#10#exact -1#6#11,12#para -1#7#13#exact -1#8#14#exact -1#9#15#exact 


First , there are many ways can be used to represent a target object , and this variety leadsleading to a huge feature set .
First , there are many ways to represent a target object , leading to a huge feature set .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#9#exact -1#7#10#exact -1#8#11#exact -1#9#12#exact -1#10#13#exact -1#11#14#exact -1#13#19#exact -1#14#20#exact -1#15#21#exact -1#16#22#exact -1#17#23#exact -1#18#24#exact 


For example , the number of Haar wavelet features used in [1] for face detection is hundreds of thousands .
For example , the number of Haar wavelet features used in [1] for face detection is hundreds of thousands .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact 


However , only small and incomplete training sets are available .
However , only small and incomplete training sets are available .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact 


As a result , these systems suffer from the curse of dimensionality and over-fitting .
As a result , these systems suffer from the curse of dimensionality and over-fitting .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact 


Second , a huge feature set usually includes many irrelevant and redundant features that can degrade the generalization performance of classifiers , waste storage space , and increase training time [2 , 3] .
Second , a huge feature set usually includes many irrelevant and redundant features that can degrade the generalization performance of classifiers , waste storage space and increase training time [2 , 3] .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#30#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact -1#28#29#exact -1#29#30#exact -1#31#32#exact -1#32#33#exact 


Third , selecting an optimal feature subset from a huge feature set can improve the performance and speed of classifiers .
Third , selecting an optimal feature subset from a huge feature set can improve the performance and speed of classifiers .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact 


Furthermore , less complex models is are easier to understand and verify .
Furthermore , less complex model is easier to understand and verify .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#stem -1#5#5#exact -1#6,7#6,7,8#para -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact 


In face detection , the success of systems such as those in [1 , 4] comes mainly from efficient feature selection methods .
In face detection , the success of systems such as those in [1 , 4] comes mainly from efficient feature selection methods .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#7,8,9#6,7,8,9#para -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact 


Generally , feature selection methods can be categorized into two kinds : the filter-based approach and the wrapper-based approach [5] .
Generally , feature selection methods can be categorized into two kinds : filter-based approach and wrapper-based approach [5] .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#17#exact -1#16#18#exact -1#17#19#exact -1#18#20#exact 


The filter-based approach is independent of any induction algorithm , while but the wrapper-based approach is associated with a specific induction algorithm to evaluate the quality of the selected feature subset . //[goodness / quality / appropriateness?<--If " goodness " is the word you would usually use in your field for this , it is fine , but I would suggest a different word choice otherwise . " Goodness " seems vague , so in what sense do you mean " good " ?]
The filter-based approach is independent of any induction algorithm while the wrapper-based approach is associated with a specific induction algorithm to evaluate the goodness of the selected feature subset .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#10#exact -1#10#12#exact -1#11#13#exact -1#12#14#exact -1#13#15#exact -1#14#16#exact -1#15#17#exact -1#16#18#exact -1#17#19#exact -1#18#20#exact -1#19#21#exact -1#20#22#exact -1#21#23#exact -1#22#24#exact -1#24#26#exact -1#25#27#exact -1#26#28#exact -1#27#29#exact -1#28#30#exact -1#29#31#exact -1#23#38#exact 


In the filter-based approach , features are normally selected based on their individual predictive power . This power is measured by Fisher scores , Pearson correlation [6] , or mutual information [7] .
In the filter-based approach , features are normally selected based on their individual predictive power which is measured by Fisher scores , Pearson correlation [6] or mutual information [7] .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#29#15#exact -1#16#17,18#para -1#17#19#exact -1#18#20#exact -1#19#21#exact -1#20#22#exact -1#21#23#exact -1#22#24#exact -1#23#25#exact -1#24#26#exact -1#25#28#exact -1#26#29#exact -1#27#30#exact -1#28#31#exact 


The major advantage of these measurement methods is their speed and ability to scale to huge feature sets .
The major advantage of these methods is their speed and ability to scale to huge feature sets .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact 


However , because the mutual relationships between features is are often not taken into account , leading the selected features might be highly redundant and less informative because two features with high individual predictive power , when combined together , might not bring significant performance improvement . Combining compared with two features of which one of them has low predictive power but is useful when combined with others would thus be more effective for improving performance .
However , the mutual relationships between features is often not taken into account , leading selected features might be highly redundant and less informative because two features with high individual predict power when combined together might not bring significant performance improvement compared with two features which one of them has low predictive power but is useful when combined with others .
-1#0#0#exact -1#1#1#exact -1#24#2#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8,9#9,10,11#para -1#10#12#exact -1#11#13#exact -1#12#14#exact -1#13#15#exact -1#14#16#exact -1#15#18#exact -1#16#19#exact -1#17#20#exact -1#18#21#exact -1#19#22#exact -1#20#23#exact -1#21#24#exact -1#22#25#exact -1#23#26#exact -1#25#28#exact -1#26#29#exact -1#27#30#exact -1#28#31#exact -1#29#32#exact -1#51#33#exact -1#52#34#exact -1#32#36#exact -1#33#37#exact -1#34#38#exact -1#35#40#exact -1#36#41#exact -1#37#42#exact -1#38#43#exact -1#39#44#exact -1#40#45#exact -1#60#46#exact -1#57#47#stem -1#41#48#exact -1#42#49#exact -1#43#50#exact -1#44#51#exact -1#47#52#exact -1#45#53#exact -1#46#54#exact -1#48#55,56#para -1#49#57#exact -1#50#58#exact -1#30#59#stem -1#31#60#exact -1#53#61#exact -1#54#62#exact -1#55#63#exact -1#56#64#exact -1#58#66#exact -1#59#67#exact 


Since wrapper-based feature selection methods use machine learning algorithms as a black box in the selection process , they can suffer from over-fitting in situations of when applied to small training sets . //[when used with / when applied to?]
Since wrapper-based feature selection methods use machine learning algorithms as a black box in selection process , they can suffer from over-fitting in situations of small training sets .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14,15#para -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#28,29#para -1#26#30#exact -1#27#31#exact -1#28#32#exact 


Furthermore , in practical object detection systems as in [1 , 8] , the feature sets usually have hundreds of thousands of features , so using wrapper-based methods is obviously inefficient because of the very high computation costs they incur .
Furthermore , in practical object detection systems as in [1 , 8] , the feature sets usually have hundreds of thousands features , using wrapper-based methods is obviously inefficient because of very high computation cost .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18,19,20#18,19,20,21#para -1#21#22#exact -1#22#23#exact -1#23#25#exact -1#24#26#exact -1#25#27#exact -1#26#28#exact -1#27#29#exact -1#28#30#exact -1#29#31#exact -1#30#32#exact -1#31#33,34#para -1#32#35#exact -1#33#36#exact -1#34#37#stem -1#35#40#exact 


For example , in the state- of- the- art face detection system in [1] , choosing a 6 ,061- feature set out of a 180 ,000-feature set by using AdaBoost has takentook several weeks . //[by using / generated by?]
For example , in the state of the art face detection system [1] , choosing a 6 ,061- feature set out of a 180 ,000-feature set by AdaBoost has taken several weeks .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#29#exact -1#28#30#exact -1#30#32#exact -1#31#33#exact -1#32#34#exact 


Consequently , feature selection methods based on conditional mutual information ( CMI ) based feature selection methods have been proposed [9 , 8 , 7 , 10] to take full advantage of the above approaches for handling large scale feature sets .
Consequently , conditional mutual information ( CMI ) based feature selection methods have been proposed [9 , 8 , 7 , 10] to take full advantage of above approaches for handling large scale feature sets .
-1#0#0#exact -1#1#1#exact -1#9#2#exact -1#10#3#exact -1#11#4#exact -1#8#5#exact -1#2#7#exact -1#3#8#exact -1#4#9#exact -1#5#10#exact -1#6#11#exact -1#7#12#exact -1#33#14#exact -1#28#16#para -1#12#17#exact -1#13#18#exact -1#14#19#exact -1#15#20#exact -1#16#21#exact -1#17#22#exact -1#18#23#exact -1#19#24#exact -1#20#25#exact -1#21#26#exact -1#22#27#exact -1#23#28#exact -1#24#29#exact -1#25#30#exact -1#26#31#exact -1#27#33#exact -1#29#35#exact -1#30#36#exact -1#31#37#exact -1#32#38#exact -1#34#40#exact -1#35#41#exact 


The main goal of these CMI-based methods is to select features which that maximize their relevance with the target class and to simultaneously minimize mutual dependency between selected ones . //[idea / goal?]
The main idea of CMI-based methods is to select features which maximize their relevance with the target class and simultaneously minimize mutual dependency between selected ones .
-1#0#0#exact -1#1#1#exact -1#15,16#2#para -1#3#3#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#13#exact -1#12#14#exact -1#13#15#exact -1#14#16#exact -1#17#19#exact -1#18#20#exact -1#19#22#exact -1#20#23#exact -1#21#24#exact -1#22#25#exact -1#23#26#exact -1#24#27#exact -1#25#28#exact -1#26#29#exact 


It doesThese methods do not select a feature similar to ones already selected ones , even if itthe feature is individually powerful , as because selecting it might not do much to increase much information about the target class [7] .
It does not select a feature similar to already selected ones , even if it is individual powerful , as selecting it might not increase much information about the target class [7] .
-1#14#0#lc -1#1,2#3,4#para -1#3#5#exact -1#4#6#exact -1#5#7#exact -1#6#8#exact -1#7#9#exact -1#10#10#exact -1#8#11#exact -1#9#12#exact -1#11#14#exact -1#12#15#exact -1#13#16#exact -1#15#19#exact -1#16#20#stem -1#17#21#exact -1#18#22#exact -1#19#23#exact -1#20#25#exact -1#21#26#exact -1#22#27#exact -1#23#28#exact -1#25#29,30#para -1#24#31,32#para -1#26#33,34#para -1#27#35#exact -1#28#36#exact -1#29#37#exact -1#30#38#exact -1#31#39#exact -1#32#40#exact 


One of the important tasks in using CMI-based methods is mutual information estimation , which involves to computecomputing the probability densities of continuous random variables .
One of the important tasks in using CMI-based methods is mutual information estimation which involves to compute probability densities of continuous random variables .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#17#18,19#para -1#18#20#exact -1#19#21#exact -1#20#22#exact -1#21#23#exact -1#22#24#exact -1#23#25#exact 


In [9] , Kwak and Choi used a Parzen windows -based density estimation method in which many parameters such as kernel function and window width are complicated to determine .
In [9] , Kwak and Choi used Parzen windows based density estimation method in which many parameters such as kernel function and window width are complicated to determine .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#8#exact -1#8#9#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact -1#28#29#exact 


For simplification , discretizing features is often used on the features . //[discretizing features is often used on the features / the features are often discretized?]
For simplification , discretizing features is often used .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#11#exact 


So far , in object detection systems like [8 , 7] treat , features are treated as binary random variables by choosing appropriate thresholds .
So far , in object detection systems like [8 , 7] , features are treated as binary random variables by choosing appropriate thresholds .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#14#11#stem -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact 


However , binarizing features is not a suitable way to handle highly complex data for which it is hard to finding the best threshold is difficult .
However , binarizing features is not a suitable way to handle highly complex data for which it is hard to find the best threshold .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16,17,18#16,17,18,19#para -1#19,20,21#20,21#para -1#22#22#exact -1#23#23#exact -1#24#26#exact 


Using multiple thresholds to discretize data is better than using a binary approach .
It is better if multiple thresholds are used to discretize data .
-1#4#1#exact -1#5#2#exact -1#8#3#exact -1#9#4#exact -1#10#5#exact -1#1#6#exact -1#2#7#exact -1#11#13#exact 


Such a simple method is equal-width binning , which divides the range of feature values into m equally sized bins , where m must be known in advance .
Such a simple method is equal-width binning which divides the range of feature values into m equal sized bins , where m must be known in advance .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#19#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#stem -1#17#18#exact -1#18#19#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact 


Our method is also a CMI-based feature selection method .
Our method is also a CMI-based feature selection method .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact 


However , the methodfs main distinguishing point is that it employs the entropy-based discretization method [11] to discretize features . //[distinguishing / unique?]
However , the main distinguished point is that it employs the entropy-based discretization method [11] to discretize features .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#4#exact -1#4#5#stem -1#5,6,7#6,7,8,9#para -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact 


This discretization method is simpler than the Parzen window-s based density estimation method and is more efficient than binary discretization .
This discretization method is simpler than Parzen windows based density estimation method and more efficient than binary discretization .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#7#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#15#exact -1#14#16#exact -1#15#17#exact -1#16#18#exact -1#17#19#exact -1#18#20#exact 


Furthermore , contrary to equal-width binning , it can automatically evaluate the optimal number of bins based on data distribution . //[evaluate / determine?]
Furthermore , contrary to equal-width binning , it can automatically evaluate the optimal number of bins based on data distribution .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact 


Experiments show that the proposed method can well capably handle huge feature sets of data such as Haar wavelets [1] and Gabor wavelets [12] for face detection , significantly reducinge the training time while maintaining high classification performance .
Experiments show that the proposed method can well handle huge feature sets for face detection such as Haar wavelets [1] and Gabor wavelets [12] , significantly reduce the training time while maintaining high classification performance .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#12#24#exact -1#13#25#exact -1#14#26#exact -1#24#27#exact -1#25#28#exact -1#27#30#exact -1#28#31#exact -1#29#32#exact -1#30#33#exact -1#31#34#exact -1#32#35#exact -1#33#36#exact -1#34#37#exact -1#35#38#exact 


FEATURE SELECTION " >
FEATURE SELECTION " >
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact 


Huge feature sets usually contain four kinds of features : ( i ) irrelevant features , ( ii ) weakly relevant and redundant features , ( iii ) weakly relevant but non-redundant features , and ( iv ) strongly relevant features ; in which ( iii ) and ( iv ) are the objectives of feature selection methods [13] .
Huge feature sets usually contain four kinds of features : ( i ) irrelevant features , ( ii ) weakly relevant and redundant features , ( iii ) weakly relevant but non-redundant features and ( iv ) strongly relevant features in which ( iii ) and ( iv ) are the objective of feature selection methods [13] .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#34#exact -1#34#35#exact -1#35#36#exact -1#36#37#exact -1#37#38#exact -1#38#39#exact -1#39#40#exact -1#40#42#exact -1#41#43#exact -1#42#44#exact -1#43#45#exact -1#44#46#exact -1#45#47#exact -1#46#48#exact -1#47#49#exact -1#48#50#exact -1#49#51#exact -1#50#52#exact -1#51#53#stem -1#52#54#exact -1#53#55#exact -1#54#56#exact -1#55#57#exact -1#56#58#exact -1#57#59#exact 


To measure the relevance of a feature , an entropy-based measure , which quantifies the uncertainty of random variables , is normally used .
To measure relevance of a feature , the entropy-based measure which quantifies the uncertainty of random variables is normally used .
-1#0#0#exact -1#1#1#exact -1#7#2#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#8#9#exact -1#9#10#exact -1#10#12#exact -1#11#13#exact -1#12#14#exact -1#13#15#exact -1#14#16#exact -1#15#17#exact -1#16#18#exact -1#17#20#exact -1#18#21#exact -1#19#22#exact -1#20#23#exact 


The entropy of a discrete random variable X is defined as : \MATH and the conditional entropy of X after another variable Y is known is defined as \MATH
The entropy of a discrete random variable X is defined as : \MATH and the conditional entropy of X after another variable Y is known is defined as \MATH
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact 


The mutual dependence between two random variables is measured by mutual information : \MATH .
The mutual dependence between two random variables is measured by mutual information \MATH .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#13#exact -1#13#14#exact 


The conditional mutual information is defined as : \MATH .
The conditional mutual information is defined as : \MATH
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact 


In the first step , the most relevant feature F1 , which has the highest largest amount of mutual information , is selected .
In the first step , the most relevant feature F1 which has the highest mutual information is selected .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#17,18#para -1#15#19#exact -1#16#21#exact -1#17#22#exact -1#18#23#exact 


However , iIn the second step , however , the condition to select feature F2 is not its mutual information alone , but how much information of F2 can add with respect to the already existing F1 .
However , in the second step , the condition to select feature F2 is not its mutual information alone , but how much information of F2 can add with respect to the already existing F1 .
-1#0#0#exact -1#1#1#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#19#8#exact -1#7#9#exact -1#8#10#exact -1#9#11#exact -1#10#12#exact -1#11#13#exact -1#12#14#exact -1#13#15#exact -1#14#16#exact -1#15#17#exact -1#16#18#exact -1#17#19#exact -1#18#20#exact -1#20#22#exact -1#21#23#exact -1#22#24#exact -1#23#25#exact -1#24#26#exact -1#25#27#exact -1#26#28#exact -1#27#29#exact -1#28#30#exact -1#29#31#exact -1#32,33#32,33,34,35#para -1#34#36#exact -1#35#37#exact 


Therefore , F2 is selected so that maximizingas to maximize the information it can add :\MATH .
Therefore , F2 is selected so that maximizing :\MATH .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#9#stem -1#8#15#exact -1#9#16#exact 


Following the same scheme, we iteratively add the feature that brings the highest increase of the information content contained in the current selected feature set . //[the / an?<-- " An " is correct if there is more than one such measure .]
Following the same scheme , we iteratively add the feature that brings the highest increase of information content contained in current selected feature set .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#5#4#exact -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15,16#para -1#17#17#exact -1#18,19,20#18,19,20,21#para -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact 


The next feature Ft to be added at iteration t is defined by :\MATH .
The next feature Ft to be added at iteration t is defined by :\MATH .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact 


To simply estimate mutual information , the easiest way is to discretize features are discretized in binary values by specifying thresholds [8 , 7] .
In order to simply estimate mutual information , the easiest way is features are discretized in binary values by specifying thresholds [8 , 7] .
-1#2#0#lc -1#3#1#exact -1#4#2#exact -1#5#3#exact -1#6#4#exact -1#7#5#exact -1#8#6#exact -1#9#7#exact -1#10#8#exact -1#11#9#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact 


However , for complex data , doing thisit is not efficient ; therefore , we use the entropy-based method proposed by Fayyad and Irani [11] for discretization .
However , for complex data , it is not efficient ; therefore , we use entropy-based method proposed by Fayyad and Irani [11] for discretization .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#17#exact -1#16#18#exact -1#17#19#exact -1#18#20#exact -1#19#21#exact -1#20#22#exact -1#21#23#exact -1#22#24#exact -1#23#25#exact -1#24#26#exact -1#25#27#exact 


This method is a supervised method , thus so it is generic and can adapt very well to any kind of data distributions .
This method is a supervised method , thus it is generic and can adapt very well to any kind of data distributions .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8,9#8,9,10#para -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact 


Discretization is essentially a quantizing process that converts continuous values into discrete values .
Basically , discretization is a quantizing process that converts continuous values into discrete values .
-1#2#0#lc -1#3#1#exact -1#4#3#exact -1#5#4#exact -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact 


Suppose that we are given a set of instances S , a feature A , and a cut-point T . ( A cut-point is a threshold value that divides the range of continuous values into two intervals ; one interval is less than or equal to the threshold , and the other interval is greater than the threshold . ) .
Suppose that we are given a set of instances S , a feature A and a cut-point T ( a cutpoint is a threshold value that divides the range of continuous values into two intervals ; one interval is less than or equal to the threshold , and the other interval is greater than the threshold ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#46#14#exact -1#47#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#57#19#exact -1#18#20#exact -1#19#21#lc -1#21#23#exact -1#22#24#exact -1#23#25#exact -1#24#26#exact -1#25#27#exact -1#26#28#exact -1#27#29#exact -1#28#30#exact -1#29#31#exact -1#30#32#exact -1#31#33#exact -1#32#34#exact -1#33#35#exact -1#34#36#exact -1#35#37#exact -1#36#38#exact -1#37#39#exact -1#38#40#exact -1#39#41#exact -1#40#42#exact -1#41#43#exact -1#42#44#exact -1#43#45#exact -1#44#46#exact -1#45#47#exact -1#14#49#exact -1#48#50#exact -1#49#51#exact -1#50#52#exact -1#52,53,54#53,54,55,56#para -1#55#57#exact -1#56#59#exact 


The class-information entropy of the partition induced by T is defined as :
The class-information entropy of the partition induced by T is defined as :
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact 


Among candidate cut-points , the best candidate cut-point Tmin , which minimizes the entropy function \MATH , is selected to split \MATH into two partitions \MATH and \MATH .
Among candidate cut-points , the best candidate cut-point Tmin which minimizes the entropy function \MATH is selected to split \MATH into two partitions \MATH and \MATH .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#17#exact -1#16#18#exact -1#17#19#exact -1#18#20#exact -1#19#21#exact -1#20#22#exact -1#21#23#exact -1#22#24#exact -1#23#25#exact -1#24#26#exact -1#25#27#exact -1#26#28#exact 


This process can then be repeated recursively forto \MATH and \MATH until some stopping condition is satisfied , thus creating multiple intervals on the feature \MATH .
This process can then be repeated recursively to \MATH and \MATH until some stopping condition is satisfied , thus creating multiple intervals on the feature \MATH .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact 


Using MDLP , the stopping criteria is was proposed by Fayyad and Irani [11] as follows :
Using MDLP , the stopping criteria is proposed by Fayyad and Irani [11] as follows :
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#14#7#syn -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#15#16#exact 


MDLP Criteria : A partition induced by cut-point T for a set S of N examples is accepted if : \MATH wWhere \MATH ,where \MATH , \MATH , and \MATH is are the numbers of classes in \MATH , \MATH , and \MATH , respectively .
MDLP Criteria : A partition induced by cut-point T for a set S of N examples is accepted if : \MATH Where \MATH ,where \MATH , \MATH , \MATH is the number of classes in \MATH , \MATH , \MATH .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#29#exact -1#29#30#exact -1#30#32#exact -1#31,32#33,34#para -1#33#35#exact -1#34#36#exact -1#35#37#exact -1#36#38#exact -1#37#39#exact -1#38#40#exact -1#39#42#exact -1#40#45#exact 


Extensive experiments [11 , 14] have shown that this method is one of the best in variable discretization one because it gives a small number of cut-points while maintaining consistency .
Extensive experiments [11 , 14] have shown that this method is one of the best variable discretization one because it gives small number of cut-points while maintaining consistency .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#11,12,13,14#10,11,12,13,14#para -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22,23#para -1#22#24#exact -1#23#25#exact -1#24#26#exact -1#25#27#exact -1#26#28#exact -1#27#29#exact -1#28#30#exact 


The outline of the proposed feature selection method is shown in Algorithm 1 .
The outline of the proposed feature selection method is shown in Algorithm 1 .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact 


For experiments , a set of face and non-face patterns of size 24x24 was used .
For experiments , a set face and non-face patterns of size 24x24 was used .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5,6#5,6,7#para -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact 


A set of 10 ,000 face patterns were collected from the Internet .
A set of 10 ,000 face patterns were collected from the Internet .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact 


Another set of 10 ,000 complex non-face patterns were false positives collected by running a face detector based on a cascade of 17 AdaBoost classifiers at different locations and scales on 8 ,440 images that contained no faces ; the images with included various subjects , such as rocks , trees , buildings , scenery , and flowers , containing no faces .
Another set of 10 ,000 complex non-face patterns were false positives collected by running a face detector based on a cascade of 17 AdaBoost classifiers at different locations and scales on 8 ,440 images with various subjects , such as rocks , trees , buildings , scenery , and flowers , containing no faces .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#51#34,35#para -1#52#36#exact -1#53#37#exact -1#34#41#exact -1#35#43#exact -1#36#44#exact -1#37#45#exact -1#38#46#exact -1#39#47#exact -1#40#48#exact -1#41#49#exact -1#42#50#exact -1#43#51#exact -1#44#52#exact -1#45#53#exact -1#46#54#exact -1#47#55#exact -1#48#56#exact -1#49#57#exact -1#50#58#exact -1#54#62#exact 


The 10 ,000 patterns in each set were divided into a training set of 6 ,000 patterns and a test set of 4 ,000 patterns .
The 10 ,000 patterns in each set were divided into a training set of 6 ,000 patterns and a test set of 4 ,000 patterns .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact 


Some examples of the collected 24x24 face and non-face patterns are shown in Figure 1 .
Some examples of the collected 24x24 face and non-face patterns are shown in Figure 1 .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact 


Two types of features ?that are Haar wavelet features and Gabor wavelet features ? were used in our experiments .
Two types of features that are Haar wavelet feature and Gabor wavelet feature were used in experiments .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#stem -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#stem -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#18#exact -1#17#19#exact 


Haar wavelet features have been widely used in many face detection systems [1 , 15] .
Haar wavelet features have been widely used in many face detection systems [1 , 15] .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact 


They consists of four kinds of features modeled from adjacent basic rectangles with the same size and shape . //Ifm not 100 percent clear on what " they " points to here . " These Haar wavelet features , " perhaps? But can features consist of other kinds of features? You may want to clarify here .]
It consists of four kinds of features modeled from adjacent basic rectangles with the same size and shape .
-1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#14,15,16#13,14,15,16#para -1#17#17#exact -1#18#18#exact 


The feature value is defined as the difference of the sum of the pixels within the rectangles .
The feature value is defined as the difference of sum of the pixels within rectangles .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#11#9#exact -1#9#10#exact -1#10#11#exact -1#12#13#exact -1#13#14#exact -1#14#16#exact -1#15#17#exact 


In total , 134 ,736 features were used for training classifiers .
In total , 134 ,736 features were used for training classifiers .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact 


Gabor wavelet features have also often been used often in face recognition systems [12] and are defined as : \MATH , where \MATH and \MATH define the orientation and scale of the Gabor kernels respectively , \MATH , and the wave vector \MATH , is defined as : \MATH where \MATH , \MATH and \MATH .
Gabor wavelet features have also often been used in face recognition systems [12] and are defined as : \MATH where \MATH and \MATH define the orientation and scale of the Gabor kernels respectively , \MATH , and the wave vector \MATH , is defined as : \MATH where \MATH , \MATH \MATH .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#33#20#exact -1#19#21#exact -1#20#22#exact -1#21#23#exact -1#22#24#exact -1#23#25#exact -1#24#26#exact -1#25#27#exact -1#26#28#exact -1#27#29#exact -1#28#30#exact -1#29#31#exact -1#30#32#exact -1#31#33#exact -1#32#34#exact -1#41#35#exact -1#34#36#exact -1#35#37#exact -1#36#38#exact -1#37#39#exact -1#38#40#exact -1#39#41#exact -1#40#42#exact -1#49#43#exact -1#42#44#exact -1#43#45#exact -1#44#46#exact -1#45#47#exact -1#46#48#exact -1#47#49#exact -1#48#50#exact -1#50#52#exact -1#51#54#exact -1#52#55#exact 


The Gabor representation of a face image is computed by convolving the face image with the Gabor filters .
The Gabor representation of a face image is computed by convolving the face image with the Gabor filters .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact 


Let \MATH be the face image ; , its convolution with a Gabor filter  ,_( z ) is defined as : \MATH where \MATH denotes the convolution operator .
Let \MATH be the face image , its convolution with a Gabor filter  ,_( z ) is defined as : \MATH where \MATH denotes the convolution operator .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact -1#28#29#exact 


Similar to [12] , Gabor kernels at five scales , \MATH , and eight orientations , \MATH , were used .
Similar to [12] , Gabor kernels at five scales \MATH and eight orientations \MATH were used .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#10#exact -1#10#12#exact -1#11#13#exact -1#12#14#exact -1#13#16#exact -1#14#18#exact -1#15#19#exact -1#16#20#exact 


0
At each pixel position , 40 Gabor features are computed by convolving the input image with the real part of Gabor filters .



A Multi-Stage Approach to Fast Face Detection
A Multi-Stage Approach to Fast Face Detection
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact 


A multi-stage approach that is fast , robust , and easy to train is proposed for a face-detection system .
A multi-stage approach --- which is fast , robust and easy to train --- for a face-detection system is proposed .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#4,5#3,4#para -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#18#13#exact -1#19#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#20#19#exact 


Motivated by the work of Viola and Jones [1] , this approach uses a cascade of classifiers to yield a coarse-to-fine strategy to significantly reduce detection time while maintaining a high detection rate .
Motivated by the work of Viola and Jones [1] , this approach uses a cascade of classifiers to yield a coarse-to-fine strategy to reduce significantly detection time while maintaining a high detection rate .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#24#23#exact -1#23#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact 


However , our [system / approach?] is distinguished from previous work by two features .
However , it is distinguished from previous work by two features .
-1#0#0#exact -1#1#1#exact -1#3#6#exact -1#4#7#exact -1#5#8#exact -1#6#9#exact -1#7#10#exact -1#8#11#exact -1#9#12#exact -1#10#13#exact -1#11#14#exact 


First , a new stage has been added to detect face candidate regions more quickly by using a larger window size and larger moving step size .
First , a new stage is added to detect face candidate regions more quickly by using a larger window size and larger moving step size .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5,6#para -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact 


Second , support vector machine ( SVM ) classifiers are used instead of AdaBoost classifiers in the last stage , and Haar wavelet features selected by the previous stage are reused for the SVM classifier robustly and efficiently .
Second , SVM classifiers are used instead of AdaBoost classifiers in the last stage , and Haar wavelet features selected by the previous stage are reused for the SVM classifier robustly and efficiently .
-1#0#0#exact -1#1#1#exact -1#2#6#exact -1#3#8#exact -1#4#9#exact -1#5#10#exact -1#6#11#exact -1#7#12#exact -1#8#13#exact -1#9#14#exact -1#10#15#exact -1#11#16#exact -1#12#17#exact -1#13#18#exact -1#14#19#exact -1#15#20#exact -1#16#21#exact -1#17#22#exact -1#18#23#exact -1#19#24#exact -1#20#25#exact -1#21#26#exact -1#22#27#exact -1#23#28#exact -1#24#29#exact -1#25#30#exact -1#26#31#exact -1#27#32#exact -1#28#33#exact -1#29#34#exact -1#30#35#exact -1#31#36#exact -1#32#37#exact -1#33#38#exact 


By combining AdaBoost and SVM classifiers , the final system can achieve both fast and robust detection because most non-face patterns are rejected quickly in earlier layers , while only a small number of promising face patterns are classified robustly in later layers .
By combining AdaBoost and SVM classifiers , the final system can achieve both fast and robust detection because most non-face patterns are rejected quickly in earlier layers , while only a small number of promising face patterns is classified robustly in later layers .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact -1#37#37#syn -1#38#38#exact -1#39#39#exact -1#40#40#exact -1#41#41#exact -1#42#42#exact -1#43#43#exact 


The proposed multi-stage-based system has been shown to run faster than the original AdaBoost-based system while maintaining comparable accuracy .
The proposed multi-stage-based system is shown to run faster than the original AdaBoost-based system while maintaining comparable accuracy .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4,5#para -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact 


Face detection is one of the most active research areas in computer vision because of its many interesting applications in fields such as security , surveillance , multimedia retrieval , and human-computer interaction .
Face detection is one of the most active research areas in computer vision because of its many interesting applications in fields such as security , surveillance , multimedia retrieval , and human-computer interaction .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact 


For example , face detection is combined with other modules to identify a person in a video sequence [2] .
For example , face detection is combined with other modules to identify who a person in a video sequence is [2] .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#13,14#12,13,14,15#para -1#17#16#exact -1#18#17#exact -1#20#18#exact -1#21#19#exact 


Face locations , the results of a face detection system , can be used for applications such as face recognition and video indexing [3] .
Face locations , the results of a face detection system , can be used for applications such as face recognition and video indexing [3] .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#4,5,6#3,4,5,6#para -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11,12#11,12,13,14#para -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact 


Although this area has been studied for more than 30 years , developing a fast and robust face detection system that can handle the variations found in different faces in real applications , such as facial expressions , pose changes , illumination changes , complex backgrounds , and low resolutions , is still a challenging research target [4] .
Although it has been studied for more than 30 years , developing a fast and robust face detection system that can handle the variations found in different faces in real applications , such as facial expressions , pose changes , illumination changes , complex backgrounds , and low resolutions , is still a challenging research target [4] .
-1#0#0#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact -1#28#29#exact -1#29#30#exact -1#30#31#exact -1#31#32#exact -1#32#33#exact -1#33#34#exact -1#34#35#exact -1#35#36#exact -1#36#37#exact -1#37#38#exact -1#38#39#exact -1#39#40#exact -1#40#41#exact -1#41#42#exact -1#42#43#exact -1#43#44#exact -1#44#45#exact -1#45#46#exact -1#46#47#exact -1#47#48#exact -1#48#49#exact -1#49#50#exact -1#50#51#exact -1#51#52#exact -1#52#53#exact -1#53#54#exact -1#54#55#exact -1#55#56#exact -1#56#57#exact -1#57#58#exact 


Recently , with advances in machine learning research , neural networks [5] , [6] , support vector machines ( SVM ) [7] , [8] , [9] and AdaBoost [1] , [10] , [11] , [12] , [13] are typical choices for building robust face detectors .
Recently , with advances in machine learning research , Neural Network [5] ,[6] , Support Vector Machines ( SVM ) [7] ,[8] ,[9] and AdaBoost [1] ,[10] ,[11] ,[12] ,[13] are typical choices for building robust face detectors .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#lc -1#10#10#stem -1#11#11#exact -1#13#12#exact -1#14#15#lc -1#15#16#lc -1#16#17#lc -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#23#26#exact -1#24#27#exact -1#25#28#exact -1#30#37#exact -1#31#38#exact -1#32#39#exact -1#33#40#exact -1#34#41#exact -1#35#42#exact -1#36#43#exact -1#37#44#exact -1#38#45#exact 


Current research is focusing on feature extractions and appropriate structures for combining classifiers .
Current research is focusing on feature extractions and appropriate structures for combining classifiers .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact 


Generally , to classify an input pattern of intensities as a face or non-face , features must be extracted and normalized before passing [the image / the pattern / the results?] to a classifier [14] .
Generally , to classify an input pattern of intensities as a face or non-face , features must be extracted and normalized before passing to a classifier [14] .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#31#exact -1#24#32#exact -1#25#33#exact -1#26#34#exact -1#27#35#exact 


Many kinds of features have been used , ranging from simple ones such as intensity values [7] , [5] and eigenspace [15] to complex ones such as wavelets [16] , [1] , [12] , edge orientation histograms [17] , [18] , and Bayesian discriminating features ( BDF ) [19] .
There are many kinds of features that have been used ranging from simple features such as intensity values [7] ,[5] and eigenspace [15] to complex features such as wavelets [16] ,[1] ,[12] , edge orientation histograms [17] ,[18] and Bayesian discriminating features ( BDF ) [19] .
-1#2#0#lc -1#3#1#exact -1#4#2#exact -1#5#3#exact -1#7#4#exact -1#8#5#exact -1#9#6#exact -1#32#7#exact -1#10#8#exact -1#11#9#exact -1#12#10#exact -1#14#12#exact -1#15#13#exact -1#16#14#exact -1#17#15#exact -1#18#16#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact -1#23#22#exact -1#24#23#exact -1#26#25#exact -1#27#26#exact -1#28#27#exact -1#29#28#exact -1#33#34#exact -1#34#35#exact -1#35#36#exact -1#36#37#exact -1#38#41#exact -1#39#42#exact -1#40#43#exact -1#41#44#exact -1#42#45#exact -1#43#46#exact -1#44#47#exact -1#45#48#exact -1#46#49#exact 


Discriminative and informative features usually increase detection rates and reduce the complexity of training procedures [17] .
Discriminative and informative features usually increase detection rate and reduce complexity of the training procedure [17] .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7,8#7,8#para -1#9#9#exact -1#10,11,12#10,11,12#para -1#13#13#exact -1#14#14#stem -1#15#15#exact -1#16#16#exact 


In a typical face detector that is scale- and location-free , the number of analyzed patterns is usually very large ( 160 ,000 patterns for a 320x240 pixel image ) because the face classifier has to scan over the input image at every location and every scale .
In a typical face detector which is scale-free and location-free , the number of analyzed patterns is usually very large ( 160 ,000 patterns for a 320x240 pixel image ) because the face classifier has to scan over the input image at every location and every scale .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5,6#5,6#para -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact -1#37#37#exact -1#38#38#exact -1#39#39#exact -1#40#40#exact -1#41#41#exact -1#42#42#exact -1#43#43#exact -1#44#44#exact -1#45#45#exact -1#46#46#exact -1#47#47#exact 


However , the vast majority of the analyzed patterns are non-face .
However , the huge majority of the analyzed patterns are non-face .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#4,5#3,4,5#para -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact 


Statistics from [9] have shown that the ratio of non-face to face patterns is about 50 ,000 to 1 .
Statistics from [9] have shown that the ratio of non-face to face patterns is about 50 ,000 to 1 .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact 


Face detectors based on single classifiers such as SVM [7] , [8] , [9] and neural networks [6] , [5] are usually slow because they equally process non-face and face regions in the input image .
Face detectors based on single classifiers such as SVM [7] ,[8] ,[9] and Neural Network [6] ,[5] are usually slow because they process non-face regions and face regions in the input image equally .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#12#14#exact -1#13#15#lc -1#14#16#stem -1#15#17#exact -1#17#20#exact -1#18#21#exact -1#19#22#exact -1#20#23#exact -1#21#24#exact -1#32#25#exact -1#22#26#exact -1#23#27#exact -1#25#28#exact -1#26#29#exact -1#27#30#exact -1#28#31#exact -1#29#32#exact -1#30#33#exact -1#31#34#exact -1#33#35#exact 


To deal with the problem of processing a large number of patterns , a combination of simple-to-complex classifiers has been proposed [8] , [1] , [9] , [20] , [21] , [11] .
To deal with the problem of processing a large number of patterns , a combination of simple-to-complex classifiers is proposed [8] ,[1] ,[9] ,[20] ,[21] ,[11] .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#8,9,10#7,8,9,10#para -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18,19#18,19,20#para -1#20#21#exact -1#26#32#exact 


In particular , fast and simple classifiers are [recommended to be?] used as filters at the earliest stages to quickly reject a large number of non-face patterns and a slower yet more accurate classifier is then recommended to be used for classifying face-like patterns .
In particular , fast and simple classifiers are used as filters at the earliest stages to quickly reject a large number of non-face patterns and a slower yet more accurate classifier is then used for classifying face-like patterns .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#15#9#exact -1#8#11#exact -1#9#12#exact -1#10#13#exact -1#11#14#exact -1#12#15#exact -1#13#16#exact -1#14#17#exact -1#16#19#exact -1#17#20#exact -1#19,20,21#21,22,23,24#para -1#22#25#exact -1#23#26#exact -1#24#27#exact -1#25#28#exact -1#26#29#exact -1#27#30#exact -1#28#31#exact -1#29#32#exact -1#30#33#exact -1#31#34#exact -1#32#35#exact -1#33#37,38,39,40#para -1#35#41#exact -1#36#42#exact -1#37#43#exact -1#38#44#exact 


In this way , the complexity of classifiers can be adapted corresponding to the difficulty in the input patterns . / / [is / can be?]
By this way , the complexity of classifiers is adapted corresponding to the difficulty in the input patterns .
-1#14#0#lc -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8,9#para -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact 


In [8] , nonlinear SVM classifiers using pixel-based features were arranged into a sequence by increasing the number of support vectors , while in [9] , linear SVM classifiers trained at different resolutions were used for rejection and a reduced set of principle component analysis ( PCA )-based features were used with the nonlinear SVM at the classification stage in order to reduce computation time .
In [8] , non linear SVM classifiers using pixel-based features are arranged into a sequence with increasing number of support vectors , or in [9] , linear SVM classifiers trained at different resolutions are used for rejection and a reduced set of principle component analysis ( PCA )-based features are used with the non linear SVM at the classification stage in order to reduce computation time .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#5#4#exact -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#syn -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#16#14,15#para -1#52#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33,34#33,34#para -1#35#35#exact -1#36#36#exact -1#37#37#exact -1#38#38#exact -1#39#39#exact -1#40#40#exact -1#41#41#exact -1#42#42#exact -1#43#43#exact -1#44#44#exact -1#45#45#exact -1#46#46#exact -1#47#47#exact -1#48#48#exact -1#49,50#49,50#para -1#51#51#exact -1#57#52#exact -1#55#54#exact -1#56#55#exact -1#58#56,57#para -1#59#58#exact -1#61,62,63#59,60,61,62#para -1#64#63#exact -1#65#64#exact -1#66#65#exact 


In [1] , AdaBoost-based classifiers were arranged in a degeneration decision tree or a cascade .
In [1] , AdaBoost based classifiers are arranged in a degeneration decision tree or a cascade .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#5#4#exact -1#6#5#syn -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact 


Using about 10 features of the first two layers , more than 90\% of non-face patterns were rejected .
Using about 10 features of the first two layers , more than 90\% of non-face patterns are rejected .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#6,7#4,5,6,7#para -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16,17#16,17#para -1#18#18#exact 


Recently , a boosting chain [20] and a nested cascade [11] have also been proposed for improvements .
Recently , boosting chain [20] and nested cascade [11] have also been proposed for improvements .
-1#0#0#exact -1#1#1#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#8#exact -1#7#9#exact -1#8#10#exact -1#9#11#exact -1#10#12#exact -1#11#13#exact -1#12#14#exact -1#13#15#exact -1#14#16#exact -1#15#17#exact 


It is believed that the cascade structure of classifiers is the key factor in enhancement of current real-time face detectors . / / It is believed?This sounds vague?who believes this? " May researchers believe , " for example , would be clearer and sound more believable .]
It is believed that the cascade structure of classifiers is the key factor in enhancement of current real-time face detectors .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#11,12,13#10,11,12,13#para -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact 


This work is motivated by Viola and Jones [1] , who proposed a framework for fast and robust face detection .
This work is motivated by Viola and Jones [1] who proposed a framework for fast and robust face detection .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact 


Their success comes mainly from three contributions :
Their success mainly comes from three contributions :
-1#0#0#exact -1#1#1#exact -1#3#2#exact -1#2#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact 


-The cascaded structure of simple-to-complex classifiers reduces computation time dramatically .
-Firstly , the cascaded structure of simple-to-complex classifiers reduces computation time dramatically ( as mentioned above ) .
-1#3#1#exact -1#4#2#exact -1#5#3#exact -1#6#4#exact -1#7#5#exact -1#8#6#exact -1#9#7#exact -1#10#8#exact -1#11#9#exact -1#17#10#exact 


-AdaBoost is used to select discriminative and significant features from a pool of a very large number of features and then construct the classifier .
-Secondly , AdaBoost is used to select discriminative and significant features from a pool of a very large number of features and then construct the classifier .
-1#3#1#exact -1#4#2#exact -1#5#3#exact -1#6#4#exact -1#7#5#exact -1#8#6#exact -1#9#7#exact -1#10#8#exact -1#11#9#exact -1#12#10#exact -1#13#11#exact -1#14#12#exact -1#15,16,17,18,19#13,14,15,16#para -1#20#18#exact -1#21#19#exact -1#22#20#exact -1#23#21#exact -1#24#22#exact -1#25#23#exact -1#26#24#exact 


The output classifier built from these selected features is very fast and robust in classification .
The output classifier built from these selected features is very fast and robust in classification .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact 


Compared to SVM-based classifiers or neural network-based classifiers , AdaBoost-based classifiers are hundreds of times faster .
Compared to SVM-based classifiers or neural network-based classifiers , AdaBoost based classifiers are hundreds of times faster .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact 


-Haar wavelet features used for all stages are informative [22] and can be evaluated extremely quickly due to the introduction of the integral image .
-Thirdly , Haar-wavelet features used for all stages are informative [22] and evaluated extremely fast due to the introduction of the integral image .
-1#3#2#exact -1#4#3#exact -1#5#4#exact -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#12,13#para -1#13#14#exact -1#14#15#para -1#17,18#16,17,18,19#para -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact 


However , this framework still has the following problems :
However , this framework still has the following problems :
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact 


-First , the cascaded classifiers that use AdaBoost and Haar wavelet features are only efficient in quickly rejecting simple non-face patterns .
-First , the cascaded classifiers that use AdaBoost and Haar wavelet features are only efficient in quickly rejecting simple non-face patterns .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact 


To robustly classify complex patterns , it is necessary to use a larger number of features and layer classifiers .
To robustly classify complex patterns , it is necessary to use a larger number of features and layer classifiers .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6,7,8,9#6,7,8#para -1#10,11#9,10,11#para -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact 


This need is apparent because when face and non-face patterns become hard to distinguish , weak classifiers are too weak to boost [22] .
This need is apparent when face and non-face patterns become hard to distinguish , weak classifiers are too weak to boost [22] .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact 


With the first several layers in our experiment ( cf . Figure 1 ) , using some 800 weak classifiers , more than \MATH of non-face patterns were rejected .
With the first several layers in our experiment ( cf. Figure 1 ) , using some 800 weak classifiers , more than \MATH of non-face patterns are rejected .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#syn -1#28#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26,27#27,28#para 


However , enabling the later layers to robustly classify a smaller number of remaining patterns requires many more weak classifiers ( around 5 ,660 ) , thus making the training task much more complicated .
However , turning the later layers into robustly classifying a smaller number of remaining patterns , it requires a lot more , e.g. , 5 ,660 , weak classifiers , thus making the training task much more complicated .
-1#0#0#exact -1#1#1#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#7#7#exact -1#8#8#stem -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#17#15#exact -1#20#17#exact -1#27#18#exact -1#28#19#exact -1#24#22#exact -1#25#23#exact -1#15#25#exact -1#30#26#exact -1#31#27#exact -1#32#28#exact -1#33#29#exact -1#34#30#exact -1#35#31#exact -1#36#32#exact -1#37#33#exact -1#38#34#exact 


-Second , the training process is complicated .
-Second , the training process is complicated .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact 


It requires a long time because the training time is proportional to the number of features in the input feature set ( which is normally hundreds of thousands ) and the number of training samples ( which is generally tens of thousands ) .
Firstly , it requires a long training time because the training time is proportional to the number of features in the input feature set ( which is normally hundreds of thousands ) and the number of training samples ( which is generally tens of thousands ) .
-1#2#0#lc -1#3#1#exact -1#4#2#exact -1#5#3#exact -1#7#4#exact -1#8#5#exact -1#9#6#exact -1#10#7#exact -1#11#8#exact -1#12#9#exact -1#13#10#exact -1#14#11#exact -1#15#12#exact -1#16#13#exact -1#17#14#exact -1#18#15#exact -1#19#16#exact -1#20#17#exact -1#21#18#exact -1#22#19#exact -1#23#20#exact -1#24#21#exact -1#25#22#exact -1#26#23#exact -1#27#24#exact -1#28#25#exact -1#29#26#exact -1#30#27#exact -1#31#28#exact -1#32#29#exact -1#33#30#exact -1#34#31#exact -1#35#32#exact -1#36#33#exact -1#37#34#exact -1#38#35#exact -1#39#36#exact -1#40#37#exact -1#41#38#exact -1#42#39#exact -1#43#40#exact -1#44#41#exact -1#45#42#exact -1#46#43#exact 


In our experiment , with 20 ,000 training samples and 134 ,736 features , the average training time for choosing one feature associated with the weak classifier was about 30 minutes on a PC ( Pentium 4 , 2 .8 MHz , 512-MB RAM ) .
In our experiment , with 20 ,000 training samples and 134 ,736 features , the average training time for choosing one feature associated with the weak classifier is about 30 minutes on a PC ( Pentium 4 , 2 .8 MHz , 512-MB RAM ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27,28#27,28#para -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact -1#37#37#exact -1#38#38#exact -1#39#39#exact -1#40#40#exact -1#41#41#exact -1#42#42#exact -1#43#43#exact -1#44#44#exact -1#45#45#exact 


Therefore , training a cascade of classifiers with around 6 ,060 features [1] might take on the order of several weeks .
Therefore , training a cascade of classifiers with around 6 ,060 features [1] might take in order of several weeks .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15,16,17#15,16,17,18#para -1#18#19#exact -1#19#20#exact -1#20#21#exact 


Another thing that complicates the training process is that AdaBoost-based classifiers are constructed by adding features after each round of boosting , so several training parameters must be tuned manually while training .
Secondly , AdaBoost-based classifiers are constructed by adding features after each round of boosting , so several training parameters must be tuned manually while training .
-1#24#5#exact -1#2#9#exact -1#3#10#exact -1#4#11#exact -1#5#12#exact -1#6#13#exact -1#7#14#exact -1#8#15#exact -1#9#16#exact -1#10#17#exact -1#11#18#exact -1#12#19#exact -1#13#20#exact -1#14#21#exact -1#15#22#exact -1#16#23#exact -1#17#24#exact -1#18#25#exact -1#19#26#exact -1#20#27#exact -1#21#28#exact -1#22#29#exact -1#23#30#exact -1#25#32#exact 


In practice , for stopping training a classifier , at least the following three parameters must be determined in advance : minimum detection rate , maximum false positive rate , and maximum number of boosting rounds ( or the number of weak classifiers of each layer ) .
In practice , for stopping training a classifier , at least the following three parameters must be determined in advance : minimum detection rate , maximum false positive rate , and maximum number of boosting rounds ( or the number of weak classifiers of each layer ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact -1#37#37#exact -1#38#38#exact -1#39#39#exact -1#40#40#exact -1#41#41#exact -1#42#42#exact -1#43#43#exact -1#44#44#exact -1#45#45#exact -1#46#46#exact -1#47#47#exact 


Because the complexity of the training sets varies throughout the layers in the cascade , a way to choose these parameters automatically and optimally has not been determined .
Because the complexity of the training sets varies through layers in the cascade , it is undetermined how to choose these parameters automatically and optimally .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#para -1#11#9#exact -1#9#10#exact -1#10#11#exact -1#12#13#exact -1#13#14#exact -1#17,18#15,16,17#para -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact -1#23#22#exact -1#24#23#exact -1#15#24#para -1#25#28#exact 


For example , in the first layers , it is quite easy to train a classifier with a minimum detection rate of \MATH and a maximum false-positive rate of \MATH .
For example , in the first layers , it is quite easy to train a classifier with a minimum detection rate of \MATH and a maximum false-positive rate of \MATH .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact 


However , in later layers , choosing the detection rate of \MATH will give a false positive rate greater than \MATH [22] .
However , in later layers , choosing the detection rate of \MATH will give a false positive rate greater than \MATH [22] .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact 


Adding more features directly increases computation time and might cause over-fitting .
Adding more features directly increases computation time and might cause over-fitting .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact 


The authors therefore propose a multi-stage approach to build a face-detection system by adopting the advantages of Viola and Jones' approach and by introducing a method to address the above problems .
The authors therefore propose a multi-stage approach to build a face-detection system by adopting the advantages of Viola and Jones' approach and by introducing a method to address the above problems .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact 


Specifically , for quick rejection of non-face patterns , we have reused two key ingredients of Viola and Jones' system , that is , the cascaded structure of simple-to-complex classifiers and AdaBoost trained with Haar wavelet features .
Specifically , for quick rejection of non-face patterns , we reuse two key ingredients of Viola and Jones' system , that is , the cascaded structure of simple-to-complex classifiers and AdaBoost trained with Haar-wavelet features .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#34#10#syn -1#10#11#stem -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact -1#28#29#exact -1#29#30#exact -1#30#31#exact -1#31#32#exact -1#32#33#exact -1#35#37#exact 


Furthermore , for robust classification and simple training , we propose using SVM classifiers for later layers .
Furthermore , for robust classification and simple training , we propose using SVM classifiers for later layers .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact 


The contribution of this approach is threefold :
The contribution of this approach is three fold :
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#para -1#8#7#exact 


-First , to detect the face candidate regions , a new stage ( using a larger window size and a larger moving step size ) has been added .
-First , to detect the face candidate regions , a new stage ( using a larger window size and a larger moving step size ) is added .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25,26#para -1#26#27#exact -1#27#28#exact 


We use 36 x 36-pixel window-based classifiers with a moving step size of 12 pixels to quickly estimate the candidate face regions .
We use 36 x 36-pixel window-based classifiers with a moving step size of 12 pixels , to quickly estimate the candidate face regions .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact -1#23#22#exact 


The idea of using larger windows and moving the step size was adopted in [5] , but it severely degraded performance .
The idea of using larger windows and moving the step size was adopted in [5] , but it severely degraded performance .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact 


To improve speed while maintaining high accuracy , our approach takes advantage of the combination of the Haar wavelet features and the AdaBoost learning for fast and robust evaluation .
To improve speed while maintaining high accuracy , our approach takes advantage of the combination of the Haar wavelet features and the AdaBoost learning for fast and robust evaluation
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13,14,15,16#13,14,15#para -1#21#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact 


Second , we have investigated how to efficiently reuse the features selected by AdaBoost in the previous stage for the SVM classifiers of the last stage .
Second , how to efficiently reuse the features selected by AdaBoost in the previous stage , for the SVM classifiers of the last stage , is investigated .
-1#0#0#exact -1#1#1#exact -1#26#4#exact -1#2#5#exact -1#3#6#exact -1#4#7#exact -1#5#8#exact -1#6#9#exact -1#7#10#exact -1#8#11#exact -1#9#12#exact -1#10#13#exact -1#11#14#exact -1#12#15#exact -1#13#16#exact -1#14#17#exact -1#16#18#exact -1#17#19#exact -1#18#20#exact -1#19#21#exact -1#20#22#exact -1#21#23#exact -1#22#24#exact -1#23#25#exact -1#27#26#exact 


Reusing these features brings two advantages : ( i ) Haar wavelet features are very fast in being evaluated and normalized [1] .
Reusing these features brings to two advantages : ( i ) Haar wavelet features are very fast in evaluating and normalizing [1] .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#5#4#exact -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#18#stem -1#19#19#exact -1#20#20#stem -1#21#21#exact -1#22#22#exact 


Furthermore , these features do not need to be re-evaluated because they have already been evaluated .
Furthermore , it is unnecessary to re-evaluate these features because they have been previously evaluated .
-1#0#0#exact -1#1#1#exact -1#7#2#exact -1#8#3#exact -1#3,4#4,5,6#para -1#5#7#exact -1#6#9#stem -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13,14#para -1#14#15#exact -1#15#16#exact 


( ii ) By using SVM classifiers with powerful generalization , using too many features in the cascade is avoided , with the important results of saving training time and avoiding over-fitting .
( ii ) By using SVM classifiers with powerful generalization , using too many features in the cascade is avoided , therefore importantly training time is saved and over-fitting is avoided .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#22#23#stem -1#23#27#exact -1#24#28#exact -1#27#29#exact -1#28#31#exact -1#31#32#exact 


Third , the training time of AdaBoost classifiers has been shortened by using simple sampling techniques to reduce the number of features in the feature set .
Third , the training time of AdaBoost classifiers is shortened by using simple sampling techniques to reduce the number of features in the feature set .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8,9#para -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#16,17,18,19#16,17,18,19,20#para -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact 


Experiments showed that for rejection , the performance gained by using a sampled feature set was comparable to that of a full feature set .
Experiments will show that for rejection , using a full feature set and a sampled feature set gives the comparable performance .
-1#0#0#exact -1#2#1#stem -1#3#2#exact -1#4#3#exact -1#5#4#exact -1#6#5#exact -1#18#6#exact -1#20#7#exact -1#7,8#9,10,11#para -1#14#12#exact -1#15#13#exact -1#16#14#exact -1#19#16#exact -1#13#20#exact -1#9#21#exact -1#10#22#exact -1#11#23#exact -1#21#24#exact 


Along with using several SVM classifiers instead of many AdaBoost classifiers in later layers , the total training time has been significantly reduced .
Along with using several SVM classifiers instead of many AdaBoost classifiers in later layers , the total training time is reduced significantly .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19,20#para -1#21#21#exact -1#20#22#exact -1#22#23#exact 


Several studies have worked on addressing the drawbacks of Viola and Jones' system .
There have been several studies working on how to handle the drawbacks of Viola and Jones' system .
-1#3#0#lc -1#4#1#exact -1#1#2#exact -1#5#3#stem -1#6#4#exact -1#9#5#syn -1#10#6#exact -1#11#7#exact -1#12#8#exact -1#13#9#exact -1#14#10#exact -1#15#11#exact -1#16#12#exact -1#17#13#exact 


Wu et al. [23] used direct feature selection to reduce training time while maintaining comparable performance .
Wu et al. [23] used direct feature selection to reduce training time while maintaining comparable performance .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact 


Their idea is to separate the training process into two stages : feature selection and classifier construction .
Their idea is to separate the training process into two stages : feature selection and classifier construction .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact 


In Viola and Jones' work , features are selected by the discriminative performance of their associated weak classifiers through the boosting process .
In Viola and Jones' work , features are selected by the discriminative performance of their associated weak classifiers through the boosting process .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact 


This process is very time consuming because all weak classifiers must be trained every time one feature is selected .
It is therefore very time consuming because all weak classifiers must be trained every time one feature is selected .
-1#1#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact 


With the new proposal of Wu et al. , weak classifiers are trained only once and features are selected by the direct feature selection method , which directly maximizes the learning objective of the output classifier .
With their new proposal , weak classifiers are trained only once and features are selected by the direct feature selection method that directly maximizes the learning objective of the output classifier .
-1#0#0#exact -1#16#1#exact -1#2#2#exact -1#3#3#exact -1#27#4#exact -1#4#8#exact -1#5#9#exact -1#6#10#exact -1#7#11#exact -1#8#12#exact -1#9#13#exact -1#10#14#exact -1#11#15#exact -1#12#16#exact -1#13#17#exact -1#14#18#exact -1#15#19#exact -1#24#20#exact -1#17#21#exact -1#18#22#exact -1#19#23#exact -1#20#24#exact -1#21,22#26,27#para -1#23#28#exact -1#28#29#exact -1#25#30#exact -1#26#31#exact -1#29#33,34#para -1#30#35#exact -1#31#36#exact 


They claim that their method is 100 times faster than Viola and Jones' method .
They claim that their method is 100 times faster than Viola and Jones' method .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact 


Another direction is to optimally build the cascade to improve its overall performance .
Another direction is to optimally build the cascade to improve the overall performance of the cascade .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9,10#9,10#para -1#11#11#exact -1#12#12#exact -1#16#13#exact 


Sun et al. [24] and [25] proposed a scheme to optimally tune parameters in layer classifiers .
Sun et al. [24] and [25] propose a scheme to optimally tune parameters in layer classifiers .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#stem -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact 


However , their approach is somewhat complicated and is not easy to implement .
However , their approach is somewhat complicated and is not easy to implement .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8,9,10#8,9,10,11#para -1#12#12#exact -1#13#13#exact 


Xiao et al. [20] and Huang et al. [11] proposed a boosting chain structure in which subsequent layers utilize the historical information of the previous layers .
Xiao et al. [20] and Huang et al. [11] propose the boosting chain structure in which subsequent layers utilize historical information of previous layers .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#stem -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#10#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23,24#para -1#23#25#exact -1#24#26#exact 


This significantly reduces the number of features used in each layer .
This significantly reduces the number of features used in each layer .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact 


Discrete AdaBoost uses a binary weak classifier that is too weak to boost in the case of a hard distinguished dataset .
Discrete AdaBoost uses a binary weak classifier that is too weak to boost in the case of the hard distinguished dataset .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13,14,15,16,17#13,14,15,16#para -1#18#17,18#para -1#19#19#exact -1#20#20#exact -1#21#21#exact 


Studies based on RealBoost [26] , such as [12] , [10] , [27] , and [11] , introduced new kinds of weak classifiers that are stronger than binary weak classifiers .
Studies based on RealBoost [26] , such as [12] ,[10] ,[27] ,[11] , introduced new kinds of weak classifiers that are stronger than binary weak classifiers .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#12#9#exact -1#13#17#exact -1#14#18#exact -1#15#19#exact -1#16#20#exact -1#17#21#exact -1#18#22#exact -1#19#23#exact -1#20#24#exact -1#21#25#exact -1#22#26#exact -1#23#27#exact -1#24#28#exact -1#25#29#exact -1#26#30#exact 


These new real-valued weak classifiers can effectively discriminate face and non-face distributions , so the total number of features used is also reduced dramatically .
New real-valued weak classifiers can effectively discriminate face and non-face distributions and , in consequence , the total number of features used also reduces dramatically .
-1#0#1#lc -1#1#2#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#12#12#exact -1#16,17,18,19#14,15,16#para -1#20#18#exact -1#21#19#exact -1#22#20,21#para -1#23#22#stem -1#24#23#exact -1#25#24#exact 


Face detection systems such as [27] and [11] only use around 800 features .
Face detection systems such as [27] ,[11] only use around 800 features .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact 


However , the main problem with these systems is how to choose the most appropriate number of bins .
However , the main problem with these systems is how to choose the most appropriate number of bins .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact 


A small number of bins might not accurately approximate the real distribution , while a large number of bins might cause over-fitting , increase computation time , and waste storage space .
Small number of bins might not well approximate the real distribution while large number of bins might cause over-fitting , increase computation time and waste storage space .
-1#0#1#lc -1#1#2#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#19#12#exact -1#11#13#exact -1#12,13,14#14,15,16,17#para -1#15#18#exact -1#16#19#exact -1#17#20#exact -1#18#21#exact -1#20#23#exact -1#21#24#exact -1#22#25#exact -1#23#27#exact -1#24#28#exact -1#25#29#exact -1#26#30#exact -1#27#31#exact 


However , our system can benefit from this approach when building the rejection stage and can thus reduce the training time even further .
Actually , our system can benefit from this approach when building the rejection stage and thus also reduce the training time much more .
-1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#16#22#para -1#23#23#exact 


The proposed face detection system consists of three stages that classify a 24x24-pixel window as either a face or a non-face .
The proposed face detection system consists of three stages that classify a 24x24 pixel window as either a face or a non-face .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact 


To detect faces of different sizes and locations , the detector is applied at every location and scale in the input image with a scale factor of 1 .2 , which is similar to other approaches [5] , [6] , [9] .
To detect faces of different sizes and locations , the detector is applied at every location and scale in the input image with a scale factor of 1 .2 , which is similar to the other approaches [5] ,[6] ,[9] .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#31,32,33,34#30,31,32,33#para -1#35#34#exact -1#36#35#exact -1#37#36#exact -1#40#41#exact 


An outline of this system is given in Figure 2 .
An outline of this system is given in Figure 2 .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact 


The first stage is a cascade of classifiers used to estimate face candidate regions by evaluating 36x36 input windows , with a moving step of 12 pixels .
The first stage is a cascade of classifiers used to estimate face candidate regions by evaluating 36x36 input windows , with a moving step of 12 pixels .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact 


If a 36x36-pixel window is detected as the existence of a face , 144 ( i.e. , 12x12 ) likely face positions are collected and passed to the next stage .
If a 36x36 window is detected as the existence of a face , 144 ( i.e. 12x12 ) likely face positions are collected and passed to the next stage .
-1#0#0#exact -1#1#1#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7,8,9#7,8,9,10#para -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact -1#28#29#exact -1#29#30#exact 


The second stage is a cascade of classifiers used to investigate 24x24 window face candidate locations returned from the previous stage .
The second stage is a cascade of classifiers used to investigate 24x24 window face candidate locations returned from the previous stage .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact 


The main purpose of designing these two stages is trying to filter out a large number of non-face patterns as quickly as possible before passing complex patterns to the final stage classifier .
The main purpose of designing these two stages is trying to filter out a large number of non-face patterns as quick as possible before passing complex patterns to the final stage classifier .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#14,15,16#13,14,15,16#para -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#stem -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact 


This is done by taking advantage of Viola and Jones' approach [1] , in which Haar wavelet features and the cascaded AdaBoost classifiers enable extremely fast computation .
This is done by taking advantages of Viola and Jones' approach [1] , in which Haar wavelet features and the cascaded AdaBoost classifiers are extremely fast in computation .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5,6#5,6#para -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#24#24#exact -1#25#25#exact -1#27#26#exact -1#28#27#exact 


Although the cascade of \MATH AdaBoost classifiers rejects non-face patterns rapidly , it is still influenced by the large number of \MATH patterns that it must process .
Although the cascade of \MATH AdaBoost classifiers rejects non-face patterns rapidly , it is still influenced by the large number of \MATH patterns that it must process .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17,18,19#17,18,19,20#para -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact 


For this reason , the first stage , which is a cascade of \MATH classifiers , is added is to decrease the number of analyzed patterns .
The reason why the fist stage , which is a cascade of \MATH classifiers , is added is to decrease the number of analyzed patterns .
-1#1#2#exact -1#14#3#exact -1#3#4#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact 


To this end , this stage is trained specially to make the classifiers invariant to small face translations .
To this end , this stage is trained specially to make the classifiers invariant to small face translations .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact 


These classifiers can detect faces that are off-center by up to six pixels in any direction .
These classifiers can detect faces that are off-center by up to six pixels in any direction .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact 


An illustration of the difference between 24x24 and \MATH face training samples is depicted in Figure 3 .
An illustration of the difference between 24x24 and \MATH face training samples is depicted in Figure 3 .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact 


The \MATH window is chosen in accordance with the idea in [5] that the classifier can be trained to be invariant to translation by up to \MATH of the original window size .
The \MATH window is chosen in accordance with the idea from [5] stated that the classifier can be trained to be invariant to translation by up to \MATH of original window size .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5,6,7,8#5,6,7#para -1#14#8#exact -1#9,10#9,10#para -1#11#11#exact -1#13#12#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact -1#23#22#exact -1#24#23#exact -1#25#24#exact -1#26#25#exact -1#27#26#exact -1#28#27#exact -1#29#28,29#para -1#30#30#exact -1#31#31#exact -1#32#32#exact 


With this flexible classifier , the moving step size can be increased up to 12 pixels to dramatically reduce the number of analyzed patterns .
With this flexible classifier , the moving step size can be increased up to 12 pixels that reduce dramatically number of analyzed patterns .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#18#17#exact -1#17#18#exact -1#19,20#19,20,21#para -1#21#22#exact -1#22#23#exact -1#23#24#exact 


The efficiency of this stage will be discussed further in section 6 .3 .
Efficiency of this stage will be discussed further in section 6 .3 .
-1#0#1#lc -1#1#2#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact 


The last stage is a cascade of nonlinear SVM classifiers that reuses features that have been selected by AdaBoost in the second stage classifier .
The last stage is a cascade of non-linear SVM classifiers that reuses features that have been selected by AdaBoost in the second stage classifier .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact 


These feature values are evaluated and scaled to be between 0 and 1 to form a feature vector .
These feature values are evaluated and scaled to be between 0 and 1 to form a feature vector .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact 


In our experiments , only 100 features were used , making classification faster than it would have been using pixel-based SVM classifiers [8] , [9] .
In our experiments , only 100 features are used and hence it is faster than using any pixel-based SVM classifiers [8] ,[9] .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7,8#7,8#para -1#13#12#exact -1#14#13#exact -1#11#14#exact -1#12#17#syn -1#15#18#exact -1#17#19#exact -1#18#20#exact -1#19#21#exact -1#20#22#exact -1#22#25#exact 


The same feature set proposed in [1] was used ( cf . Figure 4 ) .
The same feature set as proposed in [1] is used ( cf. Figure 4 ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#5#4#exact -1#6#5#exact -1#7#6#exact -1#8,9#7,8#para -1#10#9#exact -1#11#10#syn -1#15#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact 


It consists of four kinds of features modeled from adjacent basic rectangles of the same size and shape .
It consists of four kinds of features modeled from adjacent basic rectangles with the same size and shape .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#13,14,15#12,13,14,15#para -1#16#16#exact -1#17#17#exact -1#18#18#exact 


The feature value is defined as the difference of the sum of the pixels within rectangles .
The feature value is defined as the difference of sum of the pixels within rectangles .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#11#9#exact -1#9#10#exact -1#10#11#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact 


Each feature is parameterized by four parameters : the position within the window \MATH , the width \MATH , and the height \MATH ( cf . Figure 5 ) .
Each feature is parameterized by four parameters : the position within the window \MATH , width \MATH and height \MATH ( cf. Figure 5 ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#16#exact -1#16#17#exact -1#17#19#exact -1#18#20,21#para -1#19#22#exact -1#20#23#exact -1#21#24#syn -1#25#25#exact -1#22#26#exact -1#23#27#exact -1#24#28#exact 


By using integral image definition [1] , the feature values of these rectangles can be computed extremely quickly .
By using integral image definition [1] , these rectangle feature values can be computed extremely quickly .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#9#8#exact -1#10#9#exact -1#7#11#exact -1#8#12#stem -1#11#13#exact -1#12#14#exact -1#13#15#exact -1#14#16#exact -1#15#17#exact -1#16#18#exact 


The integral image at location \MATH is defined as \MATH , where \MATH is the integral image and \MATH is the original image .
The integral image at location \MATH is defined as \MATH , where \MATH is the integral image and \MATH is the original image .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact 


In practice , \MATH can be computed simply by using the following recurrent function :\MATH , and sum of the pixels within a rectangle can be computed from four integral image values of its vertices , for example , \MATH .
In practice , \MATH can be computed simply by using the following recurrent function :\MATH , and sum of the pixels within a rectangle can be computed from four integral image values of its vertices , for example , \MATH .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact -1#37#37#exact -1#38#38#exact -1#39#39#exact -1#40#40#exact 


Boosting is used to improve the classification performance of any given simple learning algorithm [28] .
Boosting is used to improve the classification performance of any given simple learning algorithm [28] .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact 


Given \MATH weak classifiers \MATH learned through \MATH rounds of boosting , the strong classifier is formed by a linear combination : \MATH , where \MATH are coefficients found in the boosting process .
Given \MATH weak classifiers \MATH learned through \MATH rounds of boosting , the strong classifier is formed by a linear combination : \MATH where \MATH are coefficients found in the boosting process .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact -1#28#29#exact -1#29#30#exact -1#30#31#exact -1#31#32#exact -1#32#33#exact 


Each weak classifier \MATH is associated with a feature \MATH and a threshold \MATH such that the number of incorrectly classified examples corresponding to the weak classifier is minimized : \MATH , where polarity \MATH indicates the direction of the inequality sign .
Each weak classifier \MATH is associated with a feature \MATH and a threshold \MATH such that the number of incorrect classified examples corresponding to this weak classifier is minimized : \MATH , where polarity \MATH indicates the direction of the inequality sign .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#16,17,18#15,16,17,18#para -1#19#19#stem -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#36#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#37,38,39#36,37,38,39#para -1#40#40#exact -1#41#41#exact -1#42#42#exact 


In each round of boosting , the best weak classifier \MATH that has the lowest error \MATH will be chosen .
In each round of boosting , the best weak classifier \MATH that has the lowest error \MATH will be chosen .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact 


The error of each weak classifier is measured with respect to the set of weights over each example of the training set \MATH , where \MATH and \MATH are the respective weight and label of the training example \MATH .
The error of each weak classifier is measured with respect to the set of weights over each example of the training set \MATH , where \MATH and \MATH are the weight and the label of the training example \MATH , respectively .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#40#30#stem -1#30#31#exact -1#31#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact -1#37#37#exact -1#38#38#exact -1#41#39#exact 


After each round , these weights are updated such that the weak learner will focus much more on the hard examples in the next round .
After each round , these weights are updated such that the weak learner will focus much more on the hard examples in the next round .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#22,23,24#21,22,23,24#para -1#25#25#exact 


The main idea of building a cascade of classifiers is to reduce the computation time by giving different treatments to different complexities of input windows ( cf .
The main idea of building a cascade of classifiers is to reduce the computation time by giving different treatments to different complexities of input windows ( cf .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact 


Figure 7 ) .
Figure 7 ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact 


Only input windows that have passed through all layers of the cascade are classified as faces .
Only input windows that have passed through all layers of the cascade are classified as faces .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact 


Training cascaded classifiers that can achieve both good detection rates and less computation time is quite complex ; a higher detection rate requires more features , but more features correspond to more time needed for evaluation .
Training cascaded classifiers that can achieve both good detection rate and less computation time is quite complex , because a higher detection rate requires more features , but more features are correspondent to more time for evaluation .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9,10#9,10#para -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact -1#23#22#exact -1#24#23#exact -1#25#24#exact -1#26#25#exact -1#27#26#exact -1#28#27#exact -1#29#28#exact -1#30#29#para -1#32#30#exact -1#33#31#exact -1#34#32#exact -1#35#34#exact -1#36#35#exact -1#37#36#exact 


To simplify this , the detection rate goal and the false positive rate goal for each layer are usually set beforehand .
To simplify this , the detection rate goal and the false positive rate goal for each layer are usually set beforehand .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact 


Viola and Jones [1] stated that , if the layer classifier has achieved the predefined target goals after 200 features are used , the training process will stop and a new layer will be added .
Viola and Jones [1] stated that , if the layer classifier could achieve the predefined target goals after 200 features are used , the training process will stop and a new layer will be added .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#19#11#syn -1#12#12#stem -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact 


1 .	<section label= " SVM Classifier " >
1 .	<section label= " SVM Classifier " >
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact 


The support vector machine is a statistical learning method based on the structure-risk minimization principle .
The support vector machine is a statistical learning method based on the structure-risk minimization principle .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact 


It has been very efficiently proven in many pattern recognition applications [29] , [8] , [9] .
It has been very efficiently proved in many pattern recognition applications [29] ,[8] ,[9] .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#syn -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#14#16#exact 


In the binary classification case , the objective of the SVM is to find the best separating hyperplane with a maximum margin .
In the binary classification case , the objective of the SVM is to find the best separating hyperplane with a maximum margin .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6,7,8,9#6,7,8#para -1#14#9#exact -1#10#10#exact -1#11,12,13#11,12,13,14#para -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact 


The form of SVM classifiers is : \MATH where \MATH is the d-dimensional vector of an observation example , \MATH is a class label , and \MATH is the vector of the \MATH training example .
The form of SVM classifiers is : \MATH where : \MATH is the d-dimensional vector of an observation example , \MATH is a class label , and \MATH is the vector of the \MATH training example .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact -1#23#22#exact -1#24#23#exact -1#25#24#exact -1#26#25#exact -1#27#26#exact -1#28#27#exact -1#29#28#exact -1#30#29#exact -1#31#30#exact -1#32#31#exact -1#33#32#exact -1#34#33#exact -1#35#34#exact -1#36#35#exact 


All the \MATH corresponding to non-zero \MATH are called support vectors .
All the \MATH corresponding to non-zero \MATH are called support vectors .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact 


It is important to choose the appropriate kernel and parameter \MATH in order to obtain the robust SVM classifier .
It is important to choose the appropriate kernel and parameter \MATH in order to to obtain the robust SVM classifier .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#14,15#11,12,13,14#para -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact 


Although many kernels have been introduced by researchers , the following four kernels are commonly used : \MATH where \MATH , and \MATH are kernel parameters .
Although many kernels have been introduced by researchers , the following four kernels are commonly used : \MATH where \MATH and \MATH are kernel parameters .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact 


Compared to AdaBoost classifiers , SVM classifiers run much more slowly because of the large number of support vectors and the heavy kernel computation .
Compared to AdaBoost classifiers , SVM classifiers run much slower in running because of the large number of support vectors and heavy kernel computation .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9,10#para -1#12#11#exact -1#14,15,16,17#12,13,14,15,16#para -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20,21#para -1#22#22#exact -1#23#23#exact -1#24#24#exact 


To control the trade-off between the number of support vectors and errors , Scholkopf et al. [30] proposed using a new parameter \MATH instead of the parameter \MATH .
To control the trade-off between the number of support vectors and errors , Scholkopf et al. [30] proposed using a new parameter \MATH instead of the parameter \MATH .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact 


They proved that the parameter \MATH is an upper bound of the fraction of margin errors and a lower bound of the fraction of support vectors .
They proved that the parameter \MATH is an upper bound of the fraction of margin errors and a lower bound of the fraction of support vectors .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact 


The implementations of \MATH and \MATH are provided by LibSVM [31] .
The implementations of \MATH and \MATH are provided by LibSVM [31] .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact 


For training , we collected 7 ,500 , 24x24-size face patterns from the Internet . / / size / pixel?
For training , we collected 7 ,500 , 24x24-size face patterns from the Internet .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact 


Non-face patterns were generated at different locations and scales from 8 ,440 images with various subjects , such as rocks , trees , buildings , scenery , and flowers , containing no faces .
Non-face patterns were generated at different locations and scales from 8 ,440 images with various subjects , such as rocks , trees , buildings , scenery , and flowers , containing no faces .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact 


Some examples of the collected 24x24 face patterns are shown in Figure 8 .
Some examples of the collected 24x24 face patterns are shown in Figure 8 .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact 


Face patterns for training the 36x36 classifiers were generated by selecting 36x36 windows containing the 24x24 face window of the input image .
Face patterns for training the 36x36 classifiers are generated by selecting 36x36 windows containing the 24x24 face window of the input image .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7,8#7,8#para -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact 


Figure 9 shows some examples of 36x36 face patterns that include various kinds of floating positions and backgrounds .
Figure 9 shows some examples of 36x36 face patterns that include various kinds of floating positions and backgrounds .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact 


To train the cascade of 24x24 AdaBoost classifiers used in the rejection stage , the same 7 ,500 face patterns were used for all layers .
To train the cascade of 24x24 AdaBoost classifiers used in the rejection stage , the same 7 ,500 face patterns are used for all layers .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20,21#20,21#para -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact 


Non-face patterns of the training and the validating sets of the first layer in the cascade were selected randomly .
Non-face patterns of the training and the validating sets of the first layer in the cascade are selected randomly .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3,4,5,6#3,4,5#para -1#14#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#15#15#exact -1#16,17#16,17#para -1#18#18#exact -1#19#19#exact 


Non-face patterns of the subsequent layer classifiers are false positives collected by the partially trained cascade on the set of non-face images .
Non-face patterns of the subsequent layer classifiers are false positives collected by the partially trained cascade on the set of non-face images .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact 


For each layer classifier , 7 ,500 non-face patterns were used for training and 7 ,500 other non-face patterns were used for validating .
For each layer classifier , 7 ,500 non-face patterns are used for training and 7 ,500 other non-face patterns are used for validating .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9,10#9,10#para -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19,20#19,20#para -1#21#21#exact -1#22#22#exact -1#23#23#exact 


To compare the performance of classifiers , we implemented a full cascade of classifiers trained by AdaBoost , similar to that used by Viola and Jones [1] .
To compare the performance of classifiers , we have implemented a fully cascade of classifiers trained by AdaBoost , similar to that used by Viola and Jones [1] .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#syn -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact -1#23#22#exact -1#24#23#exact -1#25#24#exact -1#26#25#exact -1#27#26#exact -1#28#27#exact 


The training parameters of each layer were set as follows .
The training parameters of each layer were set as follows .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact 


The minimum of the detection rate was \MATH , the maximum of the false positive rate was \MATH , and the maximum of the number of features in each layer was 200 .
The minimum of the detection rate is \MATH , the maximum of the false positive rate is \MATH and the maximum of the number of features in each layer is 200 .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#15,16#6#para -1#17#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#6#15,16#para -1#7#17#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21,22,23,24#22,23,24#para -1#25#26#exact -1#26#27#exact -1#27#28#exact -1#28#29#exact -1#29#30#syn -1#30#31#exact -1#31#32#exact 


This setting resulted in a face detector that consists of 38 layers with 6 ,360 features .
This setting resulted in a face detector that consists of 38 layers with 6 ,360 features .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact 


All experiments were run on a PC ( Pentium 4 , 2 .8 MHz , 512-MB RAM ) .
All experiments were run on a PC ( Pentium 4 , 2 .8 MHz , 512-MB RAM ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact 


The training process was terminated when no more false positives were found in the non-face images of the data set .
The training process was terminated when no more false positives were found in the non-face images of the data set .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact 


If \MATH is the number of Haar wavelet features and \MATH is the number of training patterns , the learning time of AdaBoost to train \MATH weak classifiers is roughly [1] .
If \MATH is the number of Haar wavelet features and \MATH is the number of training patterns , the learning time of AdaBoost to train \MATH weak classifiers is roughly[1] .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#30#31#exact 


Therefore , if the number of training patterns is fixed , the learning time can be shortened when either the number of features in the feature set or the number of weak classifiers in the final cascade is reduced .
Therefore , if the number of training patterns is fixed , the learning time can be shortened when either the number of features in the feature set or the number of weak classifiers in the final cascade is reduced .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact -1#37#37#exact -1#38#38#exact -1#39#39#exact 


In our approach , the cascaded classifiers are only used for efficient rejection , so we can reduce both of these numbers in order to keep the training time for the full system reasonable .
In our approach , the cascaded classifiers are only used for efficient rejection , so we can reduce both these numbers in order to keep training time for the full system reasonable .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#20#exact -1#20#21#exact -1#23,24#22,23,24,25#para -1#28#26#exact -1#25#27#exact -1#26#28#exact -1#27#29#exact -1#29#30,31#para -1#30#32#exact -1#31#33#exact -1#32#34#exact 


As mentioned in section 4 .1 , each feature is parameterized by a tuple of four parameters \MATH . / / If this ( and other places ) do not display with spaces after the commas , spaces must be insert . A comma should always be followed by a space . I recommend checking this carefully throughout .]
As mentioned in section 4 .1 , each feature is parameterized by a tuple of four parameters \MATH .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact 


A set of features is then formed by changing these parameters in corresponding steps \MATH .
A set of features is then formed by changing these parameters in correspondent steps \MATH .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#stem -1#13#13#exact -1#14#14#exact -1#15#15#exact 


A feature set , on the other hand , is parameterized by \MATH .
In the other hand , a feature set is parameterized by \MATH .
-1#5#0#lc -1#6#1#exact -1#7#2#exact -1#4#3#exact -1#1#5#exact -1#2#6#exact -1#3#7#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact 


One of the simplest ways to sub-sample the feature set is to change parameters \MATH , for example , from a full feature set \MATH to a reduced feature set \MATH .
One of the simplest ways to sub-sample the feature set is to change parameters \MATH , for example , from a full feature set \MATH to a reduced feature set \MATH .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact 


Because the full feature set is redundant , this sub-sampling is expected not to significantly affect the rejection performance of AdaBoost classifiers .
Because the full feature set is redundant , this sub-sampling is expected not to affect the rejection performance of AdaBoost classifiers significantly .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#21#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#22#22#exact 


We carried out experiments to compare the performance of classifiers trained on these two feature sets : the full feature set \MATH , containing 134 ,736 features and the reduced feature set \MATH , containing 14 ,807 features ( excluding features of small size ) .
We carried out experiments to compare the performance of classifiers trained on these two feature sets : the full feature set \MATH containing 134 ,736 features and the reduced feature set \MATH containing 14 ,807 features ( excluding features with the small size ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact -1#28#29#exact -1#29#30#exact -1#30#31#exact -1#31#32#exact -1#32#34#exact -1#33#35#exact -1#34#36#exact -1#35#37#exact -1#36#38#exact -1#37#39#exact -1#38#40#exact -1#40,41#41,42#para -1#42#43#exact -1#43#44#exact -1#44#45#exact 


Two classifiers were trained up to the maximum of 200 features .
Two classifiers are trained up to the maximum of 200 features .
-1#0#0#exact -1#1#1#exact -1#2#2#syn -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact 


The classifier 's threshold was changed to meet the detection rate of \MATH .
The classifier 's threshold is changed to meet the detection rate of \MATH .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#syn -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact 


The training set contains 7 ,500 face patterns and 7 ,500 non-face patterns .
The training set contains 7 ,500 face patterns and 7 ,500 non-face patterns .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact 


Rejection performance was evaluated through the false positive rate on a validation test set that contains 500 ,000 non-face patterns .
Rejection performance is evaluated through the false positive rate on a validation test set which contains 500 ,000 non-face patterns .
-1#0#0#exact -1#1#1#exact -1#2#2#syn -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14,15#14,15#para -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact 


All non-face patterns were selected randomly from the training set mentioned above .
All non-face patterns are selected randomly from the training set mentioned above .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3,4#3,4#para -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact 


The results shown in Figure 10 indicate that the performances of these two classifiers were no different , especially when the number of features was large enough , for example , more than 50 .
The result shown in Figure 10 indicates that the performances of these two classifiers are no different , especially when the number of features is large enough , for example , more than 50 .
-1#0#0#exact -1#1#1#stem -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6,7#6,7#para -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14,15#14,15#para -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#syn -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact 


As a result , by using the reduced feature set , the training time can be shortened to approximately one-ninth .
As a result , by using the reduced feature set , the training time can be shortened approximately to one ninth .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#18#17#exact -1#17#18#exact -1#20#19#syn -1#21#20#exact 


Another experiment we conducted showed that , for similar performance , an AdaBoost classifier trained on the reduced feature set that uses larger sampling step sizes requires more features than one trained on the full feature set . / / [Do you need a reference here , or is this still talking about the experiments you report in this paper?]
Our another experiment has shown that , for similar performance , the AdaBoost classifier trained on the reduced feature set that uses larger sampling step sizes requires more features than that trained on the full feature set .
-1#1#0#lc -1#2#1#exact -1#3,4#4#para -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact -1#37#37#exact -1#11#53#exact 


Therefore , only the sampling parameter \MATH was used in training the 24x24 AdaBoost classifiers .
Therefore , only the sampling parameter \MATH was used in training the 24x24 AdaBoost classifiers .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact 


In our system , the first stage is a cascade of classifiers that processes 36x36 patterns with a moving step size of 12 pixels .
In our system , the first stage is a cascade of classifiers that processes 36x36 patterns with a moving step size of 12 pixels .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact 


By taking advantage of simplification in training classifiers only for rejection , as demonstrated in section 6 .2 , training this cascade only uses the feature set generated from a 36x36 window with sampling parameters \MATH .
By taking advantage of simplification in training classifiers only for rejection demonstrated in section 6 .2 , training this cascade only uses the feature set generated from a 36x36 window with sampling parameters \MATH .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#16#11#exact -1#11#13#exact -1#12#14#exact -1#13#15#exact -1#14#16#exact -1#15#17#exact -1#17#19#exact -1#18#20#exact -1#19#21#exact -1#20#22#exact -1#21#23#exact -1#22#24#exact -1#23#25#exact -1#24#26#exact -1#25#27#exact -1#26#28#exact -1#27#29#exact -1#28#30#exact -1#29#31#exact -1#30#32#exact -1#31#33#exact -1#32#34#exact -1#33#35#exact -1#34#36#exact 


As a result , 12 ,223 features are produced .
As a result , 12 ,223 features are produced .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact 


The training set contains 12 ,000 face patterns and 12 ,000 non-face patterns .
The training set contains 12 ,000 face patterns and 12 ,000 non-face patterns .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact 


Since a 36x36 face sample contains a large proportion of background outside the 24x24 face region and the classifier is required to be fast and to keep all possible face regions , a minimum detection rate of \MATH and a maximum of false positive rate of \MATH were set as the training parameters .
Since a 36x36 face sample contains a lot of background outside the 24x24 face region while the classifier is required to be fast and to keep all possible face regions , training parameters are set as follows : the minimum detection rate of \MATH and maximum of false positive rate of \MATH .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7,8#7,8#para -1#42#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#23#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#44#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact -1#28#29#exact -1#29#30#exact -1#30#31#exact -1#38,39#32,33#para -1#40#34#exact -1#41#35#exact -1#46#36#exact -1#43#37#exact -1#45#39,40#para -1#50#41#exact -1#47#42#exact -1#48#43#exact -1#49#44#exact -1#51#46#exact -1#34#47,48#para -1#35#49#exact -1#31#50,51#para -1#32#52#exact -1#52#53#exact 


In our experiments , after reaching 50 features , the classifier 's performance did not significantly increase , so the maximum number of features for each layer is set to 50 .
In our experiments , after reaching 50 features , the classifier 's performance does not significantly increase anymore , so the maximum number of features for each layer is set to 50 .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#14#13,14#para -1#15#15#exact -1#16#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact -1#23#22#exact -1#24#23#exact -1#25#24#exact -1#26#25#exact -1#27#26#exact -1#28#27#exact -1#29#28#exact -1#30#29#exact -1#31#30#exact -1#32#31#exact 


To keep a balance between computation speed and robustness , the maximum number of layers is set to three because using more layers would degrade the overall detection rate dramatically .
To keep a balance between computation speed and robustness , the maximum number of layers is set to three because using more layers would degrade the overall detection rate dramatically .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact 


Figure 11( a ) shows several features of the first 36x36 layer classifier selected by AdaBoost .
Figure 11( a ) shows several features of the first 36x36 layer classifier selected by AdaBoost .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact 


They are somehow similar to the features of the first 24x24 layer classifier as shown in Figure 11( b ) . / / [somehow?This sounds vague . How are they similar?]
It is somehow similar to features of the first 24x24 layer classifier as shown in Figure 11( b ) .
-1#0,1#0,1#para -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#7#5#exact -1#5#6#exact -1#6#7#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact 


In addition , Figure 12 shows an example of face candidate regions estimated by using this cascade .
In addition , Figure 12 shows an example of face candidate regions estimated by using this cascade .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact 


Two main issues surrounding the reuse of features selected by AdaBoost are : ( i ) which layerfs features should be reused for SVM and ( ii ) how many features should be used .
Two main issues surrounding the reuse of features selected by AdaBoost are : ( i ) which layer whose features will be reused for SVM is the best? and ( ii ) How many features should be used?
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#19#18#exact -1#35#19#exact -1#36#20#exact -1#22#21#exact -1#23#22#exact -1#24#23#exact -1#28#24#exact -1#29#25#exact -1#30#26#exact -1#31#27#exact -1#32#28#lc -1#33#29#exact -1#34#30#exact -1#21#32#exact 


For comparison of the performance of SVM classifiers , 2 ,450 face patterns and 7 ,500 non-face patterns that were separated from the training set ( section 6 .1 ) were used .
For comparison of the performance of SVM classifiers , 2 ,450 face patterns and 7 ,500 non-face patterns which are separated from the training set ( section 6 .1 ) were used .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18,19#18,19#para -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact 


The SVM classifiers were trained with a RBF kernel whose parameter \MATH is \MATH .
The SVM classifiers were trained with a RBF kernel whose parameter \MATH is \MATH .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact 


The parameter \MATH was set to \MATH .
The parameter \MATH is set to \MATH .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#syn -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact 


These parameters were found by using a cross-validation test .
These parameters were found by using cross-validation test .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact 


Figure 13 compares the performance of classifiers trained on 200-feature sets selected by different layers in the cascade ( layers 14 , 17 , 20 , and 25 ) .
Figure 13 compares the performance of classifiers trained on 200-feature sets selected by different layers in the cascade ( layers 14 , 17 , 20 , and 25 ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact 


These comparable performances suggest that the second stage ( using AdaBoost ) can be switched to the final stage ( using SVM ) at any time .
These comparable performances suggest that the second stage ( using AdaBoost ) can be switched to the final stage ( using SVM ) at any time .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact 


As a result , the total training time of the system can easily be controlled .
As a result , total training time of the system can be easily controlled .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#8#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#10,11#9,10,11#para -1#12#12#exact -1#13#13,14#para -1#14#15#exact 


To determine the number of features is that would be sufficiently robust , we used the 200-feature set selected in layer 17 to generate different subsets of features with different numbers of features .
To determine how many features is robust enough , we used the 200-feature set selected in layer 17 to generate different subsets of features with different number of features .
-1#0#0#exact -1#1#1#exact -1#11#2#exact -1#26#3#exact -1#27#4#exact -1#28#5#exact -1#5#6#exact -1#6#11#exact -1#8#12#exact -1#9#13#exact -1#10#14#exact -1#12#16#exact -1#13#17#exact -1#14#18#exact -1#15#19#exact -1#16#20#exact -1#17#21#exact -1#18#22#exact -1#19#23#exact -1#20#24#exact -1#21#25#exact -1#22#26#exact -1#23#27#exact -1#24#28#exact -1#25#29#exact -1#4#32#exact -1#29#33#exact 


Features in each set were selected in the order in which they were added in the training process .
Features in each set were selected in the order that they were added in the training process .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7,8#7,8,9,10#para -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact 


For example , a 25-feature set consists of the first 25 features selected by AdaBoost when training layer 17 .
For example , a 25-feature set consists of first 25 features selected by AdaBoost when training layer 17 .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact 


The results shown in Figure 14 indicate that with more than 100 features , the performance of the classifiers was comparable . / / [to what?]
The results shown in Figure 14 indicate that with more than 100 features , the performance of classifiers is comparable .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14,15,16#14,15,16,17#para -1#17#18#exact -1#18#19#syn -1#19#20#exact -1#20#21#exact 


Basically , the speed of a SVM classifier is proportional to the number of features used , so the greater the number of features used , the slower the classifier will be .
Basically , the speed of a SVM classifier is proportional to the number of features used , so the greater number of features used , the slower the classifier will be .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20,21#20,21,22#para -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact -1#28#29#exact -1#29#30#exact -1#30#31#exact -1#31#32#exact 


Figure 15 shows the processing speed of SVM classifiers using different subsets of features .
Figure 15 shows the processing speed of SVM classifiers that uses different subsets of features .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#11#9,10#para -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact 


The SVM classifier using 25 features ran the fastest , while the SVM classifier using 200 features was the slowest .
The SVM classifier using 25 features run fastest while the SVM classifier using 200 features run slowest .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#syn -1#9#7#exact -1#7#8#exact -1#8#10#exact -1#10#12#exact -1#11#13#exact -1#12#14#exact -1#13#15#exact -1#14#16#exact -1#16#18,19#para -1#17#20#exact 


The speeds of SVM classifiers using 100 , 125 , and 175 features were not importantly different because their difference in terms of number of features and number of support vectors were not large enough to have a significant impact .
The speeds of SVM classifiers using 100 , 125 and 175 features are not importantly different because their difference in terms of number of features and number of support vectors is inconsiderable .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12,13#13,14#para -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact -1#28#29#exact -1#29#30#exact -1#30#31#syn -1#32#40#exact 


Therefore , 100 features might be the best trade-off between speed and performance .
Therefore , 100 features might be the best trade-off between the speed and the performance .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10,11,12#10,11#para -1#14#12#exact -1#15#13#exact 


We carried out an experiment to show the efficiency of a single SVM classifier over a cascade of AdaBoost classifiers .
We carried out an experiment to show efficiency of a single SVM classifier over a cascade of AdaBoost classifiers .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7,8#7,8,9#para -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact 


In this experiment , 40 ,000 false positives were gathered by running a cascade of 17 AdaBoost classifiers ( CAB17 ) on the set of non-face images mentioned in section 6 .1 .
In this experiment , 40 ,000 false positives were gathered by running a cascade of 17 AdaBoost classifiers ( CAB17 ) on the set of non-face images mentioned in section 6 .1 .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact 


These false positives then were used as hard non-face patterns to train and test the performance of two classifiers : a single RBF SVM classifier and a cascade of other 18 AdaBoost classifiers .
These false positives then were used as hard non-face patterns to train and test the performance of two classifiers : a single RBF SVM classifier and a cascade of other 18 AdaBoost classifiers .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact 


Of 40 ,000 non-face patterns , 7 ,500 non-face patterns were used along with 7 ,500 face patterns to train these two classifiers .
Of 40 ,000 non-face patterns , 7 ,500 non-face patterns were used along with 7 ,500 face patterns to train these two classifiers .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact 


The remaining 34 ,000 non-face patterns and other 2 ,450 face patterns were used to compare the accuracy of the classifiers .
The remaining 34 ,000 non-face patterns and other 2 ,450 face patterns were used to compare the accuracy .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#21#exact 


The cascade of AdaBoost classifiers were trained with the parameters set as in section 6 .1 .
The cascade of AdaBoost classifiers were trained with the parameters set as in section 6 .1 .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact 


The RBF SVM classifier reused 100 features selected by the last layer of CAB17 as the feature vector and was trained by an RBF kernel whose parameter \MATH is \MATH .
The RBF SVM classifier reused 100 features selected by the last layer of CAB17 as the feature vector and was trained by a RBF kernel whose parameter \MATH is \MATH .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact 


The parameter \MATH was set to \MATH .
The parameter \MATH is set to \MATH .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#syn -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact 


These parameters were found by using a cross-validation test .
These parameters are found by using cross-validation test .
-1#0#0#exact -1#1#1#exact -1#2#2#syn -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact 


The result shown in Figure 16 demonstrates that with hard classified patterns that later layers of the cascade will process , the single SVM classifier can achieve higher accuracy than the cascade of AdaBoost classifiers trained by roughly predefined training parameters . / / ?NOTE : I believe that I hyphenated this term in your previous document , but after seeing it used here , I would say that it does not need to be hyphenated. My apologies for any confusion . A better way to express this , however , might be " patterns that have been classified as difficult " or " patterns shown to be difficult to classify .]
The result shown in Figure 16 demonstrates that with hard classified patterns that later layers of the cascade will process , the single SVM classifier can achieve higher accuracy than the cascade of AdaBoost classifiers trained by roughly predefined training parameters .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact -1#37#37#exact -1#38#38#exact -1#39#39#exact -1#40#40#exact -1#41#41#exact 


Furthermore , the training time of a single SVM ( which takes several hours ) is much shorter than that of a cascade of AdaBoost classifiers ( which might take several weeks ) .
Furthermore , the training time of a single SVM ( which takes several hours ) is much smaller than that of a cascade of AdaBoost classifiers ( which might take everal weeks ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#31#30,31#para -1#32#32#exact -1#33#33#exact 


The final system consists of three stages .
The final system consists of three stages .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact 


In the first stage , the cascaded 36x36 classifiers consist of three layers , making for a total of 120 features .
In the first stage , the cascaded 36x36 classifiers consist of three layers , making a total number of features used of 120 .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#16#exact -1#16#17#exact -1#21#18#exact -1#22#19#exact -1#19#20#exact -1#23#21#exact 


The second stage consists of 17 layers with 2 ,160 features .
The second stage consists of 17 layers with 2 ,160 features .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact 


Compared to the system with 6 ,061 features used in [1] , our system uses fewer features and can thus save significant training time ; the training time needed using the new system is approximately 27 times shorter / approximately 27 rounds of training are needed in the new system . / / <--I think that the first choice here is your intended meaning , but please check carefully .
Compared to the system with 6 ,061 features used in [1] , our system uses fewer features and , thus , can save significant training time ( which is approximate 27 times in total ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#21#18#exact -1#19#19#exact -1#22#20#exact -1#23#21#exact -1#24#22#exact -1#25#23#exact -1#31,32#27#para -1#28#32,33#para -1#29#34#stem -1#30#35#exact -1#35#50#exact -1#18#64#exact 


The final stage is a cascade of three SVM classifiers that take 100 features of the last layer in the second stage as the feature vectors .
The final stage is a cascade of three SVM classifiers that take 100 features of the last layer in the second stage as the feature vector .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#stem -1#26#26#exact 


Each SVM classifier was trained by using 7 ,500 face patterns and 7 ,500 non-face patterns .
Each SVM classifier was trained by using 7 ,500 face patterns and 7 ,500 non-face patterns .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact 


The same 7 ,500 face patterns were used in training all these SVM classifiers .
The same 7 ,500 face patterns were used in training all these SVM classifiers .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact 


By running the cascade of AdaBoost classifiers of the second stage on the set of non-face images , 40 ,000 false positives were collected and used as non-face patterns to train the SVM classifiers .
By running the cascade of AdaBoost classifiers of the second stage on the set of non-face images , 40 ,000 false positives were collected and used as non-face patterns to train the SVM classifiers .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact 


The 7 ,500 non-face patterns used to train the first SVM classifier were selected randomly from the 40 ,000 non-face patterns .
7 ,500 non-face patterns used to train the first SVM classifier were selected randomly from the 40 ,000 non-face patterns .
-1#15#0#lc -1#0#1#exact -1#1#2#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact 


Non-face patterns in the subsequent SVM classifiers were false positives collected by the partially cascaded SVM classifiers on these 40 ,000 non-face patterns .
Non-face patterns in the subsequent SVM classifiers were false positives collected by the partially cascaded SVM classifiers on these 40 ,000 non-face patterns .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact 


To control the number of support vectors , the parameter \MATH was used instead of the parameter \MATH .
To control the number of support vectors , the parameter \MATH was used instead of the parameter \MATH .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact 


All SVM classifiers were trained by using the RBF kernel with \MATH .
All SVM classifiers were trained by using the RBF kernel with \MATH .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact 


0
All these parameters were found by using cross-validation test tool provided by LibSVM [31]} .



Unsupervised Face Re-Ranking By Mining the Web and Video Archives
Unsupervised Face Re-Ranking By Mining the Web and Video Archives
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact 


It is necessary to utilize visual information to improve the efficiency of retrieval in image-search engines that use textual information for indexing .
to improve the retrieval performance of image search engines that use textual information for indexing , it is necessary to utilize visual information .
-1#16#0#lc -1#17#1#exact -1#18#2#exact -1#19#3#exact -1#20#4#exact -1#21#5#exact -1#22#6#exact -1#0,1,2#7,8,9,10,11#para -1#3#12#exact -1#8#15#exact -1#9#16#exact -1#10#17#exact -1#11#18#exact -1#12#19#exact -1#13#20#exact -1#14#21#exact -1#23#22#exact 


One popular approach has been to learn visual consistency between images returned by these search engines .
One popular approach is to learn visual consistency among the images returned by these search engines .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3,4#para -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8,9#9#para -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact 


Most state-of-the-art methods of learning visual consistency usually learn one specific classifier for each query to re-rank the returned images .
Most of the state of the art methods for learning the visual consistency usually learn one specific classifier for each query for re-ranking the returned images .
-1#0#0#exact -1#7#2#exact -1#1#3#exact -1#9#4#exact -1#11#5#exact -1#12#6#exact -1#13#7#exact -1#14#8#exact -1#15#9#exact -1#16#10#exact -1#17#11#exact -1#18#12#exact -1#19#13#exact -1#20#14#exact -1#22#16#stem -1#23#17#exact -1#24#18#exact -1#25#19#exact -1#26#20#exact 


The main drawback with these methods is that they require computational cost and processing time that are unsuitable for handling a large number of queries .
The drawback of these methods is it requires computational cost and processing time that are unsuitable for handling a large number of queries .
-1#0#0#exact -1#1#2#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#13#7#exact -1#7#9#stem -1#8#10#exact -1#9#11#exact -1#10#12#exact -1#11#13#exact -1#12#14#exact -1#14#15,16#para -1#15#17#exact -1#16#18#exact -1#17#19#exact -1#19,20,21#20,21,22,23#para -1#22#24#exact -1#23#25#exact 


We propose a method in which one generic classifier is learned and is then used for all queries .
We propose a method in which one generic classifier is learned and then is used for all queries .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#13#12#exact -1#12#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact 


Different from query-specific based methods that learn classifiers for recognition concepts encoded in each query , the generic classifier in our method learns relevance between images and the query for re-ranking purposes .
Different from query-specific based methods that learn classifiers for recognition concepts encoded in each query , the generic classifier of our method learns relevancy between images and the query for re-ranking purpose .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#stem -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#stem -1#32#32#exact 


The key contribution of this research is to introduce a query-dependent feature to represent this relevance and an unsupervised method of collecting training samples to learn the generic classifier .
The key contribution of this paper is to introduce a query-dependent feature to represent this relevancy and an unsupervised method to collect training samples for learning the generic classifier .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#6#5,6#para -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#stem -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20,21#20,21#para -1#22#22#exact -1#23#23#exact -1#25#24,25#para -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact 


The generic classifier is built automatically and is independent of existing ranking algorithms for input search engines .
The generic classifier is built automatically and independent with existing ranking algorithms of input search engines .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7,8#para -1#12#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact 


The experimental results demonstrated that the proposed method performed very well in various datasets .
experimental results show that the proposed method achieves good performance in various datasets .
-1#0#1#exact -1#1#2#exact -1#2#3#syn -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#8#10#syn -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact 


Image searches are essential for many search engines .
Image search is essential for many search engines .
-1#0#0#exact -1#1#1#stem -1#2,3#2,3#para -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact 


Most existing image-search engines usually use text information to determine relevance , resulting in poor precision .
Most of existing image search engines usually use text information for judging relevancy , resulting low precision performance .
-1#0#0#exact -1#2#1#exact -1#5#3#exact -1#6#4#exact -1#7#5#exact -1#8#6#exact -1#9#7#exact -1#10,11#8,9#para -1#12#10#stem -1#13#11#exact -1#14#12#exact -1#16#15#exact -1#18#16#exact 


To improve the accuracy of retrieval , it is necessary to use visual information from images to re-rank them .
To improve the retrieval performance , it is necessary to use visual information of images for re-ranking .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#13#4#exact -1#3#5#exact -1#5#6#exact -1#6,7,8#7,8,9,10#para -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#14#15#exact -1#9#16#exact -1#16#17#stem -1#17#19#exact 


However , understanding content-based images remains a challenging and unsolved problem .
However , content-based image understanding is a challenging and unsolved problem .
-1#0#0#exact -1#1#1#exact -1#4#2#exact -1#2#3#exact -1#3#4#stem -1#5#5#para -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact 


In addition , using visual information requires much greater computational cost than using text .
In addition , using visual information requires huge computational cost compared with using text .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#8#9#exact -1#9#10#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact 


One popular approach \CITE combining both text and visual information has been to use text information to quickly retrieve a set of candidates and then do post-processing ( i . e . , re-ranking ) on this set to improve precision .
One popular approach \CITE combining both text and visual information is to use text information to quickly retrieve a set of candidates and then do post-processing (i . e . re-rank) on this set to improve the precision .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10,11#10,11,12#para -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#27#29#exact -1#28#30#exact -1#29#31#exact -1#31#35#exact -1#32#36#exact -1#33#37#exact -1#34#38#exact -1#35#39#exact -1#37#40#exact -1#38#41#exact 


There are two ways of doing post-processing : The first \CITE has been to build a ranker or a classifier specific to the given query using the returned images .
There are two ways for post-processing : The first way \CITE is to build a ranker or a classifier specific to the given query using the returned images .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#10#10#exact -1#11,12#11,12,13#para -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact -1#28#29#exact 


Building such classifiers involves large computational cost and time .
Building such classifiers requires large computational cost and time .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#syn -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact 


As a result , this way is not scalable for applications that process very large numbers of queries .
As a result , this way is not scalable for applications processing very large number of queries .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#12#stem -1#12#13#exact -1#13#14#exact -1#14,15#15,16#para -1#16#17#exact -1#17#18#exact 


The second way \CITE has been to build a generic classifier once and then use it for all new queries .
The second way \CITE is to build a generic classifier once and then use it for all new queries .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4,5#para -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact 


This is more scalable and can be used for practical applications such as meta-search engines .
This way is more scalable and can be used for practical applications such as meta search engines .
-1#0#0#exact -1#2#1#exact -1#3#2#exact -1#4#3#exact -1#5#4#exact -1#6,7#5,6,7,8#para -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#16#14#exact -1#17#15#exact 


We pursued the latter way to solve the problem with face retrieval in which the system enables users to search people's appearances by their names .
We follow the latter way for the problem of face retrieval in which the system enables users to search persons's appearance by their names .
-1#0#0#exact -1#1#1#syn -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#17#5#exact -1#6#7#exact -1#7,8#8,9#para -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#18#18,19#para -1#20#21#stem -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact 


Our system re-ranks the faces returned by text-based search engines with a generic classifier that is trained in advance using visual information before returning them to the user .
Our system re-ranks the faces returned by text-based search engines by a generic classifier that is trained in advance using visual information before returning to the user .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact 


Building such generic classifiers requires two problems to be solved : finding a good query-relative representation of faces and collecting a large labeled dataset to train the classifier .
Building such generic classifiers requires solving two problems : finding good query-relative representation of faces and collecting a large labeled dataset for training the classifier .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#6#5#exact -1#7#6#exact -1#5#9#stem -1#8#10#exact -1#9#11#exact -1#17#12#exact -1#10#13#exact -1#11#14#exact -1#12#15#exact -1#13#16#exact -1#14#17#exact -1#15#18#exact -1#16#19#exact -1#18#20,21#para -1#19#22#exact -1#20#23#exact -1#21,22#24,25#para -1#23#26#exact -1#24#27#exact -1#25#28#exact 


Our contribution by addressing these problems is two-fold :
By addressing these problems , Our contribution is two-fold :
-1#5#0#exact -1#6#1#exact -1#0#2#lc -1#1#3#exact -1#2#4#exact -1#3#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact 


-We propose a general framework for re-ranking faces returned by existing text-based search engines .
-We propose a general framework for re-ranking faces returned by existing text-based search engine .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#stem -1#14#14#exact 


We learn a relevance classifier that classifies whether an input face is relevant to the associated query or not in this framework .
In this framework , We learn a relevance classifier that classifies whether an input face is relevant to the associated query or not .
-1#4#0#exact -1#5#1#exact -1#6#2#exact -1#7#3#exact -1#8#4#exact -1#9#5#exact -1#10#6#exact -1#11#7#exact -1#12#8#exact -1#13#9#exact -1#14#10#exact -1#16,17,18#11,12,13,14#para -1#19#15#exact -1#20#16#exact -1#21#17#exact -1#22#18#exact -1#0#19#lc -1#1#20#exact -1#2#21#exact -1#23#22#exact 


The output scores returned by this classifier are used to re-rank the faces .
The output scores returned by this classifier are used to re-rank the faces .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact 


The more relevant a face is to the query , the higher score is .
The more relevant a face to the query , the higher score is .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#12#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#13#14#exact 


This approach is different from existing ones \CITE that learn a classifier to recognize the identity of the returned faces .
This approach is different from existing approaches such as \CITE that learn a classifier to recognize the identity of the returned faces .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#9#7#exact -1#10#8#exact -1#11#9#exact -1#12#10#exact -1#13#11#exact -1#14#12#exact -1#15#13#exact -1#16#14#exact -1#17#15#exact -1#18#16#exact -1#19#17#exact -1#20#18#exact -1#21#19#exact -1#22#20#exact 


For example , it recognizes a face as the appearance of 'personX' or not the appearance of 'personX' .
For example , it recognizes a face as the appearance of 'personX' or not the appearance of 'personX' .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact 


Instead , the relevance classifier is learned to classify a face being relevant or irrelevant to the query .
Instead , the relevance classifier is learned to classify a face being relevant or irrelevant to the query .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact 


As this classifier is independent of the identity of faces , it can be shared for multiple queries ( cf . Figure \REF ) .
this classifier is independent with the identity of faces , so it can be shared for multiple queries (cf . Figure \REF) .
-1#0#1#exact -1#1#2#exact -1#2#3#exact -1#3#4#exact -1#7#5#exact -1#5#6#exact -1#6#7#exact -1#8#9#exact -1#9#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#19#20#exact -1#20#21#exact -1#22#24#exact 


We propose a novel representation for each face that models the relevance between that face and the query .
We propose a novel representation for each face that models relevance between that face and the query .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#15#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#16#17#exact -1#17#18#exact 


Once this query-dependent feature for each face is extracted , one relevance classifier can be shared by the faces of various queries .
Once this query-dependent feature for each face is extracted , one relevance classifier can be shared by faces of various queries .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact 


The experimental results demonstrated that the relevance classifier that is independent of the underlying ranking algorithms of existing search engines could significantly boost performance .
experimental results show that the relevance classifier that is independent with underlying ranking algorithm of existing search engines can significantly boost the performance .
-1#21#0#lc -1#0#1#exact -1#1#2#exact -1#2#3#syn -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#14#11#exact -1#11#12,13#para -1#12#14#exact -1#13#15#stem -1#15#16,17#para -1#16#18#exact -1#17#19#exact -1#18#20#para -1#19#21#exact -1#20#22#exact -1#22#23#exact -1#23#24#exact 


-We propose a simple yet efficient mining technique of automatically collecting labeled data to train the generic classifier .
-We propose a simple yet efficient mining technique for automatically collecting labeled data for training the generic classifier .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13,14#13,14#para -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact 


We specifically detected and grouped faces of people appearing in video programs in face tracks in which each face track contained the faces of one person .
Specifically , We detect and group faces of persons appearing in video programs in face tracks in which each face track contains of the faces of one person .
-1#2#0#exact -1#0#1#lc -1#3#2#stem -1#4#3#exact -1#5#4#stem -1#6#5#exact -1#7#6#exact -1#8#7#para -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#stem -1#23#21#exact -1#24#22#exact -1#25#23#exact -1#26#24#exact -1#27#25#exact -1#28#26#exact 


To distinguish the face tracks of different people , we assumed that if multiple faces were detected at different locations in one frame , they would be of different people ( cf .
To distinguish face tracks of different persons , we assume that if multiple faces are detected at different locations in one frame , they are of different persons (cf . Figure \REF) .
-1#0#0#exact -1#1#1#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#para -1#7#8#exact -1#8#9#exact -1#9,10#10,11#para -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#23,24#15#para -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#14#25,26#para -1#25#27#exact -1#26#28#exact -1#27#29#para -1#29#32#exact 


Using this assumption , we collected face tracks whose faces were detected in the same frames to guarantee that each face track was associated with one unique person .
Using this assumption , we collect the face tracks whose faces are detected in the same frames to guarantee that each face track is associated to one unique person .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#stem -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#12,13#10,11,12#para -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact -1#23#22#syn -1#24#23#exact -1#26#25#exact -1#27#26#exact -1#28#27#exact -1#29#28#exact 


We used video programs from multiple genres and channels to increase the number of such face tracks .
To enlarge the number of such face tracks , We use video programs of multiple genres and channels .
-1#9#0#exact -1#10#1#stem -1#11#2#exact -1#12#3#exact -1#14#5#exact -1#15#6#exact -1#16#7#exact -1#17#8#exact -1#0#9#lc -1#1,2#10,11#para -1#3#12#exact -1#4#13#exact -1#5#14#exact -1#6#15#exact -1#7#16#exact -1#18#17#exact 


We could artificially generate face sets from these faces similar to the sets returned by search engines given people's names .
From these faces , We can artificially generate face sets similar to the sets returned by search engines given person names .
-1#4#0#exact -1#5#1#para -1#6#2#exact -1#7#3#exact -1#8#4#exact -1#9#5#exact -1#0#6#lc -1#1#7#exact -1#2#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#20#19#exact -1#21#20#exact 


Since we knew the relevance of these faces to the artificial sets , the labels for each face could be easily generated and no human intervention was needed in this process .
Since we know the relevance of these faces to the artificial sets , the labels of each face can be easily generated and no human intervention is needed for this process .
-1#0#0#exact -1#1#1#exact -1#2#2#syn -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15,16#15,16#para -1#17#17#exact -1#18,19#18,19#para -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26,27#26,27#para -1#29,30#28,29,30#para -1#31#31#exact 


Note that the labels of faces in our approach did not identity those faces but the relevance between the faces and the associated query .
Note that the label of faces in our approach is not identity of that face . It is the relevance between the face and the associated query .
-1#0#0#exact -1#1#1#exact -1#18#2#exact -1#2,3#3#para -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#10#9,10#para -1#11#11#exact -1#14#13#stem -1#21#15#exact -1#19#16#exact -1#20#17#exact -1#24#18#exact -1#22,23#19,20#para -1#25#21,22#para -1#26#23#exact -1#27#24#exact 


Collecting training sets from such external sources as video archives is easy and efficient because , first , a large number of videos can be easily obtained .
Collecting training sets from such external sources as video archives is easy and efficient because : firstly , a large number of videos can be easy to obtain .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#17#15#exact -1#19,20,21#18,19,20,21#para -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25,26#25#para -1#27#26#stem -1#28#27#exact 


For example , people can record broadcast videos from different channels within a certain period .
For example , people can record broadcast videos of different channels in a certain period .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8,9#8,9#para -1#10#10#exact -1#12,13,14#11,12,13,14#para -1#15#15#exact 


Second , a huge number of faces can be obtained by applying a face detector to all frames .
Secondly , a huge number of faces can be obtained by applying the face detector in every frame .
-1#0#0#stem -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#13#13#exact -1#14#14#exact -1#17#17#stem -1#18#18#exact 


In addition , the faces of one person appearing in consecutive frames can be automatically grouped with a high degree of accuracy using temporal information .
In addition , using temporal information , faces of one person appearing in consecutive frames can be automatically grouped with high accuracy .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#7#4#exact -1#8#5#exact -1#9#6#exact -1#10#7#exact -1#11#8#exact -1#12#9#exact -1#13#10#exact -1#14#11#exact -1#15#12#exact -1#16#13#exact -1#17#14#exact -1#18#15#exact -1#19#16#exact -1#20#17,18,19,20#para -1#21#21#exact -1#3#22#exact -1#4#23#exact -1#5#24#exact -1#22#25#exact 


It is essential for image-search engines to find relevant images with a high degree of precision given queries described by text , e.g. , 'airplane' or 'George Bush' .
given a query described by text , for example , 'airplane' or 'George Bush' , finding relevant images with high precision is essential for image search engines .
-1#21#1#exact -1#22#2#exact -1#23#3#exact -1#26#5#exact -1#15#6,7#para -1#16#8#exact -1#17#9#exact -1#18#10#exact -1#1#11#exact -1#19#12#exact -1#20#15#exact -1#0#16#exact -1#2#17#stem -1#3#18#exact -1#4#19#exact -1#5#20#exact -1#6#21#exact -1#9#23#exact -1#10#24#exact -1#11#25#exact -1#12#26#exact -1#13#27#exact -1#27#28#exact 


Existing image-search engines usually use textual information associated with images such as filenames , image captions , and surrounding text for ranking that leads to poor precision .
Existing image search engines usually use textual information associated with the images such as filename , image caption , and surrounding text for ranking that leads to poor precision .
-1#0#0#exact -1#3#2#exact -1#4#3#exact -1#5#4#exact -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#11#9#exact -1#12#10#exact -1#13#11#exact -1#14#12#stem -1#15#13#exact -1#16#14#exact -1#17#15#stem -1#18#16#exact -1#19#17#exact -1#20#18#exact -1#21#19#exact -1#22#20#exact -1#23#21#exact -1#24#22#exact -1#25#23#exact -1#26#24#exact -1#27#25#exact -1#28#26#exact -1#29#27#exact 


To improve precision , visual information is used to re-rank the returned images .
To improve the precision , visual information is used to re-rank the returned images .
-1#0#0#exact -1#1#1#exact -1#3#2#exact -1#4#3#exact -1#5#4#exact -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact 


The idea is to rely on the visual consistency between these images to learn visual classifiers that measure the relevance between an image and the input query .
The idea is to rely on the visual consistency among these images to learn visual classifiers that measure the relevancy between an image and the input query .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9,10#9,10#para -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#stem -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact 


There have been different approaches \CITE to re-ranking images containing general objects and faces returned from text-based search engines .
There are different approaches described in \CITE for re-ranking images containing general objects and faces returned from text-based search engines .
-1#0#0#exact -1#1#1,2#para -1#2#3#exact -1#3#4#exact -1#6#5#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact 


Work \CITE has extended to topics on models using probabilistic Late Semantic Analysis , Latent Dirichlet Allocation , or the Hierarchical Dirichlet Process to learn generative model-based classifiers .
Work such as \CITE extend topics models using probabilistic Late Semantic Analysis , Latent Dirichlet Allocation , or Hierarchical Dirichlet Process to learn generative model based classifiers .
-1#0#0#exact -1#3#1#exact -1#21#4#exact -1#5#5#exact -1#6#6,7#para -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#20#exact -1#19#21#exact -1#20#22#exact -1#22#23,24#para -1#23#25#exact -1#26#27#exact -1#27#28#exact 


These models can handle noisy image data to some degree .
These models can handle noisy image data in some degree .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6,7#6,7#para -1#8#8#exact -1#9#9#exact -1#10#10#exact 


However , they have many parameters that need to be tuned such as the number of topics and feature configurations .
However , they have many parameters needed to be tuned such as number of topics and feature configurations .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#7,8#6,7,8,9#para -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12,13#13,14,15#para -1#14#16#exact -1#15#17#exact -1#16#18#exact -1#17#19#exact -1#18#20#exact 


In addition , how the best topic is selected associated with the input query to identify the target label is still a difficult issue \CITE .
In addition , how to select the best topic associated with the input query for identifying target label is still challenging \CITE .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#6#4#exact -1#7#5#exact -1#8#6#exact -1#18#7#exact -1#5#8#stem -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#4#14#exact -1#15#15,16#para -1#16#17#exact -1#17#18#exact -1#19#19,20#para -1#20#22#para -1#21#24#exact -1#22#25#exact 


Textual information has been used to build a text ranker to re-rank the returned images \CITE .
In \CITE , Textual information is used to build a text ranker to re-rank the returned images \CITE .
-1#3#0#exact -1#4#1#exact -1#5#2,3#para -1#6#4#exact -1#7#5#exact -1#8#6#exact -1#9#7#exact -1#10#8#exact -1#11#9#exact -1#12#10#exact -1#13#11#exact -1#14#12#exact -1#15#13#exact -1#16#14#exact -1#17#15#exact -1#18#16#exact 


The top images in this ranked list were used as positive samples to train visual classifiers using SVM ( Support vector machines ) .
The top images in this ranked list are used as positive samples to train visual classifiers using SVM (Support vector machines) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7,8#7,8#para -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#19#20#exact -1#21#23#exact 


This method made the training data cleaner and led to improved performance .
This method makes the training data cleaner that leads to performance improvement .
-1#0#0#exact -1#1#1#exact -1#2#2#syn -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#8,9#8,9#para -1#10#10,11#para -1#12#12#exact 


A multiple-instance learning framework has been used to learn category models from images associated with keywords \CITE .
In \CITE , A multiple instance learning framework is used to learn category models from images associated with keywords \CITE .
-1#3#0#exact -1#6#2#exact -1#7#3#exact -1#8#4,5#para -1#9#6#exact -1#10#7#exact -1#11#8#exact -1#12#9#exact -1#13#10#exact -1#14#11#exact -1#15#12#exact -1#16#13#exact -1#17#14#exact -1#18#15#exact -1#19#16#exact -1#20#17#exact 


The returned images were treated as a positive bag .
The returned images are treated as positive bag .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#syn -1#4#4#exact -1#5#5#exact -1#6#6,7#para -1#7#8#exact -1#8#9#exact 


Negative bags were collected from image sets corresponding to unrelated keywords .
Negative bags are collected from image sets corresponding to unrelated keywords .
-1#0#0#exact -1#1#1#exact -1#2,3#2,3#para -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact 


The learned model was used to re-rank the images .
The learned model is used to re-rank the images .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3,4#3,4#para -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact 


These researchers re-ranked images containing general objects .
The work mentioned above are for re-ranking images containing general objects .
-1#6#2#stem -1#7#3#exact -1#8#4#exact -1#9#5#exact -1#10#6#exact -1#11#7#exact 


Gaussian mixture models have been used for re-ranking faces to build face recognizers and apply these recognizers back to the input faces for re-ranking \CITE .
For re-ranking faces , work described in \CITE use Gaussian mixture models to build face recognizers and apply these recognizers back to the input faces for re-ranking \CITE .
-1#9#0#exact -1#10#1#exact -1#11#2#exact -1#8#4,5#para -1#0#6#lc -1#1#7#exact -1#2#8#exact -1#12#9#exact -1#13#10#exact -1#14#11#exact -1#15#12#exact -1#16#13#exact -1#17#14#exact -1#18#15#exact -1#19#16#exact -1#20#17#exact -1#21#18#exact -1#22#19#exact -1#23#20#exact -1#24#21#exact -1#25#22#exact -1#26#23#exact -1#27#24#exact -1#28#25#exact 


Discriminative-approach-based models such as SVM and linear discriminant analysis have been used instead of Gaussian mixture models \CITE .
In \CITE , Discriminative approach based models such as SVM and linear discriminant analysis are used instead of Gaussian mixture models \CITE .
-1#6#1#exact -1#7#2#exact -1#8#3#exact -1#9#4#exact -1#10#5#exact -1#11#6#exact -1#12#7#exact -1#13#8#exact -1#14,15#9,10,11#para -1#16#12#exact -1#17#13#exact -1#18#14#exact -1#19#15#exact -1#20#16#exact -1#21#17#exact -1#22#18#exact 


A densest-graph-based method has been used for finding the face group relevant to the query \CITE .
In \CITE , A densest graph based method is used for finding the face group relevant to the query \CITE .
-1#3#0#exact -1#7#2#exact -1#8#3,4#para -1#9#5#exact -1#10#6#exact -1#11#7#exact -1#12#8#exact -1#13#9#exact -1#14#10#exact -1#15#11#exact -1#16#12#exact -1#17#13#exact -1#18#14#exact -1#19#15#exact -1#20#16#exact 


One specific classifier is built for each query in these approaches .
As for these approaches , One specific classifier is built for each query .
-1#5#0#exact -1#6#1#exact -1#7#2#exact -1#8#3#exact -1#9#4#exact -1#10#5#exact -1#11#6#exact -1#12#7#exact -1#2#9#exact -1#3#10#exact -1#13#11#exact 


Therefore , many classifiers must be built , which are not suitable in practice , to handle a large number of queries .
Therefore , to handle a large number of queries , many classifiers must be built which are not suitable in practice .
-1#0#0#exact -1#1#1#exact -1#10#2#exact -1#11#3#exact -1#12#4#exact -1#13#5#exact -1#14#6#exact -1#9#7#exact -1#15#8#exact -1#16#9#exact -1#17#10#exact -1#18#11#exact -1#19#12#exact -1#20#13#exact -1#2#15#exact -1#3#16#exact -1#5,6,7#17,18,19,20#para -1#8#21#exact -1#21#22#exact 


Only one generic classifier has been built in advance \CITE and then used for all queries .
In \CITE{Krapac10CVPR} , Only one generic classifier is built in advance \CITE and then used for all queries .
-1#3#0#exact -1#4#1#exact -1#5#2#exact -1#6#3#exact -1#7#4,5#para -1#8#6#exact -1#9#7#exact -1#10#8#exact -1#11#9#exact -1#12#10#exact -1#13#11#exact -1#14#12#exact -1#15#13#exact -1#16#14#exact -1#17#15#exact -1#18#16#exact 


This generic classifier was a relevance classifier that learned relevance between an image and the query .
This generic classifier is a relevance classifier that learns relevancy between an image and the query .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3,4#3,4#para -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#stem -1#9#9#stem -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact 


Each image for specific classifiers is classified as 'class-A' or 'non-class-A' , where 'class-A' is the category associated with the query , e.g. , 'airplane' .
As for specific classifiers , Each image is classified as 'class-A' or 'non-class-A' , where 'class-A' is the category associated with the query , for example , 'airplane' .
-1#5#0#exact -1#6#1#exact -1#1#2#exact -1#2#3#exact -1#3#4#exact -1#7#5#exact -1#8#6#exact -1#9#7#exact -1#10#8#exact -1#11#9#exact -1#12#10#exact -1#13#11#exact -1#14#12#exact -1#15#13#exact -1#16#14#exact -1#17#15#exact -1#18#16#exact -1#19#17#exact -1#20#18#exact -1#21#19#exact -1#22#20#exact -1#23#21#exact -1#4#23#exact -1#27#24#exact -1#28#25#exact 


In other words , each specific classifier is associated with one class label implied by the query .
In other words , each specific classifier is associated with one class label implied by the query .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact 


Each image in a generic classifier is classified as relevant or irrelevant to the query .
In generic classifier , Each image is classified as relevant or irrelevant to the query .
-1#4#0#exact -1#5#1#exact -1#0#2#lc -1#1#4#exact -1#2#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact 


Therefore , it is independent of class labels and can be used for any query .
Therefore , it is independent to class labels and can be used for any query .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#6#5,6#para -1#7#7#exact -1#8#8#exact -1#9,10#9,10,11,12#para -1#13#13#exact -1#14#14#exact -1#15#15#exact 


This method works well for objects such as cars and flags , but fails to handle faces .
This method works well for objects such as car , flag , but fails to handle faces .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#stem -1#10#10#stem -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact 


Our method was inspired by the generic-classifier-based approach .
Our method is inspired by the generic classifier based approach .
-1#0#0#exact -1#1#1#exact -1#2#2#syn -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#9#7#exact -1#10#8#exact 


We extended it in two ways : first , query-dependent features specific to faces are proposed , and second , the training data for learning the generic classifier are collected automatically by mining video archives .
We extend it by two means : first , query-dependent features specific for faces are proposed , and second , the training data for learning the generic classifier is collected automatically by mining video archives .
-1#0#0#exact -1#1#1#stem -1#2#2#exact -1#3,4#3,4#para -1#5#5#syn -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#syn -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact 


Given a set of faces returned by any search engine for a queried person ( e.g. , 'George Bush' ) , our task is to re-rank these faces to improve precision .
Given a set of faces returned by any search engine for a queried person ( e .g . 'George Bush' ) , our task is to re-rank these faces to improve the precision .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#21#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#22,23,24,25#21,22,23#para -1#29#24#exact -1#26#25#exact -1#27#26#exact -1#28#27#exact -1#30#28,29#para -1#32#30#exact -1#33#31#exact 


To this end , we extract query-dependent features for each face and then use the generic classifier trained in advance to predict scores representing the relevance between that face and the query .
To this end , we extract query-dependent feature for each face and then use the generic classifier trained in advance to predict scores representing the relevance between that face and the query .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#stem -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact 


These scores are sorted and used for re-ranking .
These scores are sorted and used for re-ranking .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact 


The ranked list is then returned to users as shown in Figure \REF( b ) .
The ranked list is then return to users as shown in Figure \REF( b ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5,6#5,6#para -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact 


This approach is different from the existing approaches \CITE shown in Figure \REF( a ) in which one specific classifier is built for each query .
This approach is different from existing approaches such as \CITE as shown in Figure \REF( a ) in which one specific classifier is built for each query .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#6#exact -1#6#7#exact -1#9#8#exact -1#11#9#exact -1#12#10#exact -1#13#11#exact -1#14#12#exact -1#15#13#exact -1#16#14#exact -1#17#15#exact -1#18#16#exact -1#19#17#exact -1#20#18#exact -1#21#19#exact -1#22#20#exact -1#23#21#exact -1#24#22#exact -1#25#23#exact -1#26#24#exact -1#27#25#exact 


To build a specific classifier for re-ranking faces returned by the query of 'personX' , each face is represented by a query-independent feature such as pixel intensity around facial features such as the eyes , nose , and mouth \CITE .
To build the specific classifier for re-ranking faces returned by the query of 'personX' , each face is represented by the query-independent feature such as pixel intensity around facial features such as eyes , nose , and mouth \CITE .
-1#0#0#exact -1#1#1#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#2#32#exact -1#32#33#exact -1#33#34#exact -1#34#35#exact -1#35#36#exact -1#36#37#exact -1#37#38#exact -1#38#39#exact -1#39#40#exact 


The label for each face is 'personX' or 'non-personX' meaning that it is relevant or irrelevant to 'personX' .
The label for each face is 'personX' or 'non-personX' meaning that it is relevant or irrelevant to 'personX' .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact 


Further , each face is represented by the query-dependent feature to build a generic classifier that is independent of any 'personX' .
Meanwhile , to build the generic classifier which is independent with any \textit{'personX'} , each face is represented by the query-dependent feature .
-1#13#1#exact -1#14#2#exact -1#15#3#exact -1#16#4#exact -1#17#5#exact -1#18#6#exact -1#19#7#exact -1#20#8#exact -1#21#9#exact -1#2#10#exact -1#3#11#exact -1#5#13#exact -1#6#14#exact -1#7,8#15,16#para -1#9#17#exact -1#11#18,19#para -1#22#21#exact 


The label for each face is relevant or irrelevant to the query .
The label for each face is relevant or irrelevant to the query .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact 


The query-dependent feature is used to encode this relevance .
The query-dependent feature is used to encode this relevancy .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#stem -1#9#9#exact 


Query-dependent features using textual information has been proposed \CITE .
In \CITE , the Query-dependent features using textual information are proposed \CITE .
-1#4#0#exact -1#5#1#exact -1#6#2#exact -1#7#3#exact -1#8#4#exact -1#10#5,6,7#para -1#11#8#exact -1#12#9#exact 


Each feature was treated as binary indicating the presence or absence of query terms in the textual data associated with the input image , e.g. , filenames , image titles , and nearby text .
Each feature is treated as binary indicating the presence or absence of the query terms in textual data associated with the input image , for example , filename , image title , and nearby text .
-1#0#0#exact -1#1#1#exact -1#2,3#2,3#para -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#12#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#26#25#exact -1#27#26#stem -1#28#27#exact -1#29#28#exact -1#30#29#stem -1#31#30#exact -1#32#31#exact -1#33#32#exact -1#34#33#exact -1#35#34#exact 


Extending this query-dependent feature to use visual information is not trivial since we cannot compute the presence or absence of query terms such as 'George Bush' in each face .
Extending this query-dependent feature for using visual information is not trivial since we can not compute the presence and absence of the query term such as 'George Bush' in each face .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4,5#4,5#para -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13,14#13#para -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#19#18#exact -1#20#19#exact -1#22#20#exact -1#23#21#stem -1#24#22#exact -1#25#23#exact -1#26#24#exact -1#27#25#exact -1#28#26#exact -1#29#27#exact -1#30#28#exact -1#31#29#exact 


Each image in \CITE is represented as a set of visual words .
In \CITE , Each image \CITE is represented as a set of visual words .
-1#3#0#exact -1#4#1#exact -1#0#2#lc -1#1#3#exact -1#6#4#exact -1#7#5#exact -1#8,9,10,11#6,7,8#para -1#12#10#exact -1#13#11#exact -1#14#12#exact 


The top- \MATH visual words that are strongly associated with the set of returned images for the query are selected .
The top- \MATH visual words that are strongly associated with the set of the returned images for the query are selected .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact 


The binary features for each image are computed by evaluating the presence and absence of these visual words in that image .
The binary features for each image are computed by evaluating the presence and absence of these visual words in that image .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact 


Since this method is suitable for general objects rather than faces , we propose another method of extracting query-dependent features to train the generic classifier that is described below .
Since this method is suitable for general objects rather than faces , we proposed another method described below for extracting query-dependent features to train the generic classifier .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#stem -1#14#14#exact -1#15#15#exact -1#19#17#exact -1#20#18#exact -1#21#19#exact -1#22#20#exact -1#23#21#exact -1#24#22#exact -1#25#23#exact -1#26#24#exact -1#16#26,27#para -1#17#28#exact -1#27#29#exact 


We assumed that there would be visual consistency between faces returned by search engines for a query to be able to model the relevance between a face and that given query .
To be able to model the relevance between a face and the given query , We assume that there is visual consistency among faces returned by search engines for that query .
-1#15#0#exact -1#16#1#stem -1#17#2#exact -1#18#3#exact -1#19#4,5#para -1#20#6#exact -1#21#7#exact -1#7#8#exact -1#23#9#exact -1#24#10#exact -1#25#11#exact -1#26#12#exact -1#27#13#exact -1#28#14#exact -1#8#15#exact -1#13#16#exact -1#1,2,3#17,18,19,20#para -1#4#21#exact -1#5#22#exact -1#6#23#exact -1#9#26#exact -1#10#27#exact -1#29#28#exact -1#12#29#exact -1#30#30#exact -1#31#31#exact 


In the other words , we assumed faces that were relevant to the query would form the largest cluster .
In the other word , we assume faces that are relevant to the query form the largest cluster .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#stem -1#4#4#exact -1#5#5#exact -1#6#6#stem -1#7#7#exact -1#8#8#exact -1#9#9#syn -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact 


Note that finding such clusters is still difficult since the number of clusters is not known in advance and the accuracy of clustering algorithms always depends on the discriminative power of feature representation .
Note that finding such cluster is still difficult since the number of clusters is not known in advance and the accuracy of clustering algorithms always depends on the discriminative power of feature representation .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#12#4#exact -1#13#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#4#12#stem -1#5#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact 


This assumption is widely accepted in most of the work in this field \CITE .
This assumption is widely accepted in most of the work of this field \CITE .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5,6,7,8#5,6#para -1#10#7#exact -1#9#8,9#para -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact 


We consider the problem of finding relevant and irrelevant faces in the input set to be the problem of outlier detection \CITE that is popular in the data-mining community .
We consider the problem of finding relevant and irrelevant faces in the input set as the problem of outlier detection \CITE that is popular in data mining community .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#22#15#syn -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#23#24#exact -1#24#25#exact -1#27#28#exact -1#28#29#exact 


We first describe several distance-based methods of outlier detection that use the distance to the \MATH -nearest neighbors to determine observations as outliers or non-outliers .
We first describe several distance based outlier detection methods that use the distance to the \MATH -nearest neighbors to determine observations as outliers or non-outliers .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#8#5#exact -1#6#7#exact -1#7#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact 


Then , adaptation is proposed to form a query-dependent feature .
Then the adaptation is proposed to form the query-dependent feature .
-1#0#0#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact 


Given threshold \MATH , for each point \MATH , we examine the number of points \MATH so that \MATH , where \MATH is the distance ( e.g. , Euclidean distance ) between \MATH and \MATH in the feature space .
Given a threshold \MATH , for each point \MATH , we examine number of points \MATH so that \MATH , where \MATH is the distance ( e .g . Euclidean distance ) between \MATH and \MATH in the feature space .
-1#0#0#exact -1#2#1#exact -1#3#2#exact -1#4#3#exact -1#5#4#exact -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12,13#11,12,13#para -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#29#28#exact -1#30#29#exact -1#31#30#exact -1#32#31#exact -1#33#32#exact -1#34#33#exact -1#35#34#exact -1#36#35#exact -1#37#36#exact -1#38#37#exact -1#39#38#exact -1#40#39#exact 


This number of points \MATH is called the neighborhood score of \MATH and is defined as : \MATH where \MATH is the total number of points in the input dataset .
This number of points \MATH is called the neighborhood score of \MATH and is defined as follows : \MATH where \MATH is the total number of points of the input dataset .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22,23,24,25#21,22,23#para -1#27#24#exact -1#26#25#exact -1#28#27#exact -1#29#28#exact -1#30#29#exact -1#31#30#exact 


A low value for \MATH indicates \MATH is a candidate of outliers , while a high value for \MATH indicates \MATH is a member of one strong association cluster .
A low value of \MATH indicates \MATH is a candidate of outliers , while a high value of \MATH indicates \MATH is a member of one strong association cluster .
-1#0#0#exact -1#1#1#exact -1#2,3#2,3#para -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16,17#16,17#para -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#22,23,24#21,22,23,24#para -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact 


In practice , it is difficult to know \MATH because this depends on the underlying distribution of the input dataset .
In practice , it is difficult to know \MATH because it depends on underlying distribution of the input dataset .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3,4,5,6#3,4,5#para -1#7#6,7#para -1#8#8#exact -1#9#9#exact -1#10,11#10,11#para -1#12#12#exact -1#16#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact 


For each point \MATH , find its \MATH -nearest neighbors \MATH ; the distance score of \MATH is the sum of the distances between \MATH and its \MATH -nearest neighbors \MATH and is defined as : \MATH
For each point \MATH , find its \MATH -nearest neighbors \MATH , the distance score of \MATH is the sum of the distances between \MATH and its \MATH -nearest neighbors \MATH and is defined as follows : \MATH
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#36#35#exact -1#37#36#exact 


Points with larger values for \MATH have sparser neighborhoods and are more likely outliers than points belonging to dense clusters , which usually have lower values for \MATH .
Points with larger values for \MATH have more sparse neighborhoods and are likely outliers than points belonging to dense clusters which usually have lower values of \MATH .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#8#7#syn -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#7#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#26#27#exact -1#27#28#exact 


Similar to the nearest neighbor score , it is difficult to determine the appropriate \MATH value for each dataset .
Similar to nearest neighbor score , it is difficult to determine the appropriate \MATH value for each dataset .
-1#0#0#exact -1#1#1#exact -1#11#2#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6,7,8,9#7,8,9#para -1#10#10,11#para -1#12#12,13#para -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact 


We consider the generic classifier as an outlier classifier that classifies an input sample as an outlier or a non-outlier .
We consider the generic classifier as an outlier classifier that classifies an input sample as outlier or non-outlier .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#16#exact -1#16#17#exact -1#17#19#exact -1#18#20#exact 


Each face in our framework is a sample , and non-outliers / outliers mean faces are relevant / irrelevant to the query ( i.e. , target person ) .
In our framework , Each face is an sample , and non-outliers / outliers mean faces relevant / irrelevant to the query ( i .e . target person ) .
-1#4#0#exact -1#5#1#exact -1#0#2#lc -1#1#3#exact -1#2#4#exact -1#6,7#5,6#para -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#3#24#exact -1#26#25#exact -1#27#26#exact -1#28#27#exact -1#29#28#exact 


As described above , the \MATH and \MATH of outliers and non-outliers might have the distributions in Figure \REF ; these scores can be used as feature values to discriminate non-outliers from outliers .
As described above , \MATH and \MATH of outliers and non-outliers might have distributions shown in Figure \REF , these scores can be used as feature values to discriminate non-outliers and outliers .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#19#20#exact -1#20#21#exact -1#21,22#22,23,24,25#para -1#25#26#exact -1#26#27#exact -1#27#28#exact -1#28#29#exact -1#29#30#exact -1#31#32#exact -1#32#33#exact 


From this observation , the feature vector is formed by varying parameters such as \MATH and \MATH in the formula of \MATH and \MATH as follows : \MATH .
From this observation , the feature vector is formed by varying parameters such as \MATH and \MATH in formula of \MATH and \MATH as follows : \MATH .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18,19#para -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact 


It requires a sufficient number of training samples to train the relevance classifier using supervised learning methods such as SVM .
In order to train the relevance classifier using supervised learning methods such as SVM , it requires a sufficient number of training samples .
-1#15#0#lc -1#16#1#exact -1#17#2#exact -1#18#3#exact -1#19#4#exact -1#20#5#exact -1#21#6#exact -1#22#7#exact -1#2#8#exact -1#3#9#exact -1#4#10#exact -1#5#11#exact -1#6#12#exact -1#7#13#exact -1#8#14#exact -1#9#15#exact -1#10#16#exact -1#11#17#exact -1#12#18#exact -1#13#19#exact -1#23#20#exact 


The simplest way \CITE of collecting training samples is to pick many names , and pass them to search engines .
To collect training samples , The simplest way \CITE is we pick many names , and pass them to search engines .
-1#5#0#exact -1#6#1#exact -1#7#2#exact -1#8#3#exact -1#0,1#4,5#para -1#2#6#exact -1#3#7#exact -1#9#8#exact -1#18#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#19#17,18#para -1#20#19#exact -1#21#20#exact 


After collecting the returned faces , we manually label each face as to whether it is relevant to the input query or not .
After collecting the returned faces , we manually label each face whether it is relevant to the input query or not .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11,12,13#11,12,13,14,15#para -1#14#16#exact -1#15#17#exact -1#16#18#exact -1#17#19#exact -1#18#20#exact -1#19#21#exact -1#20#22#exact -1#21#23#exact 


This is a tedious task and involves a human-labor cost .
It is a tedious task and requires human labor cost .
-1#0,1#0,1#para -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#syn -1#9#9#exact -1#10#10#exact 


We propose another approach to automatically collecting training samples to train the relevant classifier .
We propose another approach to automatically collect training samples for training the relevant classifier .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#stem -1#7#7#exact -1#8#8#exact -1#9,10#9,10#para -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact 


This approach consists of two steps .
This approach consists of two steps :
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact 


First , by mining video archives , we automatically collect a set of faces of \MATH different people \MATH , where \MATH is the set of faces of person \MATH , and \MATH is the number of people .
First , by mining video archives , we automatically collect a set of faces of \MATH different persons \MATH , where \MATH is the set of faces of person \MATH , and \MATH is the number of persons; and
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#para -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact 


Second , we generate a set of subsets \MATH , where \MATH is the set of faces that is picked from \MATH , and \MATH is the number of subsets .
Second , we generate a set of subsets \MATH , where \MATH is the set of faces that is picked from \MATH , and \MATH is the number of subsets .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact 


The restriction is that the assumption of visual consistency is satisfied .
The restriction is the assumption of visual consistency is satisfied .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact 


In other words , as seen in Figure \REF , \MATH might have several face clusters and the largest cluster is equivalent to the faces relevant to the query if they are returned by a search engine .
In other words , as shown in Figure \REF , \MATH might have several face clusters and the largest cluster is equivalent to the faces relevant to the query if returning by a search engine .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#32#stem -1#31#33#exact -1#32#34#exact -1#33#35#exact -1#34#36#exact -1#35#37#exact 


As a result , this method can be used to stimulate face sets returned by search engines using many names as mentioned above .
As a result , this method can stimulate face sets returned by search engines using many names mentioned above .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#14#8#stem -1#7#9,10#para -1#8#11#exact -1#9#12#exact -1#10#13#exact -1#11#14#exact -1#12#15#exact -1#13#16#exact -1#15#18#exact -1#16#19#exact -1#17#21#exact -1#18#22#exact -1#19#23#exact 


To obtain \MATH , we use a simple technique for faces extracted from video archives .
To obtain \MATH , we use a simple technique for faces extracted from video archives .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact 


We specifically use the following heuristics to pick a set of different people appearing in video archives :
Specifically , We use the following heuristics to pick a set of different persons appearing in video archives :
-1#2#0#exact -1#0#1#lc -1#3#2#exact -1#4#3#exact -1#5#4#exact -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#para -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact 


-If there is more than one face appearing in different locations in one frame , they are likely to belong to different people .
-If there are more than one face appearing in different locations in one frame , they likely belong to different persons .
-1#0#0#exact -1#1#1#exact -1#2,3#2,3#para -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16,17#para -1#17,18#18,19#para -1#19#21#exact -1#20#22#para -1#21#23#exact 


Figure \REF shows an example where this has occurred .
Figure \REF shows an example of this case .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#6#6#exact -1#8#9#exact 


-If two people appear in video programs broadcast by different broadcast stations ( e.g. , CNN , MSNBC , and CCTV ) , they are likely to be different .
-If two persons appear in video programs broadcast by different broadcast stations ( e .g . , CNN , MSNBC , and CCTV ) , they are likely different .
-1#0#0#exact -1#1#1#exact -1#2#2#para -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#16#14#exact -1#17#15#exact -1#18#16#exact -1#19#17#exact -1#20#18#exact -1#21#19#exact -1#22#20#exact -1#23#21#exact -1#24#22#exact -1#25,26,27#23,24,25,26#para -1#28#27,28#para -1#29#29#exact 


If we have large video archives , we can collect a sufficient number of training samples to learn the relevance classifier by using these heuristics .
If we have large video archives , using these heuristics we can collect a sufficient number of training samples for learning the relevance classifier .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#10#7#exact -1#11#8#exact -1#12#9#exact -1#13#10#exact -1#14#11#exact -1#15#12#exact -1#16#13#exact -1#17#14#exact -1#18#15#exact -1#20#16,17#para -1#21#18#exact -1#22#19#exact -1#23#20#exact -1#7#21,22#para -1#8#23#exact -1#9#24#exact -1#24#25#exact 


We form face set Generating \MATH by picking a subset of faces of Generating \MATH and randomly adding faces from other sets Generating \MATH .
We form a face set Generating \MATH by picking a subset of faces of Generating \MATH and adding randomly faces from other sets Generating \MATH .
-1#0#0#exact -1#1#1#exact -1#3#2#exact -1#4#3#exact -1#5#4#exact -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#18#16#exact -1#17#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact -1#23#22#exact -1#24#23#exact -1#25#24#exact 


To keep satisfying the assumption of visual consistency , the number of faces selected in each set Generating \MATH must be smaller than the number of faces in set Generating \MATH .
To keep the assumption of visual consistency satisfied , the number of faces selected in each set Generating \MATH must be smaller than the number of faces in set Generating \MATH .
-1#0#0#exact -1#1#1#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#8#8#exact -1#22,23,24,25#9,10,11#para -1#26#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#9,10,11#22,23,24,25#para -1#12#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact 


We then label faces in set Generating \MATH as relevant to the query associated with Generating \MATH , and the other faces of Generating \MATH as irrelevant to the query .
We then label faces in set Generating \MATH as relevant to the query associated with Generating \MATH , and the other faces of Generating \MATH as irrelevant to the query .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact 


Once the training samples are collected , we use SVM with a linear kernel to learn the relevance classifier .
Once the training samples are collected , we use SVM with linear kernel to learn the relevance classifier .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact 


TRECVID dataset : We collected all video programs from the TRECVID 2006 dataset \CITE .
TRECVID dataset : We collected all video programs of TRECVID 2006 dataset \CITE .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact 


There were 527 video programs broadcast on seven channels in three languages including English , Chinese , and Arabic .
There are 527 video programs broadcast on 7 channels in 3 languages including English , Chinese and Arabic .
-1#0#0#exact -1#1#1#syn -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#syn -1#8#8#exact -1#9#9#exact -1#10#10#syn -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact 


We extracted faces from these video programs and grouped faces belonging to one person in each shot in one face track using a similar method to that described in \CITE .
We extracted faces from these video programs and grouped faces belonging to one person in each shot in one face track using a similar method described in \CITE .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#27#exact -1#26#28#exact -1#27#29#exact -1#28#30#exact 


We scanned all face tracks for each channel extracted from the videos broadcast by this channel , and picked face tracks extracted from key frames where several faces were detected at different locations .
For each channel , We scanned all face tracks extracted from the videos broadcast by this channel , and picked face tracks extracted from keyframes that several faces were detected at different locations .
-1#4#0#exact -1#5#1#exact -1#6#2#exact -1#7#3#exact -1#8#4#exact -1#0#5#lc -1#1#6#exact -1#2#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact -1#23#22#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact 


To guarantee selected face tracks representing different people , only the face tracks from one shot were picked for one channel .
To guarantee selected face tracks representing different persons , for one channel , only face tracks of one shot was picked .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#para -1#8#8#exact -1#13#9#exact -1#14#10,11#para -1#15#12#exact -1#10#14#exact -1#18#15#exact -1#19#16,17#para -1#9#18#exact -1#17#19#exact -1#11#20#exact -1#21#21#exact 


As a result , there were 5 ,126 faces of 19 face tracks selected from the seven channels corresponding to 19 different people .
As a result , there are 5 ,126 faces of 19 face tracks picked from the 7 channels corresponding to 19 different persons .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#syn -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#para -1#14#14#exact -1#15#15#exact -1#16#16#syn -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#para -1#23#23#exact 


Note that the system did not know the identity of these faces .
Note that , the system does not know the identity of these faces .
-1#0#0#exact -1#1#1#exact -1#3#2#exact -1#4#3#exact -1#5,6,7#4,5,6#para -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact 


It only knew any two face tracks represented different people .
It only knows any two face tracks represent different persons .
-1#0#0#exact -1#1#1#exact -1#2#2#syn -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#stem -1#8#8#exact -1#9#9#para -1#10#10#exact 


The number of faces in these face tracks is shown in Figure \REF .
The number of faces of these face tracks is shown in Figure \REF .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#10#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact 


We generated the 133 labeled sets described in Section \REF using these face tracks and used them to train the relevance classifier .
Using these face tracks , We generated 133 labeled sets described in Section \REF and used them for training the relevance classifier .
-1#5#0#exact -1#6#1#exact -1#19#2#exact -1#7#3#exact -1#8#4#exact -1#9#5#exact -1#10#6#exact -1#11#7#exact -1#12#8#exact -1#13#9#exact -1#0#10#lc -1#1#11#exact -1#2#12#exact -1#3#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17,18#17,18#para -1#20#19,20#para -1#21#21#exact -1#22#22#exact 


Yahoo News Images : This dataset consists of approximately half a million news photos and captions from Yahoo News collected over a period of roughly two years \CITE .
Yahoo News Images : This dataset consists of approximately half a million news photos and captions from Yahoo News collected over a period of roughly two years \CITE .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact 


Using peoplefs names as queries , we applied a simple string search to the captions in this dataset to return a list of faces for each queried name .
Using person names as queries , we applied simple string search to the captions this dataset to return a list of faces for each queried name .
-1#0#0#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#18#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#16#exact -1#15#17#exact -1#16#18#exact -1#17#19#exact -1#19#20,21#para -1#20#22#exact -1#21#23#exact -1#22#24#exact -1#23#25#exact -1#24#26#exact -1#25#27#exact -1#26#28#exact 


We used 23 names of celebrities such as George W .
We used 23 names of celebrities such as George W .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact 


Bush , Vladimir Putin , Ziang Jemin , Tony Blair , and Abdullah Gul .
Bush , Vladimir Putin , Ziang Jemin , Tony Blair , and Abdullah Gul .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact 


These names have widely been used in experiments \CITE .
These names are widely used in experiments such as \CITE .
-1#0#0#exact -1#1#1#exact -1#2#2#para -1#3#3#exact -1#4,5#4,5,6#para -1#6#7#exact -1#9#8#exact -1#10#9#exact 


A total of 9 ,136 faces were retrieved in which 3 ,909 faces were relevant .
In total , 9 ,136 faces were retrieved in which 3 ,909 faces were relevant .
-1#0,1#0,1,2#para -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact 


The accuracy was \MATH on average .
On average , The accuracy was \MATH .
-1#3#0#exact -1#4#1#exact -1#5#2#exact -1#6#3#exact -1#0#4#lc -1#1#5#exact -1#7#6#exact 


Google Images : We used the same set of peoplefs names used in the Yahoo News Images dataset and input them into the Google Image Search Engine .
Google Images : We used the same set of person names used in Yahoo News Images dataset and put to Google Image Search Engine .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#20#23#exact -1#21#24#exact -1#22#25#exact -1#23#26#exact -1#24#27#exact 


We crawled a maximum of 500 images from URLs returned by Google for each query .
For each query , We crawled a maximum of 500 images from URLs returned by Google .
-1#4#0#exact -1#5#1#exact -1#6#2#exact -1#7#3#exact -1#8#4#exact -1#9#5#exact -1#10#6#exact -1#11#7#exact -1#12#8#exact -1#13#9#exact -1#14#10#exact -1#15#11#exact -1#0#12#lc -1#1#13#exact -1#2#14#exact -1#16#15#exact 


A total of 9 ,516 faces were extracted in which 5 ,816 faces were relevant .
In total , 9 ,516 faces were extracted in which 5 ,816 faces were relevant .
-1#0,1#0,1,2#para -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact 


The accuracy was \MATH on average .
On average , The accuracy was \MATH .
-1#3#0#exact -1#4#1#exact -1#5#2#exact -1#6#3#exact -1#0#4#lc -1#1#5#exact -1#7#6#exact 


The TRECVID dataset was used for training the generic classifier .
The TRECVID dataset was used for training the generic classifier .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact 


The datasets for Yahoo News Images and Google Images , as shown in Figure \REF , were used for testing .
The datasets , Yahoo News Images and Google Images as shown in Figure \REF , were used for testing .
-1#0#0#exact -1#1#1#exact -1#17#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#2#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#18#19#exact -1#19#20#exact 


We used the Viola-Jones face detector \CITE to detect frontal faces in images and video frames .
We used the Viola-Jones face detector \CITE to detect frontal faces in images and video frames .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact 


We simply used a similar technique to that described in \CITE to group faces belonging to one person in one video shot .
To group faces belonging to one person in one video shot , We simply used a similar technique described in \CITE .
-1#12#0#exact -1#13#1#exact -1#14#2#exact -1#15#3#exact -1#16#4#exact -1#17#5#exact -1#4#6#exact -1#18#8#exact -1#19#9#exact -1#20#10#exact -1#0#11#lc -1#1#12#exact -1#2#13#exact -1#3#14#exact -1#5#16#exact -1#6#17#exact -1#7#18#exact -1#8#19#exact -1#9#20#exact -1#10#21#exact -1#21#22#exact 


Using prior knowledge that faces of the same person in consecutive frames do not change much in locations and appearance , the technique used tracked points to robustly associate these faces in face tracks with a precision of \MATH .
Using the prior knowledge that faces of the same person in consecutive frames do not change much in locations and appearance , the technique used tracked points to robustly associate these faces into face tracks with the precision of \MATH .
-1#0#0#exact -1#2#1#exact -1#3#2#exact -1#4#3#exact -1#5#4#exact -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact -1#23#22#exact -1#24#23#exact -1#25#24#exact -1#26#25#exact -1#27#26#exact -1#28#27#exact -1#29#28#exact -1#30#29#exact -1#31#30#exact -1#33#32#exact -1#34#33#exact -1#35#34#exact -1#37#36#exact -1#38#37#exact -1#39#38#exact -1#40#39#exact 


Once faces were extracted , we used the code provided by the authors \CITE to extract features .
Once faces were extracted , we used the code provided by the authors \CITE to extract features .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact 


Each face was then represented as a point in a very high dimensional feature space .
Each face is then represented as a point in a very high dimensional feature space .
-1#0#0#exact -1#1#1#exact -1#2#2#syn -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact 


Nine facial-feature points were specifically detected for each face , and four more facial feature points were inferred from these nine points .
Specifically , for each face , 9 facial feature points were detected , and 4 more facial feature points were inferred from these 9 points .
-1#9#2#exact -1#10#3#exact -1#0#4#lc -1#11#5#exact -1#2#6#exact -1#3#7#exact -1#4#8#exact -1#5#9#exact -1#13#10#exact -1#14#11#syn -1#15#12#exact -1#16#13#exact -1#17#14#exact -1#18#15#exact -1#19#16#exact -1#20#17#exact -1#21#18#exact -1#22#19#exact -1#23,24#20,21#para -1#25#22#exact 


There were a total of 13 feature points from which features were extracted .
In total , There were 13 feature points from which features are extracted .
-1#3#0#exact -1#4#1#exact -1#0,1#2,3#para -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#syn -1#12#12#exact -1#13#13#exact 


The features were intensity values lying within a circle with a radius of 15 pixels .
The features are intensity values lying within the circle with radius of 15 pixels .
-1#0#0#exact -1#1#1#exact -1#2#2#syn -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7,8#7,8#para -1#9#9#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact 


The output feature had 13x149 = 1 ,937 dimensions .
The output feature has 13x149 = 1 ,937 dimensions .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#syn -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact 


Figure \REF illustrates this feature .
Figure \REF shows illustration of this feature .
-1#0#0#exact -1#1#1#exact -1#2#2#para -1#5#3#exact -1#6#4#exact -1#7#5#exact 


We evaluated the efficiency of retrieval with measures that are commonly used in information retrieval , such as precision , recall , and average precision .
We evaluated the retrieval performance with measures that are commonly used in information retrieval , such as precision , recall , and average precision .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact 


Given a queried person and letting \MATH be the total number of faces returned , \MATH the number of relevant faces , and \MATH the total number of relevant faces , recall and precision can be calculated as : \MATH .
Given a queried person and letting \MATH be the total number of faces returned , \MATH the number of relevant faces , and \MATH the total number of relevant faces , recall and precision can be calculated as follows : \MATH .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8,9,10,11#8,9,10#para -1#18#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#24,25,26,27#16,17,18#para -1#28#19#exact -1#29#20#exact -1#30#21#exact -1#22#22#exact -1#23#23#exact -1#16#24#exact -1#17#25,26#para -1#19#28#exact -1#20#29#exact -1#21#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact -1#37#37#exact -1#39#38#exact -1#40#39#exact -1#41#40#exact 


Precision and recall were only used to evaluate the quality of an unordered set of retrieved faces .
Precision and recall only evaluate the quality of an unordered set of retrieved faces .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#4#exact -1#4,5#6,7,8#para -1#6#9#exact -1#7#10#exact -1#8#11#exact -1#9#12#exact -1#10#13#exact -1#11#14#exact -1#12#15#exact -1#13#16#exact -1#14#17#exact 


Average precision is usually used to evaluate ranked lists in which both recall and precision are taken into account .
To evaluate ranked lists in which both recall and precision are taken into account , the average precision is usually used .
-1#16#0#lc -1#17#1#exact -1#18#2#exact -1#19#3#exact -1#20#4#exact -1#0#5#lc -1#1#6#exact -1#2#7#exact -1#3#8#exact -1#4#9#exact -1#5#10#exact -1#6#11#exact -1#7#12#exact -1#8#13#exact -1#9#14#exact -1#10#15#exact -1#11#16#exact -1#12#17#exact -1#13#18#exact -1#21#19#exact 


The average precision is computed by taking the average of the interpolated precision measured at 11 recall levels of 0 .0 , 0 .1 , 0 .2 , . . . , 1 .0 .
The average precision is computed by taking the average of the interpolated precision measured at the 11 recall levels of 0 .0 , 0 .1 , 0 .2 , . . . , 1 .0 .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#6,7,8#5,6,7,8#para -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact -1#23#22#exact -1#24#23#exact -1#25#24#exact -1#26#25#exact -1#27#26#exact -1#28#27#exact -1#29#28#exact -1#30#29#exact -1#31#30#exact -1#32#31#exact -1#33#32#exact -1#34#33#exact -1#35#34#exact 


The interpolated precision , \MATH , at a certain recall level , \MATH , is defined as the highest precision found for any recall level \MATH :
The interpolated precision \MATH at a certain recall level \MATH is defined as the highest precision found for any recall level \MATH :
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#4#exact -1#4#6#exact -1#5#7#exact -1#6#8#exact -1#7#9#exact -1#8#10#exact -1#9#12#exact -1#10#14#exact -1#11#15#exact -1#12#16#exact -1#13#17#exact -1#14#18#exact -1#15#19#exact -1#16#20#exact -1#17#21#exact -1#18#22#exact -1#19#23#exact -1#20#24#exact -1#21#25#exact -1#22#26#exact 


In addition , we used the mean average precision to evaluate the performance of multiple queries , which is the mean of average precisions computed from queries .
In addition , to evaluate the performance of multiple queries , we used mean average precision , which is the mean of average precisions computed from queries .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#11#3#exact -1#12#4#exact -1#19#5#exact -1#20#6#exact -1#14#7#exact -1#15#8#exact -1#3#9#exact -1#4#10#exact -1#5#11#exact -1#6#12#exact -1#7#13#exact -1#8#14#exact -1#9#15#exact -1#10#16#exact -1#17#17#exact -1#18#18#exact -1#13#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact 


We compared the performance of the Maximum A-Posteriori ( MAP ) algorithm in seven systems in this experiment by testing it on YahooNews Images :
In this experiment , We compare the MAP performance of the following systems testing on YahooNews Images :
-1#4#0#exact -1#5#1#stem -1#6#2#exact -1#8#3#exact -1#9#4#exact -1#10#5#exact -1#7#9#exact -1#0#12#lc -1#12#14#exact -1#1#16#exact -1#2#17#exact -1#13#19#exact -1#14#21#exact -1#15#22#exact -1#16#23#exact -1#17#24#exact 


-DistScore-TrainGoogleImages : The training set was the set of annotated faces returned by Google Images Search for 23 peoplefs names .
-DistScore-TrainGoogleImages : The training set is the set of annotated faces returned by Google Images Search for 23 person names .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5,6#5,6#para -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#19#19#exact -1#20#20#exact 


The feature vector was computed using \MATH .
The feature vector is computed using \MATH .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#syn -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact 


-NNScore-TrainGoogleImages : The training set was the same as DistScore-TrainGoogleImages .
-NNScore-TrainGoogleImages : The training set is the same as DistScore-TrainGoogleImages .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5,6#5,6#para -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact 


The feature vector was computed using \MATH .
The feature vector is computed using \MATH .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#syn -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact 


DistScore-TrainTRECVID : The feature vector was computed using .
DistScore-TrainTRECVID : The feature vector is computed using .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#syn -1#6#6#exact -1#7#7#exact -1#8#8#exact 


The training set was the set of annotated faces artificially generated with our method described in Section \REF .
The training set is the set of annotated faces artificially generated by our method described in Section \REF .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3,4#3,4#para -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact 


-NNScore-TrainTRECVID : The training set was the same as DistScore-TrainTRECVID .
-NNScore-TrainTRECVID : The training set is the same as DistScore-TrainTRECVID .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5,6#5,6#para -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact 


The feature vector was computed using \MATH .
The feature vector is computed using \MATH .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#syn -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact 


-Krapac[11]-TrainGoogleImages : The training set was the same as DistScore-TrainGoogleImages .
-Krapac[11]-TrainGoogleImages : The training set is the same as DistScore-TrainGoogleImages .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5,6#5,6#para -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact 


We re-implemented the method proposed by Krapac et al. \CITE of extracting the query-dependent feature .
We re-implemented the method proposed by Krapac et al . \CITE for extracting query-dependent feature .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#10#9#exact -1#12#11#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact 


Since this method was proposed to handle images , not faces , we modified it to handle faces .
Since this method was proposed to handle images , not for faces , we modified it for handling faces .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16,17#15,16#para -1#18#17#exact -1#19#18#exact 


Each face was specifically represented as a bag of visual words .
Specifically , Each face is represented as a bag of visual words .
-1#2#0#exact -1#3#1#exact -1#4#2#syn -1#0#3#lc -1#5#4#exact -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact 


We used 13 facial-feature points detected in each face and their descriptors using pixel intensity as visual words .
We used 13 facial feature points detected in each face and their descriptors using pixel intensity as visual words .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#5#4#exact -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact 


The codebook was formed by clustering all visual words extracted from all faces of the training set into 200 clusters .
The codebook is formed by clustering all visual words extracted from all faces of the training set into 200 clusters .
-1#0#0#exact -1#1#1#exact -1#2#2#syn -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact 


The top-$k$ visual words strongly related to the returned faces of each query and the binary feature vector were computed as described in \CITE .
top-$k$ visual words strongly related to the returned faces of each query and the binary feature vector are computed as described in \CITE .
-1#6#0#lc -1#0#1#exact -1#1#2#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#13#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#syn -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact 


-Mensink[15]-GaussianModels : This method proposed by Mensink et al. \CITE modeled the returned faces by using two Gaussians , the first for the faces relevant to the target person and the second for the remaining faces .
-Mensink[15]-GaussianModels : This method proposed by Mensink et al . \CITE models the returned faces by using two Gaussians , one for the faces relevant to the target person and one for the remaining faces .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#10#9#exact -1#11#10#stem -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#22#19#exact -1#31#21#exact -1#32#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#21#32#exact -1#33#33,34#para -1#34#35#exact -1#35#36#exact 


-Mensink[15]-Friends : This method proposed by Mensink et al. \CITE used linear discriminant analysis to train a specific classifier for each query .
-Mensink[15]-Friends : This method proposed by Mensink et al . \CITE uses linear discriminant analysis to train a specific classifier for each query .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#10#9#exact -1#11#10#stem -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact -1#23#22#exact 


This method used detected peoplefs names in captions associated with faces for query expansion to model faces of the target person 's friends .
This method uses detected person names in captions associated with faces for query expansion to model faces of the target person 's friends .
-1#0#0#exact -1#1#1#exact -1#2#2#stem -1#3#3#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact 


Methods such as Mensink[15]-GaussianModels and Mensink[15]-Friends are state-of-the-art that learn a specific classifier for each query .
The Methods such as Mensink[15]-GaussianModels and Mensink[15]-Friends are the state of the art methods that learn a specific classifier for each query .
-1#1#0#exact -1#2#1#exact -1#3#2#exact -1#4#3#exact -1#5#4#exact -1#6#5#exact -1#7#6#exact -1#14#8#exact -1#15#9#exact -1#16#10#exact -1#17#11#exact -1#18#12#exact -1#19#13#exact -1#20#14#exact -1#21#15#exact -1#22#16#exact 


Krapac[11]-TrainGoogleImages is similar to our method in which one generic classifier is trained in advance and then used for new queries .
The method Krapac[11]-TrainGoogleImages is similar to our method in which one generic classifier is trained in advance and then is used for new queries .
-1#2#0#exact -1#3#1#exact -1#4#2#exact -1#5#3#exact -1#6#4#exact -1#7#5#exact -1#8#6#exact -1#9#7#exact -1#10#8#exact -1#11#9#exact -1#12#10#exact -1#13#11#exact -1#14#12#exact -1#15#13#exact -1#16#14#exact -1#17#15#exact -1#18#16#exact -1#19,20,21#17,18#para -1#22#19#exact -1#23#20#exact -1#24#21#exact 


Figure \REF compares the performance of these systems when they were tested on the YahooNews Images dataset .
Figure \REF shows the performance comparison of these systems when testing on YahooNews Images dataset .
-1#0#0#exact -1#1#1#exact -1#3#3#exact -1#4#4#exact -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#11#stem -1#11#12#exact -1#12#14#exact -1#13#15#exact -1#14#16#exact -1#15#17#exact 


The curves plot the correlation between performance and the number of features for systems such as DistScore-TrainGoogleImages , NNScore-TrainGoogleImages , DistScore-TrainTRECVID , and NNScore-TrainTRECVID .
As for systems such as DistScore-TrainGoogleImages , NNScore-TrainGoogleImages , DistScore-TrainTRECVID , and NNScore-TrainTRECVID , the curves show the correlation between the performance and the number of features .
-1#14#0#lc -1#15#1#exact -1#17#3#exact -1#18#4#exact -1#19#5#exact -1#21#6#exact -1#22#7#exact -1#23#8#exact -1#24#9#exact -1#25#10#exact -1#26#11#exact -1#1#12#exact -1#2#13#exact -1#3#14#exact -1#4#15#exact -1#5#16#exact -1#6#17#exact -1#7#18#exact -1#8#19#exact -1#9#20#exact -1#10#21#exact -1#11#22#exact -1#12#23#exact -1#27#24#exact 


-DistScore performed significantly better than NNScore .
-DistScore is significantly better than that of NNScore .
-1#0#0#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#7#5#exact -1#8#6#exact 


-The performance of DistScore and NNScore was not affected by selecting the number of features .
-The performance of DistScore and NNScore are not affected by selecting the number of features .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#syn -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact 


Therefore , we could use small numbers of features to reduce the computational cost .
Therefore , we can use small number of features for reducing the computational cost .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3,4#3,4#para -1#5#5#exact -1#6,7#6,7#para -1#8#8#exact -1#9,10#9,10#para -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact 


-The performance of the system using training data generated artificially with our method was comparable to that of the system using training data returned by search engines .
-The performance of the system using the training data generated artificially by our method is comparable with that of the system using the training data returned by search engines .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#16#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#syn -1#15#14#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#23#21#exact -1#24#22#exact -1#25#23#exact -1#26#24#exact -1#27#25#exact -1#28#26#exact -1#29#27#exact 


-The method of DistScore-TrainTRECVID we propose performed comparably to the state-of-the-art method in the specific classifier-based approach of Mensink[15]-Friends .
-Our proposed method DistScore-TrainTRECVID has comparable performance to the state of the art method in specific classifier-based approach Mensink[15]-Friends .
-1#2#1#exact -1#10#2#exact -1#3#3#exact -1#1#4,5#para -1#4#6#para -1#5#7#stem -1#7#8#exact -1#8#9#exact -1#13#11#exact -1#14#12#exact -1#11#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#18#exact -1#19#19#exact 


It outperformed the method where only visual information was used , i.e. , Mensink[15]-GaussianModels .
It outperforms the method using only visual information Mensink[15]-GaussianModels .
-1#0#0#exact -1#1#1#stem -1#2#2#exact -1#3#3#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#4#9#stem -1#8#13#exact -1#9#14#exact 


-Our proposed method DistScore-TrainTRECVID outperformed the method proposed by Krapac et al. , which was customized to handle faces .
-Our proposed method DistScore-TrainTRECVID outperforms the method proposed by Krapac et al . customized for handling faces .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#stem -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#13#15#exact -1#14,15#16,17#para -1#16#18#exact -1#17#19#exact 


As seen in Figure \REF , DistScore-TrainTRECVID outperformed the original ranking of the Google Images Search Engine if from 20 to 50 features were used .
As shown in Figure \REF , DistScore-TrainTRECVID outperforms original ranking of Google Images Search Engine if using from 20 to 50 features .
-1#0#0#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#stem -1#8#8,9#para -1#9#10#exact -1#10#11#exact -1#11#13#exact -1#12#14#exact -1#13#15#exact -1#14#16#exact -1#15#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#16#24#stem -1#22#25#exact 


The results for DistScore-TrainTRECVID on the YahooNews Images set and Google Images set indicate that the relevance classifier with our proposed method was able to generalize well on different queries and was independent of underlying ranking algorithms used in search engines .
The result of DistScore-TrainTRECVID on YahooNews Images set and Google Images set indicates that the relevance classifier of our proposed method is able to generalize well on different queries and independent with underlying ranking algorithms of search engines .
-1#0#0#exact -1#1#1#stem -1#3#3#exact -1#4#4#exact -1#14#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12,13#13,14#para -1#15#15,16#para -1#16#17#exact -1#31#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#syn -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact -1#28#29#exact -1#29#30#exact -1#30#32#exact -1#2#33#exact -1#32#34#exact -1#33#35#exact -1#34#36#exact -1#36#39#exact -1#37#40#exact -1#38#41#exact 


Figure \REF shows an example of re-ranking results for the top-30 faces for the query John Paul , which is one of the most difficult cases in the YahooNews Images set .
Figure \REF shows an example of re-ranking result of top-30 faces for the query John Paul that is one of the most difficult cases of the YahooNews Images set .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#stem -1#11#8#exact -1#12#9#exact -1#9#10#exact -1#10#11#exact -1#20#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16,17,18,19#18,19,20,21#para -1#25#22#exact -1#21#23#exact -1#22#24#exact -1#23#25#exact -1#26#28#exact -1#27#29#exact -1#28#30#exact -1#29#31#exact 


The results clearly demonstrate that our proposed method outperformed the other state-of-the-art methods .
The result clearly shows that our proposed method outperforms the other state of the art methods .
-1#0#0#exact -1#1#1#stem -1#2#2#exact -1#3,4#3,4#para -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#stem -1#9#9#exact -1#10#10#exact -1#15#12#exact -1#16#13#exact 


Our query-dependent feature was based on the nearest neighbors of images in the returned image set that usually have a complexity of \MATH , where \MATH is the total number of images in the set .
Our query-dependent feature is based on nearest neighbors of the images in the returned image set that usually have complexity of \MATH , where \MATH is the total number of images in the set .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3,4#3,4#para -1#5#5#exact -1#9#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26,27,28,29#27,28,29#para -1#30#30,31#para -1#31#32#exact -1#32#33#exact -1#33#34#exact -1#34#35#exact 


However , recent studies on indexing techniques such as \MATH -d tree , locality sensitive hashing ( LSH ) , and a Self Adaptive Set of Histograms ( SASH ) \CITE could significantly speed up the nearest neighbor search .
However , recent studies on indexing techniques such as \MATH -d tree , locality sensitive hashing ( LSH ) , and SASH \CITE can speed up the nearest neighbor search significantly .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#28#exact -1#22#30#exact -1#23#31#para -1#30#32#exact -1#24#33#exact -1#25#34#exact -1#26#35#exact -1#27#36#exact -1#28#37#exact -1#29#38#exact -1#31#39#exact 


For example , the complexity of the fast lookup of $k$ approximate nearest neighbors is \MATH \CITE .
For example , as described in \CITE , the complexity of fast lookup of $k$ approximate nearest neighbors is \MATH \CITE .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#9,10#3,4,5,6#para -1#11#7#exact -1#12#8#exact -1#13#9#exact -1#14#10#exact -1#15#11#exact -1#16#12#exact -1#17#13#exact -1#18#14#exact -1#19#15#exact -1#20#16#exact -1#21#17#exact 


Studying other techniques to speed up the process of query-feature extraction is our next step in future work .
Studying other techniques to speedup the query-feature extraction process is our next step in future work .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#8#5,6,7,8#para -1#6#9#exact -1#7#10#exact -1#9#11#exact -1#10#12#exact -1#11#13#exact -1#12#14#exact -1#13#15#exact -1#14#16#exact -1#15#17#exact -1#16#18#exact 


376
b</subsection>



We have presented a novel method of re-ranking face images returned by existing search engines .
We have presented a novel method for re-ranking face images returned by existing search engines .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5,6#5,6#para -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact 


0
Instead of training a specific classifier for each new query , we train only one generic classifier and use it for ranking new queries .



Enhancing mathematical searches with names of formulas
Enhancing mathematical search with names of formulas
-1#0#0#exact -1#1#1#exact -1#2#2#stem -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact 


We present a method to enhance the performance of a mathematical search system .
We present a method to enhance the performance of a mathematical search system in this paper .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#16#13#exact 


By targeting mathematical formulas that appear in natural language documents , we collect the names of formulas from the surrounding text and incorporate the correspondence into the search system 's database .
Targeting to mathematical formulas that appear in natural language documents , we collect the names of formulas from the surrounding text , and incorpo-rate the correspondence to the search system 's database .
-1#0#1#lc -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#22#21#exact -1#24#23#exact -1#25#24#exact -1#27#26#exact -1#28#27#exact -1#29#28#exact -1#30#29#exact -1#31#30#exact -1#32#31#exact 


The effectiveness of the approach is demonstrated through experiments using Wikipedia mathematical articles and Wolfram Functions Site data sets .
E ectiveness of the proposed approach is shown through experiments using Wikipedia mathematical articles and Wolfram Functions Site data sets .
-1#2#2#exact -1#3#3#exact -1#5#4#exact -1#6#5#exact -1#7#6#syn -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact 


The mathematical content being published on the Web is increasing day by day , and retrieving mathematical content has become an important issue for many users .
In the current digital environment , the mathematical content being published on the Web is increasing day by day . While more and more mathematical contents being available on the Web , retrieving mathematical contents becomes an important issue for many users .
-1#6#0#lc -1#7#1#exact -1#8#2#exact -1#9#3#exact -1#10#4#exact -1#11#5#exact -1#12#6#exact -1#13#7#exact -1#14#8#exact -1#15#9#exact -1#16#10#exact -1#17#11#exact -1#18#12#exact -1#5#13#exact -1#22#14#exact -1#32#15#exact -1#33#16#exact -1#34#17,18#para -1#35#19#stem -1#36#20#exact -1#37#21#exact -1#38#22#exact -1#39#23#exact -1#40#24#exact -1#41#25#exact -1#42#26#exact 


Teachers , students , and researchers need better access to mathematical resources for teaching , studying , and obtaining information for research and development .
Teach-ers , students , researchers do need to gain access to mathematical resources for teaching , studying , or obtaining updated information for research and development .
-1#1#1#exact -1#2#2#exact -1#3#3#exact -1#24#4#exact -1#4#5#exact -1#6#6#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#19#18#exact -1#21#19#exact -1#22#20#exact -1#23#21#exact -1#25#23#exact -1#26#24#exact 


Moreover , users need specialized search systems to find formulas that are relevant to their needs .
Therefore , users need specialized search systems to nd the formula that is relevant to their requirements .
-1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#10#9#stem -1#11#10#exact -1#12,13#11,12#para -1#14#13#exact -1#15#14#exact -1#16#15#para -1#17#16#exact 


Internet search engines can detect particular keywords in mathematical formulas but they mostly fail at recognizing mathematical symbols and constructs such as integral and square root symbols , fractions , and matrices .
Internet search engines are able to detect some particular keywords in mathematical formula but they mostly fail to recognize mathematical symbols and constructs such as integral sym-bols , square root symbols , fractions , or matrices .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3,4,5#3#para -1#6#4#exact -1#8#5#exact -1#9#6#exact -1#10#7#exact -1#11#8#exact -1#12#9#stem -1#13#10#exact -1#14#11#exact -1#15#12#exact -1#16#13#exact -1#18#15#stem -1#19#16#exact -1#20#17#exact -1#21#18#exact -1#22#19#exact -1#23#20#exact -1#24#21#exact -1#25#22#exact -1#28#24#exact -1#29#25#exact -1#30#26#exact -1#31#27#exact -1#32#28#exact -1#33#29#exact -1#35#31#exact -1#36#32#exact 


There are some mathematically oriented search engines on the Internet .
There exist some mathematical-dedicated search engines available on the Internet .
-1#0#0#exact -1#1#1#syn -1#2#2#exact -1#4#5#exact -1#5#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact 


Although such engines provide more accurate and relevant results , they usually do not provide enough information for the user .
Although such engines provide more accurate and relevant results , they usually do not provide enough information for the user .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact 


Furthermore , these systems do not take into account the semantics of mathematical formulas as revealed by the surrounding natural language text , e.g. , the formulafs name or the description of its variables .
Furthermore , these systems do not take into account the semantics of mathematical formulas revealed by surrounding natural language text , like the name of the formula and its variables' descrip-tion .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#5,6,7,8,9#4,5,6,7,8,9#para -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#15#exact -1#15#16#exact -1#22#17#exact -1#16#18#exact -1#17#19#exact -1#18#20#exact -1#19#21#exact -1#20#22#exact -1#25#25#exact -1#23#27#exact -1#4#28#para -1#24#31#exact -1#28#32#exact -1#29#33#stem -1#31#34#exact 


The Digital Library of Mathematical Functions ( DLMF ) project is a mathematical database available on the Web [8] .
The Digital Library of Mathematical functions ( DLMF ) project is a mathematical database available on the Web [8] .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#lc -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact 


This site provides a major resource of mathematical reference data for special formulas and their applications .
This site provides a major resource of mathematical reference data for special formulas and their applications .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact 


But even this site does not provide a full mathematical search .
But full mathematical search is still not available .
-1#0#0#exact -1#6#5#exact -1#1#8#exact -1#2#9#exact -1#3#10#exact -1#8#11#exact 


Other systems that support mathematical searches are MathFind [4] , MathWebSearch [3] .
Other systems that support mathematical search are MathFind [4] , MathWebSearch [3] .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#stem -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact 


These systems , however , provide neither similarity structures nor semantic meanings of their formulas .
These systems , however , provide neither similarity structures nor semantic meanings of the formulas .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#14#14#exact -1#15#15#exact 


The Wolfram Functions Site [7] contains a large number of mathematical formulas and also provides a semantic search for them .
The Wolfram Functions Site [7] contains large mathe-matical formulas and also provides a semantics search for mathematical formulas .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#12#6#exact -1#6#7#exact -1#16#10#exact -1#17#11#exact -1#9#12#exact -1#10#13#exact -1#11#14#exact -1#13#16#stem -1#14#17#exact -1#15#18#exact -1#18#20#exact 


This site and some recent work done by Adeel et al. [2] and Yokoi and Aizawa [1] employ similarity search methods based on MathML but they do not make use of the semantics of the formulas' surrounding text . //[ ? ? propose is unclear in the sense of a website .]
This site and some recent works done by Adeel et al. [2] and Yokoi and Aizawa [1] propose similarity search methods based on MathML but these works do not make use of the semantics of the formulas' surrounding text , which is considered to be important information sources .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#stem -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#30,31#17#para -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#27#25,26#para -1#28#27#exact -1#29#28#exact -1#34#30#exact -1#35#31#exact -1#33#32#exact -1#32#34#exact -1#36#35#exact -1#37#36#exact -1#38#37#exact -1#48#38#exact -1#17#42#exact -1#41#43#exact -1#40#47,48,49#para 


The work presented in this paper focuses on retrieving mathematical formulas on the Web by using mathematical expressions and the surrounding natural language text .
The work presented in this paper focuses on retrieving mathematical formulas on the Web using mathematical expressions and the surrounding natural language text .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14,15#para -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact 


We describe our work toward creating a mathematical database that contains formulas , their names , variable descriptions , and other related information .
We describe here in detail our work toward creating a mathematical database that contains for-mulas , their names , their variables' descriptions and other related information .
-1#0#0#exact -1#1#1#exact -1#5#2#exact -1#6#3#exact -1#7#4#exact -1#8#5#exact -1#9#6#exact -1#10#7#exact -1#11#8#exact -1#12#9#exact -1#13#10#exact -1#15#12#exact -1#16#13#exact -1#17#14#exact -1#18#15#exact -1#20#16#stem -1#21#17#exact -1#22#19#exact -1#23#20#exact -1#24#21#exact -1#25#22#exact -1#26#23#exact 


We implemented a mathematical search system that uses this information as its base knowledge .
We also implement a mathematical search system that use this information as its base knowledge .
-1#0#0#exact -1#2#1#stem -1#3#2#exact -1#4#3#exact -1#5#4#exact -1#6#5#exact -1#7#6#exact -1#8#7#stem -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact 


This information is very helpful when performing mathematical search by reducing the need for formula input and solving the notational variation problem where mathematically equivalent formulas follow different notations .
This information is very helpful when performing mathematical search by reducing the need for formula input and solving the notational variation problem where mathematically equivalent formulas follow di erent notations .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#29#28#exact -1#30#29#exact 


The relationship between formulas and their names can also be used to correct errors in mathematical OCR systems , such as Infty [5] .
Relations between formulas and their name could also be used to correct errors in mathematical OCR systems , such as Infty [5] .
-1#0#0,1#para -1#1#2#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#stem -1#6,7,8,9#7,8,9,10#para -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact 


It also provides opportunities to make mathematics better understandable and usable for people with disabilities .
It also provides opportunities to make mathematical better understandable and usable for di erent groups of people with disabilities .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#stem -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#16#12#exact -1#17#13#exact -1#18#14#exact -1#19#15#exact 


The remainder of this paper is organized as follows : we present an overview of our framework in section 2 .
The remainder of this paper is organized as follow : In section 2 , we present an overview of the proposed framework .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#stem -1#9#9#exact -1#14#10#exact -1#15#11#exact -1#16#12#exact -1#17#13#exact -1#18#14#exact -1#21#15,16#para -1#10#17#lc -1#11#18#exact -1#12#19#exact -1#22#20#exact 


We then describe the results of our experiments in section 3 .
We then describe the results of our experiments in section 3 .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#4,5,6#3,4,5,6#para -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact 


Section 4 concludes the paper and gives avenues of future study .
Section 4 concludes the paper and gives avenues for future works .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8,9#8,9#para -1#10#10#syn -1#11#11#exact 


Mathematical formulas on the Web have many different formats , e.g. , LaTeX and Mathematical Markup Language ( MathML ) [6] .
Mathematical formulas on the Web has many di erent formats , some of them are LaTeX , and the Mathematical Markup Language ( MathML ) [6] .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5,6#5,6#para -1#9#8#exact -1#10#9#exact -1#16#11#exact -1#15#12#exact -1#17#13#exact -1#19#14#exact -1#20#15#exact -1#21#16#exact -1#22#17#exact -1#23#18#exact -1#24#19#exact -1#25#20#exact -1#26#21#exact 


This diversity makes searches more difficult .
This makes the search more dif-cult .
-1#0#0#exact -1#1#2#exact -1#3#3#stem -1#4#4#exact -1#6#6#exact 


In this paper , we shall use the MathML format for mathematical formulas .
In this paper , we use the presentation MathML format for mathematical formulas .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#6#exact -1#6#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact 


Formulas with other formats can be easily converted to MathML format by using freely available tools .
Formulas with other formats can be easily converted to MathML format using existing freely available tools .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11,12#para -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact 


For our work , we used LaTeXML Converter , which is freely available at \URL .
For our works , we use LaTeXML Converter which is freely available at \URL .
-1#0#0#exact -1#1#1#exact -1#2#2#stem -1#3#3#exact -1#4#4#exact -1#5#5#stem -1#6#6#exact -1#7#7#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact 


We automatically collected our mathematical formulas from Wikipedia and the Wolfram Functions Site .
We automatically collected our mathematical formulas from Wikipedia and the Wolfram Functions Site .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact 


Figure 1 shows a page from a mathematical section on Wikipedia and the information we retrieved on this site , besides the mathematical formulas .
Figure 1 shows a page on mathematical section on Wikipedia and the information we retrieved on this site besides the mathematical formulas .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#6#6,7#para -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#20#exact -1#19#21#exact -1#20#22#exact -1#21#23#exact -1#22#24#exact 


We used heuristics to ensure adequate matching of mathematical formulas with their names .
At this point , we use some heuristics to provide an adequate solution for matching mathematical formulas with their names .
-1#4#0#lc -1#5,6#1#para -1#7#2#exact -1#8#3#exact -1#11#5#exact -1#14#6#exact -1#15#8#exact -1#16#9#exact -1#17#10#exact -1#18#11#exact -1#19#12#exact -1#20#13#exact 


These heuristics are based on the type settings and distances between the name strings and formulas on the same page .
These heuristics are based on the type settings and distances between the name strings and formulas in the same page .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16,17,18#16,17,18#para -1#19#19#exact -1#20#20#exact 


After collecting mathematical formulas from these resources , we extracted keywords for indexing .
After collecting the mathematical formulas from these resources , we extract keywords for indexing .
-1#0#0#exact -1#1#1#exact -1#3#2#exact -1#4#3#exact -1#5#4#exact -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#stem -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact 


The keywords included formulas' names , operators , variables' names , and so on .
The keywords include formulas' names , operators , variables' names , and so on .
-1#0#0#exact -1#1#1#exact -1#2#2#stem -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact 


Our system allows two ways of searching : text content and formula content .
Our system allows two ways of searching : text content search and formula content search .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#15#13#exact 


In a text content search , users search with extracted keywords , e.g. , " sin " , " Pythagorean " or " trigonometric functions " .
In the rst case , users can use the extracted keywords for search , for example : " sin " , " Pythagorean " or " trigonometric functions " .
-1#0#0#exact -1#12#4#exact -1#4#5#exact -1#5#6#exact -1#9#9#exact -1#10#10#exact -1#13#11#exact -1#20#13#exact -1#21#14#exact -1#18#15#exact -1#19#16#exact -1#17#18#exact -1#22#19#exact -1#23#20#exact -1#24#21#exact -1#25#22#exact -1#26#23#exact -1#27#24#exact -1#28#25#exact -1#29#26#exact 


In a formula content search , users directly input the formulas , for example : \MATH .
In the second case , users can input the mathematical formulas directly , for example : \MATH .
-1#0#0#exact -1#4#5#exact -1#5#6#exact -1#11#7#exact -1#7#8#exact -1#8#9#exact -1#10#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact 


The system then looks for relevant formula names .
The system then looks for relevant formula names .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact 


If found , it will return other information related to that formula .
If found , it will return other information related with that formula .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact 


If nothing matching is found , it looks for mathematical formulas which are similar to the input ( including formulas with a similar structure ) .
Else , it just looks for mathematical formulas which are similar to the input ( including formulas with similar structure ) .
-1#1#5#exact -1#2#6#exact -1#4#7#exact -1#5#8#exact -1#6#9#exact -1#7#10#exact -1#8,9,10,11#11,12,13#para -1#12#15#exact -1#13#16#exact -1#14#17#exact -1#15#18#exact -1#16#19#exact -1#17#20#exact -1#18#21,22#para -1#19#23#exact -1#20#24#exact -1#21#25#exact 


Evaluating a mathematical search system is not an easy task because we do not have any standard for this task .
Evaluate a mathematical search system is not an easy task because we do not have any standard for this task .
-1#0#0#stem -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10,11#10,11,12,13#para -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact 


The similarity between mathematical formulas is very subjective .
The similarity between mathematical formulas is very subjective .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact 


We consider that formulas with the same semantic meaning are relevant . //[The original is unclear the rewrite seems to be what you mean .]
In our work , we manually consider formulas with the same semantic meaning are relevant .
-1#4#0#lc -1#6#1#exact -1#7#3#exact -1#8#4#exact -1#9#5#exact -1#10#6#exact -1#11#7#exact -1#12#8#exact -1#13#9#exact -1#14#10#exact -1#15#11#exact 


For example , while searching for sin( a ) , we also consider results containing arcsin or cosin .
For example , while searching for sin( a ) , we also consider the results containing arcsin or cosin .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact 


Our experiments were conducted on a collection of about 16 ,000 mathematical docu-ments on Wikipedia and about 155 ,000 mathematical formulas on the Wolfram Functions Site .
Our experiments were conducted on a collection of about 16 ,000 mathematical docu-ments on Wikipedia and about 155 ,000 mathematical formulas on the Wolfram Functions Site .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact 


To show the effect of linking the formula with its name , we also set up an experimental search system without using the formula 's names .
In order to show the e ect of linking the formula with its name , we also set up an experimental search system without using the formula 's names .
-1#2#0#lc -1#3#1#exact -1#4#2#exact -1#7#4#exact -1#8#5#exact -1#9#6#exact -1#10#7#exact -1#11#8#exact -1#12#9#exact -1#13#10#exact -1#14#11#exact -1#15#12#exact -1#16#13#exact -1#17#14#exact -1#18#15#exact -1#19#16#exact -1#20#17#exact -1#21#18#exact -1#22#19#exact -1#23#20#exact -1#24#21#exact -1#25#22#exact -1#26#23#exact -1#27#24#exact -1#28#25#exact -1#29#26#exact 


Table 1 shows the top 5 search results for the query " sin( a + b ) " .
Table 1 shows top 5 of the searching results for the query \MATH .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#6#3#exact -1#3#4#exact -1#4#5#exact -1#7#6#stem -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#13#18#exact 


As can be seen , when the system associates the formulas with their names , it can provide more useful information to the user .
As can be seen from the table , when the system associates the formulas with their names , it can provide more useful information to the user .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#7#4#exact -1#8#5#exact -1#9#6#exact -1#10#7#exact -1#11#8#exact -1#12#9#exact -1#13#10#exact -1#14#11#exact -1#15#12#exact -1#16#13#exact -1#17#14#exact -1#18#15#exact -1#19#16#exact -1#20#17#exact -1#21#18#exact -1#22#19#exact -1#23#20#exact -1#24#21#exact -1#25#22#exact -1#26#23#exact -1#27#24#exact 


The system also allows the user to input the formula 's name directly .
The system also allows the user to input the formula 's name directly .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact 


Table 2 shows the top 10 results for the query " Pythagorean " .
Table 2 shows top 10 results with the query " Pythagorean " .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#7#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact 


Note that at this time , when the user submits a query that does not match any function 's name in our database , the system can not return anything .
Note that at this time , when the user submits a query that does not match any function 's name in our database , the system can not return anything .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact 


We presented a new framework for mathematical searches where links between formulas and their names are automatically detected in the target documents and then utilized in the search .
In this paper , we presented a new framework for mathematical search where links between formulas and their names are automatically detected from the target documents and then utilized in the search .
-1#4#0#lc -1#5#1#exact -1#6#2#exact -1#7#3#exact -1#8#4#exact -1#9#5#exact -1#10#6#exact -1#11#7#stem -1#12#8#exact -1#13#9#exact -1#14#10#exact -1#15#11#exact -1#16#12#exact -1#17#13#exact -1#18#14#exact -1#19#15#exact -1#20#16#exact -1#21#17#exact -1#29#18#exact -1#30#19#exact -1#24#20#exact -1#25#21#exact -1#26#22#exact -1#27#23#exact -1#28#24#exact -1#0#25#lc -1#23#26#exact -1#31#27#exact -1#32#28#exact 


Due to unavailability of a standard corpora to evaluate mathematical search systems , our evaluation at this moment remains subjective and limited .
Due to unavailability of the standard corpora to evaluate mathemat-ical search systems , our evaluation at this moment still remained subjective and limited .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#para -1#20#19#exact -1#21#20#exact -1#22#21#exact -1#23#22#exact 


We believe that our approach of incorporating information other than the mathematical formulas themselves showed promising results .
We believe that our approach , by incorporating information other than the mathematical formulas themselves , showed promising results .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#16#14#exact -1#17#15#exact -1#18#16#exact -1#19#17#exact 


The experimental results showed how helpful this information is to mathematical search users .
The experimental results have shown how helpful this information provides to the users of mathematical search .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3,4#3#para -1#5#4#exact -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#para -1#10#9#exact -1#14#10#exact -1#15#11#exact -1#12#12#exact -1#16#13#exact 


However , this is only a first step ; many important issues are left for future study .
However , this is only a rst step , some important issues are left for future study .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#7#6,7#para -1#10,11#9,10,11#para -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact 


Using a formula 's name is only one way of taking into account the semantic meaning of the formula ; we are considering other information such as the formula 's description and its variable 's description .
Using formula 's name is one way of taking into account the semantic meaning of the formula , we are considering other information such as formula 's description and variable 's description .
-1#0#0#exact -1#1#2#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5,6#6,7,8#para -1#7#9#exact -1#8,9,10,11#10,11,12#para -1#15#13#exact -1#12#14#exact -1#13#15#exact -1#14#16#exact -1#16#17,18#para -1#18#20#exact -1#19#21#exact -1#20#22#exact -1#21#23#exact -1#22#24#exact -1#23#25#exact -1#24#26#exact -1#25#27,28#para -1#26#29#exact -1#27#30#exact -1#28#31#exact -1#29#33#exact -1#30#34#exact -1#31#35#exact -1#32#36#exact 


Currently , our system uses only the links between formulas and their names in the same article .
Currently , our system uses only the links between formulas and their names in the same article .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact 


Therefore , linking formulas across articles should also be taken into account .
Therefore , linking formulas across articles should be taken into account .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7,8,9#7,8,9,10#para -1#10#11#exact -1#11#12#exact 


Automatic approach to understanding mathematical expressions using MathML Parallel Markup corpora
Automatic approach to understanding mathematical expressions using MathML Parallel Markup corpora
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact 


This paper explores the use of MathML Pallel Markup Corpora for automatic understanding of mathematical expressions , the task of which is formulated as a translation from Presentation to Content MathML Markups . // <the use of capitals implies that these are software applications like PowerPoint or Word . I assume this is the right idea .> .
This paper explores the use of MathML Pallel Markup Corpora for mathematical expression understanding , the task of which is formulated as a translation from Presentation to Content MathML Markups in our approach .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#13#12#exact -1#17#13#exact -1#11#14#exact -1#12#15#stem -1#14#16#exact -1#15#17#exact -1#16#18#exact -1#18#19,20#para -1#19#21#exact -1#20#22#exact -1#21#23#exact -1#22#24#exact -1#23#25#exact -1#24#26#exact -1#25#27#exact -1#26#28#exact -1#27#29#exact -1#28#30#exact -1#29#31#exact -1#33#32#exact 


In contrast to previous research that mainly relied on manually encoded transformation rules , we use a statistical-machine-translation-based method to automatically extract translation rules from parallel markup corpora .
In contrast to existing researches that mainly relied on manually encoded transformation rules , we adopt a Statistical-Machine-Translation-based method to automatically extract translation rules from parallel markup corpora .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#4#4#stem -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#16#16#exact -1#17#17#lc -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact 


Our study shows that the structural features embedded in the MathML tree can be effectively exploited in the sub-tree alignment and the translation rules extracted from the alignment give a boost to the translation system .
Our study shows that the structural features embedded in the MathML tree can be effectively exploited in the sub-tree alignment and the translation rules extracted from the alignment give boost to the translation system .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#30#exact -1#30#31#exact -1#31#32#exact -1#32#33#exact -1#33#34#exact -1#34#35#exact 


Experimental results on the Wolfram Function Site show that our approach is an improvement over prior rule-based systems . // <Note : It seems that where were two prior systems that were compared . If not , you can go back to using a prior system .> .
Experimental results on the Wolfram Function Site show that our approach achieves an improvement against the prior rule-based system .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#12,13#11,12,13#para -1#16#15#exact -1#17#16#exact -1#18#17#stem -1#19#18#exact -1#14#32#para 


One of the most significant discussions regarding the digitization of mathematical and scientific content and its applications is about semantic enrichment of mathematical documents , that is , adding or associating semantic tags - usually concepts - with mathematical expressions .
One of the most significant current discussions in the digitization of mathematical and scientific content and its applications is the semantic enrichment of mathematical documents , that is adding or associating semantic tags - usually concepts - to mathematical expressions .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#6#5#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact -1#23#22#exact -1#24#23#exact -1#25#24#exact -1#26#25#exact -1#27#26#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact -1#38#38#exact -1#39#39#exact -1#40#40#exact 


By encoding the underlying mathematical meaning of an expression explicitly , it is possible to interchange information more precisely between systems that semantically process mathematical objects .
By encoding the underlying mathematical meaning of an expression explicitly , it is possible to interchange information more precisely between systems that semantically process mathematical objects .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11,12,13,14#11,12,13#para -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact 


The direct application of this idea enables semantic searches for mathematical expressions whereby the system 's eunderstanding ' of the intent of the searcher and the contextual meaning of mathematical terms improves search accuracy .
The direct application of this is enabling semantic searches for mathematical expressions by understanding the intent of the searcher and the contextual meaning of mathematical terms improve search accuracy .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#6#6#stem -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#14#13#exact -1#16#18#exact -1#17#19#exact -1#15#20#exact -1#23#21#exact -1#20#22#exact -1#18#23#exact -1#19#24#exact -1#21#26#exact -1#22#27#exact -1#24#29#exact -1#25#30#exact -1#26#31#stem -1#27#32#exact -1#28#33#exact -1#29#34#exact 


It also benefits computer algebra systems , automatic reasoning systems and multi-lingual translation systems .
It also benefits computer algebra systems , automatic reasoning system and multi-lingual translation systems .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#13#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#9#13#stem -1#14#14#exact 


However , as is the case with natural language , semantic enrichment of mathematical expressions is a non-trivial task .
However , as is the case with natural language , the semantic enrichment of mathematical expressions is a non-trivial task .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact 


- First , mathematical notation , though more rigorous than natural language , is nonetheless at times ambiguous , context-dependent , and varies from community to community .
- First , mathematical notation , though more rigorous than natural language , is nonetheless at times ambiguous , context-dependent , and varies from community to community .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact 


- Second , the underlying mathematical meaning of an expression needs to follow a semantic markup in a semantically rigorous way .
- Second , the underlying mathematical meaning of an expression need to follow a semantic markup in a semantically rigorous way .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10,11#10,11#para -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact 


Because of this , in failing to follow the constraint , the computer might not be able to process that expression .
Because of this , failing to follow the constraint , the computer might not be able to process that expression .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4,5#para -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact 


- The third problem is that new notations tend to be introduced and used when needed so a mechanism is required for referring to mathematical concepts outside of the base collection .
- The third problem is that new notations tend to be introduced and used as and when needed so a mechanism is required for referring to mathematical concepts outside of the base collection , allowing them to be represented .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#16#14#exact -1#17#15#exact -1#18#16#exact -1#19#17#exact -1#20#18#exact -1#21#19#exact -1#22#20#exact -1#23#21#exact -1#24#22#exact -1#25#23#exact -1#26#24#exact -1#27#25#exact -1#28#26#exact -1#29#27#exact -1#30#28#exact -1#31#29#exact -1#32#30#exact -1#39#31#exact 


The aim of this paper is to describe a method of automatic semantic enrichment for mathematics that is capable of analyzing and disambiguating mathematical terms .
The aim of this paper is to introduce a method for automatic mathematics semantic enrichment that capable of analyze and disambiguate mathematical terms .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#8#8#exact -1#9#9#exact -1#17#10#exact -1#11#11#exact -1#13#12#exact -1#14#13#exact -1#10#14#exact -1#12#15#exact -1#15#16#exact -1#16#17,18#para -1#18#20#stem -1#19#21#exact -1#20#22#stem -1#21#23#exact -1#22#24#exact -1#23#25#exact 


In our research , MathML \CITE Presentation Markup is used to display mathematical expressions and MathML Content Markup is used to convey mathematical meaning .
In our research , MathML \CITE Presentation Markup is used to display mathematical expressions and MathML Content Markup is used to convey mathematical meaning .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact 


The semantic enrichment task then becomes one of generating Content MathML outputs from Presentation MathML expressions .
The semantic enrichment task then becomes generating Content MathML outputs from Presentation MathML expressions .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#8#exact -1#7#9#exact -1#8#10#exact -1#9#11#exact -1#10#12#exact -1#11#13#exact -1#12#14#exact -1#13#15#exact -1#14#16#exact 


There are three reasons why we chose MathML markup in our research .
There are three reasons why we choose MathML markup in our research .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#syn -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact 


- First , since its first release in 1997 , MathML has grown to become a general format that enables mathematics to be served , received , and processed in a wide variety of applications .
- First , since its first release in 1997 , MathML has grown to become a general format that enables mathematics to be served , received , and processed in a wide variety of applications .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact 


- Second , MathML can be used to encode both mathematical notations and mathematical content .
- Second , MathML can be used to encode both mathematical notation and mathematical content .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4,5,6#4,5,6,7#para -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#stem -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact 


- Last , large collections of formulas are available in MathML , and we can easily assess these collections .
- Last , large collections of formulas are available in MathML and we can easily assess these collections .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact 


- In the scope of this paper , we only make use the information within a mathematical expression for disambiguation when translating it into content markup .
- In the scope of this paper , we only make use the information within a mathematical expression for disambiguation when translating it to content markup .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact 


The prior solution to this problem is SnuggleTeX \CITE , which was proposed by David McKain .
The prior solution to this problem is SnuggleTeX \CITE , which was proposed by David McKain .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact 


The system uses rule-based methods for disambiguation and translation .
The system used rule-based methods for disambiguation and translation .
-1#0#0#exact -1#1#1#exact -1#2#2#stem -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact 


This solution has two main limitations :
This solution has two main limitations :
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact 


- Since it is a hand-written rule-based system , SnuggleTeX requires mathematical knowledge and human effort to develop .
- Since it is a hand written rule-based system , SnuggleTeX requires mathematical knowledge and human effort to develop
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact 


- Due to the diversity of mathematical expressions , SnuggleTeX is still considered experimental and has difficulty processing complicated mathematical symbols and expressions .
- Due to the diversity of mathematical expressions , SnuggleTeX is still to be considered experimental and has difficulty processing complicated mathematical symbols and expressions .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#14#12#exact -1#15#13#exact -1#16#14#exact -1#17#15#exact -1#18#16#exact -1#19#17#exact -1#20#18#exact -1#21#19#exact -1#22#20#exact -1#23#21#exact -1#24#22#exact -1#25#23#exact 


In this paper , we propose an approach that automatically learns semantic inferences in a presentation from parallel markup data . // <The original has too many from to be logically clear . The rewrite is a guess . > .
In this paper , we propose an approach that automatically learn the semantics inference from a presentation from parallel markup data .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#stem -1#12#11#stem -1#13#12#stem -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#14#27#exact -1#11#33#lc 


This approach is based on statistical machine translation .
The idea of this approach is based on statistical machine translation .
-1#3#0#lc -1#4#1#exact -1#5#2#exact -1#6#3#exact -1#7#4#exact -1#8#5#exact -1#9#6#exact -1#10#7#exact -1#11#8#exact 


The underlying mathematical meaning of an expression is inferred from the probability distribution $ p( c | p ) $ that a semantic expression $ c $ is the translation of a presentation expression $ p $ .
The underlying mathematical meaning of an expression is inferred according to the probability distribution $ p( c | p ) $ that a semantic expression $ c $ is the translation of a presentation expression $ p $ .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact -1#23#22#exact -1#24#23#exact -1#25#24#exact -1#26#25#exact -1#27#26#exact -1#28#27#exact -1#29#28#exact -1#30#29#exact -1#31#30#exact -1#32#31#exact -1#33#32#exact -1#34#33#exact -1#35#34#exact -1#36#35#exact -1#37#36#exact -1#38#37#exact 


The probability distribution is automatically learned from both Presentation and Content MathML markup data , that is , parallel markup MathML data .
The probability distribution will be automatically learned from data that have both Presentation and Content MathML markup , that is the parallel markup MathML data .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#19#3#exact -1#5#4#exact -1#6#5#exact -1#7#6#exact -1#11#7#exact -1#12#8#exact -1#13#9#exact -1#14#10#exact -1#15#11#exact -1#16#12#exact -1#8#13#exact -1#17#14#exact -1#18#15#exact -1#3,4#16#para -1#21#18#exact -1#22#19#exact -1#23#20#exact -1#24#21#exact -1#25#22#exact 


The data used in this study was collected from the Wolfram Function Site \CITE .
The data used in this study was collected from the Wolfram Function Site \CITE .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact 


We also prepared other parallel markup MathML data by annotating mathematical expressions in 20 papers from The Archives of the Association for Computational Linguistics \CITE ( ACL-ARC ) .
We also prepare another parallel markup MathML data by annotating mathematical expressions on 20 papers from The Archives of the Association for Computational Linguistics \CITE ( ACL-ARC ) .
-1#0#0#exact -1#1#1#exact -1#2#2#stem -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact 


There are two main contributions in this paper :
We have two main contributions in this paper
-1#1,2#0,1,2#para -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact 


- First , we successfully applied machine translation techniques to solving the problem of mathematic semantic enrichment .
- First , successfully apply the machine translation techniques to the problem of mathematic semantic enrichment .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#4#exact -1#4#5#stem -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#5#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact 


Experimental results show that our system significantly outperforms the current rule-based system and it can handle a lot of practical cases in the semantic enrichment problem .
Experimental results show that our system significantly outperforms the current rule-based system and it can handle a lot of practical cases in the mathematics semantic enrichment problem .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#24#23#exact -1#25#24#exact -1#26#25#exact -1#27#26#exact 


The quantity and quality of mathematical expressions are continuing to grow , and we believe that our system will be able to cover most mathematical expressions .
Since both quantity and quality of mathematical expressions are continuing to grow and expand through time , we believe that our system will cover most of real life mathematical expressions .
-1#2#1#exact -1#3#2#exact -1#4#3#exact -1#5#4#exact -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#16#11#exact -1#12#12#exact -1#18,19,20#13,14,15,16#para -1#21#17#exact -1#22#18#exact -1#23#21,22#para -1#24#23#exact -1#28#24#exact -1#29#25#exact -1#30#26#exact 


- Second , mathematics knowledge such as a symbol 's meanings or structural relations is automatically learned while training ; therefore , the system requires no human effort or expertise , and it is easier to update with more data .
- Second , mathematics knowledge such as symbol 's meanings or structural relations is automatically learned while training , therefor it is not required mathematics experts nor human effort and it is also easier to update the system given more data .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7,8#para -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#19#20#stem -1#18#21#exact -1#36#22#exact -1#37#23#exact -1#23#24#stem -1#27#25,26#para -1#28#27#exact -1#26#28#para -1#25#29#para -1#29#31#exact -1#30#32#exact -1#31#33#exact -1#33#34#exact -1#34#35#exact -1#35#36#exact -1#39#38#exact -1#40#39#exact -1#41#40#exact 


Since new notations keep cropping up , it is important to update the system as quickly as possible .
Since new notations keep growing , it is important to update the system as quick as possible .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#5#6#exact -1#6,7,8,9#7,8,9#para -1#10#10,11#para -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#stem -1#15#16#exact -1#16#17#exact -1#17#18#exact 


We performed a ten-fold cross validation on mathematical expressions from six categories of the Wolfram Functions Site to evaluate the effectiveness of our learning method .
In our experiments , we performed a 10-folds cross validation on mathematical expressions from 6 categories of the Wolfram Functions Site to evaluate the effectiveness of our proposed learning method .
-1#4#0#lc -1#5#1#exact -1#6#2#exact -1#8#4#exact -1#9#5#exact -1#10#6#exact -1#11#7#exact -1#12#8#exact -1#13#9#exact -1#14#10#syn -1#15#11#exact -1#16#12#exact -1#17#13#exact -1#18#14#exact -1#19#15#exact -1#20#16#exact -1#22,23,24,25#17,18,19,20,21#para -1#26#22#exact -1#28#23#exact -1#29#24#exact -1#30#25#exact 


We performed another experiment to assess the correlation between the system 's performance and training set size and found that increasing the size of the training data boosted the system 's performance .
We set up another experiment to confirm the correlation between system performance and training set size and saw that increasing the size of training data actually boost the system performance .
-1#0#0#exact -1#3#2#exact -1#4#3#exact -1#5#4#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#20#9#exact -1#10#10#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17,18#18,19#para -1#19#20#exact -1#27#21#exact -1#21#22#exact -1#22#23#exact -1#23#24,25#para -1#24#26#exact -1#26#27#stem -1#28#28,29#para -1#29#31#exact -1#30#32#exact 


We also performed an extensive comparison with prior work \CITE using a data set collected from ACL-ARC scientific papers .
We also performed extensive side-by-side comparison with prior work \CITE over a data set from ACL-ARC scientific papers .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact 


Our experimental results show that our approach works well in dealing with the mathematics semantic enrichment problem and it outperforms the previous work by making significantly fewer errors .
Our experimental results show that the proposed approach works well on the mathematics semantic enrichment problem and it excels the previous work by providing significantly less error rate .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#5#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#11#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#24#25#exact -1#25#26#para -1#26#27#stem -1#28#28#exact 


The remainder of this paper is organized as follows : In Section 2 , we give a brief overview of the background and related work on semantic enrichment of mathematical expressions .
The remainder of this paper is organized as follows : In Section 2 , we give a brief overview of the background and related work for semantic enrichment of mathematical expressions , while in Section 3 we present our proposed method .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#41#31#exact 


We present our method in Section 3 and describe the experimental setup and results in Section 4 .
We then describe the experimental setup and results in Section 4 .
-1#0#0#exact -1#8#4#exact -1#9#5#exact -1#6#7#exact -1#2#8#exact -1#3#9#exact -1#4#10#exact -1#5#11#exact -1#7#13#exact -1#10#16#exact -1#11#17#exact 


Section 5 concludes the paper and gives avenues for future work .
Section 5 concludes the paper and gives avenues for future work .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact 


Since mathematical formulas contain both mathematical symbols and structures , a special markup is required for their representation .
Since mathematical formulas contain both mathematical symbols and structures , a special markup is required for their representation .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact 


Until recently , images have been used to represent mathematical formulas on the web .
Until recently , images have been used to represent mathematical formulas on the web .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4,5#4,5,6,7#para -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact 


This type of display does not need any markup language to decode the formulas , but it is hard to process them .
This type of display does not need any markup language to decode the formulas , but it is hard to process them .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15,16,17,18,19#15,16,17,18#para -1#20#20#exact -1#21#21#exact -1#22#22#exact 


A way of dealing with mathematical formulas in this format is to convert them into another text-based format , for example , InftyReader \CITE .
A way of dealing with mathematical formulas in this format is to convert them to another text-based format , as seen in InftyReader \CITE .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11,12,13#11,12,13,14#para -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact 


\TeX{} has been used to encode mathematical formulas in scientific documents .
For scientific documents , \TeX{} has been used to encode mathematical formulas .
-1#4#0#exact -1#5#1#exact -1#6#2#exact -1#7#3#exact -1#8#4#exact -1#9#5#exact -1#10#6#exact -1#11#7#exact -1#1#8,9#para -1#2#10#exact -1#12#11#exact 


A formula is printed in a way a person would write by hand , or typeset the equation .
The formula is printed in a way a person would write by hand , or typeset the equation .
-1#7#0#lc -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#8#7,8#para -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact 


In some web pages , such as on the Wikipedia site , formulas are displayed in both image and \TeX{} formats .
In some web pages , such as the Wikipedia site , a formula is displayed in both image and \TeX{} formats .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#12#12#stem -1#13#13#syn -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact 


The best known open markup format for representing mathematical formulas for the web is MathML \CITE , which was recommended by the W3C math working group .
The best known open markup format for representing mathematical formulas for the web is MathML \CITE , which was recommended by the W3C math working group .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact 


It provides a standard way of representing mathematical expressions .
It provides a standard way of representing mathematical expressions .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact 


It is an XML application for describing mathematical notations and encoding mathematical content within a text format .
It is an XML application for describing mathematical notations and encoding mathematical content within a text format .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact 


MathML has two types of encoding , content-based encoding , called Content MathML , dealing with the meaning of formulas , and presentation-based encoding , called Presentation MathML , dealing with the display of formulas .
MathML has two types of encoding , content-based encoding which is called Content MathML , dealing with the meaning of formulas , and presentation-based encoding which is called Presentation MathML , dealing with the display of formulas .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#21#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#30#20#exact -1#22#21#exact -1#23#22#exact -1#24#23#exact -1#27#25#exact -1#28#26#exact -1#29#27#exact -1#31#29#exact -1#32#30#exact -1#33#31#exact -1#34#32#exact -1#35#33#exact -1#36#34#exact -1#37#35#exact 


The illustration trees of the Presentation and Content Markup of the expression $ C_{-\frac{17}{2}}= \tilde {\infty} $ are depicted in Figure \REF and Figure \REF .
The illustration tree display of Presentation and Content Markup of the expression $ C_{-\frac{17}{2}}= \tilde {\infty} $ are depicted in Figure \REF and Figure \REF respectively .
-1#0#0#exact -1#1#1#exact -1#2#2#stem -1#9#3#exact -1#10#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#4#9#exact -1#11#10,11#para -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#26#25#exact 


Besides MathML , there are other markups such as eqn \CITE , OpenOffice .
Besides MathML , there are other markups such as eqn \CITE , OpenOffice .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact 


org Math \CITE , ASCIIMathML \CITE , and OpenMath \CITE , but these markups can be converted into MathML by using freely available tools .
org Math \CITE , ASCIIMathML \CITE and OpenMath \CITE , but these markup can be converted to MathML using freely available tools .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#9#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#10#11#exact -1#11#12#exact -1#12#13#stem -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#17#18#exact -1#18#19,20#para -1#19#21#exact -1#20#22#exact -1#21#23#exact -1#22#24#exact 


There are not many studies on the semantic enrichment problem .
There are not many studies on semantic enrichment problem .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact 


In this section , we list some of the work on exploiting the meanings of mathematical expressions .
In this section , we list some works that related to exploit the meaning of mathematical expressions .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#14#7#exact -1#12#8#exact -1#7#9#stem -1#10,11#10,11#para -1#15#15#exact -1#16#16#exact -1#17#17#exact 


Grigole et al. \CITE proposed an approach to understanding mathematical expressions based on the text surrounding the mathematical expressions .
For understanding mathematical expressions , Grigole et al. \CITE proposed an approach based on the surrounding text of mathematical expressions .
-1#5#0#exact -1#6#1#exact -1#7#2#exact -1#8#3#exact -1#9#4#exact -1#10,11,12,13#5,6#para -1#0,1#7,8#para -1#2#9#exact -1#3#10#exact -1#14#13#exact -1#16#14#exact -1#15#15#exact -1#18#16,17#para -1#19#18#exact -1#20#19#exact 


The main idea of this approach is to use the surrounding text for disambiguation based on word sense disambiguation and lexical similarity .
The main idea of this approach is to use the surrounding text for disambiguation which is based on word sense disambiguation and lexical similarity .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14,15,16,17#14,15#para -1#18#16#exact -1#19#17#exact -1#20#18#exact -1#21#19#exact -1#22#20#exact -1#23#21#exact -1#24#22#exact 


First , a local context C ( five nouns preceding a target mathematical expression ) is found in each sentence .
First , a local context C ( 5 nouns preceding a target mathematical expression ) is found in each sentence .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#syn -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact 


For each noun , the system identifies a Term Cluster ( derived from the OpenMath Content Dictionary ) with the highest semantic similarity according to a similarity metric .
For each noun , the system identifies a Term Cluster ( derived from the OpenMath Content Dictionary ) with the highest semantic similarity according to a similarity metric .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact 


The similarity scores obtained are weighted , summed up , and normalized by the length of the considered context .
The similarity scores obtained were weighted , summed up , and normalized by the length of the considered context .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#syn -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13,14,15,16#13,14,15#para -1#17#17#exact -1#18#18#exact -1#19#19#exact 


The Term Cluster with the highest similarity score is assigned as the interpretation .
The assigned interpretation is the Term Cluster with the highest similarity score .
-1#4#0#lc -1#5#1#exact -1#6#2#exact -1#7#3#exact -1#8#4#exact -1#9#5#exact -1#10#6#exact -1#11#7#exact -1#3#8#exact -1#1#9#exact -1#0#11#lc -1#2#12#exact -1#12#13#exact 


The approach was evaluated on 451 manually annotated mathematical expressions , and the best result was an F_{0.5} $ score of 68.26 $ .
The approach was evaluated on 451 manually annotated mathematical expressions and the best result was 68.26 $ F_{0.5} $ score .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#15#21#exact -1#16#22#exact -1#20#23#exact 


To deal with the meanings of mathematical formulas , Nghiem et al. \CITE proposed an approach for extracting names or descriptions of formulas by using the natural language text surrounding them .
To deal with the meanings of mathematical formulas , Nghiem et al. \CITE proposed an approach for extracting the names or descriptions of the formulas using natural language text surrounding them .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact -1#24#22#exact -1#25#23,24#para -1#18#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact 


The most accurate extraction result using data from Wikipedia was $ 68.33 $ percent .
The most accurate extraction result using data from Wikipedia was $ 68.33 $ percent .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact 


There are two other projects that deal with the semantic meaning of mathematical expressions .
There are two other projects that deal with the semantic meaning of mathematical expressions .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact 


The first is the SnuggleTeX project \CITE , which provides a free and open-source Java library for converting fragments of LaTeX into XML including Content MathML .
The first is the SnuggleTeX project \CITE , which provides a free and open-source Java library for converting fragments of LaTeX to XML including Content MathML .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact 


The other project is Lamapun \CITE .
The other project is Lamapun \CITE .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact 


This project investigates semantic enrichment , structural semantics , and ambiguity resolution in mathematical corpora .
This project investigates semantic enrichment , structural semantics and ambiguity resolution in mathematical corpora .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact 


Unfortunately , there are no evaluations of these systems .
Unfortunately , there are no evaluation report on these systems .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#stem -1#8#7#exact -1#9#8#exact -1#10#9#exact 


To translate mathematical expressions from the Presentation MathML into Content MathML format , a list of translation rules is required .
To translate mathematical expressions from the Presentation MathML to Content MathML format , a list of rules for translation is required .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#18#16#exact -1#16#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact 


Building these translation rules by hand is a large undertaking .
Building these translation rules by hand is a large undertaking .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact 


Our task is inherently domain-specific ; therefore , we devised an approach based on statistical machine learning for automatically extracting rules from a dataset .
Our task is inherently domain specific therefore we propose an approach which is based on statistical machine learning methods that automatically extract these rules from a dataset .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#6#6#exact -1#7#8#exact -1#9,10#10,11,12,13#para -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#20#18#exact -1#21#19#stem -1#23#20#exact -1#24#21#exact -1#25#22#exact -1#26#23#exact -1#27#24#exact 


Statistical machine translation ( SMT ) is by far the most widely studied machine translation method .
Nowadays , statistical machine translation ( SMT ) is by far the most widely-studied machine translation method .
-1#2#0#lc -1#3#1#exact -1#4#2#exact -1#5#3#exact -1#6#4#exact -1#7#5#exact -1#8,9,10,11#6,7,8,9,10#para -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact 


SMT uses a very large data set of good translations , that is , a corpus of texts which have already been translated into another language , and it uses those texts to automatically infer a statistical model of translation .
SMT uses a very large data set of good translations , that is , a corpus of texts which have already been translated into other language , and then uses those texts to automatically infer a statistical model of translation .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24,25#24,25#para -1#26#26#exact -1#27#27#exact -1#29#28,29#para -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact -1#37#37#exact -1#38#38#exact -1#39#39#exact -1#40#40#exact 


The statistical model is then applied to new texts to make a translation of them .
The statistical model is then applied to new texts to make a translation .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#15#exact 


Tree-based or syntax-based SMT can be used for tree-to-tree translation but it has two drawbacks when it is applied to the problem of translating Presentation into Content MathML .
Tree-based or syntax-based SMT can be used for tree-to-tree translation but it has two drawbacks when apply to the problem of translating from Presentation to Content MathML expression .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4,5#4,5,6,7#para -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16,17,18#17,18,19,20#para -1#19#21#exact -1#20#22#exact -1#21#23#exact -1#23#24#exact -1#25#26#exact -1#26#27#exact -1#28#28#exact 


- The first drawback is that tree-based SMT focuses on generating surface texts rather than tree structures .
- The first drawback is tree-based SMT focus on generating the surface texts rather than the tree structures .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#6#exact -1#6#7#exact -1#7,8#8,9#para -1#9#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact 


Mathematical expressions have strict structures , and it fails to fulfill this requirement .
While mathematical expressions have strict structures , it fails to fulfill this requirement .
-1#1#0#lc -1#2#1#exact -1#3#2#exact -1#4#3#exact -1#5#4#exact -1#6#5#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact 


- The second drawback is there are many long mathematical expressions in real-world data and translating long and complex sentences has been a critical problem in machine translation .
- The second drawback is there are many long mathematical expressions in real-world data and translating long and complex sentences has been a critical problem in machine translation .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact 


To overcome these limitations , we made two separate rule sets : fragment rules and translation rules .
To overcome these limitations , we introduced two separated sets of rule : fragment rules and translation rules .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#para -1#7#7#exact -1#8#8#stem -1#11#9#exact -1#9#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact 


The details are described in the next section .
The detail is described in the next section .
-1#0#0#exact -1#1,2#1,2#para -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact 


The framework of the system is shown in Figure \REF .
The framework of the system is shown in Figure \REF .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact 


The system has three main modules .
The system has three main modules .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact 


- Preprocessing : This module processes MathML expressions by removing error expressions or format tags with no semantic meaning .
- Preprocessing : processes MathML expressions to remove error expressions or format tags with no semantic meaning .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#5#exact -1#4#6#exact -1#5#7#exact -1#7#9#stem -1#8#10#exact -1#9#11#exact -1#10#12#exact -1#11#13#exact -1#12#14#exact -1#13#15#exact -1#14#16#exact -1#15#17#exact -1#16#18#exact -1#17#19#exact 


- Rule Extraction : This module is given a dataset containing MathML parallel markup expressions , and it extracts translation rules from it . // <The original is ungrammatical and unclear . The rewrite is a guess .> .
- Extracting Rules : given a dataset contains MathML parallel markup expressions , extract the rules for translation .
-1#0#0#exact -1#3#3#exact -1#4#7#exact -1#5#8#exact -1#6#9#exact -1#7#10#stem -1#8#11#exact -1#9#12#exact -1#10#13#exact -1#11#14#exact -1#12#15#exact -1#1#18#stem -1#17#19#exact -1#15#20#exact -1#18#23#exact -1#14#32#lc 


- Content MathML Generation : This module is given mathematical expressions in Presentation MathML markup and a set of rules , and it generates Content MathML expressions to enrich the Presentation MathML expressions .
- Generating Content MathML : given a mathematical expressions in Presentation MathML markup , and a set of rules , generate Content MathML expressions to enrich the Presentation MathML expressions .
-1#0#0#exact -1#2#1#exact -1#3#2#exact -1#1#3#stem -1#4#4#exact -1#5#8#exact -1#7#9#exact -1#8#10#exact -1#9#11#exact -1#10#12#exact -1#11#13#exact -1#12#14#exact -1#14#15#exact -1#16,17,18#16,17,18,19#para -1#19#20#exact -1#20#23#stem -1#21#24#exact -1#22#25#exact -1#23#26#exact -1#24#27#exact -1#25#28#exact -1#26#29#exact -1#27#30#exact -1#28#31#exact -1#29#32#exact -1#30#33#exact 


The presentation elements of Presentation MathML are divided into two classes : token elements and layout schemata .
The presentation elements of Presentation MathML are divided into two classes : token elements and layout schemata .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact 


Token elements represent the identifier 's names , function 's names , numbers , etc. // <the identifier 's names means there is one identifier with possibly many names . If this is what you want to say , it is okay . If not , maybe you mean simply " identifier names " . ><Likewise , maybe you mean " function names " .>
Token elements represent identifier 's names , function 's names , numbers , etc.
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact 


Layout schemata build expressions out of parts .
Layout schemata build expressions out of parts .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact 


After investigating data on the Wolfram Function Site , we noticed that there are elements that have no specific meaning ; they are used for display purposes only and most of them are layout schemata .
By investigating the data from the Wolfram Function Site , we noticed that there are elements that have no specific meaning , they are used for displaying purpose only and most of them are layout schemata .
-1#1#1#exact -1#3#2#exact -1#5#4#exact -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#22#21#exact -1#23#22#exact -1#24#23#exact -1#25#24#exact -1#26#25#stem -1#27#26#stem -1#28#27#exact -1#29#28#exact -1#30#29#exact -1#31#30#exact -1#32#31#exact -1#33#32#exact -1#34#33#exact -1#35#34#exact -1#36#35#exact 


For example , the $ <mtext> </mtext> $ or $ <mspace / > $ tags are used to insert some space between expressions .
For example , the $ <mtext> </mtext> $ or $ <mspace / > $ tags are used to insert some space between expressions .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact 


Another example is pairs of parentheses ; these are used to indicate that the expressions in the parentheses go together , despite that their structure already encodes that information . // <The original is unclear . The rewrite is a guess . > .
Another example are the pairs of parentheses , it is used to indicate that the expressions in the parentheses go together , while its structure already encoded that information .
-1#0#0#exact -1#1#1#exact -1#9#2#exact -1#4#3#exact -1#5#4#exact -1#6#5#exact -1#2#7,8#para -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#27#22#exact -1#23,24#23,24#para -1#25#25#exact -1#26#26#stem -1#28#27,28#para -1#29#29#exact -1#3#36#lc 


This preprocessing step removes these elements .
As a result , in this preprocessing step , these elements are removed .
-1#5#0#lc -1#6#1#exact -1#7#2#exact -1#9#4#exact -1#10#5#exact -1#13#6#exact 


We also remove mathematical expressions with error markups such as expressions that have no Content markup .
In this step , we also removed mathematical expressions with error markups such as expressions that have no Content markup .
-1#4#0#lc -1#5#1#exact -1#6#2#stem -1#7#3#exact -1#8#4#exact -1#9#5#exact -1#10#6#exact -1#11#7#exact -1#12#8#exact -1#13#9#exact -1#14#10#exact -1#15#11#exact -1#16#12#exact -1#17#13#exact -1#18#14#exact -1#19#15#exact -1#20#16#exact 


For simplification , expressions with more than 200 content nodes are also removed .
For simplification , expressions with more than 200 content nodes also be removed .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10,11#10,11#para -1#12#12#exact -1#13#13#exact 


In the training phase , we use GIZA++ \CITE for aligning Presentation MathML terms and Content MathML terms .
In the training phase , we use GIZA++ \CITE for alignment between Presentation MathML terms and Content MathML terms .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#stem -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact 


Based on the aligned data , we use heuristics to extract rules that we call " fragment rules " .
Based on the aligned data , we use some heuristics to extract rules which we called " fragment rules " .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#14#13#exact -1#15#14#stem -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact 


Fragment rules are rules that define the translation from the Presentation MathML sub-trees to the Content MathML sub-trees .
Fragment rules are rules that define the translation from Presentation MathML sub-trees to Content MathML sub-trees .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9,10#para -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14,15#para -1#14#16#exact -1#15#17#exact -1#16#18#exact 


These rules are used to break up a large Presentation MathML tree into smaller sub-trees while maintaining the structure of the output Content MathML trees .
These rules are applied to break the large Presentation MathML tree into smaller sub-trees while maintaining the structure of output Content MathML trees .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#syn -1#4#4#exact -1#5#5#exact -1#7#7,8#para -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16,17,18#17,18,19,20#para -1#19#21#exact -1#20#22#exact -1#21#23#exact -1#22#24#exact -1#23#25#exact 


These rules are extracted based on the fact that translating a small tree is easier than translating a large one .
These rules are extracted based on the fact that translate small tree is easier than translate large one .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#stem -1#10#10,11#para -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#stem -1#16#17,18#para -1#17#19#exact -1#18#20#exact 


Each rule in the fragment rule set is associated with a probability , that is , the frequency at which a rule occurs in the training data .
Each rule in fragment rule set is associated with its probability , that is the frequent that rule happened in the training data .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#14#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#20#16#exact -1#15#17#para -1#17#20,21#para -1#18#22#syn -1#19#23#exact -1#21#24,25#para -1#22#26#exact -1#23#27#exact 


Once the sub-trees cannot be broken down further , we start to extract other rules , which we call " translation rules " .
If the sub-trees can not be broken any longer , we extract another rules , which we called " translation rules " , at that point .
-1#1#1#exact -1#2#2#exact -1#3,4#3#para -1#5#4#exact -1#6#5#exact -1#7,8#7#para -1#9#8#exact -1#10#9#exact -1#11#12#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#stem -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#26#23#exact 


We enhance the translation rule set with translation terms extracted by GIZA++ .
We then enhances the translation rule set with the translation terms extracted by GIZA++ .
-1#0#0#exact -1#2#1#stem -1#3#2#exact -1#4#3#exact -1#5#4#exact -1#6#5#exact -1#7#6#exact -1#9#7#exact -1#10#8#exact -1#11#9#exact -1#12#10#exact -1#13#11#exact -1#14#12#exact 


The pseudo code for extracting fragment rules is described in Algorithm \REF .
The pseudo code of the algorithm for extracting fragment rules is described in Algorithm \REF .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#6#3#exact -1#7#4#exact -1#8#5#exact -1#9#6#exact -1#10#7#exact -1#11#8#exact -1#12#9#exact -1#13#10#exact -1#14#11#exact -1#15#12#exact 


In the previous steps , we get two sets of rules , a fragment rule set and a translation rule set .
In the previous steps , we got two sets of rules , fragment rule set and translation rule set .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#syn -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#18#exact -1#17#19#exact -1#18#20#exact -1#19#21#exact 


We then use these rules for translation .
We then use these rules for translation .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact 


Given mathematical expressions in Presentation MathML markup , the system will generate Content MathML markup for each expression .
Given a mathematical expressions in Presentation MathML markup , the system will generate Content MathML markup of that expression .
-1#0#0#exact -1#2#1#exact -1#3#2#exact -1#4#3#exact -1#5#4#exact -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#18#17#exact -1#19#18#exact 


- First , the expression is preprocessed to remove non-semantic elements .
- First , the expression is preprocess to remove non semantic elements .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#stem -1#7#7#exact -1#8#8#exact -1#11#10#exact -1#12#11#exact 


- Second , the fragment rule is applied to the expression until it cannot be divided any further .
- Second , the fragment rule is applied to the expression until it could not be divided any further .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6,7,8#6,7,8,9#para -1#10#10#exact -1#11#11#exact -1#12,13,14,15#12,13,14#para -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact 


- Third , the small sub-expressions in Presentation MathML markup are translated into sub-expressions in Content MathML markup by using the translation rule set .
- Third , the small sub-expressions in Presentation MathML markup will be translated into sub-expressions in Content MathML markup using translation rule set .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10,11#10#para -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18,19#para -1#20#20,21#para -1#21#22#exact -1#22#23#exact -1#23#24#exact 


If no translation rule is found for a sub-expression , that expression is marked as untranslated .
If no translation rule is found for a sub-expression , that expression is marked as untranslated .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact 


- Last , sub-expressions in Content MathML markup are grouped to form the complete Content MathML expression .
- Last , sub-expressions in Content MathML markup is grouped to form the complete Content MathML expression .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#syn -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact 


Before the last step , we add a heuristic translation to translate numbers .
Before the last step , we add a heuristic translation to translate numbers .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact 


The reason for this is that there is an infinite number of rules . // <The rewrite is a guess .> .
The reason for this is that there is infinite number and we could never present every number in the rule .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#9#exact -1#9#10#exact -1#19#12#stem -1#20#13#exact 


The translation algorithm is described in Algorithm \REF .
The translation algorithm is described in Algorithm \REF .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact 


The experiments were carried out using datasets from the Wolfram Function site .
The experiments were carried out using the datasets from the Wolfram Function site .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact 


This site was created as a resource for educational , mathematical , and scientific communities .
This site was created as a resource for educational , mathematical , and scientific communities .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact 


It contains the world 's most encyclopedic collection of information about mathematical functions .
It contains the world 's most encyclopedic collection of information about mathematical functions .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact 


All formulas on this site are available in both Presentation MathML and Content MathML format .
All formulas on this site are available in both Presentation MathML and Content MathML format .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact 


The datasets we used contain 205 , 653 mathematical expressions belonging to six categories .
These datasets we used contain 205 , 653 mathematical expressions belong to 6 categories .
-1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10,11#10,11#para -1#12#12#syn -1#13#13#exact -1#14#14#exact 


All of these expressions have both MathML Presentation and Content Markups .
All of these expressions have both MathML Presentation and Content Markup .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#stem -1#11#11#exact 


Training and testing were performed using ten-fold cross-validation ; for each category , the original corpus was partitioned into ten subsets .
Training and testing were performed using 10-fold cross-validation ; for each category , the original corpus is partitioned into 10 subsets .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#syn -1#17#17#exact -1#18#18#exact -1#19#19#syn -1#20#20#exact -1#21#21#exact 


Of the ten subsets , a single subset was retained as the validation data for testing the model , and the remaining subsets were used as training data .
Of the 10 subsets , a single subset is retained as the validation data for testing the model , and the remaining subsets are used as training data .
-1#0#0#exact -1#11#1#exact -1#1,2#2#para -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#syn -1#9#9#exact -1#10#10#exact -1#16#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#20#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#21#20,21#para -1#22#22#exact -1#23,24#23,24#para -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact 


The cross-validation process was repeated ten times , with each of the ten subsets used exactly once as the validation data .
The cross-validation process is then repeated 10 times , with each of the 10 subsets used exactly once as the validation data .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#syn -1#5#4#exact -1#6,7#5,6#para -1#8#7#exact -1#9,10#8,9,10,11#para -1#12,13#12#para -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact 


The ten results from the folds then were averaged to produce a single estimation .
The 10 results from the folds then are averaged to produce a single estimation .
-1#0#0#exact -1#1#1#syn -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#syn -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact 


To prove the effectiveness of our models with real data , we conducted another experiment on the mathematical expressions in scientific papers .
To prove the effectiveness of our models to real data , we conducted another experiment on the mathematical expressions in scientific papers .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#8#7,8#para -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact 


Currently , we have 20 papers from the ACL archive , and we manually annotated all of the math expressions in these papers with both Presentation Markup and Content Markup . // The original is somewhat vague . The rewrite is a guess . Use it if it is correct . > .
Currently we have 20 papers from ACL archive , all of the math expressions in these papers are annotated manually with both Presentation Markup and Content Markup .
-1#0#0#exact -1#8#1#exact -1#1#2#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#11#7#exact -1#6#8#exact -1#7#9#exact -1#24#11#exact -1#19#13#exact -1#18#14#exact -1#9#15#exact -1#10#16#exact -1#12#18#exact -1#13#19#exact -1#14#20#exact -1#15#21#exact -1#16#22#exact -1#20#23#exact -1#21#24#exact -1#22#25#exact -1#23#26#exact -1#25#28#exact -1#26#29#exact -1#27#30#exact -1#17#34#syn 


We called this data ACL-ARC .
We called this data ACL-ARC .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact 


In the first experiment , the data was not compatible with SnuggleTeX since SnuggleTeX uses ASCII MathML but the Wolfram Functions site does not .
In the first experiment , the data is not compatible with SnuggleTeX since SnuggleTeX use ASCII MathML while the Wolfram Functions site does not .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7,8#7,8#para -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#stem -1#15#15#exact -1#16#16#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact 


In the second experiment with ACL-ARC data , we compared our model with SnuggleTeX .
In the second experiment with ACL-ARC data , we compared our model side by side with SnuggleTeX .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#15#12#exact -1#16#13#exact -1#17#14#exact 


Table \REF lists the various data statistics .
Table \REF contains the various data statistics .
-1#0#0#exact -1#1#1#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact 


Given a Presentation MathML expression $ e $ , we assume that tree $ A $ is the correct Content MathML tree of expression $ e $ and tree $ B $ is the output of the automatic translation .
Given a Presentation MathML expression $ e $ , we assume that tree $ A $ is the correct Content MathML tree of expression $ e $ and tree $ B $ is the output using the automatic translation .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#36#36#exact -1#37#37#exact -1#38#38#exact -1#39#39#exact 


The basic idea to evaluate the correctness of tree $ B $ is directly comparing it with tree $ A $ .
The basic idea to evaluate the correctness of tree $ B $ is directly comparing it with tree $ A $ .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact 


In the experiments , we extended the conventional definition of " Translation Error Rate " and used a metric which is a combined version of
In the experiments , we extend the conventional definition of " Translation Error Rate " and use a metric which is the combined version of
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#stem -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#stem -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20,21#20,21#para -1#22#22#exact -1#23#23#exact -1#24#24#exact 


- the Tree Edit Distance \CITE : the tree edit distance is the minimal cost to transform A into B using edit operations .
- Tree Edit Distance \CITE : the tree edit distance is the minimal cost to transform A into B using edit operations .
-1#0#0#exact -1#6#1#exact -1#1#2#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#11#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#12#12,13#para -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact 


There are three types of edit operation : substituting a node , inserting a node , and deleting a node .
There are three types of edit operations : substituting a node , inserting a node , and deleting a node .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#stem -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact 


- the Translation Error Rate \CITE : the translation error rate is an error metric for machine translation that measures the number of edits required to change a system output into one of the references .
- Translation Error Rate \CITE : translation error rate is an error metric for machine translation that measures the number of edits required to change a system output into one of the references .
-1#0#0#exact -1#18#1#exact -1#1#2#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#31#7#exact -1#6#8#exact -1#7#9#exact -1#8#10#exact -1#9#11#exact -1#10#12#exact -1#11#13#exact -1#12#14#exact -1#13#15#exact -1#14#16#exact -1#15#17#exact -1#16#18#exact -1#17#19#exact -1#19,20#20,21,22#para -1#21#23#exact -1#22#24#exact -1#23#25#exact -1#24#26#exact -1#25#27#exact -1#26#28#exact -1#27#29#exact -1#28,29#30,31,32,33#para -1#32#34#exact -1#33#35#exact 


We called the new metric the Tree Edit Distance Rate ( TEDR ) .
We call the new metric Tree Edit Distance Rate ( TEDR ) .
-1#0#0#exact -1#1#1#stem -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5,6#para -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact 


Improving protein coreference resolution by simple semantic classification
Improving protein coreference resolution by simple semantic classification
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact 


Current research has shown that major difficulties in event extraction cases for the biomedical domain are related to coreference .
Recent research shows a major part of difficult cases in event extraction for the biomedical domain are related to coreference .
-1#0,1#0,1#para -1#2#2,3#para -1#4#5#exact -1#6,7#6#para -1#9#7#exact -1#10#8#exact -1#11#9#exact -1#8#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact 


Therefore , coreference resolution is believed to be useful for improving event extraction .
Therefore , coreference resolution is believed to be useful for the improvement of event extraction .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10,11,12#10#para -1#13#11#exact -1#14#12#exact -1#15#13#exact 


To address coreference resolution in molecular biology literature , the Protein Coreference ( COREF ) task was arranged in the BioNLP-ST 2011 , as a supporting task .
To address the problem of coreference resolution in molecular biology literature , the Protein Coreference ( COREF ) task was arranged in the BioNLP-ST 2011 as a supporting task .
-1#0#0#exact -1#1#1#exact -1#5#2#exact -1#6#3#exact -1#7#4#exact -1#8#5#exact -1#9#6#exact -1#10#7#exact -1#11#8#exact -1#12#9#exact -1#13#10#exact -1#14#11#exact -1#15#12#exact -1#16#13#exact -1#17#14#exact -1#18#15#exact -1#19#16#exact -1#20#17#exact -1#21#18#exact -1#22#19#exact -1#23#20#exact -1#24#21#exact -1#25#23#exact -1#26#24#exact -1#27#25#exact -1#28#26#exact -1#29#27#exact 


However , the shared task results indicated that transferring coreference resolution methods developed for other domains to the biological domain was not straightforward , due to the domain differences in the coreference phenomena .
However , the shared task results showed that transferring coreference resolution methods developed for other domains to the biological domain was not straight forward , which is supposed to be caused by the domain differences in coreference phenomena .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6,7#6,7#para -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#syn -1#24#23#exact -1#30,31#24,25#para -1#32#26#exact -1#33#27#exact -1#34#28#exact -1#35#29#exact -1#36#31#exact -1#37#32#exact -1#38#33#exact 


We studied the contribution of domain-specific information , including information that indicates the protein type , in a rule-based protein coreference resolution system .
We studied the contribution of domain-specific information , i .e information indicating the protein type , in a rule-based protein coreference resolution system .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#10#9#exact -1#11#11#stem -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact 


In particular , the domain-specific information is encoded into semantic classification modules for which the output is used in different components of the coreference resolution .
In particular , the domain-specific information is encoded into semantic classification modules whose output is used in different components of the coreference resolution .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12,13,14#para -1#13#15#exact -1#14#16#exact -1#15#17#exact -1#16#18#exact -1#17#19#exact -1#18#20#exact -1#19#21#exact -1#20#22#exact -1#21#23#exact -1#22#24#exact -1#23#25#exact 


We compared our system with the top four systems in the BioNLP-ST 2011 ; surprisingly , we found that the minimal configuration had outperformed the best system in the BioNLP-ST 2011 .
We compared our system with the top four systems in the BioNLP-ST 2011 , and surprisingly we found that the minimal configuration has outperformed the best system in the BioNLP-ST 2011 .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#15#14#exact -1#13#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#syn -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact 


Analysis of the experimental results revealed that semantic classification , using protein information , had contributed to an increase in performance by 2.3 % on the test data , and 4 .0% on the development data , in F-score .
Analysis of the experimental results showed that semantic classification using protein information has contributed to an increase in performance ( 2.3 % on the test data , and 4 .0% on the development data , in F-score ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5,6#5,6#para -1#7#7#exact -1#8#8#exact -1#26#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#34#13#exact -1#12,13#14,15#para -1#15,16,17#16,17,18,19#para -1#18#20#exact -1#20#22#exact -1#21#23#exact -1#22#24#exact -1#23#25#exact -1#24#26#exact -1#25#27#exact -1#27#29#exact -1#28#30#exact -1#29#31#exact -1#30#32#exact -1#31#33#exact -1#32#34#exact -1#33#35#exact -1#35#37#exact -1#36#38#exact -1#38#39#exact 


The use of domain-specific information in semantic classification is important for coreference resolution .
The use of domain-specific information in semantic classification is important for coreference resolution .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact 


Since it is difficult to transfer domain-specific information across different domains , we need to continue to seek methods to exploit and use it in coreference resolution .
Since such information is difficult to be transferred across different domains , we need to continue seeking for methods to exploit and use it in coreference resolution .
-1#0#0#exact -1#23#1#exact -1#3#2#exact -1#4#3#exact -1#5#4#exact -1#6,7#5#para -1#2#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13,14,15#13,14,15,16#para -1#16#17#stem -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact 


While named entity recognition ( NER ) and relation / event extraction are regarded as standard tasks for biomedical information extraction ( IE ) , coreference resolution [ 2 , 16 , 30 ] is being recognized more and more as an important component of IE to achieve a higher performance .
While named entity recognition ( NER ) and relation or event extraction are regarded as standard tasks of biomedical information extraction ( IE ) , coreference resolution [ 2 , 16 , 30 ] is more and more recognized as an important component of IE for a higher performance .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#45#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#38#36#exact -1#35#37#exact -1#36#38#exact -1#37#39#exact -1#39#40#exact -1#40#41#exact -1#41#42#exact -1#42#43#exact -1#43#44#exact -1#44#45#exact -1#46#48#exact -1#47#49#exact -1#48#50#exact -1#49#51#exact 


Without coreference resolution , oftentimes , the IE performance issubstantially limited , due to the abundance of coreference relations in natural language text ; information pieces written in text with the involvement of a coreference relation are hard to be captured [ 9 , 14 ] .
Without coreference resolution , the performance of IE is often substantially limited due to an abundance of coreference relations in natural language text , i.e. , information pieces written in text with involvement of a coreference relation are hard to be captured [ 9 , 14 ] .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#23#5#exact -1#4#6#exact -1#7#7#exact -1#5#8#exact -1#11#10#exact -1#25#11#exact -1#12#12#exact -1#13#13#exact -1#15#14,15#para -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#26#24#exact -1#27#25#exact -1#28#26#exact -1#29#27#exact -1#30#28#exact -1#31#29#exact -1#32,33#30,31,32#para -1#34#33#exact -1#35#34#exact -1#36#35#exact -1#37#36#exact -1#38#37#exact -1#39#38#exact -1#40#39#exact -1#41#40#exact -1#42#41#exact -1#43#42#exact -1#44#43#exact -1#45#44#exact -1#46#45#exact -1#47#46#exact 


There have been several attempts for coreference resolution ; in particular , they have been for newswire texts [ 7 , 8 , 22 , 23 , 28 , 30 ] .
There have been several attempts for coreference resolution , particularly for newswire texts [ 7 , 8 , 22 , 23 , 28 , 30 ] .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#9,10#9,10#para -1#8#11#exact -1#11#16#exact -1#12#17#exact -1#13#18#exact -1#14#19#exact -1#15#20#exact -1#16#21#exact -1#17#22#exact -1#18#23#exact -1#19#24#exact -1#20#25#exact -1#21#26#exact -1#22#27#exact -1#23#28#exact -1#24#29#exact -1#25#30#exact -1#26#31#exact 


Coreference resolution is also one of the lessons from the BioNLP Shared Task ( BioNLP-ST , hereafter ) 2009 , in which it was communicated that coreference relations in biomedical text substantially hinder the progress of fine-grained IE [ 10 ] .
It is also one of the lessons from BioNLP Shared Task ( BioNLP-ST , hereafter ) 2009 that coreference relations in biomedical text substantially hinder the progress of fine-grained IE [ 10 ] .
-1#18#0#lc -1#1#2#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#25#9#exact -1#8#10#exact -1#9#11#exact -1#10#12#exact -1#11#13#exact -1#12#14#exact -1#13#15#exact -1#14#16#exact -1#15#17#exact -1#16#18#exact -1#20#20#exact -1#0#22#lc -1#17#25#exact -1#19#27#exact -1#21#29#exact -1#22#30#exact -1#23#31#exact -1#24#32#exact -1#26,27#33,34,35#para -1#28#36#exact -1#29#37#exact -1#30#38#exact -1#31#39#exact -1#32#40#exact -1#33#41#exact 


To address the problem of coreference resolution in molecular biology literature , the Protein Coreference ( COREF ) task was arranged in BioNLP-ST 2011 as a supporting task .
To address the problem of coreference resolution in molecular biology literature , the Protein Coreference ( COREF ) task was arranged in BioNLP-ST 2011 as a supporting task .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact 


This task definition focuses on protein , as a specific type of entity .
This task definition focuses on a specific type of entities , i.e. Protein .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#12#5#lc -1#10#6#exact -1#5#8#exact -1#6#9#exact -1#7#10#exact -1#8#11#exact -1#9#12#stem -1#13#13#exact 


Figure 1 shows an example text segmented into four sentences , S2 - S5 , where coreferential expressions are shown in brackets .
Figure 1 shows an example text segmented into four sentences , S2 - S5 , where coreferential expressions are shown in brackets .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact 


In the figure , protein names P4 - P10 are highlighted in boldface ; the targeted anaphoric expressions of the shared task ( pronouns and definite noun phrases ) are T29 , and T32 , for which the antecedents are indicated by arrows , if found in the text .
In the figure , protein names are highlighted in bold face , P4 - P10 , and targeted anaphoric expressions of the shared task , e.g. pronouns and definite noun phrases , are T29 , and T32 , of which the antecedents are indicated by arrows if found in the text .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#12#6#exact -1#13#7#exact -1#14#8#exact -1#6#9#exact -1#7#10#exact -1#8#11#exact -1#9#12#syn -1#21#14#exact -1#17#15#exact -1#18#16#exact -1#19#17#exact -1#20#18#exact -1#40#19#exact -1#22#20#exact -1#23#21#exact -1#26#23#exact -1#27#24#exact -1#28#25#exact -1#29#26#exact -1#30#27#exact -1#32#29#exact -1#33#30#exact -1#34#31#exact -1#35#32#exact -1#36#33#exact -1#37#34#exact -1#38,39#35,36#para -1#49#37#exact -1#41#38#exact -1#42#39#exact -1#43#40#exact -1#44#41#exact -1#45#42#exact -1#11#43#exact -1#46#44#exact -1#47#45#exact -1#48#46#exact -1#50#47,48#para -1#51#49#exact 


In the example , the definite-noun-phrase expression , this transcription factor ( T32 ) , is considered coreferential with the protein mention p65 ( P10 ) .
In the example , the definite-noun-phrase expression , this transcription factor ( T32 ) , is considered coreferential with the protein mention p65 ( P10 ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact 


Without knowing this coreference relation , it becomes difficult to capture the information written in the phrase , nuclear exclusion of this transcription factor , which is a localization of p65 ( out of nucleus ) , according to the framework of BioNLP-ST .
Without knowing this coreference relation , it becomes hard to capture the information written in the phrase , nuclear exclusion of this transcription factor , which is localization of p65 ( out of nucleus ) according to the framework of BioNLP-ST .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8,9#8,9#para -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#28#exact -1#28#29#exact -1#29#30#exact -1#30#31#exact -1#31#32#exact -1#32#33#exact -1#33#34#exact -1#34#35#exact -1#35#37#exact -1#36#38#exact -1#37#39#exact -1#38#40#exact -1#39#41#exact -1#40#42#exact -1#41#43#exact 


The terminologies used in this paper are similar to those in [ 25 ] .
The terminologies used in this paper are similar to those in [ 25 ] .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6,7,8#6,7,8,9#para -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact 


A new term introduced in the BioNLP-ST is antecedent protein , which indicates the protein mention contained in the antecedent expression , e.g. , p65 in T28 .
A new term is introduced in the BioNLP-ST is antecedent protein , which indicates the protein mention contained in the antecedent expression , e.g. p65 in T28 .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#4#3#exact -1#5#4#exact -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact -1#23#22#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact 


There are other coreferential expressions , which are ignored in the context of this COREF task , such as : this complex and the NF-kappa B transcription factor complex ( Figure 1 ) , since our focus is on the antecedent expressions that contain and point to protein mentions .
There are other coreferential expressions which are ignored in the context of this COREF task such as this complex and the NF-kappa B transcription factor complex ( Figure 1 ) , since we only focus on the antecedent expressions that contain and point to protein mentions .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#30#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#17#exact -1#16#18#exact -1#17#20#exact -1#18#21#exact -1#19#22#exact -1#20#23#exact -1#21#24#exact -1#22#25#exact -1#23#26#exact -1#24#27#exact -1#25#28#exact -1#26#29#exact -1#27#30#exact -1#28#31#exact -1#29#32#exact -1#31#34#exact -1#34#35,36#para -1#35#38#exact -1#36#39#exact -1#37#40#exact -1#38#41#exact -1#39#42#exact -1#40#43#exact -1#41#44#exact -1#42#45#exact -1#43#46#exact -1#44#47#exact -1#45#48#exact -1#46#49#exact 


The best system in the COREF shared task , according to the primary evaluation , found 22 .2% of the anaphoric protein references at the precision of 73 .3% ( 34 .1% F-score ) .
The best system in the COREF shared task according to the primary evaluation found 22 .2% of anaphoric protein references at the precision of 73 .3% ( 34 .1% Fscore ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#15#exact -1#14#16#exact -1#15#17#exact -1#16#18#exact -1#21#19#exact -1#17#20#exact -1#18#21#exact -1#19#22#exact -1#20#23#exact -1#22#25#exact -1#23#26#exact -1#24#27#exact -1#25#28#exact -1#26#29#exact -1#27#30#exact -1#28#31#exact -1#30#33#exact -1#31#34#exact 


The results are promising , since the authors make use of an external coreference resolution tool originally built for the news domain , without much domain adaptation on the main coreference resolution algorithm .
This is an encouraging result , since the authors make use of an external coreference resolution tool originally built for the news domain , without much domain adaptation on the main coreference resolution algorithm .
-1#20#0#lc -1#3#3#para -1#5#4#exact -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#29#19#exact -1#21#20#exact -1#22#21#exact -1#23#22#exact -1#24#23#exact -1#25#24#exact -1#26#25#exact -1#27#26#exact -1#28#27#exact -1#30#28,29#para -1#31#30#exact -1#32#31#exact -1#33#32#exact -1#34#33#exact 


Modifications are mostly made to the markable detection component and post-processing for the output coreference links [ 11 ] .
Modifications are mostly made to the markable detection component and post processing for the output coreference links [ 11 ] .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact 


However , the external coreference tool " s performance drops for biological texts than for news texts , from 66 .38% to 49 .65% in MUC-score [ 11 , 27 ] , which is supposed to be caused by domain differences .
However , the external coreference tool achieves much lower results on biological texts than that on news texts , from 66 .38% down to 49 .65% in MUC-score [ 11 , 27 ] , which is supposed to be caused by domain differences .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#9#7,8#para -1#22#9#para -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#16#14,15#para -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#23#21#exact -1#24#22#exact -1#25#23#exact -1#26#24#exact -1#27#25#exact -1#28#26#exact -1#29#27#exact -1#30#28#exact -1#31#29#exact -1#32#30#exact -1#33#31#exact -1#34#32#exact -1#35#33#exact -1#36#34#exact -1#37#35#exact -1#38#36#exact -1#39#37#exact -1#40#38#exact -1#41#39#exact -1#42#40#exact -1#43#41#exact 


A detailed analysis on the _nal submission of the COREF task participants was reported in the organizer 's papers [ 15 , 31 ] , and is summarized in table 2 .
A detailed analysis on the _nal submissions of the COREF task participants was reported in the organizer 's papers [ 15 , 31 ] , which is summarized in table 2 .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#stem -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact 


In this analysis , the submitted predictions on the test data set of the COREF shared task are analyzed according to four types of anaphoric expressions : DNP for definite noun phrases , RELAT for relative pronouns , PRON for other pronouns including personal , possessive , and demonstrative pronouns , and OTHER for catch-all type .
In this analysis , the submitted predictions on the test data set of the COREF shared task are analyzed according to four types of anaphoric expressions : DNP for definite noun phrases , RELAT for relative pronouns , PRON for other pronouns including personal , possessive , and demonstrative pronouns , and OTHER for catch-all type .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact -1#37#37#exact -1#38#38#exact -1#39#39#exact -1#40#40#exact -1#41#41#exact -1#42#42#exact -1#43#43#exact -1#44#44#exact -1#45#45#exact -1#46#46#exact -1#47#47#exact -1#48#48#exact -1#49#49#exact -1#50#50#exact -1#51#51#exact -1#52#52#exact -1#53#53#exact -1#54#54#exact -1#55#55#exact -1#56#56#exact 


Examples of the coreference types are outlined below :
Below are examples of the coreference types .
-1#2#0#lc -1#3#1#exact -1#4#2#exact -1#5#3#exact -1#6#4#exact -1#1#5#exact -1#0#7#lc 


- " [ . . . ] the phosphorylation status of [ TRAF2 ] had significant effects on the ability of [ the protein ] to bind to CD40 , " ( DNP )
- " . . . ,the phosphorylation status of [ TRAF2 ] had significant effects on the ability of [ the protein ] to bind to CD40 , " ( DNP )
-1#0#0#exact -1#1#1#exact -1#9#2#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#11#6#exact -1#16#7#exact -1#6#8#exact -1#7#9#exact -1#8#10#exact -1#19#11#exact -1#10#12#exact -1#22#13#exact -1#12#14#exact -1#13#15#exact -1#14#16#exact -1#15#17#exact -1#20#18#exact -1#17#19#exact -1#18#20#exact -1#21#22,23#para -1#23#25#exact -1#24#26#exact -1#25#27#exact -1#26#28#exact -1#27#29#exact -1#28#30#exact -1#29#31#exact -1#30#32#exact -1#31#33#exact 


- " Subnuclear fractionation reveals that there are [ two ATF1 isoforms , which ] appear to differ with respect to DNA binding activity , " ( RELAT )
- " Subnuclear fractionation reveals that there are [ two ATF1 isoforms ] [ which ] appear to differ with respect to DNA binding activity , " ( RELAT )
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#25#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact -1#23#22#exact -1#24#23#exact -1#26#25#exact -1#27#26#exact -1#28#27#exact -1#29#28#exact 


- " This ability of [ CIITA ] to facilitate promoter occupation is undissociable from [ its ] transactivation potential , " ( PRON )
- " This ability of [ CIITA ] to facilitate promoter occupation is undissociable from [ its ] transactivation potential , " ( PRON )
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact 


An analysis of the results indicated that the best resolution results for definite noun phrases ( the DNP type ) , and several pronouns of the PRON type was 27 .5% F-score and 10 .1 F-score , respectively ; the scores were much lower than the F-score for relative pronouns ( the RELAT type ) , which yielded a 66 .2 % F-score .
The analysis results in also showed that the best resolution results for definite noun phrases ( the DNP type ) , and several pronouns of the PRON type are 27 .5% F-score and 10 .1 F-score respectively , which are far less than that for relative pronoun ( the RELAT type ) 66 .2 % F-score .
-1#0,1#0,1#para -1#24#2#exact -1#25#3#exact -1#2#4#exact -1#5,6#5,6#para -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#48#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#syn -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#37#36#exact -1#36#37#exact -1#39,40#41,42#para -1#41,42#43,44#para -1#55#46#exact -1#44#47#exact -1#45#48#exact -1#46#49#stem -1#47#50#exact -1#49#52#exact -1#50#53#exact -1#51#54#exact -1#38#56#exact -1#52#59#exact -1#53#60#exact -1#54#61#exact -1#56#63#exact 


Thus , it can be inferred that it is more difficult to resolve definite noun phrases and pronouns than relative pronouns .
Thus , it can be inferred that definite noun phrases and pronouns are more difficult to be resolved than relative pronouns .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#12,13#8,9#para -1#14#10#exact -1#15#11#exact -1#16,17#12#para -1#7#13#exact -1#8#14#exact -1#9#15#exact -1#10#16#exact -1#11#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact 


The top four official results of the COREF shared task are presented in the top four rows of Table 2 .
The top four official results of the COREF shared task are shown again in the top four rows of Table 2 .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#syn -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact 


In this paper , we compare the contributions of different features in coreference resolution ; two simple types of domain-portable information : discourse preference and number-agreement , is compared , as well as domain-specific information , which is considered to be more difficult to be transferred across different domains .
In this paper , we compare the contributions of different features in coreference resolution , two simple types of domain-portable information : discourse preference and number-agreement , and domain-specific information which can be considered as more difficult to be transferred across different domains .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#31,32#27#para -1#14#29#exact -1#34#30#exact -1#28#33#exact -1#29#34#exact -1#30#36#exact -1#38#37#syn -1#33#38#exact -1#37#39#exact -1#35#41#exact -1#36#42#exact -1#39#43,44,45#para -1#40#46#exact -1#41#47#exact -1#42#48#exact -1#43#49#exact 


We implemented a protein coreference system that makes use of syntactic information from the parser output , and protein-indicated information encoded in rule-based semantic classification .
We implemented a protein coreference system that makes use of syntactic information from parser output , and protein-indicated information encoded in rule-based semantic classification .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact 


Experimental results showed that domain-specific semantic information is important for coreference resolution , and that simple semantic classification using semantic features helped our system to outperform the best-reported system results in the shared task .
Experimental results showed that domain specific semantic information is important for coreference resolution , and that simple semantic classification using semantic features helped our system to outperform the best reported result in the shared task .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact -1#23#22#exact -1#24#23#exact -1#25#24#exact -1#26#25#exact -1#27#26#exact -1#30#29#stem -1#31#30#exact -1#32#31#exact -1#33#32#exact -1#34#33#exact -1#35#34#exact 


In order to acquire insight into the problem , we took a rule-based approach , analyzing the training data of BioNLP-ST 2011 Coref task .
As we needed to get an insight into the problem , we took a rule-based approach , analyzing the training data of BioNLP-ST 2011 Coref task .
-1#3#2#exact -1#4#3#syn -1#6#4#exact -1#7#5#exact -1#8#6#exact -1#9#7#exact -1#10#8#exact -1#11#9#exact -1#12#10#exact -1#13#11#exact -1#14#12#exact -1#15#13#exact -1#16#14#exact -1#17#15#exact -1#18#16#exact -1#19#17#exact -1#20#18#exact -1#21#19#exact -1#22#20#exact -1#23#21#exact -1#24#22#exact -1#25#23#exact -1#26#24#exact 


The performance of the system evaluated on the official test dataset of the COREF task shows a significant improvement over the official winning system of the task .
The performance of the system evaluated on the official test data set of the COREF task shows a significant improvement over the official winning system of the task .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact -1#23#22#exact -1#24#23#exact -1#25#24#exact -1#26#25#exact -1#27#26#exact -1#28#27#exact 


This section presents the overview and the performance evaluation of our system .
This section presents the overview and the performance evaluation of our system .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact 


Figure 2 shows the overall design of the system , which includes five main components : preprocessing , markable detection , anaphor selection , antecedent candidate selection , and antecedent prediction .
Figure 2 shows the overall design of the system , which includes five main components : preprocessing , markable detection , anaphor selection , antecedent candidate selection , and antecedent prediction .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact 


Processing of each component is briefly described below .
Processing of each component is briefly described as below .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#8#7#exact -1#9#8#exact 


More details of implementation can be found in the method section .
More details of implementation can be found in the method section .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5,6,7#5,6,7,8#para -1#9#9#exact -1#10#10#exact -1#11#11#exact 


Step 0 - Preprocessing : The input text is preprocessed using NLP tools for sentence segmentation , and syntactic parsing .
Step 0 - Preprocessing : The input text is preprocessed using NLP tools for sentence segmentation , and syntactic parsing .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact 


We used the Genia Sentence Splitter and Enju Parser [ 15 ] for sentence segmentation and syntactic parsing , respectively .
We used Genia Sentence Splitter and Enju Parser [ 15 ] for the purposes , respectively .
-1#0#0#exact -1#1#1#exact -1#12#2#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#14#18#exact -1#15#19#exact -1#16#20#exact 


( Enju parser comes with a default tokenizer and part-of-speech tagger for biological text . ) Row 1 in the example of Table 1 shows three sentences as the output from the Genia Sentence Splitter , and noun phrases as the output from the Enju Parser for the sentence , S3 .
( Enju parser comes with a default tokenizer and part-of-speech tagger for biological text . ) Row 1 in the example Table 1 shows three sentences outputted from Genia Sentence Splitter , and noun phrases outputted from Enju Parser for the sentence S3 .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#40#28#exact -1#26#29#stem -1#27#30#exact -1#28#32#exact -1#29#33#exact -1#30#34#exact -1#31#35#exact -1#32#36#exact -1#33#37#exact -1#34#38#exact -1#35#41#stem -1#36#42#exact -1#37#44#exact -1#38#45#exact -1#39#46#exact -1#41#48#exact -1#42#50#exact -1#43#51#exact 


Due to the limited space , only a part of the phrases are shown in the table .
Due to the limit of space , only a part of the phrases are shown in the table .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#stem -1#5#4#exact -1#6#5#exact -1#7#6#exact -1#9,10#7,8,9,10#para -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact 


The full parse tree for this sentence is separately shown in Figure 3 .
The full parse tree of this sentence is separately shown in Figure 3 .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact 


Step 1 - Markable detection : Text chunks that are candidate coreferential expressions , which are also called markables following the jargon of MUC-7 , are collected .
Step 1 - Markable detection : collects text chunks that are candidate coreferential expressions , which are also called markables following the jargon of MUC-7 .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#7#6#lc -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact -1#23#22#exact -1#24#23#exact -1#6#26#stem -1#25#27#exact 


For the set of markables , noun phrases , which do not include a subordinate clause , are collected as they are analyzed by a syntactic parser ( in our case , Enju ) .
For the set of markables , noun phrases , which do not include subordinate clause , are collected as analyzed by a syntactic parser , Enju in our case .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#21#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#22#exact -1#20#23#exact -1#22#25#exact -1#23#26#exact -1#26#28#exact -1#27#29#exact -1#28#30#exact -1#24#31#exact -1#25#32#exact -1#29#34#exact 


Pronouns are also collected as markables .
Pronouns are also collected as markables .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact 


Then , for chunks that share the same head word , which is normally the main noun of a noun phrase , only the longest chunk is taken .
Then , for chunks that share the same head word , which is normally the main noun of a noun phrase , only the longest is taken .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact 


Since the Enju parser outputs head-word information for every noun phrase , we make use of this information for our processing , without any modification .
Since the Enju parser output such head-word information for every noun phrase , we make use of this information for our processing without any modification .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#stem -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13,14,15#12,13,14,15#para -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact 


The third row of Table 1 shows the result of markable detection for the sample text .
The third row of Table 1 shows the result of markable detection for the sample text .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact 


In the sentence S3 , three noun phrases recognized by the NX and NP tags of the Enju output , role , role for c-Myc in apoptosis , and this role for c-Myc in apoptosis ( Step 0 results ) share the same head-word role ; thus , only the longest noun phrase , this role for c-Myc in apoptosis , is selected .
In the sentence S3 , three noun phrases recognized by the NX and NP tags of Enju output , role , role for c-Myc in apoptosis , and this role for c-Myc in apoptosis ( Step 0 results ) share the same head word role , thus only the longest one this role for c-Myc in apoptosis is selected .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#40#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact -1#28#29#exact -1#29#30#exact -1#30#31#exact -1#31#32#exact -1#32#33#exact -1#33#34#exact -1#34#35#exact -1#35#36#exact -1#36#37#exact -1#37#38#exact -1#38#39#exact -1#39#40#exact -1#48#41#exact -1#41#42#exact -1#44#44#exact -1#46#46#exact -1#45#47#exact -1#47#48#exact -1#49#49,50#para -1#43#52#syn -1#51#54#exact -1#52#55#exact -1#53#56#exact -1#54#57#exact -1#55#58#exact -1#56#59#exact -1#57#61#exact -1#58#62#exact -1#59#63#exact 


However , between studies and studies using . . .
However , between studies and studies using . . .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact 


apoptosis , the former chunk is selected , since the latter contains a subordinate clause .
apoptosis , the former chunk is selected , since the latter contains a subordinate clause .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact 


Step 2 - Anaphor selection : Candidate anaphoric expressions , which are basically pronouns and definite noun phrases , are determined . A minority of anaphors are indefinite noun phrases or entity names , which act as appositions .
Step 2 - Anaphor selection : determines candidate anaphoric expressions , which are basically pronouns and definite noun phrases ( a minority of anaphors are indefinite noun phrases or entity names , which act as appositions . )
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#7#6#lc -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#31#18#exact -1#24#19#exact -1#6#20#stem -1#36#21#exact -1#20#22#lc -1#21#23#exact -1#22#24#exact -1#23#25#exact -1#25#27#exact -1#26#28#exact -1#27#29#exact -1#28#30#exact -1#29#31#exact -1#30#32#exact -1#32#34#exact -1#33#35#exact -1#34#36#exact -1#35#37#exact 


The system first considers all pronouns and definite noun phrases in the markable set as anaphors .
The system first considers all pronouns and definite noun phrases in the markable set as anaphors .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact 


Then , several filters are applied to remove anaphors that are not relevant to the task definition .
Then , several filters are applied to remove anaphors that are not relevant to the task definition .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact 


We implemented two types of filters : syntactic and semantic .
We implemented two types of filters : syntactic and semantic filters .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#11#10#exact 


Syntactic filters are used to filter out pleonastic its , or pronouns , like : he , she , which are not expected to refer to proteins .
Syntactic filters are used to filter out pleonastic its , or pronouns such as he , she , which are not expected to refer to proteins .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#15#12#exact -1#14#15#exact -1#17#16#exact -1#16#17#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact 


Moreover , because our task focuses on protein references , semantic filters can be used to filter out non-protein anaphors at this stage .
Moreover , because the focus of our task is protein references , semantic filters can be used to filter out non-protein anaphors at this stage .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#6#3#exact -1#7#4#exact -1#8#5#para -1#9#7#exact -1#10#8#exact -1#11#9#exact -1#12#10#exact -1#13#11#exact -1#14,15,16#12,13,14,15#para -1#18#16#exact -1#19#17#exact -1#20#18#exact -1#21#19#exact -1#22#20#exact -1#23#21#exact -1#24#22#exact -1#25#23#exact 


In practice , for definite noun phrase type of anaphors , this is accomplished , by using a list of possible head-words of protein references ; for pronouns , their context words are used .
In practice , for definite noun phrase type of anaphors , this is done using a list of possible head words of protein references , and for pronouns , their context words are used .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#para -1#24#14#exact -1#14,15#15,16,17#para -1#16#18#exact -1#17#19#exact -1#18#20#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact 


More details of these methods can be found in the following section .
More details of the methods can be found in the following section .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3,4#3,4#para -1#5#5#exact -1#6,7,8,9#6,7,8#para -1#10#9,10#para -1#11#11#exact -1#12#12#exact 


Step 3 - Antecedent candidate selection : For each anaphor , this component collects the antecedent candidates from the preceding expressions .
Step 3 - Antecedent candidate selection : For each anaphor , this component collects the antecedent candidates from the preceding expressions .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact 


One of the candidates will become the response antecedent , as a result of the antecedent prediction step .
One of the candidates will become the response antecedent as a result of the antecedent prediction step .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#10,11,12,13#10,11,12,13,14#para -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact 


In theory , all expressions in the set of markables can become antecedent candidates ; however , too many candidates makes it difficult to achieve correct antecedent prediction .
In theory , all expressions in the set of markables can become antecedent candidates , however too much candidates makes it difficult to achieve correct antecedent prediction .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#15#15#exact -1#14#16#exact -1#16#17#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact 


Moreover , we also filter out candidates that violate syntactic or semantic constraints raised by the anaphor .
Moreover , we also filter out candidates that violate syntactic or semantic constraints raised by the anaphor .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact 


In our system , this is done by using a particular window size in sentences , together with several syntactic filters .
In our system , this is done by using a window size in sentences , together with several syntactic filters .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact 


One of the syntactic filters is based on syntactic relations among phrases outputted from the parser .
One of the syntactic filters is based on syntactic relations among phrases outputted from the parser .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact 


The idea behind this filter is that some types of syntactic relations imply the impossibility of coreference relations between its argument noun phrases and the inclusive expressions of these noun phrases .
The idea behind this is that some types of syntactic relations imply the impossibility of coreference relations between its argument noun phrases and the inclusive expressions of these noun phrases .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact -1#28#29#exact -1#29#30#exact -1#30#31#exact 


For example , the two expressions : dominant negative form and its in our example in Table 1 , cannot be coreferential with each other , since they are connected via the preposition of .
For example , the two expressions dominant negative form and its in our example in Table 1 , can not be coreferential with each other , since they are connected via the preposition of .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18,19#19,20#para -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact 


Another syntactic filter removes pronouns that are not in the same pronoun family as the anaphor .
Another syntactic filter removes pronouns which are not in the same pronoun family as the anaphor .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5,6,7,8#5,6,7,8#para -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact 


This results in the disappearance of this in candidate antecedents of its .
This results in the disappearance of this in candidate antecedents of its .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact 


Pronouns in the same family as its are its , it , and itself .
Pronouns in the same family as its are its , it , and itself .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact 


Step 4 - Antecedent prediction : The best candidate in the antecedent candidate set is selected , and a response coreference link is formed .
Step 4 - Antecedent predicion : selects the best candidate in the antecedent candidate set , and forms a response coreference link .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#5#5#exact -1#7#6#lc -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#6#15#stem -1#15#16#exact -1#16#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#17#23#stem -1#22#24#exact 


Antecedent candidates are compared with one another using a comparison procedure .
Antecedent candidates are compared with one another using a comparison procedure .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact 


This procedure implements a decision rule list containing four rules , encoding the following selection preference conditions :
This procedure implements a decision rule list containing four rules , encoding the following selection preference conditions :
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact 


-Rule 1 ( Number agreement - NUM-AGREE ) : The candidate , which does not conflict in number with the anaphor , is selected .
-Rule 1 ( Number agreement - NUM-AGREE ) : The candidate which is not number conflict with anaphor is selected .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#12#exact -1#13#13,14#para -1#15#15#exact -1#14#17#exact -1#16#18#exact -1#17#20#exact -1#12#22#exact -1#19#23#exact -1#20#24#exact 


-Rule 2 ( Semantic constraint - SEM-CONS ) : If the anaphor is a protein reference , then a protein candidate is selected .
-Rule 2 ( Semantic constraint - SEM-CONS ) : If anaphor is a protein reference , then protein candidate is selected .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#19#exact -1#18#20#exact -1#19#21#exact -1#20#22#exact -1#21#23#exact 


-Rule 3 ( Discourse preference - DISC-PREF ) : According to the anaphor type , the farther candidate is selected .
-Rule 3 ( Discourse preference - DISC-PREF ) : According to the anaphor type , the farther candidate is selected .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact 


-Default rule ( Default discourse preference - DEFAULT ) : The closer candidate is selected .
-Default rule ( Default discourse preference - DEFAULT ) : The closer candidate is selected .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact 


The rules are implemented using different features of expressions , such as syntactic types of expressions , head noun , semantic types , etc. , in a similar way to [ 22 ] .
The rules are implemented using different features of expressions such as syntactic types of expression , head noun , semantic types , etc. , in a similar way to [ 22 ] .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#15#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#stem -1#18#16#exact -1#16#17#exact -1#17#18#exact -1#21#19#exact -1#19#20#exact -1#20#21#exact -1#23#22#exact -1#22#23#exact -1#24,25,26,27,28#25,26,27,28#para -1#29#30#exact -1#30#31#exact -1#31#32#exact -1#32#33#exact 


Each rule in the decision list compares two candidates , and returns the preferable candidate in concern with the anaphor .
Each rule in the decision list compares two candidates , and returns the preferrable candidate in concern with the anaphor .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact 


If equility happens , the next rule in the list is applied .
If equility happens , the next rule in the list is applied .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact 


The default and also last rule in the decision rule list is special in the sense that depending on the anaphor , it prefers the closer or the farther candidate .
The default and also last rule in the decision rule list is special in the sense that depending on the anaphor , it prefers the closer or the farther candidate .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact 


Because of this particular rule , the decision list never results in the equility result .
Thanks to this rule , the decision list never results in the equility result .
-1#2#2#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact 


In this way , candidates can be sorted , and the best candidate is selected as the antecedent .
By this way , candidates can be sorted , and the best candidate is selected as antecedent .
-1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#17#exact -1#17#18#exact 


Figure 4 illustrates how the decision list works when comparing two candidates : and .
Figure 4 illustrates how the decision list works when comparing two candidates and .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#13#exact -1#13#14#exact 


More details concerning the implementation of the main components of our system shown in Figure 2 are presented below .
More details about the implementation of the main components of our system shown in Figure 2 are presented below .
-1#0#0#exact -1#1#1#exact -1#2#2#para -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact 


In this step , we want to filter out those pronouns and definite noun phrases that are not a target of this task . The expressions are comprised of two types : non-anaphoric expressions , and anaphoric expressions , which do not point to proteins .
In this step , we want to filter out those pronouns and definite noun phrases that are not target of this task , comprised of two types : non-anaphoric expressions , and anaphoric expressions which do not point to proteins .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18,19#para -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#40#23#exact -1#29#24,25#para -1#35,36#26#para -1#23#27#exact -1#24#28#exact -1#25#29#exact -1#26#30#exact -1#27#31#exact -1#28#32#exact -1#33#33#exact -1#22#34#exact -1#31#35#exact -1#32#36#exact -1#30#38#exact -1#34#39#exact -1#37#41,42#para -1#38#43#exact -1#39#44#exact 


The term anaphoric is used with the common sense in the NLP community .
The term anaphoric is used with the common sense in NLP community .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact 


Anaphoric expression refers to an expression that has a noun phrase as an antecedent .
Anaphoric expression means an expression that has a noun phrase as antecedent .
-1#0#0#exact -1#1#1#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#13#exact -1#12#14#exact 


Thus , expressions with a sentence or phrase antecedents , or nominal but successive antecedents , are not our target and should be filtered out .
This means expressions with a sentence or phrase antecedents , or nominal but successive antecedents , are not our target and should be filtered out .
-1#9#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#15#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact 


Non-anaphoric expressions include first and second-person pronouns such as I , we , you , and pleonastic it .
Non-anaphoric expressions includes first and second person pronouns such as I , we , you , . . . , and pleonastic it .
-1#0#0#exact -1#1#1#exact -1#2#2#stem -1#3#3#exact -1#4#4#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#20#15#exact -1#21#16#exact -1#22#17#exact -1#23#18#exact 


First and second-person pronouns are easily recognized by the part-of-speech tags ; thus , we use part-of-speech information for the filtering .
First and second person pronouns are easily to be recognized by the part-of-speech tags , thus we use part-of-speech information for the filtering .
-1#0#0#exact -1#1#1#exact -1#4#3#exact -1#5#4#exact -1#6#5#exact -1#9#6#exact -1#10#7#exact -1#11#8#exact -1#12#9#exact -1#13#10#exact -1#15#12#exact -1#14#13#exact -1#16#14#exact -1#17#15#exact -1#18#16#exact -1#19#17#exact -1#20#18#exact -1#21#19#exact -1#22#20#exact -1#23#21#exact 


For pleonastic it , we make use of the following four patterns , which are similar to [ 13 ] :
For pleonastic it , we make use of the following four patterns , which are similar to [ 13 ]
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4,5,6#4,5,6,7#para -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13,14,15,16#13,14,15#para -1#17#17#exact -1#18#18#exact -1#19#19#exact 


It be [ Adj|Adv| verb ]* that
It be [ Adj|Adv| verb ]* that
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact 


It be Adj [ for NP ] to VP
It be Adj [ for NP ] to VP
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact 


It [ seems|appears|means|follows ] [ that ]*
It [ seems|appears|means|follows ] [ that ]*
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact 


NP [ makes|finds|take ] it [ Adj ]* [ for NP ]* [ to VP|Ving ]
NP [ makes|finds|take ] it [ Adj ]* [ for NP ]* [ to VP|Ving ]
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact 


To recognize and filter anaphoric expressions that do not point to proteins , the system is based on the protein semantic classification results determined by the method presented below .
To recognize and filter anaphoric expressions which do not point to proteins , the system is based on the protein semantic classification results determined by the method presented below .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6,7,8#6,7,8#para -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15,16,17,18#15,16,17#para -1#25#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#26#25,26#para -1#27#27#exact -1#28#28#exact -1#29#29#exact 


For each anaphoric markable , the system collects a list of antecedent candidates , and select the most probable candidate to be the antecedent of the anaphor .
For each anaphoric markable , the system collects a list of antecedent candidates , and select the most probable candidate to be the antecedent of the anaphor .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact 


Basically , all of the expressions detected in the initial expression set are an antecedent candidate , with the exception of anaphoric pronouns .
Basically all expressions detected in the initial expression set are antecedent candidate , except for anaphoric pronouns .
-1#0#0#exact -1#12#1#exact -1#1#2#exact -1#5#4#exact -1#2#5#exact -1#3#6#exact -1#4#7#exact -1#6#8,9#para -1#7#10#exact -1#8#11#exact -1#9#12#exact -1#10#14#exact -1#11#15#exact -1#13,14#17,18,19,20#para -1#15#21#exact -1#16#22#exact -1#17#23#exact 


However , if the list contains too many candidates , then it may be more difficult for the later antecedent-selection algorithm .
However , if the list contains too many candidates , then it may be more difficult for the later antecedent-selection algorithm .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact 


Therefore , candidates that are not probable to be an antecedent of the anaphor should be filtered out .
Therefore , candidates that are not probable to be antecedent of the anaphor should be filtered out .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact 


There are several filters that can be used :
There are several filters that can be used :
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact 


Window size Borders are set to include or exclude antecedent candidates .
Window size sets a border to include or exclude antecedent candidates .
-1#0#0#exact -1#1#1#exact -1#4#2,3#para -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact 


This is a common method for antecedent candidate filtering , as seen in the previous work [ 3 , 5 , 26 ] .
This is a common method for antecedent candidate filtering having been used in the previous work [ 3 , 5 , 26 ] .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#18#9#exact -1#10#11#para -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#20#18#exact -1#19#19#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact 


Since our task focuses on anaphoric coreference , antecedent expressions normally appear not too far ( in sentence distance ) from the anaphors . Thus , using window sizes is a proper technique .
Since our task focuses on anaphoric coreference , antecedent expressions normally appear not too far ( in sentence distance ) from the anaphors , using window sizes is a proper technique .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#31#23#exact -1#23#25#exact -1#24#26#exact -1#25#27#exact -1#26#28#exact -1#27#29#exact -1#28#30#exact -1#29#31#exact -1#30#32#exact 


Syntactic dependency relations Since arguments of some dependency relations ( such as poss-arg12 and prep-arg12 ) do not corefer with each other , they can be used to correctly eliminate the number of antecedent candidates .
Syntactic dependency relations The fact that arguments of some dependency relations such as poss-arg12 and prep-arg12 do not corefer with each other enables us to use them to correctly eliminate the number of antecedent candidates .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#6#4#exact -1#7#5#exact -1#8#6#exact -1#9#7#exact -1#10#8#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#25#23,24,25,26#para -1#24#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact 


For instance , two such truncated forms definitely cannot be an antecedent of the protein in this context : two such truncated forms of the protein .
For instance , two such truncated forms definitely cannot be antecedent of the protein in this context two such truncated forms of the protein
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#19#exact -1#18#20#exact -1#19#21#exact -1#20#22#exact -1#21#23#exact -1#22#24#exact -1#23#25#exact 


After filtering non-relevant antecedent candidates for an anaphor in the step above , depending on the anaphor type , the remaining candidates are ranked by fixed rules , or by using a pairwise comparison procedure :
After filtering non-relevant antecedent candidates for an anaphor in the above step , depending on the anaphor type , the remained candidates are ranked by fixed rules , or by using a pairwise comparison procedure :
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#11#10#exact -1#10#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#stem -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact 


The relative pronoun can be said to be the easiest type of coreference resolution , because its antecedent expression is very close to the anaphor , and in many cases , it is right before the anaphor .
The relative pronoun can be said to be the easiest type of coreference resolution , because its antecedent expression is very close to the anaphor , and in many cases , it is right before the anaphor .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#5,6#3,4,5,6#para -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact -1#37#37#exact 


For these types of anaphors , any syntactic parser can be used to find the relation between relative pronouns and their arguments .
For this type of anaphors , any syntactic parser can be used to find the relations between relative pronouns and their arguments .
-1#0#0#exact -1#1,2#1,2#para -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9,10,11,12#9,10,11#para -1#13,14#12,13,14#para -1#15,16#15,16#para -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact 


Our system accomplishes this task .
This is exactly what our system does .
-1#4#0#lc -1#5#1#exact -1#1#2#para -1#0#3#lc -1#7#5#exact 


It simply produces coreference links between the relative pronouns and their arguments .
It simply produces coreference links between the relative pronouns and their arguments .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact 


However , a disadvantage to using this method is that when the parser makes a mistake on finding the correct arguments , the coreference also fails . This is exemplified in the following : " . . .of transcription factor NF-kappa B also encodes a p70 I kappa B protein , I kappa B gamma , which is identical to the C-terminal 607 amino acids of . . . "
However , a disadvantage of this method is when the parser makes mistake on finding the correct arguments , coreference also fails , as in the example " . . .of transcription factor NF-kappa B also encodes a p70 I kappa B protein , I kappa B gamma , which is identical to the C-terminal 607 amino acids of . . . "
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#52#4#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#10#exact -1#9#11#exact -1#10#12#exact -1#11#13#exact -1#37#14#exact -1#12#15#exact -1#13#16#exact -1#14#17#exact -1#15#18#exact -1#16#19#exact -1#17#20#exact -1#18#21#exact -1#25#22#exact -1#19#23#exact -1#20#24#exact -1#21#25#exact -1#28#26#exact -1#50#28#exact -1#24#30#exact -1#53#31#exact -1#27#34#exact -1#59#35#exact -1#60#36#exact -1#30#37#exact -1#31#38#exact -1#32#39#exact -1#33#40#exact -1#34#41#exact -1#35#42#exact -1#36#43#exact -1#38#45#exact -1#39#46#exact -1#40#47#exact -1#41#48#exact -1#42#49#exact -1#43#50#exact -1#44#51#exact -1#45#52#exact -1#46#53#exact -1#47#54#exact -1#48#55#exact -1#49#56#exact -1#51#58#exact -1#54#61#exact -1#55#62#exact -1#56#63#exact -1#57#64#exact -1#58#65#exact -1#29#66#exact -1#61#67#exact -1#62#69#exact 


This procedure compares two candidate expressions at a time with respect to preferences raised by the anaphor .
This procedure compares two candidate expressions at a time with respect to preferences raised by the anaphor .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact 


The best antecedent expression is selected to form a response coreference link .
The best antecedent expression is selected to form a response coreference link .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact 


In particular , a list of rules is used to compare two candidates of an anaphor in a deterministic manner .
In particular , a list of rules is used to compare two candidates of an anaphor in a deterministic manner .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact 


For each rule , both of the candidates are checked against the condition hold by that rule .
For each rule , both of the candidates are checked against the condition hold by that rule .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact 


If one candidate satisfies and the other does not , the procedure ends with the result that the former will be preferable over the latter .
If one candidate satisfies and the other does not , the procedure ends with the result that the former will be preferable to the latter .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact 


If both satisfy or both do not satisfy , the procedure proceeds to the next rule in the same manner .
If both satisfy or both do not satisfy , the procedure proceeds to the next rule in the same manner .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact 


The rules are applied in a successive order , one after another , until the inequality occurs , or until the end-of-the-rule list is reached .
The rules are applied in a succession order one after another until the inequality occurs , or end of the rule list is reached .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#stem -1#7#7#exact -1#15#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#13#exact -1#12#14#exact -1#13#15#exact -1#14#16#exact -1#16#18#exact -1#19#20#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact 


The default rule of the procedure , is in the preference of the closer antecedent candidate .
The default rule of the procedure prefers the closer antecedent candidate .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#7#9#exact -1#6#10#stem -1#8#12,13#para -1#9#14#exact -1#10#15#exact -1#11#16#exact 


By definition , two coreferential expressions are identical , which implies a semantic-constraint on coreference relationship .
By definition , two coreferential expressions refer to the same thing , which implies a semantic-constraint on coreference relationship .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#8,9#6,7#para -1#11#8#exact -1#12#9#exact -1#13#10#exact -1#14#11#exact -1#15#12#exact -1#16#13#exact -1#17#14#exact -1#18#15#exact -1#19#16#exact 


In other words , semantic types of coreferents must be compatible .
In other words , semantic types of coreferents must be compatible .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact 


In practice , this compatibility is checked based on a given taxonomy of semantic classes in the following manner : two semantic classes are considered compatible or agreed with each other , when they have a synonym relation , or hypernym-hyponym relation .
In practice , this compatibility is checked based on a given taxonomy of semantic classes in the following manner : two semantic classes are considered compatible or agreed with each other , when they have synonym relation , e.g. , or hypernym-hyponym relation .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32,33,34#32,33,34,35#para -1#35#36#exact -1#36#37#exact -1#37#38#exact -1#40#39#exact -1#41#40#exact -1#42#41#exact -1#43#42#exact 


In this work , we only focus on the Protein type , ignoring other possible semantic types , so the structure of the taxonomy is not taken into account .
In this work , we only focus on the Protein type , ignoring other possible semantic types , so we do not take the structure of taxonomy into account .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#24,25#19,20,21,22#para -1#26#23#exact -1#21#24,25#para -1#22#26,27#para -1#28#28#exact -1#29#29#exact 


Therefore , the likelihood that two expressions are semantically compatible , is definitely beneficial for antecedent prediction , besides syntactic information .
Thus , the likelihood that two expressions are semantically compatible is definitely beneficial for antecedent prediction , besides syntactic information .
-1#0#0#syn -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#16#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact 


Focusing on specific entity types , i.e. , Protein type , enables us to find a proper method for determining the likelihood , and method for encoding the likelihood in coreference resolution .
Focusing on specific entity types , i.e. Protein type , helps us to find a proper method for determining the likelihood , and how to encode the likelihood in coreference resolution .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#9#7#exact -1#7#8#exact -1#8#9#exact -1#21#10#exact -1#11,12#11,12#para -1#13,14#13,14,15#para -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#22#23#exact -1#25#26#stem -1#26#27#exact -1#27#28#exact -1#28#29#exact -1#29#30#exact -1#30#31#exact -1#31#32#exact 


Since gold protein annotations are given , we can use them in combination with syntactic information to judge whether an expression is a protein-referential expression or not .
Since gold protein annotations are given , we can use them in combination with syntactic information to judge whether an expression is protein-referential expession or not .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#23#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact 


If an expression is a noun phrase with a single head word , and it contains a protein mention that completely overlaps with the head word , then the expression is classified as Protein .
In details , if an expression is a noun phrase with a single head word , and it contains a protein mention that completely overlaps with the head word , then the expression is classied as Protein .
-1#3#0#lc -1#4#1#exact -1#5#2#exact -1#6#3#exact -1#7#4#exact -1#8#5#exact -1#9#6#exact -1#10#7#exact -1#11#8#exact -1#12#9#exact -1#13#10#exact -1#14#11#exact -1#15#12#exact -1#16#13#exact -1#17#14#exact -1#18#15#exact -1#19#16#exact -1#20#17#exact -1#21#18#exact -1#22#19#exact -1#23#20#exact -1#24#21#exact -1#25#22#exact -1#26#23#exact -1#27#24#exact -1#28#25#exact -1#29#26#exact -1#30#27#exact -1#31#28#exact -1#32#29#exact -1#33#30#exact -1#35#32#exact -1#36#33#exact -1#37#34#exact 


In another case , when the head noun is either protein or gene , and has a protein mention as its premodifier , such as the Tax protein .
Another case is when the head noun is either protein or gene , and has a protein mention as its premodifier , such as the Tax protein .
-1#0#1#lc -1#1#2#exact -1#12#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#21#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact 


For a coordinated noun phrase , if one of its constituents is classified as a Protein , then that noun phrase is also classified as a Protein .
For a coordinated noun phrase , if one of its constituents is classified as Protein , then that noun phrase is also classified as Protein .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#26#exact -1#25#27#exact 


Pronouns , in particular , possessive pronouns , occupy the majority of anaphoric pronouns in biological texts ( Table 5 ) .
Pronouns , in particular , possessive pronouns occupy the majority of anaphoric pronouns in biological texts ( Table 5 ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact 


However , they do not contain very much useful information for the resolution ; thus , we need to exploit more information from its context [ 17 ] .
However , they do not contain in themselves much useful information for the resolution , thus we need to exploit more information from its context [ 17 ] .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#8#6,7#para -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#15#14#exact -1#14#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact 


The analysis of BioNLP-ST 2011 also showed that we need a different strategy to resolve such pronouns [ 18 ] .
The analysis of BioNLP-ST 2011 also showed that we need different strategy to resolve such pronouns [ 18 ] .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10,11#para -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact 


Fortunately , the key to this problem lies in the context of pronouns .
Fortunately , the key to this problem lies in the context of pronouns .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6,7,8#6,7,8,9#para -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact 


We implemented a simple function to classify the semantic type of a possessive pronoun , based on its context word .
We implemented a simple function to classify the semantic type of a possessive pronoun based on its context word .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact 


In particular , we check the noun phrase in which the determiner is its or their ; if the noun phrase contains a protein key word , then the inclusive pronoun is classified into the Protein semantic type .
In particular , we check the noun phrase whose determiner is its or their ; if the noun phrase contains a protein key word then the inclusive pronoun is classified into the Protein semantic type .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#9#para -1#16#10#exact -1#9#11#exact -1#10#12#exact -1#11#13#exact -1#12#14#exact -1#13#15#exact -1#14#16#exact -1#15#17#exact -1#25#18#exact -1#17#19#exact -1#18#20#exact -1#19#21#exact -1#20#22#exact -1#21#23#exact -1#22#24#exact -1#23#25#exact -1#24#27#exact -1#31#28#exact -1#26#29#exact -1#27#30#exact -1#28#31#exact -1#29#32#exact -1#30#33#exact -1#32#34,35#para -1#33#36#exact -1#34#37#exact -1#35#38#exact 


Protein key words can be a verb , a noun or an adjective that co-occurred with protein mentions , and can be used as a clue to distinguish the protein type from other semantic types .
protein key words can be a verb , a noun or an adjective that coocurred with protein mentions and can be used as a clue to distinguish the protein type from other semantic types .
-1#0#0#lc -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#19#exact -1#19,20,21,22,23#20,21,22,23#para -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact -1#28#29#exact -1#29#30#exact -1#30#31#exact -1#31#32#exact -1#32#33#exact -1#33#34#exact -1#34#35#exact 


For example , the word binding in the following noun phrases : its heterodimeric binding partner , or its binding site , is a clue to infer that it must be a protein reference .
For example , the word binding in the following noun phrases its heterodimeric binding partner , or its binding site is a good clue to infer that it must be a protein reference .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#22#exact -1#21#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact -1#28#29#exact -1#29#30#exact -1#30#31#exact -1#31#32#exact -1#32#33#exact -1#33#34#exact 


For our preliminary experiment , we collect these keywords manually by checking the noun phrases containing its and their in the training data .
For our preliminary experiment , we collect these key words manually by checking the noun phrases containing its and their in training data .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20,21#para -1#22#22#exact -1#23#23#exact 


Our final protein keyword set includes 12 words : binding , expression , interaction , regulation , phosphatase activity , localization , gene , sequence , region , phosphorylation , transactivation , and transcription .
Our final protein key word set includes 12 words : binding , expression , interaction , regulation , phosphatase activity , localization , gene , sequence , region , phosphorylation , transactivation , and transcription .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#5#4#exact -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact -1#23#22#exact -1#24#23#exact -1#25#24#exact -1#26#25#exact -1#27#26#exact -1#28#27#exact -1#29#28#exact -1#30#29#exact -1#31#30#exact -1#32#31#exact -1#33#32#exact -1#34#33#exact -1#35#34#exact 


In future , the protein key words can be collected automatically using the term corpus , or other resources of proteins .
In future , the protein key words can be collected automatically using the term corpus , or other resources of proteins .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact 


Coreferential definite noun phrases in text are used to include a broader definition of coreference .
Coreferential definite noun phrases in text are used in broader meaning of coreference .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7,8#7,8#para -1#9#10,11#para -1#11#13#exact -1#12#14#exact -1#13#15#exact 


In other words , their antecedents do not necessarily exist in the textual context ; in particular , in biomedical scientific papers , many definite noun phrases do not have antecedents , since the referenced concepts can include any concept that is understood by subject matter experts in the domain .
In other words , their antecedents do not necessarily exist in the textual context ; in particular in biomedical scientific papers , many definite noun phrases do not have antecedents since the referred concepts can be anything understood by experts in the domain .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#21#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact -1#28#29#exact -1#29#30#exact -1#30#32#exact -1#31#33#exact -1#33#35#exact -1#34#36#exact -1#35#41#syn -1#37#42#exact -1#38#43#exact -1#39#46#exact -1#40#47#exact -1#41#48#exact -1#42#49#exact -1#43#50#exact 


Distinguishing such non-anaphoric definite noun phrases from anaphoric ones is a difficult task .
Distinguishing such non-anaphoric definite noun phrases from anaphoric ones is an uneasy task .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9,10#9,10#para -1#11#11#para -1#12#12#exact -1#13#13#exact 


Knowing their semantic type helps to filter out irrelevant candidate antecedents , thereby increasing the chance of picking up the right antecedent , and increasing the precision of antecedent prediction .
Knowing their semantic type helps to filter out irrelevant candidate antecedents , increasing chance to pick up the right antecedent or the precision of antecedent prediction .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12,13#para -1#17#14#exact -1#13#15#exact -1#23#16#exact -1#15#17#stem -1#16#18#exact -1#21#19#exact -1#18#20#exact -1#19#21#exact -1#22#26#exact -1#24#28#exact -1#25#29#exact -1#26#30#exact 


In our implementation , the decision to keep an anaphoric expression for further processing steps for an anaphoric definite noun phrase is based on a protein head word list .
In our implementation , decision to keep an anaphoric expression for further processing steps for an anaphoric definite noun phrase is based on a protein head word list .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4,5#para -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact -1#28#29#exact 


We tested two different head word lists : one is built automatically from the gold anaphoric nominals in gold data ; the other word list contains the top seven common head words : protein , gene , factor , molecule , element , family , inhibitor , and receptor .
We tested two different head word lists : one is built automatically from the gold anaphoric nominals in gold data , the other word list contains top seven common head words : protein , gene , factor , molecule , element , family , inhibitor , and receptor .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#27#exact -1#27#28#exact -1#28#29#exact -1#29#30#exact -1#30#31#exact -1#31#32#exact -1#32#33#exact -1#33#34#exact -1#34#35#exact -1#35#36#exact -1#36#37#exact -1#37#38#exact -1#38#39#exact -1#39#40#exact -1#40#41#exact -1#41#42#exact -1#42#43#exact -1#43#44#exact -1#44#45#exact -1#45#46#exact -1#46#47#exact -1#47#48#exact -1#48#49#exact 


Semantic type information can be used in coreference resolution in several ways .
Semantic type information can be used in coreference resolution in several ways .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact 


First , in anaphor selection , semantic information can be used to filter out non-protein anaphoric expressions .
First , in anaphor selection , semantic information can be used to filter out non-protein anaphoric expressions .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8,9,10#8,9,10,11#para -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact 


Second , in antecedent candidate filtering , semantic agreement between the antecedent candidates and the anaphoric expression is checked .
Second , in antecedent candidate filtering , semantic agreement between the antecedent candidates and the anaphoric expression is checked .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact 


Those candidates that are not in agreement with the anaphor in semantics are filtered out .
Those candidates which are not agree with the anaphor in semantics are filtered out .
-1#0#0#exact -1#1#1#exact -1#2,3#2,3#para -1#4#4#exact -1#5,6,7#5,6,7,8#para -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact 


For example , if an anaphor is classified as a protein referent , then the non-protein antecedent candidates are removed from the candidate set of the anaphor .
For example , if anaphor is classified as protein referent , then non-protein antecedent candidates are removed from the candidate set of the anaphor .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#10#exact -1#9#11#exact -1#10#12#exact -1#11#13#exact -1#18#14#exact -1#12#15#exact -1#13#16#exact -1#14#17#exact -1#15#18#exact -1#16#19#exact -1#17#20#exact -1#22#21#exact -1#19#22#exact -1#20#23#exact -1#21#24#exact -1#23#26#exact -1#24#27#exact 


Finally , in antecedent prediction : semantic agreement can again be used as a constraint when comparing two antecedent candidates to select the more probable candidate .
Finally , in antecedent prediction : semantic agreement again can be used as a constraint when comparing two antecedent candidates to select the more probable candidate .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#9#8#exact -1#8#9#exact -1#10,11,12,13#10,11,12#para -1#14#13,14#para -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact 


Our minimal system configuration includes all of the processing and filters from step 0 to step 3 , as explained in the section above ( RB-MIN ) .
Our minimal system configuration includes all the processing and filters from step 0 to step 3 as explained in the above section ( RB-MIN ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4,5,6#4,5,6,7#para -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#18#exact -1#17#19#exact -1#18#20#exact -1#19#21#exact -1#21#22#exact -1#20#23#exact -1#22#24#exact -1#23#25#exact -1#24#26#exact -1#25#27#exact 


For antecedent candidate selection , the window size used in step 4 is set to 2 , which means that antecedent candidates are collected in the two nearest sentences from the anaphor , and the sentence embedding the anaphor .
For antecedent candidate selection , the window size used in step 4 is set to 2 , which means antecedent candidates are collected in the two nearest sentences from the anaphor , and the sentence embedding the anaphor .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact -1#28#29#exact -1#29#30#exact -1#30#31#exact -1#31#32#exact -1#32#33#exact -1#33#34#exact -1#34#35#exact -1#35#36#exact -1#36#37#exact -1#37#38#exact -1#38#39#exact 


The statistics measured on the training set of the corpus shows that 97 .0% percent of protein coreference links have antecedents appearing in within 2 sentences .
As the statistics measured on the training set of the corpus shows that 97 .0% percent of protein coreference links have antecedents appearing in within 2 sentences .
-1#1#0#lc -1#2#1#exact -1#3#2#exact -1#4#3#exact -1#5#4#exact -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact -1#23#22#exact -1#24#23#exact -1#25#24#exact -1#26#25#exact -1#27#26#exact 


With this window size , the average number of candidates per anaphor is 6 .1 .
With this window size , the average number of candidates per anaphor is 6 .1 .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact 


Also , experiments with wider window sizes did not help .
Also , experiments with wider window sizes did not help .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact 


The word list used to filter out anaphoric definite noun phrases in step 2 contains the following words : protein , gene , factor , molecule , element , family , inhibitor , and receptor .
The word list used to filter out anaphoric definite noun phrases in step 2 contains the following words : protein , gene , factor , molecule , element ,family , inhibitor , and receptor .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#29#28#exact -1#31#30#exact -1#30#31#exact -1#32#33#exact -1#33#34#exact -1#34#35#exact 


These words are selected from the top appearing head words extracted from the training data .
These words are selected from the top appearring head words extracted from the training data .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#stem -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact 


Premodifiers of definite noun phrases are also limited to numbers and popular premodifiers of proteins , such as nuclear , and transcription .
Besides , premodifiers of definite noun phrases are also limited to numbers and popular premodifiers of proteins such as nuclear , transcription .
-1#2#0#lc -1#3#1#exact -1#4#2#exact -1#5#3#exact -1#6#4#exact -1#7#5#exact -1#8#6#exact -1#9#7#exact -1#10#8#exact -1#11#9#exact -1#12#10#exact -1#13#11#exact -1#14#12#exact -1#15#13#exact -1#16#14#exact -1#1#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#21#exact -1#22#22#exact 


Using this head word list and premodifiers , the system covers 83 .5 percent of the coreference links .
Using this head word list and premodifiers , the system covers 83 .5 percent of the coreference links .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact 


To keep the minimal configuration simple , step 4 - antecedent selection of the baseline only uses the default comparison rule , which assures that the closest antecedent candidate is selected .
To keep the minimal configuration simple , step 4 - antecedent selection of the baseline only uses the default comparison rule , which assures the closest antecedent candidate is selected .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact -1#28#29#exact -1#29#30#exact -1#30#31#exact 


Table 2 compares our system with the top four official results of the COREF shared task in BioNLP-ST 2011 [ 18 ] : UU [ 11 ] , UZ [ 29 ] , CU , and UT [ 4 ] .
Table 2 compares our system with the top four official results of the COREF shared task in BioNLP-ST 2011 [ 18 ] : UU [ 11 ] , UZ [ 29 ] , CU , and UT [ 4 ] .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact -1#37#37#exact -1#38#38#exact -1#39#39#exact -1#40#40#exact 


The scoring scheme used throughout this paper is the protein coreference evaluation , the primary evaluation method of the COREF shared task [ 18 ] .
The scoring scheme used throughout this paper is the protein coreference evaluation , the primary evaluation method of the COREF shared task [ 18 ] .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact 


This primary evaluation method , which was particularly designed for the shared task , is based on protein coreference links that have been automatically generated from manually annotated coreference links .
This primary evaluation method , which was particularly designed for the shared task , is based on protein coreference links automatically generated from manually annotated coreference links .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#23#exact -1#21#24#exact -1#22#25#exact -1#23#26#exact -1#24#27#exact -1#25#28#exact -1#26#29#exact -1#27#30#exact 


The last column ALL shows the overall results , while its preceding three columns PRON , DNP , and RELAT shows the protein resolution results by three major subtypes of anaphors : pronouns , definite noun phrase and relative pronouns , respectively .
The last column ALL shows the overall results , while its preceding three columns PRON , DNP , and RELAT shows the protein resolution results by three major subtypes of anaphors : pronouns , definite noun phrase and relative pronouns , respectively .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact -1#37#37#exact -1#38#38#exact -1#39#39#exact -1#40#40#exact -1#41#41#exact -1#42#42#exact 


Note that the results from RB-MIN with minimal configuration , already surpasses the best results obtained by the UU team , with up to 7 .1% higher performance in F-score .
Note that RB-MIN with minimal configuration already outperforms the best result by the UU team , with up to 7 .1% higher in Fscore .
-1#0#0#exact -1#1#1#exact -1#12#2#exact -1#10#3#stem -1#2#5#exact -1#3#6#exact -1#4#7#exact -1#5#8#exact -1#15#9#exact -1#6#10#exact -1#7#11#syn -1#8#12#exact -1#9#13#exact -1#11#16#exact -1#13#18#exact -1#14#19#exact -1#16#21#exact -1#17#22#exact -1#18#23#exact -1#19#24#exact -1#20#25#exact -1#21#26#exact -1#22#28#exact -1#24#30#exact 


Since RB-MIN uses similar preprocessing tools as UU [ 11 ] , but less information in antecedent prediction , this gap in performance is likely caused by the different markable detection methods .
Since RB-MIN uses similar preprocessing tools as UU [ 11 ] , but less information in antecedent prediction , this gap in performance is supposed to be caused by the different markable detection methods .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#26,27,28,29#25,26,27#para -1#30#28#exact -1#31#29#exact -1#32#30#exact -1#33#31#exact -1#34#32#exact 


UU pointed in their paper that markable detection is one of the challenges of this task [ 11 ] .
UU pointed in their paper that markable detection is one of the challenges of this task [ 11 ] .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8,9,10,11#8,9,10#para -1#12,13#11,12,13#para -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact 


In their system , UU used a machine learning approach , and tested two distinguished models for markable detection : one solved both anaphors and antecedents together , the other treated anaphors and antecedents separately .
In their system , UU used a machine learning approach , and tested two distinguished models for markable detection : one solved both anaphors and antecedents together , the other treated anaphors and antecedents separately .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact 


Meanwhile , our method is basically based on the boundary of noun phrases and pronouns , as is outputted from the parser .
Meanwhile , our method is basically based on the boundary of noun phrases and pronouns , as is outputted from the parser .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact 


The patterns used to extract the proper noun phrases and pronouns , are manually designed concerning the markable boundaries annotated in the training data .
The patterns used to extract the proper noun phrases and pronouns , are manually designed concerning the markable boundaries annotated in the training data .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact 


Breaking down the system performance by the different types of anaphors provides us with insight into what has been accomplished / solved by our methods , and also provides us with improvement opportunities .
Breaking down the system performance by types of anaphors gives us an insight into what have been solved by our methods , and what needs more improvement effort .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6,7#6,7,8,9#para -1#8#10#exact -1#9,10#11,12#para -1#12#14#exact -1#13#15#exact -1#14#16#exact -1#15,16#17,18#para -1#17#21#exact -1#18#22#exact -1#19#23#exact -1#20#24#exact -1#21#25#exact -1#22#26#exact -1#26#31#exact -1#28#33#exact 


Concerning the RELAT type of coreference , we can see that RB-MIN and RB-FULL both achieve comparable results with the best team in BioNLP-ST 2011 .
Concerning the RELAT type of coreference , we can see that RB-MIN and RB-FULL both achieve comparable results with the best team in BioNLP-ST 2011 .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7,8,9#7,8,9,10#para -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact 


However , it should be noted that our antecedent prediction for the RELAT type is based solely on the output of the Enju parser for the RELAT type , so in order to improve this type of coreference , we have to find ways to overcome the parse errors on noun phrase boundary detection and relative clause attachment ( See Discussions section ) .
However , it should be noted that our antecedent prediction for the RELAT type is based completely on the output of Enju parser for the RELAT type , so in order to improve this type of coreference , we have to find ways to overcome the parse errors on noun phrase boundary detection and relative clause attachment ( See section Discussions ) .
-1#0#0#exact -1#1#1#exact -1#3,4,5#2,3,4,5#para -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#24#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#45#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact -1#28#29#exact -1#31,32#30,31,32,33#para -1#33#34#exact -1#34#35#exact -1#35#36#exact -1#36#37#exact -1#37#38#exact -1#38,39#39,40,41,42#para -1#42#43#exact -1#43#44#exact -1#44#45#exact -1#46#47#exact -1#47#48#exact -1#48#49#exact -1#49#50#exact -1#50#51#exact -1#51#52#exact -1#52#53#exact -1#53#54#exact -1#54#55#exact -1#55#56#exact -1#56#57#exact -1#57#58#exact -1#58#59#exact -1#60#60#exact -1#59#61#exact -1#61#62#exact -1#62#63#exact 


The increase in system performance on the PRON and DNP types by RB-FULL demonstrate the effectiveness of discourse and semantic information in the performance of protein coreference resolution .
The increase in system performance on the PRON and DNP types by RB-FULL demonstrate the effectiveness of discourse and semantic information in the performance of protein coreference resolution .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact 


Comparing RB-MIN , RB-FULL and RB-MIN+1 , 3 , we found that rule 3 , which stands for discourse preference , works well for the PRON type ( 2 ) .
Comparing RB-MIN , RB-FULL and RB-MIN+1 , 3 , we found that rule 3 , which stands for discourse preference , works well for the PRON type ( 2 ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact 


On the other hand , the major contribution to the improvement of DNP resolution is from rule 2 .
On the other hand , the major contribution to the improvement of DNP resolution is from rule 2 .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6,7,8#6,7,8,9#para -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact 


This rule successfully utilizes the domain-specific information , which shows that coreference resolution requires domain-specific information .
This rule successfully utilizes the domain-specific information , which shows that coreference resolution requires domain-specific information .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact 


To further explore the elements contributed to this significant improvement , we analyzed our system in more detail .
To further explore the elements contributed to this significant improvement , we analyzed our system in more details .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#stem -1#18#18#exact 


The analyses of the results are provided in the section entitled Discussions .
The analysis results are given in section Discussions .
-1#0#0#exact -1#1#1,2,3#para -1#2#4#exact -1#3#5#exact -1#5#7#exact -1#6#8,9#para -1#7#11#exact -1#8#12#exact 


" >
" >
-1#0#0#exact -1#1#1#exact 


Table 3 compares various configurations of the rule-based system .
Table 3 compares various configurations of the rule-based system .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact 


The first , RB-MIN , is the minimal system .
The first , RB-MIN , is the minimal system .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact 


The following three show the contribution of the three rules , NUM-AGREE , SEM-CONS , and DISC-PREF .
The following three show contribution of the three rules , NUM-AGREE , SEM-CONS , and DISC-PREF .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4,5,6#4,5,6,7#para -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact 


RB-FULL is the full system .
RB-FULL is the full system .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact 


To emphasize the contribution of the semantic rules , it also shows RB-FULL-sem system .
To emphasize the contribution of the semantic rules , it also shows RB-FULL-sem system .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact 


The combination of rule 1 , 2 and 3 resulted in a 62 .4% F-score ( RB-MIN+1 , 2 , 3 ) ( Table 3 ) In this configuration , rule 2 contributes to a 4-point F-score increase in the development set , and 2 .3-point F-score increase on the test set , when comparing RB-MIN+1 , 3 and RB-MIN+1 , 2 , 3 .
The combination of rule 1 , 2 and 3 resulted in 62 .4% fscore ( RB-MIN+1 , 2 , 3 ) ( Table 3 ) In this configuration , rule 2 contribute to the increasement of 4 points Fscore on the development set , and 2 .3 points Fscore on the test set , when comparing RB-MIN+1 , 3 and RB-MIN+1 , 2 , 3 .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#12#exact -1#12#13#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact -1#28#29#exact -1#29#30#exact -1#30#31#exact -1#31,32#32,33#para -1#34#37#stem -1#39,40,41#38,39,40#para -1#42#41#exact -1#43#42#exact -1#44#43#exact -1#45#44#exact -1#49#48#exact -1#50#49#exact -1#51#50#exact -1#52#51#exact -1#53#52#exact -1#54#53#exact -1#55#54#exact -1#56#55#exact -1#57#56#exact -1#58#57#exact -1#59#58#exact -1#60#59#exact -1#61#60#exact -1#62#61#exact -1#63#62#exact -1#64#63#exact -1#65#64#exact 


However , the result of RB-MIN is still more than 7 points higher than in state-of-the-art performance .
However , the result of RB-MIN is more than still 7 points higher than the state-of-the-art performance .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#9#7#exact -1#7#8#exact -1#8#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact 


This gain is due to the fact that the rule ensures that the semantic type of antecedents is the same as for their anaphors , thus enabling the correct detection of antecedents .
This gain is due to the fact that the rule ensures the semantic type of antecedents is the same as their anaphors , enabling the correct detection of antecedents .
-1#0#0#exact -1#1#1#exact -1#2,3,4#2,3,4,5#para -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#5#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16,17,18,19#17,18,19#para -1#20#21,22#para -1#21#23#exact -1#22#24#exact -1#23#26#exact -1#24#27#exact -1#25#28#exact -1#26#29#exact -1#27#30#exact -1#28#31#exact -1#29#32#exact 


In other words , if an anaphor is classified as a protein reference , then the antecedent must also be a protein reference .
In other words , if anaphor is classified as a protein reference , then antecedent must also be a protein reference .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#16#exact -1#15#17#exact -1#16#18#exact -1#17#19#exact -1#18#20#exact -1#19#21#exact -1#20#22#exact -1#21#23#exact 


The following examples illustrate the way rule 2 works .
The following examples illustrate the way rule 2 works .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact 


( Coreference examples in this paper are represented in the following manner : gold anaphoric and antecedent expressions are bracketed , antecedents before anaphors ; gold protein mentions are underlined ; and incorrect response antecedents are in italics . )
( Coreference examples in this paper are represented as below : gold anaphoric and antecedent expressions are bracketed , antecedents before anaphors ; gold protein mentions are underlined ; and incorrect response antecedents are in italics . )
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#34#8#exact -1#16#10#syn -1#10#12#exact -1#11#13#exact -1#12#14#exact -1#13#15#exact -1#14#16#exact -1#15#17#exact -1#26#18#exact -1#17#19#exact -1#18#20#exact -1#19#21#exact -1#20#22#exact -1#21#23#exact -1#22#24#exact -1#23#25#exact -1#24#26#exact -1#25#27#exact -1#33#28#exact -1#27#29#exact -1#28#30#exact -1#29#31#exact -1#30#32#exact -1#31#33#exact -1#32#34#exact -1#35#37#exact -1#36#38#exact -1#37#39#exact 


- " Therefore , [ IRF-1 ] may be an important contributor to IL-12 signaling , and we speculate that the defective IL-12 responses seen in IRF-1- / - mice might be attributable , in part , to the absence of [ this transcription factor ] . " ( PMID-10358173 )
- " Therefore , [ IRF-1 ] may be an important contributor to IL-12 signaling , and we speculate that the defective IL-12 responses seen in IRF-1- / - mice might be attributable , in part , to the absence of [ this transcription factor ] . " ( PMID-10358173 )
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#10,11,12#9,10,11,12#para -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact -1#37#37#exact -1#38#38#exact -1#39#39#exact -1#40#40#exact -1#41#41#exact -1#42#42#exact -1#43#43#exact -1#44#44#exact -1#45#45#exact -1#46#46#exact -1#47#47#exact -1#48#48#exact -1#49#49#exact -1#50#50#exact 


In this example , without rule 2 , the faulty response antecedent of this transcription factor is part because it is the closet antecedent candidate agreeing with the anaphor on the singular number .
In this example , without rule 2 , the faulty response antecedent of this transcription factor is part because it is the closet antecedent candidate agreeing with the anaphor on the singular number .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact 


Meanwhile , since this transcription factor is recognized as a protein reference , its closest protein antecedent IRF-1 was successfully detected by RB-FULL .
Meanwhile since this transcription factor is recognized as a protein reference , its closest protein antecedent IRF-1 was successfully detected by RB-FULL .
-1#0#0#exact -1#11#1#exact -1#1#2#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact 


Another example is :
Another interesting example is
-1#0#0#exact -1#2#1#exact -1#3#2#exact 


- " This role for [ c-Myc ] in apoptosis is now confirmed in studies using a dominant negative form of [ its ] heterodimeric binding partner , Max , which . . . " ( PMID-7964516 )
- " This role for [ c-Myc ] in apoptosis is now confirmed in studies using a dominant negative form of [ its ] heterodimeric binding partner , Max , which . . . " ( PMID-7964516 )
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact -1#37#37#exact 


Concerning the anaphoric pronoun its in this example , there are several antecedent candidates : this role , c-Myc , apoptosis , studies , a dominant negative form of its heterodimeric binding partner .
Concerning the anaphoric pronoun its in this example , there are several antecedent candidates : this role , c-Myc , apoptosis , studies , a dominant negative form of its heterodimeric binding partner .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact 


Although studies and a dominant negative form of its heterodimeric binding partner have been crossed out because of disagreement in numbers , and violation of abandoned syntactic constraints , correspondingly , the system would return the incorrect antecedent apoptosis instead of c-Myc .
Although studies and a dominant negative form of its heterodimeric binding partner have been crossed out because of disagreement in numbers , and violation of abandoned syntactic constraints correspondingly , the system would return the incorrect antecedent apoptosis instead of c-Myc .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#29#28#exact -1#28#29#exact -1#30#31#exact -1#31#32#exact -1#32#33#exact -1#33#34#exact -1#34#35#exact -1#35#36#exact -1#36#37#exact -1#37#38#exact -1#38#39#exact -1#39#40#exact -1#40#41#exact -1#41#42#exact 


Fortunately , the containing noun phrase of the anaphor its has the modifier word binding , which is a clue for classifying its as a protein reference ( See Semantic type classification for pronominal anaphors ) .
Fortunately , the containing noun phrase of the anaphor its has the modifier word binding , which is a clue for classifying its as a protein reference ( See Semantic type classification for pronominal anaphors ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact 


Rule 2 utilizes semantic classification result to make the correct selection .
Rule 2 utilizes semantic classification result to make correct selection .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8,9#para -1#9#10#exact -1#10#11#exact 


In our system , domain-specific semantic information is utilized in two places : anaphor selection and antecedent prediction .
In our system , domain-specific semantic information is ultilized at two places : anaphor selection and antecedent prediction .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#9,10#9,10#para -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact 


The effect of semantic information in antecedent prediction has been analyzed in the sections above .
The effect of semantic information in antecedent prediction has been analyzed in above section .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#13#12,13#para -1#12#14#exact -1#14#15#exact 


In this subsection , we are going to explore the contribution of semantic information in the anaphor selection step .
In this subsection , we are going to explore the contribution of semantic information in the anaphor selection step .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4,5,6,7#4,5,6#para -1#8#7,8#para -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact 


To classify anaphors into protein or non-protein reference , our system employs a head-word based classifier for definite noun phrases , DEFNP-ANA-SEM , and a context-based classifier for pronouns , PRO-ANA-SEM ( Section Methods ) .
To classify anaphors into protein or non-protein reference , our system employs a head-word based classfier for definite noun phrases , DEFNP-ANA-SEM , and a context-based classifier for pronouns , PRO-ANA-SEM ( Section Methods ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#26#15#exact -1#27#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#16#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact 


Without limiting the number of anaphors by using semantic information-based filtering , the precision significantly drops , causing a big decrease in the F-score ( Table 4 , RB-FULL without DEFNP-ANA-SEM ) .
Without limiting the number of anaphors by using semantic information-based filtering , the precision significantly drops , causing a big decrease in Fscore ( Table 4 , RB-FULL w / o DEFNP-ANA-SEM ) . .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact -1#31#30#exact -1#32#31#exact -1#33#32#exact 


This decrease is due to the fact that the semantic filter is the only way to filter out definite noun phrase anaphors .
This is because the semantic filter is the only way to filter out definite noun phrase anaphors .
-1#0#0#exact -1#1#2#exact -1#2#3,4,5,6,7#para -1#3#8#exact -1#4#9#exact -1#5#10#exact -1#6,7,8,9,10#11,12,13,14#para -1#11#16#exact -1#12#17#exact -1#13#18#exact -1#14#19#exact -1#15#20#exact -1#16#21#exact -1#17#22#exact 


Without the filter , all definite expressions , which include a huge amount of non-anaphoric expressions , are considered as anaphors .
Without the filter , all definite expressions , which include a huge amount of non-anaphoric expressions , are considered as anaphors .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10,11#10,11,12,13#para -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact 


Besides the anaphoric use , definite noun phrases are also used to refer to entities or concepts in the common domain knowledge shared between readers and writers .
Besides the anaphoric use , definite noun phrases are also used to refer to entities or concepts in the common domain knowledge shared between readers and writers .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact 


Statistics in [ 21 ] show that only around 30% of definite noun phrases are anaphoric , and the other uses according to their classification include associative , unfamiliar / larger situation , idiom and doubt .
Statistics in [ 21 ] show that only around 30% of definite noun phrases are anaphoric , and the other uses according to their classification include associative , unfamiliar / larger situation , idiom and doubt .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact 


Distinguishing such non-anaphoric definite noun phrases from anaphoric ones is extremely difficult .
Distinguishing such non-anaphoric definite noun phrases from anaphoric ones is extremely difficult .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact 


In our system , contextual information of possessive pronouns is utilized through the protein key words ( Section Methods ) , and this contributed to a 1 .8% gain in F-score ( Table 4 , RB-FULL without PRO-ANA-SEM ) .
In our system , contextual information of possessive pronouns is utilized through the protein key words ( Section Methods ) , and this contributed to 1 .8% gain in f-score ( Table 4 , RB-FULL w / o PRO-ANA-SEM ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25,26#para -1#26#27#exact -1#27#28#exact -1#28#29#exact -1#29#30#lc -1#30#31#exact -1#31#32#exact -1#32#33#exact -1#33#34#exact -1#34#35#exact -1#38#37#exact -1#39#38#exact -1#40#39#exact 


This gain is a good indication for seeking a systematic method to develop and include such contextual information in coreference resolution .
This is an encouraging sign to seek for a systematic method to exploit and include such contextual information in coreference resolution .
-1#0#0#exact -1#1#2#exact -1#8#3#exact -1#7#6#exact -1#9#8,9#para -1#10#10#exact -1#11#11#exact -1#12,13#12,13#para -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact 


Examples showing the effectiveness of semantic information from the context of pronouns is provided below :
Below are the examples showing the effectiveness of semantic information from the context of pronouns .
-1#3#0#lc -1#4#1#exact -1#5#2#exact -1#6#3#exact -1#7#4#exact -1#8#5#exact -1#9#6#exact -1#10#7#exact -1#11#8#exact -1#12#9#exact -1#13#10#exact -1#14#11#exact -1#1#12#syn -1#0#14#lc 


- " This role for [ c-Myc ] in apoptosis is now confirmed in studies using a dominant negative form of [ its ] heterodimeric binding partner , Max , which . . . " ( MID-7964516 )
- " This role for [ c-Myc ] in apoptosis is now confirmed in studies using a dominant negative form of [ its ] heterodimeric binding partner , Max , which . . . " ( MID-7964516 )
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact -1#37#37#exact 


- " This ability of [ CIITA ] to facilitate promoter occupation is undissociable from [ its ] transactivation potential . " ( PMID-10221658 )
- " This ability of [ CIITA ] to facilitate promoter occupation is undissociable from [ its ] transactivation potential . " ( PMID-10221658 )
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact 


- " In transient transfectin experiments , [ BCL6 ] can repress transcription from promoters linked to [ its ] DNA target sequence and this activity is . . . " ( PMID-8692924 )
- " In transient transfectin experiments , [ BCL6 ] can repress transcription from promoters linked to [ its ] DNA target sequence and this activity is . . . " ( PMID-8692924 )
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact 


- " [ Human immunodeficiency virus type 1 ( HIV-1 ) Tat ] , an early regulatory protein that is critical for viral gene expression and replication , transactivates the HIV-1 long terminal repeat ( LTR ) via [ its ] binding to the transactivation response element ( TAR ) and , . . . " ( PMID-9261367 )
- " [ Human immunodeficiency virus type 1 ( HIV-1 ) Tat ] , an early regulatory protein that is critical for viral gene expression and replication , transactivates the HIV-1 long terminal repeat ( LTR ) via [ its ] binding to the transactivation response element ( TAR ) and , . . . " ( PMID-9261367 )
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact -1#37#37#exact -1#38#38#exact -1#39#39#exact -1#40#40#exact -1#41#41#exact -1#42#42#exact -1#43#43#exact -1#44#44#exact -1#45#45#exact -1#46#46#exact -1#47#47#exact -1#48#48#exact -1#49#49#exact -1#50#50#exact -1#51#51#exact -1#52#52#exact -1#53#53#exact -1#54#54#exact -1#55#55#exact -1#56#56#exact -1#57#57#exact -1#58#58#exact 


In all the examples above , the appearance of words such as binding , transactivation , DNA target sequence in the noun phrases for which the anaphor plays a role as a determiner , is a contextual indicator for the protein type .
In all the above examples , the appearance of words such as binding , transactivation , DNA target sequence in the noun phrases of which the anaphor plays a role as a determiner , is contextual indicator for the protein type .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#4#3#exact -1#3#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23,24#23,24#para -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#36#exact -1#36#37#exact -1#37#38#exact -1#38#39#exact -1#39#40#exact -1#40#41#exact -1#41#42#exact 


Since the anaphors are predicted as protein reference from their context , the system correctly detects their protein antecedents .
Since the anaphors are predicted as protein reference from their context , the system correctly detects their protein antecedents .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact 


Other challenges specific to the protein coreference task Number agreement is a constraint in English writing .
Other challenges specific to the protein coreference task Number agreement is a constraint in English writing .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact 


However , in the data , we found several coreferential expressions that violate this constraint .
However , we found in the data several coreferential expressions violating this constraint .
-1#0#0#exact -1#1#1#exact -1#4#2#exact -1#5#3#exact -1#6#4#exact -1#2#6#exact -1#3#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11,12#para -1#11#13#exact -1#12#14#exact -1#13#15#exact 


259
For instance , the anaphor and antecedent in the following :



417
The anaphor and antecedent in the following is an instance of this violation :



- " . . .for OTF-2 in DRA gene transcription .
- " . . .for OTF-2 in DRA gene transcription .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact 


In contrast , [ OTF-1-enriched protein fractions ] did not affect DRA gene transcription although [ it ] functionally enhanced the transcription of another . . . " ( PMID-1560002 )
In contrast , [ OTF-1-enriched protein fractions ] did not affect DRA gene transcription although [ it ] functionally enhanced the transcription of another . . . " ( PMID-1560002 )
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact 


Coreference annotation and evaluation Current protein coreference evaluation schemes generate protein links ( links between anaphors and antecedent proteins ) from surface links ( links between anaphors and antecedent expressions ) , without concerning the relative position of antecedent proteins in the antecedent expression .
Coreference annotation and evaluation Current protein coreference evaluation scheme generates protein links ( links between anaphors and antecedent proteins ) from surface links ( links between anaphors and antecedent expressions ) , without concerning the relative position of antecedent proteins in the antecedent expression .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#stem -1#9#9#stem -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact -1#37#37#exact -1#38#38#exact -1#39#39#exact -1#40#40#exact -1#41#41#exact -1#42#42#exact -1#43#43#exact -1#44#44#exact 


Therefore , when the proteins appear in premodifiers or postmodifers of noun phrases as [ cDNAs encoding EBF or a covalent homodimer of E47 ] in this example :
Therefore , when the proteins appear in premodifiers or postmodifers of noun phrases as [ cDNAs encoding EBF or a covalent homodimer of E47 ] in this example
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact 


- " With the aim of identifying genetic targets for these transcription factors , we stably transfected [ cDNAs encoding EBF or a covalent homodimer of E47 ] , individually or together , into immature hematopoietic Ba / F3 cells , which lack [ both factors ] . " ( PMID-9252117 )
- " With the aim of identifying genetic targets for these transcription factors , we stably transfected [ cDNAs encoding EBF or a covalent homodimer of E47 ] , individually or together , into immature hematopoietic Ba / F3 cells , which lack [ both factors ] . " ( PMID-9252117 )
-1#0#0#exact -1#1#1#exact -1#2,3,4,5#2,3,4#para -1#25#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact -1#37#37#exact -1#38#38#exact -1#39#39#exact -1#40#40#exact -1#41#41#exact -1#42#42#exact -1#43#43#exact -1#44#44#exact -1#45#45#exact -1#46#46#exact -1#47#47#exact -1#48#48#exact -1#49#49#exact -1#50#50#exact -1#51#51#exact 


Such proteins might not be the correct antecedent proteins .
Such proteins might not be the right antecedent proteins .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#syn -1#7#7#exact -1#8#8#exact -1#9#9#exact 


In future , revision of corpus annotation and evaluation schemes would benefit the ease of automation of coreference resolution .
In furture , corpus annotation and evaluation scheme should be revised for the ease of automation of coreference resolution .
-1#0#0#exact -1#2#2#exact -1#9,10#3#para -1#14#4#exact -1#3#5#exact -1#4#6#exact -1#5#7#exact -1#6#8#exact -1#7#9#stem -1#8#10#para -1#12#12#exact -1#13#13#exact -1#16#14#exact -1#15#15#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact 


Parse error Coreference expression boundary is determined mostly based on noun phrase boundary output from the parser .
Parse error Coreference expression boundary is determined mostly based on noun phrase boundary output from parser .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#16#exact -1#16#17#exact 


Therefore , parse error on noun phrase boundary strongly affects the performance of coreference resolution .
Therefore , parse error on noun phrase boundary strongly affects the performance of coreference resolution .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact 


Examining the data , we found that many antecedent expressions of plural anaphors are coordinated noun phrases , which are unfortunately difficult cases to many parsers including Enju .
Examining the data , we found that many antecedent expressions of plural anaphors are coordinated noun phrases , which are unfortunately difficult cases to many parsers including Enju .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact 


Incorporation of recent works for coordination resolution like [ 20 ] should be useful for improving the performance .
Incorporation of recent works for coordination resolution like [ 20 ] should be useful to improve the performance .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14,15#14,15#para -1#16#16#exact -1#17#17#exact -1#18#18#exact 


The following example shows a coordination-structured antecedent AML1 / CBF beta , C / EBP , Ets , c-Myb , HOX , and MZF-1 that failed to be detected by the parser .
The following example shows a coordination-structured antecedent AML1 / CBF beta , C / EBP , Ets , c-Myb , HOX , and MZF-1 that was failed to be detected by the parser .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#26#25#exact -1#27#26#exact -1#28#27#exact -1#29#28#exact -1#30#29#exact -1#31#30#exact -1#32#31#exact -1#33#32#exact 


The spurious response expression is transcription factors from several families .
The spurious response expression is transcription factors from several families .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact 


- " granulocytic and monocytic lineages , transcription factors from several families are active , including [ AML1 / CBF beta , C / EBP , Ets , c-Myb , HOX , and MZF-1 ] .
- " granulocytic and monocytic lineages , transcription factors from several families are active , including [ AML1 / CBF beta , C / EBP , Ets , c-Myb , HOX , and MZF-1 ] .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact 


Few of [ these factors ] are expressed exclusively in myeloid cells ; . . . " ( PMID-9291089 )
Few of [ these factors ] are expressed exclusively in myeloid cells ; . . . " ( PMID-9291089 )
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact 


Our current work has reconfirmed that domain knowledge is indispensable for coreference resolution .
Our work has confirmed again that domain knowledge is indispensable for coreference resolution .
-1#0#0#exact -1#1#2#exact -1#2#3#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact 


Since the biological domain has richer knowledge resources than any other domain , it would be interesting to continue studying how to exploit and employ domain-specific semantic information in coreference resolution for this domain .
Since the biologicaldomain has richer knowledge resources than any other domain , it would be interesting to continue studying how to exploit and employ domain-specific semantic information in coreference resolution for this domain .
-1#0#0#exact -1#1#1#exact -1#10#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#32#11#exact -1#11#12#exact -1#12,13,14,15,16#13,14,15,16#para -1#20#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#21#21,22#para -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact -1#28#29#exact -1#29#30#exact -1#30#31#exact -1#31#32#exact -1#33#34#exact 


Another conclusion concerns markable detection .
Another conclusion concerns with markable detection .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#4#3#exact -1#5#4#exact -1#6#5#exact 


This sub-problem is often regarded as an easy task in coreference resolution systems ; however , in actuality , it is an important subtask , which strongly affects the performance of coreference system .
This subproblem is often thought as an easy task in coreference resolution systems , however , indeed it is an important subtask which strongly affects the performance of coreference system .
-1#0#0#exact -1#2#2#exact -1#3#3#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#14#14#exact -1#15#15#exact -1#13#18#exact -1#18,19,20#19,20,21,22#para -1#21#23#exact -1#22#25#exact -1#23#26#exact -1#24#27#exact -1#25#28#exact -1#26#29#exact -1#27#30#exact -1#28#31#exact -1#29#32#exact -1#30#33#exact 


Sticking to the gold data in designing the markable detection method , as done in this paper , is one employed strategy .
Sticking to the gold data in the designing markable detection method as we did in this paper is one of the strategies .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#7#6#exact -1#6#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#12#exact -1#13,14#13,14#para -1#15#15#exact -1#16#16#exact -1#17#18#exact -1#18#19#exact -1#21#21#stem -1#22#22#exact 


However , from the perspective of coreference data creation , revision of the markable annotations would aid in automatic and robust markable detection .
However , from another perspective , the perspective of coreference data creation , we should revise the markable annotations , for the sake of automatic and robust markable detection .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#6#3#exact -1#7#4#exact -1#8#5#exact -1#9#6#exact -1#10#7#exact -1#11#8#exact -1#12#9#exact -1#15,16#10,11,12#para -1#17#13#exact -1#18#14#exact -1#14#15#para -1#24#18#exact -1#25#19#exact -1#26#20#exact -1#27#21#exact -1#28#22#exact -1#29#23#exact 


For future opportunities , more effort should be spent on automating the semantic classification for coreference expressions , using context .
As for the future , more effort should be spent on automating the semantic classification for coreference expressions using context .
-1#1#0#lc -1#3#1#exact -1#4#3#exact -1#5#4#exact -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact 


Furthermore , it would be interesting to test the results in this study in a machine-learning framework .
Furthermore , it would be interesting to test the results in this study in a machine learning framework .
-1#0#0#exact -1#1#1#exact -1#2,3,4,5,6#2,3,4,5#para -1#7#6,7#para -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#17#16#exact -1#18#17#exact 


TEDR is defined as the rate between ( 1 ) the minimal cost to transform a tree A into another tree B using edit operations and ( 2 ) the maximum number of nodes of A and B . // <The " rate between " is unclear to me . Do you mean , " the ratio of " >
TEDR is defined as the rate between ( 1 ) the minimal cost to transform a tree A into another tree B using edit operations and ( 2 ) the maximum number of nodes of A and B .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact -1#37#37#exact -1#38#38#exact 


It can be computed using Eq . \REF .
It can be computed using Eq . \REF .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact 


For example , the output tree using the translation system for the expression $ C_{-\frac{17}{2}}= \tilde {\infty} $ is depicted in Figure \REF .
For example , the output tree using translation system for the expression $ C_{-\frac{17}{2}}= \tilde {\infty} $ is depict in Figure \REF .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#10#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#11#11,12#para -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#stem -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact 


Compared with the reference tree in Figure \REF , we need to substitute X nodes , insert Y nodes , and delete Z nodes , so that $ TED( A , B ) = x $ , while the maximum number of nodes of the two trees is y .
Compare to the reference tree in Figure \REF , we need to substituting X node , inserting Y node , and deleting Z node , so that $ TED( A , B ) = x $ . While the maximum number of node of two trees is y .
-1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#stem -1#13#13#exact -1#14#14#stem -1#15#15#exact -1#16#16#stem -1#17#17#exact -1#18#18#stem -1#19#19#exact -1#20#20#exact -1#21#21#stem -1#22#22#exact -1#23#23#stem -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#37#37#lc -1#38#38#exact -1#39#39#exact -1#40#40#exact -1#41#41#exact -1#42#42#stem -1#43#43#exact -1#44#44,45#para -1#45#46#exact -1#46#47#exact -1#47#48#exact -1#48#49#exact 


Therefore , $ TEDR( A \rightarrow B ) = \frac{x}{y} = z $ .
Therefore , $ TEDR( A \rightarrow B ) = \frac{x}{y} = z $ .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact 


It appeared that SnuggleTeX was not applicable to the data from the Wolfram Function site since it uses ASCII MathML but the site does not .
For the data in Wolfram Function site , it appeared that SnuggleTeX is not applicable to this data since SnuggleTeX use ASCII MathML while the Wolfram Functions site does not .
-1#8#0#lc -1#9#1#exact -1#10#2#exact -1#11#3#exact -1#12,13#4,5#para -1#14#6#exact -1#15#7#exact -1#1#8#exact -1#2#9#exact -1#24#11#exact -1#25#12#exact -1#5#13#exact -1#6#14#exact -1#18#15#exact -1#20#16,17#para -1#21#18#exact -1#22#19#exact -1#27#21,22#para -1#28#23#exact -1#29#24#exact -1#30#25#exact 


Therefore , we could not do a comparison on this data .
Therefore we could not do the side-by-side comparison on this data .
-1#0#0#exact -1#1#2#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact 


Our experimental results show that our approach gives reasonable results , that is , a 20 percent TEDR with large training data .
Our experimental results show that our approach can archive reasonable results , that is 20 percent TEDR with large training data .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#14,15#para -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact 


For small data ( less than 3000 training samples ) , the results vary from 50 to 75 percent TEDR .
For small data which has less than 3000 training samples , the results vary from 50 to 75 percent TEDR .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#5#4#exact -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#15,16,17#14,15,16,17#para -1#18#18#exact -1#19#19#exact -1#20#20#exact 


For ACL-ARC data , the experimental results show that our system significantly outperforms SnuggleTeX in terms of the Tree Edit Distance Rate .
For ACL-ARC data , the experimental results from our side-by-side comparison show that our system significantly outperforms SnuggleTeX in terms of Tree Edit Distance Rate .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#11#7#exact -1#12#8#exact -1#13#9#exact -1#14#10#exact -1#15#11#exact -1#16#12#exact -1#17#13#exact -1#18,19,20#14,15,16,17#para -1#21#18#exact -1#22#19#exact -1#23#20#exact -1#24#21#exact -1#25#22#exact 


Our system had a 24 percent lower TEDR in comparison with SnuggleTeX .
Our system archived 24 percent TEDR less than the output using SnuggleTeX .
-1#0#0#exact -1#1#1#exact -1#3#4#exact -1#4#5#exact -1#6#6#para -1#5#7#exact -1#7#9,10#para -1#11#11#exact -1#12#12#exact 


To investigate the correlation between the TEDR score and training set size , we set up an experiment using mathematical expressions in the Elementary Functions category .
To find out the correlation between TEDR score and training set size , we set up an experiment using mathematical expressions in Elementary Functions category .
-1#0#0#exact -1#3#2#exact -1#4#3#exact -1#5#4#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22,23#para -1#23#24#exact -1#24#25#exact -1#25#26#exact 


We started with one fifth of the data and increased the data by one fifth in each run .
We started with one fifth of the data , and then increase data one fifth each run .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#9#8#exact -1#11#9#stem -1#12#10,11#para -1#13#13#exact -1#14#14#exact -1#15#15,16#para -1#16#17#exact -1#17#18#exact 


Our experimental results conformed with the theoretical analysis that the more training data we have , the better the results are .
Our experimental results conform with the theoretical analysis that the more training data we have , the better the results are .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#stem -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact 


Table \REF and Table \REF show the TEDR of our method on the Wolfram Functions Site data and in comparison with SnuggleTeX on ACL ARC data , respectively .
Table \REF and Table \REF show the TEDR of our proposed method on the Wolfram Functions Site data and in comparison with SnuggleTeX on ACL ARC data , respectively .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#19,20,21#17,18,19,20#para -1#22#21#exact -1#23#22#exact -1#24#23#exact -1#25#24#exact -1#26#25#exact -1#27#26#exact -1#28#27#exact -1#29#28#exact 


Table \REF and Figure \REF shows the correlation between TEDR score and training set size .
Table \REF and Figure \REF shows the correlation between TEDR score and training set size .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact 


We discussed the problem of semantic enrichment of mathematical expressions .
In this paper , we discussed the problem of the semantic enrichment of mathematical expressions .
-1#4#0#lc -1#5#1#exact -1#6#2#exact -1#7#3#exact -1#8#4#exact -1#10#5#exact -1#11#6#exact -1#12#7#exact -1#13#8#exact -1#14#9#exact -1#15#10#exact 


Our experimental results show that our approach based on the statistical machine translation method for translating a Presentation MathML expressions to Content MathML expressions is a significant improvement over prior systems .
Our experimental results show that our approach based on the statistical machine translation method for translating a Presentation MathML expression to a Content MathML expression has the significant improvement over a prior system .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6,7,8,9#6,7#para -1#26#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#stem -1#20#20#exact -1#22#21#exact -1#23#22#exact -1#24#23#stem -1#25#24#para -1#21#25#exact -1#27#26#exact -1#28#27#exact -1#29#28#exact -1#31#29#exact -1#32#30#stem -1#33#31#exact 


As we mentioned before , mathematical notations are context-dependent .
As we mentioned before , mathematical notations are context-dependent .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact 


That means we need to consider not only surrounding expressions but also the document that contains the notations in order to generate the correct semantic output .
That means we need to consider not only surrounding expressions but also the document that contains the notations in order to generate the correct semantic output .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact 


In the scope of this paper , we only considered the first sort of context information .
In the scope of this paper , we only consider the first context information .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#stem -1#10#10#exact -1#11#11#exact -1#12#13,14#para -1#13#15#exact -1#14#16#exact 


Since this is a first attempt to translate from Presentation to Content MathML using a machine learning method , there is room for further improvement .
Since this is a first attempt to translate Presentation to Content MathML using a machine learning method , there is room for further improvement .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact 


Possible improvements are
Possible improvements are
-1#0#0#exact -1#1#1#exact -1#2#2#exact 


- Increasing the training data so the system can cover more mathematical notations
- Increasing the training data so the system can cover more mathematical notations
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact 


- Expanding the work by incorporating the surrounding information of mathematical expressions , for example , definitions or other mathematical expressions .
- Expanding the work by incorporating the surrounding information of mathematical expressions , for example definitions or other mathematical expressions .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact 


Our approach combining automatic extraction of fragment rules and translation rules has shown promising results .
By combining the automatic extraction of fragment rules and translation rules , our approach has shown promising results .
-1#12#0#lc -1#13#1#exact -1#1#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#14#11#exact -1#15#12#exact -1#16#13#exact -1#17#14#exact -1#18#15#exact 


The experimental results confirm that it would be helpful for automatic understanding of mathematical expressions .
The experimental results confirm that this approach is helpful to the understanding of mathematical expressions .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#7#6,7#para -1#8,9#8,9#para -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact 


However , this is only a first step ; many important issues remain for future studies .
However , this is only a first step ; many important issues remain for future studies .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact 


Currently , our system deals with a limited range of mathematical notations .
Currently , our system deals only with a sub-part of mathematical notations .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#6#5#exact -1#7#6#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact 


In the future , we should consider expanding it to cover all mathematical notations .
In future work , we should also consider expanding it to cover all mathematical notations .
-1#0#0#exact -1#1#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact 


381
Instead of training a specific classifier for each new query , we only trained one generic classifier and used it for ranking new queries .



This helped make the ranking application more scalable .
This helps to make the ranking application more scalable .
-1#0#0#exact -1#1#1#stem -1#3#2#exact -1#4#3#exact -1#5#4#exact -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact 


We propose a simple unsupervised method to train the generic classifier to obtain a large number of labeled faces from video archives .
To train the generic classifier , We propose a simple unsupervised method to obtain a large number of labeled faces from video archives .
-1#6#0#exact -1#7#1#exact -1#8#2#exact -1#9#3#exact -1#10#4#exact -1#11#5#exact -1#12#6#exact -1#1#7#exact -1#2#8#exact -1#3#9#exact -1#4#10#exact -1#0#11#lc -1#13#12#exact -1#15,16,17#13,14,15,16#para -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact -1#23#22#exact 


It uses temporal information to group faces belonging to one person in one shot into one track .
It uses temporal information to group faces belonging to one person in one shot into one track .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact 


Several heuristics are employed to guarantee that a subset of face tracks has the correct labels used in the training process .
Several heuristics are employed to guarantee that a subset of face tracks has the correct labels used in the training process .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact 


Experiments revealed that although our method is unsupervised and independent of underlying algorithms in existing search engines , it successfully learned visual consistency between returned faces to boost efficiency of retrieval .
Experiments shown that although our method is unsupervised and independent with underlying algorithms of existing search engines but successfully learns visual consistency among returned faces to boosts retrieval performance .
-1#0#0#exact -1#1,2#1,2#para -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#13#10#exact -1#11#11#exact -1#12#12#exact -1#14#13,14#para -1#15#15#exact -1#16#16#exact -1#18#19#exact -1#19#20#stem -1#20#21#exact -1#21#22#exact -1#22#23#para -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#stem -1#27#29,30#para -1#29#31#exact 


363
All these parameters were found by using a cross-validation test tool provided by LibSVM [31] . / / ?NOTE : I believe that I hyphenated this term in your previous document , but after seeing it used here , I would say that it does not need to be hyphenated



This training procedure yielded three SVM classifiers whose numbers of support vectors are 4 ,725 , 5 ,043 , and 4 ,847 .
This training procedure resulted three SVM classifiers whose the numbers of support vectors are 4 ,725 , 5 ,043 , and 4 ,847 respectively .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact -1#24#22#exact 


The average evaluating speed of a SVM classifier is approximately 610 WPS ( windows per second ) .
The average evaluating speed of a SVM classifier is approximate 610 WPS ( windows per second ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#stem -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact 


We tested our system on the MIT+CMU frontal-face standard test set [5] , which consists of 124 images with 480 frontal faces ( excluding images containing hand-drawn , cartoon , and small faces ) .
We tested our system on the MIT+CMU frontal-face standard test set [5] which consists of 124 images with 480 frontal faces ( excluding images containing hand-drawn , cartoon and small faces ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#26#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#27#28#exact -1#28#30#exact -1#29#31#exact -1#30#32#exact -1#31#33#exact -1#32#34#exact 


The configuration and rejection performance of the classifiers are listed in Tables 1 and 2 .
The configuration and rejection performance of the classifiers are listed in Table 1 and 2 .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#stem -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact 


The first row presents the number of features of each layer and the second row shows the fraction of the remaining patterns after each layer were processed . / / [fraction / percentage?<--Here and after , you use " percentage " in the graph , so you may want to keep the same term here .]
The first row presents the number of features of each layer , and the second row shows the fraction of the remaining patterns after each layer processing .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact -1#23#22#exact -1#24#23#exact -1#25#24#exact -1#26#26#stem -1#27#27#exact -1#11#35#exact 


The last row indicates the fraction of time that each layer consumed . / / [fraction / percentage?]
The last row indicates the fraction of time that each layer consumes .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#stem -1#12#12#exact 


All these statistics were extracted by running the classifiers on the MIT+CMU test set .
All these statistics are extracted from running the classifiers on the MIT+CMU test set .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#syn -1#4#4#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact 


The fraction of the remaining patterns on these two tables indicates that most of the non-face patterns , i.e. , \MATH , were rejected by the first stage , the cascade of 36x36 AdaBoost classifiers .
The fraction of the remaining patterns on these two tables indicates that most of the non-face patterns , i.e. , \MATH , are rejected by the first stage , the cascade of 36x36 AdaBoost classifiers .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22,23#22,23#para -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact 


When the first 24x24 layer classifier was added to the cascade of 36x36 classifiers , this combination rejected 85 .91\% of analyzed patterns compared to \MATH of using only the first layer of the single cascade of 24x24 classifiers .
If the first 24x24 layer classifier is added to the cascade of 36x36 classifiers , this combination rejects 85 .91\% of analyzed patterns compared to \MATH of using only the first layer of the single cascade 24x24 classifiers .
-1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#7#6,7#para -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#stem -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#37#exact -1#37#38#exact -1#38#39#exact 


Furthermore , the rejection of this very large number of patterns was done extremely quickly , only using \MATH of the total processing time . / / [the total / the standard?]
Furthermore , the rejection of this very large number of patterns is done extremely quickly , only using \MATH of processing time .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6,7,8,9#6,7,8#para -1#19#9#exact -1#10#10#exact -1#11#11#syn -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#20#22#exact -1#21#23#exact -1#22#24#exact 


It also shows that most of the processing time used by the AdaBoost+SVM system , \MATH , was used for SVM classifiers .
It also shows that most of the processing time used by the AdaBoost+SVM system , \MATH , is used for SVM classifiers .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17,18#17,18#para -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact 


The detection rate and speed of the classifiers with ten false positives are listed in Table 3 .
Detection rate and speed of classifiers with ten false positives are listed in Table 3 .
-1#0#1#lc -1#1#2#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#7#exact -1#6#8#exact -1#7#9#exact -1#8#10#exact -1#9#11#exact -1#10#12#exact -1#11#13#exact -1#12#14#exact -1#13#15#exact -1#14#16#exact -1#15#17#exact 


It is clear that our multi-stage system ran faster than the single cascade of 24x24 AdaBoost classifiers while achieving comparable detection rates .
It is clear that our multi-stage system runs faster than the single cascade of 24x24 AdaBoost classifiers while detection rates are comparable .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#syn -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#21#19#exact -1#18#20#exact -1#19#21#exact -1#22#22#exact 


This performance was possible for three reasons .
This performance is possible because of the three following reasons :
-1#0#0#exact -1#1#1#exact -1#2#2#syn -1#3#3#exact -1#7#4,5#para -1#9#6#exact 


First , the cascade of 36x36 AdaBoost classifiers rejected many of non-face patterns extremely quickly , while slow SVM classifiers only processed a very small number of the remaining patterns .
First , the cascade of 36x36 AdaBoost classifiers rejects a lot of non-face patterns extremely fast while slow SVM classifiers only process a very small number of the remaining patterns .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#stem -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#para -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#stem -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact 


Second , many images in the MIT+CMU test set contain large portion of background , which [9] mentioned has a ratio of non-face to face patterns of about 50 ,000 to 1 .
Second , many images in the MIT+CMU test set contain large portion of background which was mentioned in [9] which said the ratio of non-face to face patterns is about 50 ,000 to 1 .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#15#exact -1#18#16#exact -1#16#17#exact -1#28#18,19#para -1#22#20#exact -1#23#21#exact -1#24#22#exact -1#25#23#exact -1#26#24#exact -1#27#25#exact -1#29#26,27#para -1#30#28#exact -1#31#29#exact -1#32#30#exact -1#33#31#exact -1#34#32#exact 


Experimental results showed that the AdaBoost+SVM system ran faster than that of the original AdaBoost on \MATH of the total number of images in this test set .
Experimental results showed that the AdaBoost+SVM system runs faster than that of the original AdaBoost on \MATH of total number of images in this test set .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#syn -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17,18#17,18,19,20#para -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact 


Third , at a small number of false positives , some true face candidate regions rejected by 36x36 classifiers did not severely affect the final performance because they might also be rejected by 24x24 classifiers in later layers .
Third , at a small number of false positives , some true face candidate regions rejected by 36x36 classifiers do not affect so much in final performance because it might also be rejected by 24x24 classifiers in later layers .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19,20#19,20#para -1#21#22#exact -1#25#23,24#para -1#26#25#exact -1#27#26#exact -1#29#27,28#para -1#30#29#exact -1#31#30#exact -1#32#31#exact -1#33#32#exact -1#34#33#exact -1#35#34#exact -1#36#35#exact -1#37#36#exact -1#38#37#exact -1#39#38#exact 


Some detection results are given in Figure 17 .
Some detection results are given in Figure 17 .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact 


We have developed a method to build a fast and robust face detection system based on a multi-stage approach .
We have developed a method to build a fast and robust face detection system based on a multi-stage approach .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact 


The cascaded structure of AdaBoost-based classifiers in the two first stages allows the system to best adapt to various complexities of input patterns , while nonlinear SVM classifiers at the final stage are robust enough to achieve good results .
The cascaded structure of AdaBoost-based classifiers in two first stages allows to best adapt to various complexities of input patterns ,while non linear SVM classifiers at the final stage are robust enough to achieve good results .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#26#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#14#exact -1#12#15#exact -1#13#16#exact -1#14#17#exact -1#15#18#exact -1#16#19#exact -1#17#20#exact -1#18#21#exact -1#19#22#exact -1#23#26#exact -1#24#27#exact -1#25#28#exact -1#27#29,30#para -1#28#31#exact -1#29#32#exact -1#30#33#exact -1#31#34#exact -1#32#35#exact -1#33#36#exact -1#34#37#exact -1#35#38#exact -1#36#39#exact 


Extensive experiments demonstrated that a significant computation time is devoted to potential face regions because almost all non-face patterns are rejected quickly by the two first stages , and only a very small number of face-like patterns are processed by the slow SVM classifiers . / / [are / need to be?]
Extensive experiments demonstrated that a significant computation time is devoted to potential face regions because almost all non-face patterns are rejected quickly by the two first stages , and only a very small number of face-like patterns is processed by the slow SVM classifiers .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact -1#37#37#syn -1#38#38#exact -1#39#39#exact -1#40#40#exact -1#41#41#exact -1#42#42#exact -1#43#43#exact -1#44#44#exact 


Discriminant Haar wavelet features selected from AdaBoost are used for all stage classifiers to take advantage of their efficient representation and fast evaluation .
Discriminant Haar wavelet features selected from AdaBoost are used for all stage classifier to take advantages from their efficient representation and fast evaluation .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#stem -1#13,14#13,14,15,16#para -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact 


151
At each pixel position , 40 Gabor features are computed by convolving the input image with the real part of Gabor filters .



As a result , one \MATH training sample hasthere are \MATH Gabor features for one 24x24 training sample .
As a result , \MATH there are \MATH Gabor features for one 24x24 training sample .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#11#4#exact -1#4#5#exact -1#13#6#exact -1#14#7#exact -1#6#9#exact -1#7#10#exact -1#8#11#exact -1#9#12#exact -1#10#13#exact -1#12#15#exact -1#15#18#exact 


To prove the effectiveness of the proposed feature selection method ( CMI-Multi ) , we compared it with two other feature selection methods ?that are forward feature selection ( FFS ) [16] and a CMI-based methods using binary features ( CMI-Binary ) [8 , 7] ? on the data set and feature sets mentioned described above .
In order to show effectiveness of the proposed feature selection method ( CMI-Multi ) , we compared it with two other feature selection methods that are forward feature selection ( FFS ) [16] and CMI-basedmethod using binary features ( CMIBinary ) [8 , 7] on the data set and feature setsmentioned above .
-1#2#0#lc -1#3#1#syn -1#4,5#2,3,4#para -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact -1#23#22#exact -1#25#24#exact -1#26#25#exact -1#27#26#exact -1#28#27#exact -1#29#28#exact -1#30#29#exact -1#31#30#exact -1#32#31#exact -1#33#32#exact -1#35#36#exact -1#36#37#exact -1#37#38#exact -1#38#39#exact -1#40#41#exact -1#41#42#exact -1#42#43#exact -1#43#44#exact -1#44#46#exact -1#45#47#exact -1#46#48#exact -1#47#49#exact -1#48#50#exact -1#49#51#exact -1#51#55#exact -1#52#56#exact 


All classifiers were trained using AdaBoost similar to [1] .
All classifiers were trained using AdaBoost similar to [1] .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact 


We chose the forward feature selection proposed by Wu et. al. [16] because it has very impressive results , when not only reducing significantly the training time of the AdaBoost-based face detection systems [1] by ( about 100 times , ) but also maintaining comparable performance .
We chose the forward feature selection proposed by Wu et. al. [16] because it has very impressive results when not only reducing significantly the training time of AdaBoost-based face detection system [1] ( about 100 times ) but also maintaining comparable performance .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#29#exact -1#28#30#exact -1#29#31#exact -1#30#32#stem -1#31#33#exact -1#32#35#exact -1#33#36#exact -1#34#37#exact -1#35#38#exact -1#36#40#exact -1#37#41#exact -1#38#42#exact -1#39#43#exact -1#40#44#exact -1#41#45#exact -1#42#46#exact 


Figure 2 shows performance of classifiers trained by Haar feature subsets selected by three feature selection methods .
Figure 2 shows performance of classifiers trained by Haar feature subsets selected by three feature selection methods .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact 


The figureIt indicates that , the proposed method , CMI-Multi , outperforms the others while the performances of FFS and CMI-Binary have were comparable performanceto one another .
It indicates that , the proposed method CMI-Multi outperforms the others while FFS and CMI-Binary have comparable performance .
-1#9#0#lc -1#1#2#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#9#exact -1#8#11#exact -1#10#12,13#para -1#11#14#exact -1#12#18#exact -1#13#19#exact -1#14#20#exact -1#15#21#exact -1#16#23#exact -1#18#27#exact 


The A similar result is was also shown when the three feature selection methods were tested on Gabor wavelet features .
The similar result is also shown when tested on Gabor wavelet features .
-1#0#0#exact -1#1#2#exact -1#2#3#exact -1#3#4#exact -1#4#6#exact -1#5#7#exact -1#6#8#exact -1#7,8#14#para -1#9#17#exact -1#10#18#exact -1#11#19#exact -1#12#20#exact 


In this case , CMI-based feature selection methods obviously clearly outperformed FFS , and CMI-Multi is was confirmed to be more efficient than CMI-Binary .
In this case , CMI-based feature selection methods obviously outperform FFS and CMI-Multi is confirmed to be more efficient than CMI-Binary .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#10#stem -1#10#11#exact -1#11#13#exact -1#12#14#exact -1#13#15#exact -1#14#16,17#para -1#15#18#exact -1#16#19#exact -1#17#20#exact -1#18#21#exact -1#19#22#exact -1#20#23#exact -1#21#24#exact 


Because our proposed method uses same principle as FFS , which only trains weak classifiers once , it is extremely fast compared with AdaBoost [1] .
Because our proposed method uses same principle as FFS which only trains weak classifiers once , it is extremely fast compared with AdaBoost [1] .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#15#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact 


We built two cascades of AdaBoost classifiers that use CMI-Multi and AdaBoost [1] as feature selection methods .
We built two cascade of AdaBoost classifiers that use CMI-Multi and AdaBoost [1] as feature selection methods .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#stem -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact 


Testing on the standard benchmark MIT+CMU test set , they hadve comparable performance .
Testing on the standard benchmark MIT+CMU test set , they have comparable performance .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact 


However , CMI-Multi wasis trained faster than was AdaBoost by approximately 70 times .
However , CMI-Multi is trained faster than AdaBoost approximately 70 times .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#3#7#syn -1#7#8#exact -1#8#9,10#para -1#9#11#exact -1#10#12#exact -1#11#13#exact 


We have presented a fast feature selection method using conditional mutual information to handle huge feature sets .
We have presented a fast feature selection method using conditional mutual information to handle huge feature sets .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact 


The estimation of mutual information is simplified by using an MDLP- based discretization method .
The estimation of mutual information is simplified by using MDLP based discretization method .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact 


Integrated into AdaBoost-based object detection systems , our proposed methodit can not only reduces the training time significantly , but also achieves high classification performance .
Integrated into AdaBoost-based object detection systems , it can not only reduce the training time significantly but also achieve high classification performance .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#8#10#exact -1#9#11#exact -1#10#12#exact -1#11,12#13,14#para -1#13#15#exact -1#14#16#exact -1#15#17#exact -1#16#19#exact -1#17#20#exact -1#18#21#stem -1#19#22#exact -1#20#23#exact -1#21#24#exact -1#22#25#exact 


Experiments on two popular feature sets have demonstrated the effectiveness of the proposed method . //[Please note : I am not sure which of the following you mean .--> one composed of such as Haar wavelets and the other composed of Gabor wavelets / ? Haar wavelets and Gabor wavelets ?]
Experiments on two popular feature sets such as Haar wavelets and Gabor wavelets have demonstrated the effectiveness of the proposed method .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#13#6#exact -1#14#7#exact -1#15,16,17,18#8,9,10#para -1#19#12#exact -1#20#13#exact -1#21#14#exact -1#6#32#exact -1#7#33#exact -1#8#34#exact -1#9#35#exact -1#10#36#exact -1#11#41#exact -1#12#42#exact 


250
Experiments have shown promising results , especially in the building of a robust face detector .



Therefore , it is generalization is difficult for new test sets .
Therefore , it is difficult to generalize for new test sets .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#6#4#stem -1#3#5#exact -1#4#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact 


We have proposed a unified and general framework for shot boundary detection that uses a text segmentation based approach .
Different from these approaches , in this paper , we have proposed a unified and general framework for shot boundary detection using a text segmentation based approach .
-1#9#0#lc -1#10#1#exact -1#11#2#exact -1#12#3#exact -1#13#4#exact -1#14#5#exact -1#15#6#exact -1#16#7#exact -1#17#8#exact -1#18#9#exact -1#19#10#exact -1#20#11#exact -1#21,22#13,14#para -1#23#15#exact -1#24#16#exact -1#25#17#exact -1#26#18#exact -1#27#19#exact 


Firstly , we label the frames with one of the six labels defined for different types of frames : NORM -FRM , PRE -CUT , POST -CUT , PRE -GRAD , IN -GRAD , and POST -GRAD .
Firstly , we label frames by one of six labels defined for different types of frames : NORM -FRM , PRE -CUT , POST -CUT , PRE -GRAD , IN -GRAD and POST -GRAD .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#5#exact -1#6#7#exact -1#7#8#exact -1#8#9,10#para -1#9#11#exact -1#10#12#exact -1#11#13#exact -1#12#14#exact -1#13#15#exact -1#14#16#exact -1#15#17#exact -1#16#18#exact -1#17#19#exact -1#18#20#exact -1#19#21#exact -1#20#22#exact -1#21#23#exact -1#22#24#exact -1#23#25#exact -1#24#26#exact -1#25#27#exact -1#26#28#exact -1#27#29#exact -1#28#30#exact -1#29#31#exact -1#30#32#exact -1#31#34#exact -1#32#35#exact -1#33#36#exact -1#34#37#exact 


Then we extract the shot boundaries and types from these labeled frames .
Then we extract shot boundaries and types from these labeled frames .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact 


In order to label frames , we proposed a new feature type to model the difference and motion in color and the edges between the frames and used it in the classification with SVM classifiers .
In order to label frames , we proposed a new feature type to model the difference and motion in color and edge between frames and used it in classification with SVM classifiers .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#22#stem -1#22#23#exact -1#23#25#exact -1#24#26#exact -1#25#27#exact -1#26#28#exact -1#27#29#exact -1#28#30,31#para -1#29#32#exact -1#30#33#exact -1#31#34#exact -1#32#35#exact 


The experiments we conducted on various videos from TRECVID 2003 have shown that our approach is effective .
Experiments on various videos of TRECVID 2003 have shown that our approach is effective .
-1#0#1#lc -1#1#4#exact -1#2#5#exact -1#3,4#6,7#para -1#5#8#exact -1#6#9#exact -1#7#10#exact -1#8#11#exact -1#9#12#exact -1#10#13#exact -1#11#14#exact -1#12#15#exact -1#13#16#exact -1#14#17#exact 


In Figure \REF , we show the performance of five single classifiers and that of five ensemble classifiers .
In Figure \REF , we show the performance of five single classifiers and that of five ensemble classifiers .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact 


The ensemble classifier \MATH is formed by combining single classifiers from \MATH to \MATH .
The ensemble classifier \MATH is formed by combination of single classifiers from \MATH to \MATH .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#stem -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact 


It clearly indicates that the ensemble classifier is more stable than single weak classifiers . //You use both plural and singular forms of " classifier " here , so it is a bit confusing if you are talking about a single classifier or more than one . I suggest you use the same form throughout if applicable .]
It clearly indicates that the ensemble classifier is more stable that single weak classifiers .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact 


We conducted another experiment to show the effectiveness of our approach in which learned models are used to annotate new faces of other databases .
We conducted another experiment to show the effectiveness of our approach in which learned models can be used to annotate new faces of other databases .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#16,17#15,16#para -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact -1#23#22#exact -1#24#23#exact -1#25#24#exact 


We used each name in the list as a query to obtain the top 500 images from the Google Image Search Engine ( GoogleSE ) .
For each name in the list , we used it as the query to obtain top 500 images from Google Image Search Engine .
-1#7#0#lc -1#8#1#exact -1#1#2#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#10#7#exact -1#12#9#exact -1#13#10#exact -1#14#11#exact -1#11#12#exact -1#15#13#exact -1#16#14#exact -1#17#15#exact -1#18#16#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact -1#23#25#exact 


Next , these images were processed using the steps described in section \REF : extracting faces , detecting eyes , and doing normalization .
Next , these images were processed as the steps described in section \REF : extracting faces , detecting eyes and doing normalization .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact 


We projected these faces to the PCA subspace trained for that name and used the learned model to re-rank faces .
We projected these faces to the PCA subspace trained for that name and used the learned model to re-rank faces .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact 


There were 4 ,103 faces ( including false positives - non-faces detected as faces ) detected from 7 ,500 returned images .
There were 4 ,103 faces ( including false positives - non-faces were detected as faces ) detected from 7 ,500 returned images .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact 


We manually labeled these faces and there were 2 ,342 relevant faces .
We manually labeled these faces and there were 2 ,342 relevant faces .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact 


On average , the accuracy of the GoogleSE is 57 .08\% .
On average , the accuracy of the Google Search Engine ( GoogleSE ) is 57 .08\% .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3,4,5,6#3,4,5#para -1#11#7#exact -1#13#8#exact -1#14#9#exact -1#15#10#exact -1#16#11#exact 


In Table \REF , we compare the performance of the methods .
In Table \REF , we compare the performance of the methods .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6,7,8,9#6,7,8#para -1#10#9,10#para -1#11#11#exact 


The performance of UEL-LDS was obtained by running the best system , which is shown as the peak of the UEL-LDS curve in Figure \REF .
The performance of UEL-LDS was obtained by running the best system , which is shown as the peak of UEL-LDS curve in Figure \REF .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16,17,18#16,17,18,19#para -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact 


The performances of SVM-SUP-05 and SVM-SUP-10 correspond to the supervised systems ( cf . section \REF ) that used \MATH of the data set , respectively .
The performances of SVM-SUP-05 and SVM-SUP-10 correspond to the supervised systems ( cf . section \REF ) that used \MATH of the data set respectively .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#25#exact -1#25#26#exact 


We evaluated the performance by calculating the precision of the top 20 returned faces , which is common for image search engines and recall and precision on all detected faces of the test set .
We evaluated the performance by calculating the precision at top 20 returned faces , which is popular for image search engines ; and recall and precision on all detected faces of the test set .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#30#8#exact -1#31#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#32#30,31,32#para -1#33#33#exact -1#34#34#exact 


UEL-LDS achieved comparable performance to the supervised methods and outperformed the baseline GoogleSE .
UEL-LDS achieved comparable performance to the supervised methods and outperformed the baseline GoogleSE .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact 


The precision of the top 20 of SVM-SUP-05 is poorer than that of UEL-LDS due to the small number of training samples .
The precision at top 20 of SVM-SUP-05 is poorer than that of UEL-LDS is due to small number of training samples .
-1#0#0#exact -1#1#1#exact -1#11#2#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#18#12#exact -1#12#13#exact -1#14#14#exact -1#15#15#exact -1#16#16,17#para -1#17#18#exact -1#19#19,20#para -1#20#21#exact -1#21#22#exact 


Figure \REF shows top 20 faces ranked using these two methods .
Figure \REF shows top 20 faces ranked by these two methods .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact 


Our approach works fairly well for well known people , where the main assumption that text-based search engines return a large fraction of relevant images is satisfied .
Our approach works fairly well for well known people , where the main assumption that text-based search engines return a large fraction of relevant images is satisfied .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact 


Figure \REF shows an example where this assumption is broken .
Figure \REF shows an example where this assumption is broken .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact 


Consequently , as shown in Figure \REF , the model learned by this set performed poorly in recognizing new faces returned by GoogleSE .
Consequently , as shown in Figure \REF , the model learned by this set obtained poor performance in recognizing new faces returned by GoogleSE .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#16#14#stem -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact -1#23#22#exact -1#24#23#exact 


Our approach solely relies on the above assumption ; therefore , it is not affected by the ranking of text-based search engines .
Our approach solely relies on the above assumption , therefore it is not affected by the ranking of text-based search engines .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#9#9#exact -1#8#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact 


The iteration of bagging SVM classifiers does not guarantee a significant improvement in performance .
The iteration of bagging SVM classifiers does not guarantee a significant improvement in performance .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact 


The aim of our future work is to study how to improve the quality of the training sets used in this iteration .
Our future work is to study how to improve the quality of the training sets used in this iteration .
-1#12#0#lc -1#13#1#syn -1#11#2#exact -1#0#3#lc -1#1#4#exact -1#2#5#exact -1#3#6#exact -1#4#7#exact -1#5#8#exact -1#6#9#exact -1#8,9,10#10,11,12,13#para -1#14#17#exact -1#15#18#exact -1#16#19#exact -1#17#20#exact -1#18#21#exact -1#19#22#exact 


We presented a method for ranking faces retrieved using text-based correlation methods in searches for a specific person .
We presented a method for ranking faces retrieved using text-based correlation methods in searches for a specific person .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact 


This method learns the visual consistency among faces in a two-stage process .
This method learns the visual consistency among the faces in a two-stage process .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact 


In the first stage , a relative density score is used to form a ranked list in which faces ranked at the top or bottom of the list are likely to be relevant or irrelevant faces , respectively .
In the first stage , a relative density score is used to form a ranked list in which faces ranked at the top or bottom of the list are likely relevant or irrelevant faces .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#32#exact -1#31#33#exact -1#32#34#exact -1#33#35#exact -1#34#38#exact 


In the second stage , a bagging framework is used to combine weak classifiers trained on subsets labeled from the ranked list into a strong classifier .
In the second stage , a bagging framework is used to combine weak classifiers trained on subsets labeled from the ranked list into a strong classifier .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact 


This strong classifier is then applied to the original set to re-rank faces on the basis of the output probabilistic scores .
This strong classifier is then applied to the original set to re-rank faces on the basis of the output probabilistic scores .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13,14,15,16#13,14,15,16,17#para -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact 


Experiments on various face sets showed the effectiveness of this method .
Experiments on various face sets showed the effectiveness of this method .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact 


Our approach is beneficial when there are several faces in a returned image , as shown in Figure \REF .
Our approach is beneficial in the case multiple faces residing in the returned image as shown in Figure \REF .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#7#7#para -1#8#8#exact -1#4#9#exact -1#12#11#exact -1#13#12#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact 


Besides the face-based observation model , a head model is also included to represent the information of head rear .
Besides the face-based observation model , a head model is also included to represent the information of head rear .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact 


It is based on the idea that a head can be considered an object of interest instead of a face , because the face is not always present in the tracking process .
It is based on the idea that head can be considered as the object of interest instead of face because face is not always present in the tracking process .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7,8#para -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#12,13#12,13#para -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#19#exact -1#19#21#exact -1#26#22#exact -1#20#23#exact -1#21#24#exact -1#22#25#exact -1#23#26#exact -1#24#27#exact -1#25#28#exact -1#27#30#exact -1#28#31#exact -1#29#32#exact 


An extended particle filter is proposed to fuse these two interrelated information together so as to handle the occlusion due to out-of-plane head rotation ( yaw ) that is more than 90 degrees .
An extended particle filter is proposed to fuse these two interrelated information so as to handle the occlusion due to out-of-plane head rotation ( yaw ) that is more than 90 degrees .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#27,28,29#27,28,29,30#para -1#30#31#exact -1#31#32#exact -1#32#33#exact 


During the tracking procedure , face tracking systems usually use a motion model that describes how the image of the target might change for different possible motions of the face to track .
During the tracking procedure , face tracking systems usually employ a motion model that describes how the image of the target might change for different possible motions of the face to track .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9,10#9,10#para -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16,17,18,19#16,17,18#para -1#28#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#29#28,29#para -1#30#30#exact -1#31#31#exact -1#32#32#exact 


Some examples of simple motion models are as follows .
Examples of simple motion models are as follows .
-1#0#1#lc -1#1#2#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact 


Based on the assumption that a face can be considered a planar object , the corresponding motion model can be a 2D transformation , e.g. affine transformation or homography , of an image of the face , e.g. the initial frame [3 , 6] .
Based on the assumption that face can be considered as a planar object , the corresponding motion model can be a 2D transformation , e.g. affine transformation or homography , of an image of the face , e.g. the initial frame [3 , 6] .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#20#5#exact -1#5#6#exact -1#6#7#exact -1#7,8,9,10#8,9,10#para -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31,32#31,32,33,34#para -1#35#35#exact -1#36#36#exact -1#37#37#exact -1#38#38#exact -1#39#39#exact -1#40#40#exact -1#41#41#exact -1#42#42#exact -1#43#43#exact -1#44#44#exact 


Some researchers view a face as a rigid 3D object , thus the motion model defines its aspect depending on its 3D position and orientation [10] .
Some researchers assume the face as a rigid 3D object , thus the motion model defines its aspect depending on its 3D position and orientation [10] .
-1#0#0#exact -1#1#1#exact -1#6#3#exact -1#4#4#exact -1#5#5#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact 


However , a face is actually both 3D and deformable .
However , face is actually both 3D and deformable .
-1#0#0#exact -1#1#1#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact 


Some systems try to model faces in this sense , and the image of deformed face can be covered with a mesh , i.e. a sophisticated geometry and texture face model [2 , 7] .
Some system try to model face in this sense , and the image of deformable faces can be covered with a mesh , i.e. a sophisticated geometry and texture face model [2 , 7] .
-1#0#0#exact -1#1#1#stem -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#15#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10,11,12#10,11,12,13#para -1#14#14#stem -1#5#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact 


The motion of the face is defined by the position of the nodes of the mesh .
The motion of the face is defined by the position of the nodes of the mesh .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8,9,10,11#8,9,10#para -1#14#11#exact -1#12#12#exact -1#13#13#exact -1#15#15#exact -1#16#16#exact 


Generally if the quality of the video is high , a more sophisticated motion model is used , and then the face tracker generates a more accurate result .
Generally if the quality of the video is high , more sophisticated motion model is used , more accurate result the face tracker generates .
-1#0#0#exact -1#1#1#exact -1#2,3,4,5#2,3,4#para -1#20#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#21#20,21#para -1#22#22#exact -1#23#23#exact -1#17,18#24,25,26#para -1#19#27#exact -1#24#28#exact 


For instance , a sophisticated geometry and texture model might suffer from false face detections and a level of drifting [less than / that is worse than ?] a simple 2D transformation model .
For instance , a sophisticated geometry and texture model might suffer from false face detections and drifting less than a simple 2D transformation model .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#19#16#exact -1#16#19#exact -1#18#21#exact -1#20#28,29#para -1#21#30#exact -1#22#31#exact -1#23#32#exact -1#24#33#exact 


However , it must be noted that most 3D-based and mesh-based face trackers require a relatively clear appearance , high resolution , and a limited pose variation of the face , e.g. out-of-plane head rotations ( roll and yaw ) that are far less than 90 degrees .
But note that most 3D-based and mesh-based face trackers require relatively clear appearance , high resolution , and limited pose variation of the face , e.g. out-of-plane head rotations ( roll and yaw ) that are far less than 90 degrees .
-1#13#1#exact -1#1#4,5#para -1#2#6#exact -1#3#7#exact -1#4#8#exact -1#5#9#exact -1#6#10#exact -1#7#11#exact -1#8#12#exact -1#9#13#exact -1#10#14,15#para -1#11#16#exact -1#12#17#exact -1#24#18#exact -1#14#19#exact -1#15#20#exact -1#16#21#exact -1#17#22#exact -1#18#23,24#para -1#19#25#exact -1#20#26#exact -1#21#27#exact -1#22#28#exact -1#23#29#exact -1#25#31#exact -1#26#32#exact -1#27#33#exact -1#28#34#exact -1#29#35#exact -1#30#36#exact -1#31#37#exact -1#32#38#exact -1#33#39#exact -1#34#40#exact -1#35#41#exact -1#36#42#exact -1#37#43#exact -1#38#44#exact -1#39#45#exact -1#40#46#exact -1#41#47#exact 


Both of these requirements are always unavailable in the case of broadcast video .
Both of these requirements are always unavailable in the case of broadcast video .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact 


Therefore , most 3D-based and mesh-based face trackers are only tested by using non-broadcast video , e.g. webcam video [2 , 7 , 10] .
Therefore , most 3D-based and mesh-based face trackers are only tested by using non-broadcast video , e.g. webcam video [2 , 7 , 10] .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact 


Finally , the stopping procedure is rarely discussed .
Finally , the stopping procedure is rarely discussed .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact 


This constitutes a major deficiency for the face tracking algorithms that are generally not able to stop a face track in case of tracking errors , i.e. drifting .
This constitutes a major deficiency of face tracking algorithms that are generally not able to stop a face track in case of tracking error , i.e. drifting .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#6#6,7#para -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#stem -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact 


Arnaud et al. [3] proposed an approach that uses a general object tracker for face tracking and a stopping criterion based on the addition of an eye tracker to alleviate drifting .
Arnaud et al [3] proposed an approach that uses a general object tracker for face tracking and a stopping criterion based on the addition of an eye tracker to alleviate drifting .
-1#0#0#exact -1#1#1#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21,22,23,24#21,22,23#para -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact 


The two positions of the tracked eyes are compared with the tracked face position .
Two positions of tracked eyes are compared with tracked face position .
-1#0#1#lc -1#1#2#exact -1#2#3#exact -1#3#5#exact -1#4#6#exact -1#5#7#exact -1#6#8#exact -1#7#9#exact -1#8#11#exact -1#9#12#exact -1#10#13#exact -1#11#14#exact 


If neither of the eyes is in the face region , it will be determined as drifting and the tracking process will be stopped .
If none of the two eyes are in the face region , it will be determined as drifting and the tracking process will be stopped .
-1#0#0#exact -1#1,2#1,2#para -1#3#3#exact -1#5#4#exact -1#12,13,14#5#para -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#22,23#11,12#para -1#15#13,14#para -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#6#21,22#para -1#24#23#exact -1#25#24#exact 


In addition , most mesh-based and top-down trackers are assumed to be able to avoid drifting .
Besides , most mesh-based trackers and top-down trackers are considered to be able to avoid drifting .
-1#0#0,1#para -1#1#2#exact -1#2#3#exact -1#3#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#11,12,13#10,11,12,13#para -1#14#14#exact -1#15#15#exact -1#16#16#exact 


Face tracking has attracted much attention from researchers in communities including multimedia content analysis , computer vision , etc. because of its wide applications .
Face tracking has attracted much attention from researchers in communities including multimedia content analysis , computer vision , etc. because of its wide application .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#stem -1#24#24#exact 


However , while most of the attempts have been on the face tracking for high-quality videos by computer vision researchers , only a limited number of face trackers are designed for broadcast video .
However , while most attempts have been made on face tracking for videos with high quality by computer vision researchers , only a limited number of face trackers are designed for broadcast video .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#25#4#exact -1#4#5,6#para -1#5#7#exact -1#6#8#exact -1#8#9#exact -1#9#10,11#para -1#10#12#exact -1#11#13#exact -1#12#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21,22,23,24#21,22,23,24,25#para -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact 


This is because the current ability of face tracking still depends on a relatively clear appearance , high resolution , and limited pose variation of the face , which are unavailable in broadcast video .
This is because the current ability of face tracking still depends on relatively clear appearance , high resolution , and limited pose variation of the face , which are unavailable in broadcast video .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12,13#para -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact -1#28#29#exact -1#29#30#exact -1#30#31#exact -1#31#32#exact -1#32#33#exact -1#33#34#exact 


On the other hand , currently proposed face trackers are still evaluated by using different types of videos and different criteria .
On the other hand , currently proposed face trackers are still evaluated by using different types of videos and different criteria .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact 


A general evaluation criterion , in terms of speed , robustness , and accuracy , is needed for a performance comparison between the face trackers with different purposes .
A general evaluation criterion , in terms of speed , robustness and accuracy , is needed for performance comparison between face trackers of different purposes .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#13#11#exact -1#11#12#exact -1#12#13#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18,19#para -1#18#20#exact -1#19#21#exact -1#20#22,23#para -1#21#24#exact -1#22,23#25,26#para -1#24#27#exact -1#25#28#exact 


Experiments on a large number of persons with thousands of retrieved images showed the effectiveness of the proposed method .
Experiments on a large number of persons with thousands of retrieved images show effectiveness of the proposed method .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#stem -1#13,14,15#13,14,15,16#para -1#16#17#exact -1#17#18#exact -1#18#19#exact 


Syntactically annotated corpora have become important resources for natural language processing , due in part to the success of corpus-based methods .
The success of corpus-based methods has made syntactically annotated corpora important resources for natural language processing .
-1#7#0#lc -1#8#1#exact -1#9#2#exact -1#5#3,4#para -1#10#5#exact -1#11#6#exact -1#12#7#exact -1#13#8#exact -1#14#9#exact -1#15#10#exact -1#0,1,2#15,16,17,18#para -1#3#19#exact -1#4#20#exact -1#16#21#exact 


Since words are often considered as primitive units of language structures , the annotation of word segmentation forms the basis of these corpora .
Since words are often considered as the primitive units of language structures , the annotation of word segmentation forms the basis of these corpora .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19,20#18,19,20,21#para -1#23#22#exact -1#24#23#exact 


This is also a concern for the Vietnamese Treebank ( VTB ) , which is the first and only publicly available syntactically annotated corpus thus far for the Vietnamese language .
This is also a concern of Vietnamese Treebank ( VTB ) , the first and the only publicly available syntactically annotated corpus so far for the Vietnamese language .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#24#5#exact -1#25#6#exact -1#26#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#15#exact -1#13#16#exact -1#14#17#exact -1#16#18#exact -1#17#19#exact -1#18#20#exact -1#19#21#exact -1#20#22#exact -1#21#23#exact -1#22,23#24,25#para -1#15#27#exact -1#6#28#exact -1#27#29#exact -1#28#30#exact 


Although word segmentation is straight-forward for space-delimited languages like English , this is not the case for languages like Vietnamese for which a standard criterion for word segmentation does not exist .
Although word segmentation is straight-forward for space-delimited languages like English , this is not true for languages like Vietnamese of which no standard criterion for word segmentation exists .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11,12,13,14#11,12,13,14,15#para -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19,20#20,21#para -1#22#22,23#para -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#30#stem -1#28#31#exact 


This work explores the challenges of Vietnamese word segmentation through the detection and correction of inconsistency for VTB .
This work explores the challenges of Vietnamese word segmentation through the detection and correction of inconsistency for VTB .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact 


Then , by combining and splitting the inconsistent annotations that were detected , we are able to observe the influence of different word segmentation criteria on automatic word segmentation , and the applications of word segmentation , including text classification and English-Vietnamese statistical machine translation .
Then , by combining and splitting the inconsistent annotations detected , we could observe the influence of different word segmentation criteria on automatic word segmentation , and the applications of word segmentation , including text classification and English-Vietnamese statistical machine translation .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#11#exact -1#10#12#exact -1#11#13#exact -1#12#14,15#para -1#13,14#16,17,18#para -1#15#19#exact -1#16#20#exact -1#17#21#exact -1#18#22#exact -1#19#23#exact -1#20#24#exact -1#21#25#exact -1#22#26#exact -1#23#27#exact -1#24#28#exact -1#25#29#exact -1#26#30#exact -1#27#31#exact -1#28#32#exact -1#29#33#exact -1#30#34#exact -1#31#35#exact -1#32#36#exact -1#33#37#exact -1#34#38#exact -1#35#39#exact -1#36#40#exact -1#37#41#exact -1#38#42#exact -1#39#43#exact -1#40#44#exact -1#41#45#exact 


The analysis and experimental results showed that our methods improved the quality of VTB , which positively affected the performance of its applications .
The analysis and experimental results showed that our methods improved the quality of VTB , which positively affected the performance of its applications .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact 


Treebanks , which are corpora annotated with syntactic structures , have become more and more important for language processing .
Treebanks , corpora annotated with syntatic structures , have become more and more impor-tant for language processing .
-1#0#0#exact -1#1#1#exact -1#8,9#3#para -1#2#4#exact -1#3#5#exact -1#4#6#exact -1#6#8#exact -1#7#9#exact -1#10#12#exact -1#11#13#exact -1#12#14#exact -1#14#16#exact -1#15#17#exact -1#16#18#exact -1#17#19#exact 


In order to strengthen the automatic processing of the Vietnamese language , the Vietnamese Treebank ( VTB ) has been built as a part of the national project , `` Vietnamese language and speech processing ( VLSP ) '' ( Nguyen et al ., 2009b ) .
To strengthen the automatic processing of the Vietnamese language , the Vietnamese treebank ( VTB ) has been built as a part of the national project `` Vietnamese language and speech processing ( VLSP ) '' ( Nguyen et al ., 2009b ) .
-1#0#2#lc -1#1#3#exact -1#2#4#exact -1#3#5#exact -1#4#6#exact -1#5#7#exact -1#6#8#exact -1#7#9#exact -1#8#10#exact -1#9#11#exact -1#10#12#exact -1#11#13#exact -1#12#14#lc -1#13#15#exact -1#14#16#exact -1#15#17#exact -1#16#18#exact -1#17#19#exact -1#18#20#exact -1#19#21#exact -1#21,22,23#22,23,24,25#para -1#24#26#exact -1#25#27#exact -1#26#29#exact -1#27#30#exact -1#28#31#exact -1#29#32#exact -1#30#33#exact -1#31#34#exact -1#32#35#exact -1#33#36#exact -1#34#37#exact -1#35#38#exact -1#36#39#exact -1#37#40#exact -1#38#41#exact -1#39#42#exact -1#40#43#exact -1#41#44#exact -1#42#45#exact -1#43#46#exact 


However , in our preliminary experiment with VTB , when we trained the Berkeley parser ( Petrov et al ., 2006 ) and evaluated it by using the corpus , the parser achieved only 65 .8% in F-score .
However , in our preliminary experiment with VTB , when we trained the Berkeley parser ( Petrov et al ., 2006 ) and evaluated it using the corpus , the parser achieved only 65 .8% in F-score .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25,26#para -1#26#27#exact -1#27#28#exact -1#28#29#exact -1#29#30#exact -1#30#31#exact -1#31#32#exact -1#32#33#exact -1#33#34#exact -1#34#35#exact -1#35#36#exact -1#36#37#exact -1#37#38#exact 


This score is far lower than the state-of-the-art performance reported for the Berkeley Parser on the English Penn Treebank , which reported 90 .3% in F-score ( Petrov et al ., 2006 ) .
This performance is far lower than the state-of-the-art performance reported for Berkeley Parser on English Penn Treebank , 90 .3% in F-score ( Petrov et al ., 2006 ) .
-1#0#0#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15,16#para -1#15#17#exact -1#16#18#exact -1#17#19#exact -1#18#22#exact -1#19#23#exact -1#20#24#exact -1#21#25#exact -1#22#26#exact -1#23#27#exact -1#24#28#exact -1#25#29#exact -1#26#30#exact -1#27#31#exact -1#28#32#exact -1#29#33#exact 


There are two possible reasons to explain this outcome .
There are two possible reasons for this .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4,5#4,5#para -1#6#7#exact -1#7#9#exact 


One reason for this outcome is the quality of VTB , including the quality of the annotation scheme , the annotation guidelines , and the annotation process .
First , the quality of VTB is not good enough to build a good a parser , including the quality of the annotation scheme , the annotation guidelines , and the annotation process .
-1#6#5#exact -1#2#6#exact -1#3#7#exact -1#4#8#exact -1#5#9#exact -1#16#10#exact -1#17,18,19,20,21#11,12,13,14#para -1#30#15#exact -1#31#16#exact -1#23#17#exact -1#24#18#exact -1#25#19#exact -1#26#20#exact -1#27#21#exact -1#28#22#exact -1#29#23#exact -1#22#25#exact -1#32#26#exact -1#33#27#exact 


The second reason is the difficulty of parsing Vietnamese ; we need to seek new solutions to address this problem .
Second , parsing Vietnamese is a diffcult problem by its own , and we need to seek new solutions to the problem .
-1#0#1#lc -1#4#3#exact -1#20#4#exact -1#21#5,6#para -1#2#7#exact -1#3#8#exact -1#13#10#exact -1#14#11#exact -1#15#12#exact -1#16#13#exact -1#17#14#exact -1#18#15#exact -1#19#16#exact -1#7#19#exact -1#22#20#exact 


VTB is annotated with three layers : word segmentation , POS tagging , and bracketing .
VTB is annotated with three layers : word segmentation , POS tagging , and bracketing .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact 


This paper focuses on the word segmentation , since the most basic unit of a treebank are words ( Di Sciullo and Edwin , 1987 ) , and defining `` words '' is the first step ( Xia , 2000b ,a ; Sornlertlamvanich et al ., 1997 , 1999 ) .
This paper focuses on the word segmentation issues since the most basic unit of a treebank is word ( Di Sciullo and Edwin , 1987 ) , and defining `` What are words ? '' is the first problem that a treebank has to solve ( Xia , 2000b ,a ; Sornlertlamvanich et al ., 1997 , 1999 ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#23#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#31#16#exact -1#32#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#26#23#exact -1#24#24#exact -1#25#25#exact -1#47#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#17#30#stem -1#34#31#exact -1#35#32#exact -1#36#33#exact -1#37#34#exact -1#45#36#exact -1#46#37#exact -1#56#38#exact -1#48#39#exact -1#49#40#exact -1#50#41#exact -1#51#42#exact -1#52#43#exact -1#53#44#exact -1#54#45#exact -1#55#46#exact -1#57#48#exact -1#58#49#exact -1#59#50#exact 


For languages like English , defining `` words '' is almost trivial , because the blank spaces denote word delimiters .
For languages like English , answering this question is almost trivial because the blank spaces denote word delimiters .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#16#7#stem -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#13#exact -1#12#14#exact -1#13#15#exact -1#14#16#exact -1#15#17#exact -1#17#19#exact -1#18#20#exact 


However , for an isolating language like Vietnamese , for which blank spaces play a role of syllable delimiters , `` What are words ? '' is not a trivial question .
However , for an isolating language like Vietnamese , where blank spaces play a role of syllable delimiters , `` What are words ? '' is not a trivial question .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9,10#para -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact -1#28#29#exact -1#29#30#exact -1#30#31#exact 


For example , the sentence `` Hc sinh hc sinh hc ( students learn biology )1 '' is composed of three words , `` hc sinh ( student ) '' , `` hc ( learn ) , '' and `` sinh hc ( biology ) '' . Word segmentation is expected to break down the sentence at the boundaries of these words , instead of splitting `` hc sinh ( student ) '' and `` sinh hc ( biology ) '' .
For example , the sentence `` Hc sinh hc sinh hc ( students learn biology )1 '' is composed of three words `` hc sinh ( student ) '' , `` hc ( learn ) , '' and `` sinh hc ( biology ) ; '' Word segmentation is expected to break down the sentence at the boundaries of these words , not to split `` hc sinh ( student ) '' and `` sinh hc ( biology ) '' .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#29#22#exact -1#30#23#exact -1#31#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact -1#28#29#exact -1#35#30#exact -1#22#31#exact -1#23#32#exact -1#32#33#exact -1#33#34#exact -1#34#35#exact -1#61#36#exact -1#36#37#exact -1#37#38#exact -1#38#39#exact -1#39#40#exact -1#40#41#exact -1#41#42#exact -1#42#43#exact -1#43#44#exact -1#45#45#exact -1#80#46#exact -1#46#47#exact -1#47#48#exact -1#48#49#exact -1#49#50#exact -1#50#51#exact -1#51#52#exact -1#52#53#exact -1#53#54#exact -1#54#55#exact -1#55#56#exact -1#56#57#exact -1#57#58#exact -1#58#59#exact -1#59#60#exact -1#60#61#exact -1#62#63#para -1#63,64#64,65#para -1#65#66#exact -1#66#67#exact -1#67#68#exact -1#68#69#exact -1#69#70#exact -1#70#71#exact -1#71#72#exact -1#72#73#exact -1#73#74#exact -1#74#75#exact -1#75#76#exact -1#76#77#exact -1#77#78#exact -1#78#79#exact -1#79#80#exact 


Note that the terminology `` word segmentation '' also refers to the task of extracting words statistically without concerning a gold-standard for segmentation , as in ( Ha , 2003 ; Le et al ., 2010 ) .
Note that the terminology `` word segmentation '' also refers to the task of extracting words statistically without concerning a gold-standard for segmentation , as in ( Ha , 2003 ; Le et al ., 2010 ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8,9,10#8,9,10,11#para -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact -1#37#37#exact 


In such a context , the extracted words are more appropriate for building a dictionary , rather than for corpus-based language processing , which are outside of the scope of this paper .
In such context , the extracted words are more appropriate for building a dictionary than for corpus-based language processing , which are out of the focus of this paper .
-1#0#0#exact -1#1#1#exact -1#12#2#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#8,9,10#8,9,10,11#para -1#11#12#exact -1#13#13,14#para -1#19#15#exact -1#14#17#exact -1#15#18#exact -1#16#19#exact -1#17#20#exact -1#18#21#exact -1#20#23#exact -1#21#24#exact -1#22,23#25,26#para -1#24#27#exact -1#26#29#exact -1#27#30#exact -1#28#31#exact -1#29#32#exact 


Because of the discussed characteristics of the language , there are challenges in establishing a gold standard for Vietnamese word segmentation .
Establishing a gold standard for Vietnamese word segmentation faces some diffcuties coming from the characteristics of the language .
-1#15#1#exact -1#16#2#exact -1#14#4#exact -1#13#6#exact -1#17#7#exact -1#0#13#lc -1#1#14#exact -1#2#15#exact -1#3#16#exact -1#4#17#exact -1#5#18#exact -1#6#19#exact -1#7#20#exact -1#18#21#exact 


The difficulties in Vietnamese word segmentation have been recognized by many researchers ( Ha , 2003 ; Nguyen et al ., 2004 , 2006 ; Le et al ., 2010 ) .
The diffculties of Vietnamese word segmentation have been recognized by many researchers ( Ha , 2003 ; Nguyen et al ., 2004 , 2006 ; Le et al ., 2010 ) .
-1#0#0#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact 


Although most people agree that the Vietnamese language has two types of words : single and compound , there is little consensus as to the methodology for segmenting a sentence into words .
Although most people agree that the Vietnamese language has two types of words : single and compound , there is little consensus on how to segment a sentence into words .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#24#23#exact -1#25#27#stem -1#26#28#exact -1#27#29#exact -1#28#30#exact -1#29#31#exact -1#30#32#exact 


The disagreement occurs not only because of the different functions of blank spaces ( as mentioned above ) , but also because Vietnamese is not an inflectional language , as is the case for English or Japanese , for which morphological forms can provide useful clues for word segmentation .
The disagreement is not only because of the different functions of blank spaces as mentioned above , but also because Vietnamese is not an inflectional language like English or Japanese , where morphological forms can be useful clues for word segmentation .
-1#0#0#exact -1#1#1#exact -1#2#2#para -1#3,4,5,6#3,4,5#para -1#10#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#11#11#exact -1#12#12#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#18#exact -1#17#19#exact -1#18#20#exact -1#19#21#exact -1#20#22#exact -1#21#23#exact -1#22#24#exact -1#23#25#exact -1#24#26#exact -1#25#27#exact -1#30#28#exact -1#26#29,30,31,32#para -1#38#33#exact -1#27#34#exact -1#28#35#exact -1#29#36#exact -1#31#38,39#para -1#32#40#exact -1#33#41#exact -1#34#42#exact -1#36#44#exact -1#37#45#exact -1#39#47#exact -1#40#48#exact -1#41#49#exact 


While similar problems also occur with Chinese word segmentation ( Xia , 2000b ) , Vietnamese word segmentation may be more difficult , because the modern Vietnamese writing system is based on Latin characters , which represent the pronunciation , but not the meaning of words .
While the similar problems also happen with Chinese word segmentation ( Xia , 2000b ) , Vietnamese word segmentation may be more diffcult because the modern Vietnamese writing system is based on Latin characters , which represents the pronunciation but not the meaning of words .
-1#0#0#exact -1#2#1#exact -1#3#2#exact -1#4#3#exact -1#5#4#syn -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#34#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#35#35#exact -1#36,37#36,37#para -1#38#38#exact -1#39#40#exact -1#40#41#exact -1#42,43,44#42,43,44,45#para -1#45#46#exact 


All of these characteristics make it diffcult to perform word segmentation for Vietnamese , both manually and automatically , and have thus resulted in different criteria for word segmentation .
All these characteristics make it diffcult to perform word segmentation for Vietnamese both manually and automatically , and have resulted in different criteria for word segmenation .
-1#0#0#exact -1#1#2#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#16#13#exact -1#12#14#exact -1#13#15#exact -1#14#16#exact -1#15#17#exact -1#17#19#exact -1#18#20#exact -1#19#22#exact -1#20#23#exact -1#21#24#exact -1#22#25#exact -1#23#26#exact -1#24#27#exact -1#26#29#exact 


However , so far , there have been few studies on the challenges in word segmentation , and the comparison of different word segmentation criteria .
However , so far there have been few studies on the challenges in word segmentation , and the comparison of different word segmentation criteria .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#15#4#exact -1#6,7#5,6,7,8#para -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact 


In this paper , a brief introduction of the Vietnamese Treebank VTB and its annotation scheme are provided in Section 2 .
In this paper , a brief introduction of the Vietnamese treebank VTB and its annotation scheme are given in Section 2 .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#lc -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact 


Then , we described our methods for the detection and correction of the problematic annotations in the VTB corpus ( Section 4 .2 ) .
Then , we described our methods for the detection and correction of the problematic annotations in the VTB corpus ( Section 4 .2 ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact 


We classified the problematic annotations into several patterns of inconsistency , part of which were manually fixed to improve the quality of the corpus .
We classified the problematic annotations into several patterns of inconsistency , part of which were manually fixed to improve the quality of the corpus .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#18,19,20,21#17,18,19,20,21#para -1#22#22#exact -1#23#23#exact -1#24#24#exact 


The rest , which can be considered as the most difficult and controversial instances of word segmentation , were used to create different versions of the VTB corpus , representing different word segmentation criteria .
The rest , which can be considered as the most diffcult and controversial cases of word segmentation , were used to create different versions of the VTB corpus representing different word segmentation criteria .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#11#11#exact -1#12#12#exact -1#13,14#13,14#para -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#29#exact -1#29#30#exact -1#30#31#exact -1#31#32#exact -1#32#33#exact -1#33#34#exact 


Finally , we evaluated these criteria in automatic word segmentation , and its application in text classification and English-Vietnamese statistical machine translation , in Section 4 .
Finally , we evaluated these criteria in automatic word segmentation , and its application in text classification and English-Vietnamese statistical machine translation in Section 4 .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact 


This study is not only beneficial for the development of computational processing technologies for Vietnamese , a language spoken by over 90 million people , but also for similar languages such as Thai , Laos , and so on .
This study is not only beneficial for the development of computational processing technologies for Vietnamese , a language spoken by over 90 million people , but also for the similar languages such as Thai , Laos , and so on .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6,7,8#6,7,8,9#para -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25,26,27,28#25,26,27#para -1#29#28#exact -1#30#29#exact -1#31#30#exact -1#32#31#exact -1#33#32#exact -1#34#33#exact -1#35#34#exact -1#36#35#exact -1#37#36#exact -1#38#37#exact -1#39#38#exact -1#40#39#exact 


This study also promotes the computational linguistic studies on how to transfer methods developed for a popular language , like English , to a language that has not yet been intensively studied .
This study also promotes the computational linguistic studies on how to transfer methods developed for a popular language like English to a language that has not yet intensively studied .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#19#exact -1#19#20#exact -1#20#22#exact -1#21#23#exact -1#22#24#exact -1#23#25#exact -1#24,25#26,27,28,29#para -1#27#30#exact -1#28#31#exact -1#29#32#exact 


Word segmentation in VTB aims at establishing a standard for word segmentation in a context of multi-level language processing .
Word segmentation in VTB aims to found a standard for word segmentation in a context of multi-level language processing .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4,5#4,5#para -1#6#6#syn -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact 


VTB specifies 12 types of units that should be identified as words ( Table 1 ) ( Nguyen et al ., a ) , which can be divided up into three groups : single , compound , and special `` words '' .
VTB specifies 12 types of units that should be identified as words ( Table 1 ) ( Nguyen et al ., a ) , which can be divided into three groups : single , compound , and special `` words '' .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#29#exact -1#29#30#exact -1#30#31#exact -1#31#32#exact -1#32#33#exact -1#33#34#exact -1#34#35#exact -1#35#36#exact -1#36#37#exact -1#37#38#exact -1#38#39#exact -1#39#40#exact -1#40#41#exact -1#41#42#exact 


Single words contain only one token .
Single words contain only one token .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact 


The terminology tokens refers to text spans that are separated from each other by blank spaces .
The terminology tokens refers to text spans separated with each other by blank spaces .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#8,9#para -1#8,9,10#10,11,12#para -1#11#13#exact -1#12#14#exact -1#13#15#exact -1#14#16#exact 


Compound words have two or more tokens , and are divided into four types : compound words composed by semantic coordination ( semantic-coordinated compound ) , compound words composed by semantic subordination ( semantic-subordinated compound ) , compound words with an affx , and reduplicated words .
Compound words have two or more tokens , and are divided into four types : compound words composed by semantic coordination ( semantic-coordinated compound ) , compound words composed by semantic subordination ( semantic-subordinated compound ) , compound words with affx , and reduplicated words .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact -1#37#37#exact -1#38#38#exact -1#39#39#exact -1#40#41#exact -1#41#42#exact -1#42#43#exact -1#43#44#exact -1#44#45#exact -1#45#46#exact 


Special `` words '' include idioms , locutions , proper names , date times , numbers , symbols , sentence marks , foreign words , or abbreviations .
Special `` words '' can be idioms , locutions , proper names , date times , numbers , symbols , sentence marks , foreign words , or abbreviations .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact -1#23#22#exact -1#24#23#exact -1#25#24#exact -1#26#25#exact -1#27#26#exact -1#28#27#exact 


The segmentation of these types of words forms a basis for the POS tagging , with 18 different POS tags , as shown in Table 2 ( Nguyen et al ., c ) .
The segmentation of these types of words forms a basis for the POS tagging , with 18 different POS tags shown in Table 2 ( Nguyen et al ., c ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8,9#8,9,10,11#para -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#22#exact -1#21#23#exact -1#22#24#exact -1#23#25#exact -1#24#26#exact -1#25#27#exact -1#26#28#exact -1#27#29#exact -1#28#30#exact -1#29#31#exact -1#30#32#exact -1#31#33#exact 


Each unit in Table 1 goes with several example words ; English translations are provided in parentheses .
Each unit in Table 1 goes with several example words of which English translations are given in parentheses .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact 


Furthermore , we added a translation for each token , where possible , so that readers who are unfamiliar with Vietnamese can have an intuitive idea as to how the compound words are formed .
Besides , we added a translation for each token when possible , so that the readers unfamiliar with Vietnamese can have an intuitive idea of how the compound words are formed .
-1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#11#9#exact -1#9,10#10,11#para -1#12#13#exact -1#13#14#exact -1#15#15#exact -1#29#16,17#para -1#16#18#exact -1#17#19#exact -1#18#20#exact -1#19#21#exact -1#20#22#exact -1#21#23#exact -1#22#24#exact -1#23#25#exact -1#24,25,26#26,27,28,29#para -1#27#30#exact -1#28#31#exact -1#30#32#para -1#31#34#exact 


The subscript of a token translation is the index of that token in the compound word .
The subscript of a token translation is the index of that token in the compound word .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact 


However , for some tokens , we could not find any appropriate English translation , so we gave it an empty translation , marked with an asterisk .
However , for some tokens , we could not find any appropriate English translation , so we give it an empty translation marked with an asterisk .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#syn -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact 


Note that a Vietnamese word or a token in context can have other meanings , in addition to the given translations .
Note that a Vietnamese word or a token in context can have other meanings in addition to the given translations .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14,15,16,17#15,16,17#para -1#18#19#exact -1#19#20#exact -1#20#21#exact 


A classifier noun , denoted by the part-of-speech Nc in Table 2 , is a special type of word in Vietnamese .
A special type of words in Vietnamese is classifer noun , denoted by the part-of-speech Nc in Table 2 .
-1#0#0#exact -1#9#2#exact -1#10#3#exact -1#11#4#exact -1#12#5#exact -1#13#6#exact -1#14#7#exact -1#15#8#exact -1#16#9#exact -1#17#10#exact -1#18#11#exact -1#7#13#exact -1#1#14,15#para -1#2#16#exact -1#3#17#exact -1#4#18#stem -1#5#19#exact -1#6#20#exact -1#19#21#exact 


Classifier nouns are specific to several Southeast Asian languages , like Vietnamese and Thai .
Classifier nouns are specific to several Southeast Asian languages like Vietnamese and Thai .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact 


One of the functions of classifier nouns is to express the definiteness .
One of the functions of classifier nouns is to express the definiteness .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact 


For example , the common noun `` bn '' generally means tables , while `` ci bn '' means a specific table , similar to the table in English .
For example , the common noun `` bn '' means tables in general , while `` ci bn '' means a specific table similar to the table in English .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#11,12#9#para -1#9#10#exact -1#10#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact 


In this section , we analyzed the VTB corpus to determine whether the difficulties in Vietnamese word segmentation affected the quality of VTB annotations .
In this section , we analyzed the VTB corpus to know whether the diffculties in Vietnamese word segmentation affected the quality of VTB annotations .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#11#10,11#para -1#12#12#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact 


The analysis revealed several types of inconsistent annotations , which are also
The analysis results revealed several types of inconsistent annotations , which are also
-1#0#0#exact -1#1#1#exact -1#3#2#exact -1#4#3#exact -1#5#4#exact -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact 


Vietnamese word segmentation .
Vietnamese word segmentation .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact 


Our analysis is based on two types of inconsistencies : variation and structural inconsistency , which are defined below .
Our analysis is based on two types of inconsistency : variation and structural inconsistency , whose definitions and details are given below .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#stem -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#19#15,16#para -1#16#17#para -1#21#18#exact -1#22#19#exact 


Variation inconsistency : is a sequence of tokens , which has more than one way of segmentation in the corpus .
Variation inconsistency : is a sequence of tokens which have more than one way of seg-mentation in the corpus .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#9#exact -1#9,10,11#10,11,12#para -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact 


For example , `` con gi/girl '' can remain as one word , or be segmented into two words , `` con '' and `` gi '' .
For example , `` con gi/girl '' can remain as one word , or be segmented into two words `` con '' and `` gi '' .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact 


A variation can be an annotation inconsistency , or an ambiguity in Vietnamese .
A variation can be an annotation inconsistency , or an ambiguity inVietnamese .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#12#13#exact 


While ambiguity cases reflect the difficulty of the language , annotation inconsistencies are usually caused by the confusion in the decision of annotators , which should be eliminated in annotation .
While ambiguity cases reflect the diffculty of the language , annotation inconsistencies are usually caused by the confusion in the decision of annotators , which should be eliminated in annotation .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact 


We use the term variation instance to refer to a single occurrence of a variation .
We use the term variation instance to refer a single occurence of a variation .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8,9#8,9,10#para -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact 


Structural inconsistency : happens when different sequences have similar structures , and thus should be split in the same way , but are segmented in different ways in the corpus .
Structural inconsistency : happens when different sequences have similar structures , thus should be splitted in the same way , but are segmented in different ways in the corpus .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#stem -1#16,17,18#16,17,18,19#para -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23,24,25,26#24,25,26#para -1#15#27#exact -1#27#28#exact -1#28#29#exact -1#29#30#exact 


For example , `` con gi/girl '' and `` con trai/boy '' have similar structures : a combination of a classifier noun and a common noun , Nc + N , so when `` con gi/girl '' is split , and `` con trai/boy '' is not , it is considered as a structural inconsistency of Nc .
For example , `` con gi/girl '' and `` con trai/boy '' have similar structures , a combination of a classifier noun and a common noun Nc + N , so when `` con gi/girl '' is splitted and `` con trai/boy '' is not , it is considered as a structural inconsistency of Nc .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#15#26#exact -1#26#27#exact -1#27#28#exact -1#28#29#exact -1#29#30#exact -1#30#31#exact -1#31#32#exact -1#32#33#exact -1#33#34#exact -1#34#35#exact -1#35#36#exact -1#36#37#exact -1#37#38#stem -1#45#39#exact -1#38#40#exact -1#39#41#exact -1#40#42#exact -1#41#43#exact -1#42#44#exact -1#43#45#exact -1#44#46#exact -1#46#48#exact -1#47#49#exact -1#48#50#exact -1#49#51#exact -1#50#52#exact -1#51#53#exact -1#52#54#exact -1#53#55#exact -1#54#56#exact -1#55#57#exact 


It is likely that structural inconsistency at the word segmentation level complicates the higher levels of processing , including POS tagging and bracketing .
It is likely that structural inconsistency in word segmentation level makes the higher levels of processing , POS tagging and bracketing , become more complicated .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#11#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#23,24#11,12#para -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#19#exact -1#18#20#exact -1#19#21#exact -1#20#22#exact -1#25#23#exact 


The detection method for variation inconsistency is based on N-gram sequences and the phrase structures in the VTB , following the definition for variation inconsistency , above .
The detection method for variation inconsistency is based on N-gram sequences and the phrase structures in VTB treebank , following the definition of variation inconsistency above .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#20#16#exact -1#16#17#exact -1#18#18#exact -1#19#19#exact -1#21#20,21#para -1#23#23#exact -1#24#24#exact -1#25#26#exact -1#26#27#exact 


In detail , we counted N-gram sequences of different lengths in VTB that have two or more ways of word segmentation , satisfying one of the following two conditions :
In details , we counted N-gram sequences of different lengths in VTB that have two or more ways of word segmentation , satisfying one of the following two conditions :
-1#0#0#exact -1#1#1#stem -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact 


N tokens are all in the same phrase , and all have the same depth in phrase .
N tokens are all in the same phrase , and all have the same depth in phrase .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact 


For example , the 3-gram " nh tnh ngha ( house of gratitude ) " in this structure " ( NP ( Nc-H cn ) ( N nh ) ( A tnh ngha ) ) , " OR
For example , the 3-gram " nh tnh ngha ( house of gratitude ) " in this structure " ( NP ( Nc-H cn ) ( N nh ) ( A tnh ngha ) ) , " OR
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact -1#37#37#exact 


nh tnh ngha " in this structure " ( NP ( Nc-H cn ) ( N nh ) ( ADJP ( A tnh ngha ) ) ) , " where the ADJP contains only one word .
nh tnh ngha " in this structure " ( NP ( Nc-H cn ) ( N nh ) ( ADJP ( A tnh ngha ) ) ) , " where the ADJP contains only one word .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact 


Table 3 shows the overall statistics of the variation inconsistency detected by the method described above .
Table 3 shows the overall statistics of the variation inconsistency detected by the above method .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#14#13#exact -1#13#15#exact -1#15#16#exact 


Most of the diffcult cases of word segmentation occur in two-token variations , occupying the majority of variations ( 92 .9% ) .
Most of the diffcult cases of word segmentation lie in two-token variations , occupying the majority of variations ( 92 .9% ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact 


This ratio of 2-gram variations is much higher than the average ratio of two-token words in Vietnamese , as reported in ( Nguyen et al., 2009a ) , which is 80% .
This ratio of 2-gram variations is much higher than the evarage ratio of two-token words in Vietnamese reported in ( Nguyen et al., 2009a ) , which is 80% percent .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#25#17#exact -1#17#18,19#para -1#18#20#exact -1#19#21#exact -1#20#22#exact -1#21#23#exact -1#22#24#exact -1#23#25#exact -1#24#26#exact -1#26#28#exact -1#27#29#exact -1#28#30#exact -1#30#31#exact 


Variations that have lengths of three and four tokens occupy 6 .1% and 1 .0% , respectively .
Variations have lengths of three and four tokens occupy 6 .1% and 1 .0% , respectively .
-1#0#0#exact -1#1#2#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact 


We estimated the precision of our method by randomly selecting 130 2-gram variation instances , extracted from the method described above , and manually checked whether the inconsistencies are true .
We estimated the precision of our method by randomly selected 130 2-gram variation instances extracted from the above method , and manually checked whether they are true inconsistency .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#stem -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#19#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#18#18#exact -1#17#20#exact -1#20#22#exact -1#21#23#exact -1#22#24#exact -1#23#25#exact -1#25#28#exact -1#26#29#exact -1#28#30#exact 


We found that 129 cases occupying 99 .2% of all extracted 2-grams are true inconsistencies .
We found that 129 cases occupying 99 .2% of all extracted 2-grams are true inconsistency .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#stem -1#15#15#exact 


Only one instance of inconsistency was an ambiguous sequence gi c , which is one word when it means price , and two words gi / price c / all in u c gi c / all have ( their own ) price .
Only one instance is an ambiguous sequence gi c , which is one word when it means price , and two words gi / price c / all in u c gi c / all have ( their own ) price .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3,4#5,6#para -1#5#7#exact -1#6#8#exact -1#7#9#exact -1#8#10#exact -1#9#11#exact -1#10#12#exact -1#11#13#exact -1#12#14#exact -1#13#15#exact -1#14#16#exact -1#15#17#exact -1#16#18#exact -1#17#19#exact -1#18#20#exact -1#19#21#exact -1#20#22#exact -1#21#23#exact -1#22#24#exact -1#23#25#exact -1#24#26#exact -1#25#27#exact -1#26#28#exact -1#27#29#exact -1#28#30#exact -1#29#31#exact -1#30#32#exact -1#31#33#exact -1#32#34#exact -1#33#35#exact -1#34#36#exact -1#35#37#exact -1#36#38#exact -1#37#39#exact -1#38#40#exact -1#39#41#exact -1#40#42#exact -1#41#43#exact 


The precision for our method is high , so we can use the extracted variations to provide insights on the word segmentation problem .
The precision of our method is high enough so that so we can use the extracted variations to study the insights of word segmentation problem .
-1#0#0#exact -1#1#1#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#10#8#exact -1#11#9#exact -1#12#10#exact -1#13#11#exact -1#14#12#exact -1#15#13#exact -1#16#14#exact -1#17#15#exact -1#20#17#exact -1#19#19#exact -1#22#20#exact -1#23#21#exact -1#24#22#exact -1#25#23#exact 


We further analyzed the 2-gram variations to understand what types of 2-grams were most confusing for annotators .
We further analyzed the 2-gram variations to know what types of 2-grams were most confusing to annotators .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#16#16#exact -1#17#17#exact 


The analysis revealed that compound nouns , compound verbs , and compound adjectives are the most difficult cases of word segmentation .
The analysis results showed that compound nouns , compound verbs , and compound adjectives are the top diffcult cases of word segmentation .
-1#0#0#exact -1#1#1#exact -1#3#2#para -1#4#3#exact -1#5#4#exact -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact 


We classified the 2-gram variations according to their POS sequences in case the tokens in the 2-gram are split .
We classified the 2-gram variations according to their POS sequences in case the tokens in the 2-gram are splitted .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#stem -1#19#19#exact 


There are a total of 54 patterns of POS sequences . The top 10 confusing patterns , their counts of 2-gram variations , and examples are depicted in Table 4 .
There are totally 54 patterns of POS sequence , of which top 10 confusing patterns , a long with their counts of 2-gram variations , and examples are shown in Table 4 .
-1#0#0#exact -1#1#1#exact -1#16#2#exact -1#9#4#exact -1#3#5#exact -1#4#6#exact -1#5#7#exact -1#6#8#exact -1#7#9#stem -1#32#10#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#19#17#exact -1#20#18#exact -1#21#19#exact -1#22#20#exact -1#23#21#exact -1#24#22#exact -1#25#23#exact -1#26#24#exact -1#27#25#exact -1#28#26#syn -1#29#27#exact -1#30#28#exact -1#31#29#exact 


Table 5 and Table 6 show the POS patterns that are a specific POS tag , appearing at the beginning or ending of the sequence .
Table 5 and Table 6 show the POS patterns which a specific POS tag appearing at the beginning or ending of the sequence .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#16#exact -1#15#17#exact -1#16#18#exact -1#17#19#exact -1#18#20#exact -1#19#21#exact -1#20#22#exact -1#21#23#exact -1#22#24#exact -1#23#25#exact 


Investigating the inconsistent 2-grams extracted , we found that most of them are compound words , according to the VTB guidelines ( Section 2 ) .
Investigating the inconsistent 2-grams extracted , we found that most of them are compound words according to the VTB guidelines ( Section 2 ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact 


One of the reasons why the compound words are sometimes split , is because the tokens in those compound words have their own meanings , which seem to contribute to the overall meaning of the compounds .
One of the reasons why the compound words are sometimes splitted , is because the tokens in those compound words have their own meanings , which seem to contribute to the whole meaning of the compounds .
-1#0#0#exact -1#1#1#exact -1#2,3,4,5#2,3,4#para -1#14#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#stem -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#30#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27,28,29#27,28,29,30#para -1#31#31#para -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact 


This can be seen through the examples provided in Table 4 , where the meanings of tokens are given with a subscript .
This can be seen through the examples given in Table 4 , where the meanings of tokens are given with a subscript .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#6,7,8#5,6,7,8#para -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact 


This scenario has proven to be problematic for the annotators of VTB .
This problem seems to have caused a lot of trouble for the annotators of VTB .
-1#0#0#exact -1#5,6#2#para -1#3#4#exact -1#9,10,11#6#para -1#12#9#exact -1#13#10#exact -1#14#11#exact -1#15#12#exact 


Furthermore , by observing the POS patterns in Table 5 and Table 6 , we can see the potential for structural inconsistency , particularly for closed-set POS tags .
Furthermore , observing the POS patterns in Table 5 and Table 6 , we can see the potential of structural inconsistency , in particular for closed-set POS tags .
-1#0#0#exact -1#1#1#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#14,15,16#14,15,16,17#para -1#17#18#exact -1#18,19#19,20#para -1#20#21#exact -1#21#22#exact -1#22,23,24#23,24#para -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact 


Among them , classifier nouns ( Nc ) and affixes ( S ) are two typical cases of structural inconsistency , which will be used in several settings for our experiments .
Among them , classifier nouns ( Nc ) and affxes ( S ) are two typical cases of structural inconsistency , which will be used in several settings of our experiments .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#22,23,24,25#21,22,23,24,25#para -1#26#26#exact -1#27#27#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact 


The same affx or classifier noun can modify different nouns , so when they are sometimes split and combined in the variations , we can conclude that classifier nouns and affixes involve in-structural inconsistencies .
The same affx or classifier noun can modify different nouns , so when they are sometimes splitted , and sometimes combined in the variations , we can conclude that classifier nouns and affxes involve in structural inconsistency .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#stem -1#18#17#exact -1#20#18#exact -1#21#19#exact -1#22#20#exact -1#23#21#exact -1#24#22#exact -1#25#23#exact -1#26#24#exact -1#27#25#exact -1#28#26#exact -1#29#27#exact -1#30#28#exact -1#31#29#exact -1#33#31#exact -1#36#33#stem -1#37#34#exact 


In the following section , we present our detection method for structural inconsistency for classifier nouns and affixes .
In the following section , we presents our detection method for structural inconsistency for classifier nouns and affxes .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#stem -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#18#18#exact 


The detection method for structural inconsistency of classifier nouns and affixes is simple .
The detection method for structural inconsistency of classifier nouns and affxes is simple .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact 


We collected all affixes and classifier nouns in the VTB corpus , and then extracted 2-grams containing these affixes or classifier nouns , which are also structural inconsistencies .
First , we collected all affxes and classifier nouns in the VTB corpus . Then , extracted 2-grams containing these affxes or classifier nouns , which also are the structural inconsistencies .
-1#2#0#lc -1#3#1#exact -1#4#2#exact -1#6#4#exact -1#7#5#exact -1#8#6#exact -1#9#7#exact -1#10#8#exact -1#11#9#exact -1#12#10#exact -1#1#11#exact -1#14#12,13#para -1#16#14#exact -1#17#15#exact -1#18#16#exact -1#19#17#exact -1#21#19#exact -1#22#20#exact -1#23#21#exact -1#24#22#exact -1#25#23#exact -1#27#24#exact -1#26#25#exact -1#29#26#exact -1#30#27#exact -1#31#28#exact 


For example , since " con " is tagged as a classifier noun in VTB , we extracted all 2-grams of " con " including both " con gi / girl " and " con trai / boy " .
For example , since " con " is tagged as a classifier noun in VTB , we extracted all 2-grams of " con " including both " con gi / girl " and " con trai / boy " .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact -1#37#37#exact -1#38#38#exact -1#39#39#exact 


Even though the sequence , " con trai " is always split into two words throughout the corpus , it can still be an inconsistency , if we consider similar structures such as " con gi " .
Note that even though the sequence " con trai " is always splitted into two words throughout the corpus , it can still be an inconsistency if we consider similar structures such as " con gi " .
-1#2#0#lc -1#3#1#exact -1#4#2#exact -1#5#3#exact -1#19#4#exact -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#stem -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact -1#23#22#exact -1#24#23#exact -1#25#24#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact -1#37#37#exact 


In other words , by this method , we extract sequences that may be consistent at the surface level , but are not consistent , if we consider the higher analysis levels , POS tagging .
In other words , by this method , we extract sequences that may be consistent at the surface level , but are not consistent if we consider the higher analysis levels , POS tagging .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#31#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact -1#28#29#exact -1#29#30#exact -1#30#31#exact -1#32#33#exact -1#33#34#exact -1#34#35#exact 


According to the VTB POS-tagging annotation guidelines ( Nguyen et al., c ) , classifier nouns should be separated from the words that they modify .
According to the VTB POS-tagging annotation guidelines ( Nguyen et al., c ) , classifier nouns should be separated from the words they modify .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact 


However , in practice , it is confusing when the classifier noun can be standalone as a single word .
However , in practice it is confusing when the classifier noun can be stand alone as a single word .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact 


For example a classifier noun , e.g. , " con " in " con trai ( boy ) " , or " con gi ( girl ) " , can also be a simple word , which means " I ( first person pronoun used by a child when talking to his / her parents ) " , or part of a complex noun " con ci ( children ) " .
For example a classifier noun , e.g. , " con " in " con trai ( boy ) " , or " con gi ( girl ) " , can also be a simple word which means " I ( first person pronoun used by a child when talking to his / her parents ) " , or part of a complex noun " con ci ( children ) " .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#56#35#exact -1#35#36#exact -1#36#37#exact -1#37#38#exact -1#38#39#exact -1#39#40#exact -1#40#41#exact -1#41#42#exact -1#42#43#exact -1#43#44#exact -1#44#45#exact -1#45#46#exact -1#46#47#exact -1#47#48#exact -1#48#49#exact -1#49#50#exact -1#50#51#exact -1#51#52#exact -1#52#53#exact -1#53#54#exact -1#54#55#exact -1#55#56#exact -1#57#58#exact -1#58#59#exact -1#59#60#exact -1#60#61#exact -1#61#62#exact -1#62#63#exact -1#63#64#exact -1#64#65#exact -1#65#66#exact -1#66#67#exact -1#67#68#exact -1#68#69#exact -1#69#70#exact -1#70#71#exact 


Therefore , in our experiments , we want to evaluate the " splitting " and " combining " of these cases , in order to see whether the solution is successful for applications of the corpus .
Therefore , in our experiments , we want to evaluate the " splitting " and " combining " of these diffcult cases , to see whether the solution is fruitful for applications of the corpus .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#21#20#exact -1#22#21#exact -1#23,24#22,23,24,25#para -1#25#26#exact -1#26#27#exact -1#27#28#exact -1#28#29#exact -1#29,30#30,31#para -1#31#32#exact -1#32#33#exact -1#33#34#exact -1#34#35#exact -1#35#36#exact 


By examining the variations extracted by the variation inconsistency detection , we found that there are cases when a special character like a percentage ( % ) in " 30% " , is split or combined with " 30 " .
Examing the variations extracted by the variation inconsistency detection , we found that there are cases when a special character like percentage % in " 30% " , is splitted or combined with " 30 " .
-1#1#2#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22,23#para -1#22#25#exact -1#23#27#exact -1#24#28#exact -1#25#29#exact -1#26#30#exact -1#27#31#exact -1#28#32#exact -1#29#33#stem -1#30#34#exact -1#31#35#exact -1#32#36#exact -1#33#37#exact -1#34#38#exact -1#35#39#exact -1#36#40#exact 


Such inconsistent annotations are manually fixed based on their textual context .
Such inconsistent annotations are manually fixed based on their textual context .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact 


By checking structural inconsistencies of these special characters , including percentages ( % ) , hyphens ( - ) , and other symbols , we found quite a significant number of inconsistent annotations .
Checking structural inconsistency of these special characters including percentage% , hyphen - , and so on , we found quite a significant amount of inconsistent annotations .
-1#0#1#lc -1#1#2#exact -1#2#3#stem -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#12#8#exact -1#7#9#exact -1#9#14#exact -1#10#15#stem -1#11#17#exact -1#16#19#exact -1#13#20#exact -1#17#24#exact -1#18#25#exact -1#19#26#exact -1#20,21,22,23#27,28,29,30#para -1#24#31#exact -1#25#32#exact -1#26#33#exact 


For example , the character , % , in " 30% " is split , but is combined with a number in " 50 % " , which is considered to be a structural inconsistency .
For example , the character % in " 30% " is splitted but is combined with the number in " 50 % " , which is considered as a structural inconsistency .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#23#5#exact -1#5#6#exact -1#6#8#exact -1#7#9#exact -1#8#10#exact -1#9#11#exact -1#10#12#exact -1#11#13#stem -1#12#15#exact -1#13#16#exact -1#14#17#exact -1#15#18#exact -1#28#19#exact -1#17#20#exact -1#18#21#exact -1#19#22#exact -1#20#23#exact -1#21#24#exact -1#22#25#exact -1#24,25,26#27,28,29,30#para -1#29#32,33#para -1#30#34#exact -1#31#35#exact 


Note that it can be argued that splitting " N% " into two words or combined in one word is dependent on the blank space in-between N and " % " .
Note that although it can be argued that whether " N% " can be splitted into two words or combined in one word is dependent on the blank space in between N and " % " .
-1#0#0#exact -1#1#1#exact -1#3#2#exact -1#4#3#exact -1#5#4#exact -1#6#5#exact -1#7#6#exact -1#14#7#stem -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#15#11#exact -1#16#12#exact -1#17#13#exact -1#18#14#exact -1#19#15#exact -1#20#16#exact -1#21#17#exact -1#22#18#exact -1#23#19#exact -1#24#20#exact -1#25#21#exact -1#26#22#exact -1#27#23#exact -1#28#24#exact -1#31#26#exact -1#32#27#exact -1#33#28#exact -1#34#29#exact -1#35#30#exact -1#36#31#exact 


Higher-levels of annotation such as POS tagging is significant , because we may need one or two different POS tags for the different methods of annotation .
It does matter higher-levels of annotation such as POS tagging because we may need one or two different POS tags for different ways of annotation .
-1#3#0#lc -1#4#1#exact -1#5#2#exact -1#6#3#exact -1#7#4#exact -1#8#5#exact -1#9#6#exact -1#0,1#7#para -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21,22#para -1#22#23#para -1#23#24#exact -1#24#25#exact -1#25#26#exact 


Therefore , we think that it is better to carefully preprocess text and segment these special characters in a consistent way .
Therefore , we think it is better to carefully preprocess text and segment these special characters in a consistent way .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#5,6,7#5,6,7,8#para -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact 


To improve the quality of the VTB corpus , we extracted the problematic sequences using patterns of the special characters , and manually fixed this type of inconsistency .
To improve the quality of VTB corpus , we extracted the probably problematic sequences using patterns of the special characters , and manually fixed this type of inconsistency .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#10#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#17#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#18#17,18#para -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact 


Automatically modification is diffcult , since we must check the semantics of the special characters in their contexts .
Automatically modification is diffcult since we must check the semantics of the special characters in their contexts .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact 


For example , hyphens in date expressions like " 5-4-1975 " , which refers to the date , " the fifth of April , 1975 , " are combined with the numbers .
For example , hyphens in date expressions like " 5-4-1975 " , which means the date " April the fifth , 1975 , " are combined with the numbers .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13,14#13,14,15#para -1#15#16#exact -1#20#17#exact -1#16#18#exact -1#18#19#exact -1#19#20#exact -1#17#21,22#para -1#22#23#exact -1#21#24#exact -1#23#26#exact -1#24#27#exact -1#25#28#exact -1#26#29#exact -1#27#30#exact -1#28#31#exact -1#29#32#exact 


However , when the hyphen indicates " ( from ) to " or " around .
However , when the hypen has a meaning of " ( from ) to " or " around .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#9#6#exact -1#10#7#exact -1#11#8#exact -1#12#9#exact -1#13#10#exact -1#14#11#exact -1#15#12#exact -1#16#13#exact -1#17#14#exact -1#18#15#exact 


. .
. .
-1#0#0#exact -1#1#1#exact 


or " , as in " 2-3 gi sng " , meaning " around 2 or 3 oclock in the morning " , we decided to separate it from the surrounding numbers .
or " , as in " 2-3 gi sng " meaning " around 2 or 3 oclock in the morning " , we decided to separate it from the surrounding numbers .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#21#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact -1#28#29#exact -1#29#30#exact -1#30#31#exact -1#31#32#exact 


As a result , we have fixed 685 inconsistent annotations of 21 special characters in VTB .
As a result , we have fixed 685 inconsistent annotations of 21 special characters in VTB .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact 


The variation inconsistency and structural inconsistency found in Section 3 can also be seen as representatives of different word segmentation criteria for Vietnamese .
The variation inconsistency and structural inconsistency found in Section 3 above can also be seen as representatives of different word segmentation criteria for Vietnamese .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact -1#23#22#exact -1#24#23#exact 


We organized the inconsistency detected in seven configurations of the original VTB corpus .
We organized the inconsistency detected in seven configurations of the original VTB corpus .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact 


Then , by using these data sets , we could observe the influence of the different word segmentation criteria on three tasks : automatic word segmentation , text classification , and English-Vietnamese statistical machine translation .
Then , by using these data sets , we could observe the influence of the different word segmentation criteria on three tasks : automatic word segmenation , text classification , and English-Vietnamese statistical machine translation .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11,12,13,14#11,12,13#para -1#15#14,15#para -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact 


Seven data sets corresponding to different segmentation criteria are organized as follows .
Seven data sets corresponding to different segmentation criteria are organized as follows .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact 


ORG : The original VTB corpus .
ORG : The original VTB corpus .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact 


BASE : The original VTB corpus + Manual modification of special characters done in Section 3 .3 .
BASE : The original VTB corpus + Manual modification of special characters done in Section 3 .3 .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact 


VAR_SPLIT : BASE + split all variations detected in Section 3 .1 .
VAR_SPLIT : BASE + split all variations detected in Section 3 .1 .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact 


VAR_COMB : BASE + combine all variations detected in Section 3 .1 .
VAR_COMB : BASE + combine all variations detected in Section 3 .1 .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact 


VAR_FREQ : BASE + select the segmentation with higher frequency among all variations detected in Section 3 .1 .
VAR_FREQ : BASE + select the segmentation with higher frequency among all variations detected in Section 3 .1 .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact 


STRUCT_NC : BASE + combine all classifier nouns detected in Section 3 .2 with the words they modify .
STRUCT_NC : BASE + combine all classifier nouns detected in Section 3 .2 with the words they modify .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact 


STRUCT_AFFIX : BASE + combine all suffxes detected in Section 3 .2 with the words they modify .
STRUCT_AFFIX : BASE + combine all suffxes detected in Section 3 .2 with the words they modify .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact 


These data sets are used in our experiments , as illustrated in Figure 1 .
These data sets are used in our experiments as illustrated in Figure 1 .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact 


The names of the data sets are also used to label our experimental configurations .
The names of the data sets are also used to label our experimental configurations .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact 


In this section , we briefly describe the task settings and the methods used for word segmentation ( WS ) , text classification ( TC ) , and English-Vietnamese statistical machine translation ( SMT ) .
In this section , we briefly describe the task settings and the methods used for word segmentation ( WS ) , text classification ( TC ) , and English-Vietnamese statistical machine translation ( SMT ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10,11,12,13#10,11,12,13,14#para -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact 


We used YamCha ( Kudo and Matsumoto , 2003 ) , a multi-purpose chunking tool , to train our word segmentation models .
We used YamCha ( Kudo and Matsumoto , 2003 ) , a multi-purpose chunking tool , to train our word segmentation models .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact 


The core of YamCha is the Support Vector Machine ( SVM ) machine learning method , which has been proven to be effective for NLP tasks .
The core of YamCha is the Support Vector Machine ( SVM ) machine learning method , which has been proved to be effective in NLP tasks .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19,20,21,22#19,20,21,22#para -1#24#24#exact -1#25#25#exact -1#26#26#exact 


For the Vietnamese word segmentation problem , each token is labeled with standard B , I , or O labels , corresponding to the beginning , inside , and outside positions , respectively .
For the Vietnamese word segmentation problem , each token is labeled with standard B , I , or O labels , corresponding to beginning , inside , and outside positions , respectively .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23,24#para -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact -1#28#29#exact -1#29#30#exact -1#30#31#exact -1#31#32#exact -1#32#33#exact 


The label of each token is determined based on the lexical features of two preceding words , and the two following words of that token .
Label of each token is determined based on the lexical features of two preceding words and two following words of that token .
-1#8#0#lc -1#0#1#lc -1#1#2#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#17#exact -1#16#18,19#para -1#17#20#exact -1#18#21#exact -1#19#22#exact -1#20#23#exact -1#21#24#exact -1#22#25#exact 


Since the Vietnamese language is not inflectional , we cannot utilize inflection features for word segmentation .
Since Vietnamese language is not inflectional , we cannot utilize inflection features for word segmentation .
-1#0#0#exact -1#1#2#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact 


Each of the seven data sets is split into two subsets for training and testing our WS models .
Each of the seven data sets is splitted into two subsets for training and testing our WS models .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#stem -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact 


The training set contains 8443 sentences , and the test set contains 2000 sentences .
The training set contains 8443 sentences , and the test set contains 2000 sentences .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact 


Text classification is defined as a task of determining the most suitable topic from the predefined topics , for an input document .
Text classification is defined as a task of determining for an input document the most suitable topic from the predefined topics .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#13#9#exact -1#14#10#exact -1#15#11#exact -1#16#12#exact -1#17#13#exact -1#18#14#exact -1#19#15#exact -1#20#16#exact -1#9#18#exact -1#10#19#exact -1#11#20#exact -1#12#21#exact -1#21#22#exact 


We implemented a text classification system similar to the system presented in ( Nguyen et al., 2012 ) .
We implemented a text classification system similar to the system presented in ( Nguyen et al., 2012 ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact 


The difference is that we performed the task at the document level , instead of at the sentence level .
The difference is that we performed for document level , not for sentence level .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#7#9,10#para -1#8#11#exact -1#9#12#exact -1#10#13#para -1#12#17#exact -1#13#18#exact -1#14#19#exact 


The processing of the system is summarized as follows .
Processing of the system is summarized as follows .
-1#0#1#lc -1#1#2#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact 


An input document is preprocessed with word segmentation and stop-word removals .
An input document is preprocessed with word segmentation and stop-word removals .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact 


Then , the document is represented in the form of a vector of weighted words appearing in the document .
Then , the document is represented in the form of a vector of weighted words appearing in the document .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6,7,8,9,10#6,7,8,9#para -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact 


The weight is calculated using standard tf-idf product .
The weight is calculated using standard tf-idf product .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact 


An SVM-based classifier predicts the most probable topic for the vector , which also is the topic for the input document .
An SVM-based classifier predicts the most probable topic for the vector , which also is the topic of the input document .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact 


In our experiment , for comparison of different word segmentation criteria in topic classification , we only vary the word segmentation model used for this task , while fixing other configurations .
In our experiment for comparison of different word segmentation criteria in topic classification , we only vary the word segmentation model used for this task , while fixing other configurations .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#13#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#25#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#26#27#exact -1#27#28#exact -1#28#29#exact -1#29#30#exact -1#30#31#exact 


News articles of five topics : music , stock , entertainment , education , and fashion are used .
News articles of five topics : music , stock , entertainment , education , and fashion are used .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact 


The sizes of the training and test data sets are summarized in Table 8 .
The sizes of the training and test data sets are summarized in Table 8 .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact 


A	phrase-based SMT system for English-Vietnamese translation was implemented .
A	phrase-based SMT system for English-Vietnamese translation was implemented .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact 


In this system , we used SRILM ( Stolcke , 2002 ) to build the language model , GIZA++ ( Och and Ney , 2003 ) to train the word-aligned model , and Moses ( Holmqvist et al., 2007 ) to train the phrase-based statistical translation model .
In this system , we used SRILM ( Stolcke , 2002 ) to build the language model , GIZA++ ( Och and Ney , 2003 ) to train the word-aligned model , and Moses ( Holmqvist et al., 2007 ) to train the phrase-based statistical translation model .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact -1#37#37#exact -1#38#38#exact -1#39#39#exact -1#40#40#exact -1#41#41#exact -1#42#42#exact -1#43#43#exact -1#44#44#exact -1#45#45#exact -1#46#46#exact -1#47#47#exact 


Translation results are evaluated using the BLUE score ( Papineni et al., 2002 ) .
Translation results are evaluated using BLUE score ( Papineni et al., 2002 ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact 


Both training and test data are word-segmented using the word segmentation models achieved .
Both training and test data are word-segmented using the word segmentation models achieved .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact 


For the experiment , we used the VCL_EVC bilingual corpus , 18000 pairs of sentences for training , and 1000 pairs for testing .
For the experiment , we used the VCL_EVC bilingual corpus , 18000 pairs of sentences for training , and 1000 pairs for testing .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact 


Evaluation of word segmentation models trained on different versions of the VTB are given in Table 9 .
Evaluation of word segmentation models trained on different versions of the VTB are given in Table 9 .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact 


The experimental results with text classification and English-Vietnamese statistical machine translation are shown in Table 10 and Table 11 , respectively .
And the experimental results with text classification and English-Vietnamese statistical machine translation are shown in Table 10 and Table 11 , respectively .
-1#1#0#lc -1#2#1#exact -1#3#2#exact -1#4#3#exact -1#5#4#exact -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact 


There are two important conclusions that can be drawn from these tables : ( 1 ) The quality of the treebank strongly affects the applications , since our BASE model and most of the other enhanced models improved the performance of TC and SMT systems ; ( 2 ) " Splitting " seems to be a good solution for word segmentation for controversial cases , including the split of variations , affxes , and classifier nouns .
There are two important conclusions can be drawn from these tables : ( 1 ) Quality of the treebank strongly affects the applications since our BASE model and most of other enhanced models improved the performance of TC and SMT systems ; ( 2 ) " Splitting " seems to be a good solution for word segmentation of controversial cases , including the split of variations , affxes , and classifier nouns .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5,6#para -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15,16,17#16,17,18,19#para -1#18#20#exact -1#19#21#exact -1#20#22#exact -1#21#23#exact -1#22#24#exact -1#60#25#exact -1#23#26#exact -1#24#27#exact -1#25#28#exact -1#26#29#exact -1#27,28#30,31,32,33#para -1#30#34#exact -1#31#35#exact -1#32#36#exact -1#33#37#exact -1#34#38#exact -1#35#39#exact -1#36#40#exact -1#37#41#exact -1#38#42#exact -1#39#43#exact -1#40#44#exact -1#41#45#exact -1#42#46#exact -1#43#47#exact -1#44#48#exact -1#45#49#exact -1#46#50#exact -1#47#51#exact -1#48#52#exact -1#50,51,52#53,54,55,56#para -1#53#57#exact -1#54#58#exact -1#55#59#exact -1#56#60#exact -1#58#62#exact -1#59#63#exact -1#68#64#exact -1#61#65#exact -1#62#66#exact -1#63#67#exact -1#64#68#exact -1#65#69#exact -1#66#70#exact -1#67#71#exact -1#69#73#exact -1#70#74#exact -1#71#75#exact -1#72#76#exact 


According to the result in Table 9 , the VAR_SPLIT criterion gives the highest WS performance .
According to the result in Table 9 , the VAR_SPLIT criterion gives the highest WS performance .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact 


With the exception of STRUCT_NC , all of the modifications to the original VTB corpus increase the performance of WS .
Except for STRUCT_NC , all the modifications to the original VTB corpus increase the performance of WS .
-1#5#1#exact -1#0,1#2,3#para -1#2#4#exact -1#3#5#exact -1#4#6#exact -1#15#7#exact -1#13#8#exact -1#6#9#exact -1#7#10#exact -1#8#11#exact -1#9#12#exact -1#10#13#exact -1#11#14#exact -1#12#15#exact -1#14#16,17#para -1#16#19#exact -1#17#20#exact 


However , the word segmentation criterion with higher performance is not necessarily a better criterion , but a criterion should also be judged through applications of word segmentation .
However , the word segmentation criterion with higher performance is not necessarily a better criterion , but a criterion should also be judged through applications of word segmentation .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact 


In both SMT and TC experiments , the BASE model , which is based on the manually-modified inconsistency of special characters , achieved better results than the ORG model .
In both SMT and TC experiments , the BASE model which is based on the manually-modified inconsistency of special characters , achieved better results than the ORG model .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#20#10#exact -1#12,13#11,12,13,14#para -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact -1#28#29#exact 


In particular , in the TC experiment , the BASE model achieved 0 .66 point higher than ORG , which is a significant improvement .
In particular , in the TC experiment , the BASE model achieved 0 .66 point higher than ORG , which is a significant improvement .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact 


Face retrieval in large-scale news video datasets
Face retrieval on large-scale news video datasets
-1#0#0#exact -1#1#1#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact 


Face retrieval in news video has been identified as a challenging task due to huge variations in the visual appearance of the human face .
Face retrieval in news video has been identified as a challenging task due to huge variations in visual appearance of human face .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21,22#para -1#21#23#exact -1#22#24#exact 


Although several approaches have been proposed to deal with this problem , their extremely high computational cost limits their scalability to large-scale video datasets that may contain millions of faces of hundreds of characters .
Although there are several approaches proposed to cope with this problem , their extremely high computational cost limits their scalability on largescale video datasets that may contain millions faces of hundreds characters .
-1#0#0#exact -1#3#1#exact -1#4#2#exact -1#2#3,4#para -1#5#5#exact -1#6#6#exact -1#7,8#7,8#para -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#29#28#exact -1#28#29#exact -1#30#30,31#para -1#31#33#exact -1#32#34#exact 


In this paper , we introduce approaches to face retrieval that are scalable to such datasets while maintaining competitive performances with state-of-the-art approaches .
In this paper , we introduce approaches for face retrieval which are scalable on such datasets while maintaining competitive performances with the state-of-the-art approaches .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#8#8#exact -1#9#9#exact -1#10,11#10,11#para -1#12#12#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#22#21#exact -1#23#22#exact -1#24#23#exact 


To utilize the variability of face appearances in video , we use a set of face images called face track to represent the appearance of a character in a video shot .
To utilize the variability of face appearances in video , we use a set of face images called face-track to represent for the appearance of a character in a video shot .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#19#20#exact -1#20#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact 


Our first proposal is an approach to extracting face tracks .
Our first proposal is an approach for extracting face-tracks .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#7#7#exact -1#9#10#exact 


We use a point tracker to explore the connections between detected faces belonging to the same character and , then group them into one face track .
We use a point tracker for exploring the connections between detected faces belonging to the same character , then grouping them into one face-track .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#13#5#exact -1#6,7#6,7#para -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#14,15#13,14,15#para -1#16#16#exact -1#17#18#exact -1#18#19#exact -1#19#20#stem -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#24#26#exact 


We present techniques to make the approach robust to common problems caused by sudden illumination changes , partial occlusions , and scattered appearances of characters in news videos .
We present techniques to make the approach robust to common problems caused by sudden illumination changes , partial occlusions , and scattered appearances of characters in news videos .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact 


In the second proposal , we introduce an efficient approach to matching face tracks for retrieval .
In the second proposal , we introduce an efficient approach to match face-tracks for retrieval .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#stem -1#13#14#exact -1#14#15#exact -1#15#16#exact 


Instead of using all the faces in the face tracks to compute their similarity , our approach selects representative faces for each face track .
Instead of using all faces in face-tracks to compute their similarity , our approach select representative faces for each face-track .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#5#exact -1#5#6#exact -1#16#8#stem -1#7#10#exact -1#8#11#exact -1#9#12#exact -1#10#13#exact -1#11#14#exact -1#12#15#exact -1#13#16#exact -1#14#17#stem -1#15#18#exact -1#17#20#exact -1#18#21#exact -1#20#24#exact 


The representative faces are sampled from the original face track .
The representative faces are sampled from the original face-track .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#9#10#exact 


As a result , we significantly reduce the computational cost of face-track matching while taking into account the variability of faces in face tracks to achieve high matching accuracy .
As a result , we significantly reduce the computational cost for face-track matching while taking into account variability of faces in face-tracks for high matching accuracy .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#18#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14,15,16#14,15,16,17#para -1#17#18#exact -1#19#20#exact -1#20#21#exact -1#23#26#exact -1#24#27#exact -1#25#28#exact -1#26#29#exact 


Experiments are conducted on two face-track datasets extracted from real-world news videos , of such .
Experiments are conducted on two face-track datasets extracted from real-world news videos , .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#15#exact 


scales that have never been considered in the literature .
Their scales have not been considered in literature ever .
-1#1#0#exact -1#2#2#exact -1#3#3#para -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#8#exact -1#9#9#exact 


One dataset contains 1,497 face tracks of 41 characters extracted from 370 hours of TRECVID videos .
One dataset contains 1,497 face-tracks of 41 characters extracted from 370 hours of TRECVID videos .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact 


The other dataset provides 5,567 face tracks of 111 characters observed from a television news program ( NHK News 7 ) over 11 years .
The other dataset provides 5,567 face-tracks of 111 characters observed from television news program ( NHK News 7 ) channel in 11 years .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#13#exact -1#12#14#exact -1#13#15#exact -1#14#16#exact -1#15#17#exact -1#16#18#exact -1#17#19#exact -1#18#20#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact 


We make both datasets public for the research community .
We make both datasets public for research community .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6,7#para -1#7#8#exact -1#8#9#exact 


The experimental results show that our proposed approaches achieved a remarkable balance between accuracy and efficiency.
The experimental results demonstrate that our proposed approaches achieved a remarkable balance between accuracy and efficiency.
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3,4#3,4#para -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact 


News videos play an important role as a source of information nowadays because of their rich and relevant contents .
News videos play an important role in our sources of information nowadays because of their rich and important contents .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5,6#5,6#para -1#8#7,8#para -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16,17#16,17#para -1#18#18#exact -1#19#19#exact 


With the advances in modern technology , a huge amount of news videos can be obtained easily .
With the advances of modern technology , a huge amount of news videos can be obtained easily .
-1#0#0#exact -1#1#1#exact -1#2,3#2,3#para -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7,8#7,8,9,10#para -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact 


Accordingly , this creates an urgent demand to retrieve useful information from such news video datasets .
Accordingly , it creates an urgent demand for retrieving useful information in such news video datasets .
-1#0#0#exact -1#1#1#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6,7#6,7#para -1#8#8#stem -1#9#9#exact -1#10#10#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact 


Because most news are related to people , human face retrieval , which is defined as the task of extracting and returning faces relevant to a given query , obviously becomes an important task .
Since most of the news is related to human , human face retrieval , which is defined as the task of extracting and returning faces relevant to a given query , obviously becomes an important task .
-1#0,1#0,1#para -1#4#2#exact -1#5#3#syn -1#6#4#exact -1#7#5#exact -1#8#6#para -1#9#7#exact -1#10#8#exact -1#11#9#exact -1#12#10#exact -1#13#11#exact -1#14#12#exact -1#15#13#exact -1#16#14#exact -1#17#15#exact -1#18#16#exact -1#19#17#exact -1#20#18#exact -1#21#19#exact -1#22#20#exact -1#23#21#exact -1#24#22#exact -1#25#23#exact -1#26#24#exact -1#27#25#exact -1#28#26#exact -1#29#27#exact -1#30#28#exact -1#31#29#exact -1#32#30#exact -1#33#31#exact -1#34#32#exact -1#35#33#exact -1#36#34#exact 


A robust face retrieval system for large-scale news video datasets is indeed of much benefit in a wide range of applications .
A robust face retrieval system on large-scale news video datasets is indeed of much benefit to a wide range of applications .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact 


For example , by applying face retrieval to a news video dataset , we are returned a list of relevant shots or scenes containing the appearance of a selected well-known character .
For example , by applying face retrieval to a news video dataset , we are returned a list of relevant shots or scenes containing appearance of a selected well-known character .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24,25#para -1#25#26#exact -1#26#27#exact -1#27#28#exact -1#28#29#exact -1#29#30#exact -1#30#31#exact 


With such a list , important events related to the character can be found or summarized.
With the list , important events related to the character can be detected or summarized.
-1#0#0#exact -1#1,2#1,2,3#para -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#syn -1#13#14#exact -1#14#15#exact 


However , developing an accurate face retrieval system is not a trivial task because of the fact that the imaged appearance of a face changes dramatically under large variations in poses , facial expressions , and complex capturing conditions .
However , developing an accurate face retrieval system is not a trivial task because of the fact that imaged appearance of a face changes dramatically under large variations in poses , facial expressions , and complex capturing conditions .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#15,16,17#14,15,16,17#para -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact -1#28#29#exact -1#29#30#exact -1#30#31#exact -1#31#32#exact -1#32#33#exact -1#33#34#exact -1#34#35#exact -1#35#36#exact -1#36#37#exact -1#37#38#exact -1#38#39#exact 


Besides accuracy , efficiency is also an issue in such a face retrieval system because the scales of available datasets are rapidly getting larger , for instance , exceeding thousands of hours of videos with millions of faces of hundreds of characters .
On the other hand , efficiency is also an issue of such a face retrieval system beside its accuracy since scales of available datasets are getting larger rapidly , for instance , exceeding thousands hours of videos with millions faces of hundreds character .
-1#18#1#exact -1#4#2#exact -1#5#3#exact -1#6,7#4,5,6,7#para -1#11#9#exact -1#12#10#exact -1#13#11#exact -1#14#12#exact -1#15#13#exact -1#1#15#exact -1#20#16#exact -1#21#17#exact -1#22#18#exact -1#23#19#exact -1#24#20#exact -1#27#21#exact -1#25#22#exact -1#26#23#exact -1#28#24#exact -1#29#25#exact -1#30#26#exact -1#31#27#exact -1#32#28#exact -1#33#29#exact -1#34,35#30,31#para -1#10#32#exact -1#36#33#exact -1#37#34#exact -1#38#35#exact -1#40#36#exact -1#39#37#exact -1#41#38,39#para -1#42#41#stem -1#43#42#exact 


Thus , accurate and efficient approaches to face retrieval are always required.
Thus , accurate and efficient approaches for face retrieval are always required.
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5,6#5,6#para -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact 


Generally , a face retrieval system consists of two principal steps .
Generally , there are two principle steps in a face retrieval system .
-1#0#0#exact -1#1#1#exact -1#8#2#exact -1#9#3#exact -1#10#4#exact -1#11#5#exact -1#3#6#para -1#4#7,8#para -1#6#10#exact -1#12#11#exact 


The first step is extracting the appearance of faces in videos .
The first step is extracting appearance of faces in video .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#stem -1#10#11#exact 


, The second step is matching the extracted appearances with a given query so as to return a rank list .
And , the second step is matching the extracted ones with a given query to return a rank list .
-1#1#0#exact -1#2#1#lc -1#3#2#exact -1#4#3#exact -1#5#4#exact -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact 


Whereas conventional approaches consider single face images as the basic units in extracting and matching \CITE , recently proposed approaches shifted toward the use of sets of face images called face tracks .
While conventional approaches consider single face images as the basic units for extracting and matching \CITE , recently proposed approaches sifted towards sets of face images called face-tracks .
-1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#21#21,22#para -1#23#24#exact -1#22#25#exact -1#24#27#exact -1#25#28#exact -1#26#29#exact -1#28#32#exact 


A face track contains multiple face images belonging to the same individual character within a video shot .
A face-track contains multiple face images belonging to the same individual character within a video shot .
-1#0#0#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact 


The face images in a face track may present the corresponding character from different viewpoints and with different facial expressions ( as shown in Figure 1 ) .
Face images in a face-track may present the corresponding character under different viewpoints and facial expressions ( as shown in Figure 1 ) .
-1#7#0#lc -1#0#1#lc -1#1#2#exact -1#2#3#exact -1#3#4#exact -1#5#7#exact -1#6#8#exact -1#8#9,10#para -1#9#11#exact -1#11#12,13#para -1#12#14#exact -1#13#15#exact -1#14#18#exact -1#15#19#exact -1#16#20#exact -1#17#21#exact -1#18#22#exact -1#19#23#exact -1#20#24#exact -1#21#25#exact -1#22#26#exact -1#23#27#exact 


By exploiting the plenteous information from the multiple exemplar faces in the face tracks , face track-based approaches are expected to achieve a more robust and stable performance.
By exploiting the plenteous information from multiple exemplar faces in face-tracks , face-track based approaches are expected to achieve more robust and stable performance.
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6,7#para -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#11#14#exact -1#14#17#exact -1#15#18#exact -1#16#19#exact -1#17#20#exact -1#18#21#exact -1#19#23#exact -1#20#24#exact -1#21#25#exact -1#22#26#exact -1#23#27#exact 


Once all the face tracks in the video shots are extracted , they are matched with the query to return a ranked list as the output of the face retrieval system .
Once all face-tracks in video shots are extracted , they are matched with the query to return a ranked list as the output of the face retrieval system .
-1#0#0#exact -1#1#1#exact -1#24#2#exact -1#25#3#exact -1#3#5#exact -1#13#6#exact -1#4#7#exact -1#5#8#exact -1#6#9#exact -1#7#10#exact -1#8#11#exact -1#9#12#exact -1#10#13#exact -1#11#14#exact -1#12#15#exact -1#21#16#exact -1#14#17#exact -1#15#18#exact -1#16#19#exact -1#17#20#exact -1#18#21#exact -1#19#22#exact -1#20#23#exact -1#22#24,25#para -1#23#26#exact -1#26#29#exact -1#27#30#exact -1#28#31#exact 


Because each face track is a set of face images , matching face tracks can essentially be thought of as a problem of matching image sets .
Since each face-track is a set of face images , matching face-tracks essentially can be thought of as a problem of matching image sets .
-1#0,1#0,1#para -1#7#2#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#13#14#exact -1#12#15#exact -1#14#16#exact -1#15,16,17,18#17,18,19#para -1#19#20,21#para -1#20#22#exact -1#21#23#exact -1#22#24#exact -1#23#25#exact -1#24#26#exact 


Several approaches have been introduced to deal with this problem \CITE .
There are several approaches introduced to deal with this problem \CITE .
-1#2#0#lc -1#3#1#exact -1#1#2,3#para -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact 


They differ in the ways in which the sets are modeled and the similarity between sets is computed .
They differ in the ways in which the sets are modeled and the similarity between sets is computed .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact 


Using these approaches , the image set has been modeled in different ways , including as distributions \CITE , subspaces \CITE , a convex geometric region in a feature space \CITE , or more general manifolds \CITE .
In these works , image set has been modeled in different way , such as distributions \CITE , subspaces \CITE , convex geometric region in feature space \CITE , or more general manifolds \CITE .
-1#1#1#exact -1#3#3#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#stem -1#12#13#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#23#exact -1#22#24#exact -1#23#25#exact -1#24#26#exact -1#25#28#exact -1#26#29#exact -1#27#30#exact -1#28#31#exact -1#29#32#exact -1#30#33#exact -1#31#34#exact -1#32#35#exact -1#33#36#exact -1#34#37#exact 


Although these approaches have shown promising results in benchmark datasets , they require high computational costs to characterize the representation of face tracks , such as computing the convex geometric region in \CITE , the probability in \CITE , and the eigenvectors in \CITE .
Although these approaches shown promising results on benchmark datasets , they require high computational costs to characterize the representation of face-tracks , such as computing the convex geometric region in \CITE , the probability in \CITE , and the eigenvectors in \CITE .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#29#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#21#23#exact -1#22#24#exact -1#23#25#exact -1#24#26#exact -1#25#27#exact -1#26#28#exact -1#27#29#exact -1#28#30#exact -1#34#31#exact -1#35#32#exact -1#36#33#exact -1#32#34#exact -1#33#35#exact -1#40#36#exact -1#41#37#exact -1#31#38#exact -1#37#39#exact -1#38#40#exact -1#39#41#exact -1#30#43#exact -1#42#44#exact 


Their complexity in modeling face tracks and estimating the similarity between face tracks limits their practicability in large-scale datasets.
Their complexity in modeling facetracks and estimating similarity between face-tracks limits their practicability on large-scale datasets.
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#5#6#exact -1#6#7#exact -1#7#9#exact -1#8#10#exact -1#10#13#exact -1#11#14#exact -1#12#15#exact -1#14#17#exact -1#15#18#exact 


This paper provides a threefold contribution toward solving the above problems , .
Working toward solving the above problems , our contributions in this paper is three-fold.
-1#10#0#lc -1#11#1#exact -1#12#2#para -1#1#6#exact -1#2#7#exact -1#3#8#exact -1#4#9#exact -1#5#10#exact -1#6#11#exact 


Robust face-track extraction from news video .
Robust face-track extraction on news video .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact 


To enhance the performance of face-track matching , face tracks should first be extracted accurately .
To enhance the performance of face-track matching , face-tracks should be first extracted accurately .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#9#10#exact -1#10,11#11,12#para -1#12#13#exact -1#13#14#exact -1#14#15#exact 


For this purpose , we introduce an approach .
, We introduce an approach for this purpose .
-1#5#0#lc -1#6#1#exact -1#7#2#exact -1#0#3#exact -1#1#4#lc -1#2#5#exact -1#3#6#exact -1#4#7#exact -1#8#8#exact 


motivated by a study of Everingham et al .
Our approach is motivated by a study of Everingham et al .
-1#3#0#exact -1#4#1#exact -1#5#2#exact -1#6#3#exact -1#7#4#exact -1#8#5#exact -1#9#6#exact -1#10#7#exact -1#11#8#exact 


The basic idea is to use a point tracker ( Kanade-Lucas-Tomasi tracker \CITE ) to establish the connections between faces belonging to the same character in consecutive frames of a shot .
The basic idea is to employ a point tracker ( Kanade-Lucas-Tomasi tracker \CITE ) to establish the connections between faces belonging to the same character in consecutive frames of a shot .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5,6#5,6#para -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact 


Our approach incorporates techniques to overcome specific problems with news video caused by sudden illumination change and partial occlusion , in contrast to the approach in \CITE , which failed to deal with , these problems .
, In constrast to the approach in \CITE , which is failed to deal with specific problems of news video caused by sudden illumination change and partial occlusion , our approach is incorporated techniques to overcome the problems .
-1#29#0#lc -1#30#1#exact -1#31,32#2#para -1#33#3#exact -1#34#4#exact -1#35#5#exact -1#15#6#exact -1#16#7#exact -1#14#8#exact -1#18#9#exact -1#19#10#exact -1#20#11#exact -1#21#12#exact -1#22#13#exact -1#23#14#exact -1#24#15#exact -1#25#16#exact -1#26#17#exact -1#27#18#exact -1#28#19#exact -1#1#20#lc -1#3#22#exact -1#4#23#exact -1#5#24#exact -1#6#25#exact -1#7#26#exact -1#8#27#exact -1#9#28#exact -1#11#29#exact -1#12#30#exact -1#13#31#exact -1#0#33#exact -1#36,37#34,35#para -1#38#36#exact 


Evaluations of a collection of real-world news videos showed that our proposed face-track extraction approach achieved approximately 95% accuracy , a significant improvement compared to the approach in \CITE .
Evaluations on a collection of real-world news videos showed that our proposed face-track extraction approach achieved approximately 95% accuracy , a significant improvement compare the approach in \CITE .
-1#0#0#exact -1#4#1#exact -1#2#2#exact -1#3#3#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#stem -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact -1#28#29#exact 


Efficient face-track matching .
Efficient face-track matching .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact 


We introduce an approach that significantly reduces the computational cost for face-track matching while maintaining a competitive performance with state-of-the-art approaches .
We introduce an approach which significantly reduces the computational cost for face-track matching while maintaining a competitive performance compare to those of the state-of-the-art approaches .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3,4#3,4#para -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#23#19#exact -1#24#20#exact -1#25#21#exact 


Based on the observation that face tracks obtained by tracking provide highly similar faces in consecutive frames , we argue that it is redundant to use all the faces in a face track for learning the variation of faces .
Based on the observation that face-tracks obtained by tracking provide highly similar faces in consecutive frames , we argue that it is redundant to use all faces in a face-track for learning the variation of faces .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#12#5#stem -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#26#13#exact -1#27#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#32#27#exact -1#35#28#exact -1#13#29#exact -1#28#30#exact -1#30#33#exact -1#31#34#exact -1#33#35,36#para -1#34#37#exact -1#36#39#exact 


Thus , a set of faces is sampled from the original face track for matching .
Thus , a set of faces is sampled from the original face-track for matching .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact 


The size of the set is much smaller than that of the original face track .
The size of the set is much smaller than the size of original face-track .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#11#10#exact -1#9#11#exact -1#12#12#exact -1#14#15#exact 


The , mean face of the sampled faces in the set is then computed .
Then , the mean face of sampled faces in the set is computed .
-1#2#0#lc -1#1#1#exact -1#3#2#exact -1#4#3#exact -1#5#4#exact -1#9#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#10#10#exact -1#11#11#exact -1#0#12#lc -1#12#13#exact -1#13#14#exact 


The similarity between two face tracks is the distance between their mean faces.
The similarity between two face-tracks is the distance between their mean faces.
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact 


Large-scale face-track datasets from real-world news videos .
Large-scale face-track datasets from real-world news videos .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact 


We investigated the problem of face retrieval in news video datasets whose scales have never been considered in the literature .
We investigated the problem of face-retrieval on news video datasets whose scales have not been considered in literature ever .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#16#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13,14#14,15#para -1#15#16#exact -1#17#19#exact -1#19#20#exact 


Our first dataset is from 370 hours of TRECVID news videos and contains 405,887 detected faces belonging to 41 individuals .
Our first dataset is from 370 hours TRECVID news videos which contains 405,887 detected faces belonging to 41 individuals .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact 


The second dataset includes 1.2 million faces of 111 individuals observed in the NHK News 7 program over 11 years .
The second dataset is observed from NHK News7 channel in 11 years .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#4#10#exact -1#9#11#exact -1#6#13#exact -1#10#18#exact -1#11#19#exact -1#12#20#exact 


, .
In this dataset , 1.2 millions faces of 111 individuals are provided .
-1#3#0#exact -1#12#1#exact 


The total number of available face tracks is 5,567 .
The total number of available face-track is 5,567 .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact 


The number of occurrences of each individual character varies from 4 to 550 .
Number of occurrence of each individual character varies from 4 to 550 .
-1#0#1#lc -1#1#2#exact -1#2#3#stem -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact 


Both datasets are published for the research community.
Both datasets are published for the research community.
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact 


The remainder of this paper is organized as follows .
The remaining of this paper is organized as follows .
-1#0,1#0,1#para -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact 


In Section 2 , we introduce related works in detail .
In Section 2 , we introduce related works in details .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#stem -1#10#10#exact 


Sections 3 and 4 describe our approaches to face-track extraction and matching , respectively .
Section 3 and Section 4 describe our face-track extraction and matching , approaches respectively .
-1#0#0#stem -1#1#1#exact -1#2#2#exact -1#4#3#exact -1#5#4#exact -1#6#5#exact -1#12#6#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#13#13#exact -1#14#14#exact 


Section 5 presents our experimental settings , and Section 6 provides our .
Section 5 presents our experimental settings , .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#12#exact 


conclusions.
Conclusion is given in the final Section 6.



Face-track extraction .
Face-track extraction .
-1#0#0#exact -1#1#1#exact -1#2#2#exact 


Face-track extraction is a key step in a video-based face retrieval system .
Face-track extraction is a key step in a video-based face retrieval system .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact 


The existing studies on automatic face-track extraction follow a standard paradigm that consists of two basic steps , detecting faces in frames and grouping faces of the same character into face tracks .
Existing studies on automatic face-track extraction follow a standard paradigm that consists of two basic steps , detecting faces in frames and grouping faces of the same character into face-tracks .
-1#25#0#lc -1#0#1#lc -1#1#2#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#26#27#exact -1#27#28#exact -1#28#29#exact -1#30#32#exact 


In the first step , the Viola-Jones detector is usually used to detect near frontal faces in frames of videos .
In the first step , Viola-Jones detector is usually employed to detect near frontal faces in frames of videos .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9,10#10,11#para -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact 


, In the second step , the detected faces of the same character are grouped by using either clustering \CITE or tracking approaches \CITE .
Then , in the second step , detected faces of the same character will be grouped by using either clustering approaches \CITE or tracking approaches \CITE .
-1#1#0#exact -1#2#1#lc -1#3#2#exact -1#4#3#exact -1#5#4#exact -1#6#5#exact -1#10#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#11#11#exact -1#12#12#exact -1#13,14#13#para -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#21#19#exact -1#22#20#exact -1#23#21#exact -1#24#22#exact -1#25#23#exact -1#26#24#exact 


In \CITE , Ramanan et al .
In \CITE , Ramanan et al .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact 


built a color histogram for the hair , face , and torso associated with each detected face in a frame .
builds a color histogram for the hair , face , and torso associated with each detected face in a frame .
-1#0#0#syn -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact 


A concatenated vector of the normalized color histogram represented the face .
A concatenated vector of the normalized color histograms represents the face .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#stem -1#8,9#8,9#para -1#10#10#exact -1#11#11#exact 


They then clustered all vectors to obtain groups of similar faces , using agglomerative clustering .
They then cluster all vectors to obtain groups of similar faces , using agglomerative clustering .
-1#0#0#exact -1#1#1#exact -1#2#2#stem -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact 


The limitations of this approach include its high computational cost for constructing and clustering high-dimensional representation feature vectors and , its dependence on determining a reasonable threshold for the clustering algorithm to ensure that no group contains faces of multiple characters and that groups are not over-fragmented.
Limitations of this approach includes the expensive computational cost for constructing and clustering high dimensional representation feature vectors; and , its dependence on determining a reasonable threshold for the clustering algorithm to ensure no group contains faces of multiple characters and groups are not over-fragmented.
-1#5#0#lc -1#0#1#lc -1#1#2#exact -1#2#3#exact -1#3#4#exact -1#4#5#stem -1#20#6#exact -1#13#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#15#15#exact -1#16#16#exact -1#18#18#exact -1#19#19#exact -1#21,22#20,21,22#para -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#34#exact -1#34#35#exact -1#35#36#exact -1#36#37#exact -1#37#38#exact -1#38#39#exact -1#39#40#exact -1#40#41#exact -1#41#43#exact -1#42#44#exact -1#43#45#exact -1#44#46#exact 


On the other hand , Everingham et al .
On the other hand , Everingham etl al .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#7#7#exact -1#8#8#exact 


\CITE and Sivic et al .
in \CITE and Sivic et al .
-1#1#0#exact -1#2#1#exact -1#3#2#exact -1#4#3#exact -1#5#4#exact -1#6#5#exact 


In \CITE , an affine covariance tracker of \CITE is used .
In \CITE , an affine covariance tracker of \CITE is used .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact 


This tracker can develop tracks on deforming objects , where the between-frame region deformation can be modeled by an affine geometric transformation plus perturbations .
This tracker can develop tracks on deforming objects , where the between frame region deformation can be modelled by an affine geometric transformation plus perturbations .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#stem -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact -1#23#22#exact -1#24#23#exact -1#25#24#exact 


The outcome is that a face can be tracked ( by the collection of regions on it ) through significant pose variations and expression changes , allowing the association of possibly distant face detections .
The outcome is that a face can be tracked ( by the collection of regions on it ) through significant pose variations and expression changes , allowing association of possibly distant face detections .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27,28#27,28,29#para -1#29#30#exact -1#30#31#exact -1#31#32#exact -1#32#33#exact -1#33#34#exact 


The disadvantage of this tracker is its high computational cost for locating and tracking affine covariance regions .
The disadvantage of this tracker is the computational cost for locating and tracking affine covariance regions .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact 


Another way of using a tracker was introduced by Everingham et al .
Another way of using tracker is introduced by Everingham et al .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#5#exact -1#5#6#syn -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact 


in \CITE , in which .
in \CITE , .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#5#exact 


they used a Kanade-Lucas-Tomasi ( KLT ) tracker to create a set of point tracks starting at some frame in a shot and continuing until some later frame .
The authors employ Kanade-Lucas-Tomasi ( KLT ) tracker to create a set of point tracks starting at some frame in a shot and continuing until some later frame .
-1#10#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#20#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact 


Grouping faces in different frames for one character is based on enumerating the track points shared between faces .
Grouping faces in different frames of one character is based on enumerating track points shared between faces .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact 


Although using tracking is an efficient solution , it may return poor tracking results because trackers are very sensitive to illumination changes and partial occlusions .
Although using tracking is an efficient solution , it may return poor tracking results since trackers are very sensitive to illumination changes and partial occlusions .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact 


Face-track matching .
Face-track matching .
-1#0#0#exact -1#1#1#exact -1#2#2#exact 


There are two major categories of approaches to using multiple exemplars of faces in face tracks ( i.e. , sets of face images ) for robust face matching and recognition .
There are two major categories of approaches target to employ multiple-exemplar of faces in face-tracks ( i.e. , sets of face images ) for robust face matching and recognition .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#8#7#exact -1#9#8#syn -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#20#14#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#25#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#26#27#exact -1#27#28#exact -1#28#29#exact -1#29#30#exact 


The approaches in the first category \CITE make use of both face images and the temporal order of their appearances .
Approaches in the first category \CITE make use of both face images and temporal order of their appearances .
-1#0#1#lc -1#1#2#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#15#exact -1#14#16#exact -1#15#17#exact -1#16#18#exact -1#17#19#exact -1#18#20#exact 


The face dynamics within the video sequence are modeled and exploited to improve recognition accuracy .
Face dynamics within the video sequence are modeled and exploited to improve recognition accuracy .
-1#0#1#lc -1#1#2#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact 


For instance , Li et al .
For instance , Li et al .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact 


Edwards et al .
Edwards et al .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact 


They then used the trained statistical face model to incorporate identity evidence over a sequence .
They than use the trained statistical face model to incorporate identity evidence over a sequence .
-1#0#0#exact -1#2,3#2,3#para -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact 


In \CITE , Liu and Chen used an adaptive hidden Markov model ( HMM ) for this face recognition problem .
In \CITE , Liu and Chen use an adaptive Hidden Markov Model ( HMM ) for this face recognition problem .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#stem -1#7#7#exact -1#8#8#exact -1#9#9#lc -1#10#10#exact -1#11#11#lc -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact 


In the training face , they created a HMM for each character to learn the statistics and temporal dynamics using the eigen-face image sequence .
In the training face , they create a HMM model for each character to learn the statistics and temporal dynamics using the eigen-face image sequence .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#stem -1#7#7#exact -1#8#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact -1#23#22#exact -1#24#23#exact -1#25#24#exact 


The implicit constraint of these approaches is that the dynamics of faces should be temporally consecutive .
The implicit constraint of these approaches is that dynamics of faces should be temporally consecutive .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8,9#8,9,10#para -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact 


In general , this constraint is not always satisfied.
In general , this constraint is not always satisfied.
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact 


Without relying on temporal coherence between consecutive images , the approaches in the second category use multiple face images only and .
Without relying on temporal coherence between consecutive images , approaches in the second category uses multiple face images only .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#11#9#exact -1#9#10#exact -1#10#11#exact -1#12#12,13#para -1#13#14#exact -1#14#15#stem -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#21#exact 


treat the problem as a set-matching problem .
They treat the problem as a set matching problem .
-1#1#0#exact -1#2#1#exact -1#3#2#exact -1#4#3#exact -1#5#4#exact -1#8#6#exact -1#9#7#exact 


These approaches are differentiated based on the ways in which the sets are modeled and the similarity between sets is computed .
These approaches are differentiated based on the ways in which the sets are modeled and the similarity between sets is computed .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#7,8,9#6,7,8,9#para -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact 


Shakhnarovich et al .
Shakhnarovich et al .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact 


However , to make the computation tractable , they made the assumption that faces are normally distributed , which may not be true \CITE .
However , to make the computation tractable , they made a assumption that faces are normally distributed , which may not be true \CITE .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact 


Cevikalp and Triggs \CITE claimed that a face sequence is a set of points and discovered a convex geometric region expanded by these points .
Cevikalp and Triggs \CITE claimed a face sequence was a set of points and discovered a convex geometric region expanded by these points .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8,9,10,11#9,10,11,12#para -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact 


The min-min approach \CITE considered a face sequence as a cluster of points and measured the distance between these clusters .
The min-min approach \CITE considered a face sequence as a cluster of points and measured the distance between these clusters .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact 


Subspace methods \CITE viewed a face sequence as points spread over a subspace .
Subspace methods \CITE viewed a face sequence as points spread over a subspace .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact 


Although these methods can be highly accurate , a lot of computation is needed to represent the distribution of the face sequence , such as computing the convex hulls in \CITE , the probability models in \CITE , and the eigenvectors in \CITE .
Although these methods can be highly accurate , a lot of computation is needed to represent the distribution of the face sequence , such as computing the convex hulls in \CITE , the probability models in \CITE , and the eigenvectors in \CITE .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact -1#37#37#exact -1#38#38#exact -1#39#39#exact -1#40#40#exact -1#41#41#exact -1#42#42#exact -1#43#43#exact 


For this reason , they are not scalable to large-scale video datasets .
For this reason , they are not scalable for large-scale video datasets .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact 


Face datasets .
Face Datasets .
-1#0#0#exact -1#1#1#lc -1#2#2#exact 


In evaluating the performance of face-matching approaches , most of the recent works on face retrieval in video use two benchmark datasets: Mobo ( Motion of Body ) \CITE and Honda / UCSD \CITE .
To evaluate performance of face matching approaches , most of recent works on face retrieval in video uses two benchmark datasets Mobo ( Motion of Body ) \CITE and Honda / UCSD \CITE .
-1#15#0#lc -1#2#3#exact -1#3#4#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10,11#para -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#16#17#exact -1#17#18#stem -1#18#19#exact -1#19#20#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact -1#28#29#exact -1#29#30#exact -1#30#31#exact -1#31#32#exact -1#32#33#exact -1#33#34#exact 


The scales of these datasets are limited , varying from hundreds to thousands of face images of tens of individual characters .
Scales of these datasets are limited , they are varying from hundreds to thousands face images of tens individual characters .
-1#0#1#lc -1#1#2#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#16#13#exact -1#14#14#exact -1#15#15#exact -1#17#16,17,18#para -1#18#19#exact -1#19#20#exact -1#20#21#exact 


Particularly , Honda / UCSD consists of 75 videos involving 20 individuals .
Particularly , Honda / UCSD consists of 75 videos involving 20 individual .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#stem -1#12#12#exact 


Each video contains approximately 300-500 frames .
Each video contains approximately 300-500 frames .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact 


Meanwhile , Mobo provides 96 image sets of 24 individuals .
Meanwhile , Mobo provides 96 image sets of 24 individuals .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact 


Hence , there are only 4 image sets for each individual .
Hence , there are only 4 image sets for each individual .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact 


One of the largest face datasets recently available is the YouTube Faces dataset \CITE , which .
One of the largest available face dataset recently is the Youtube Faces dataset \CITE , .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#5#4#exact -1#6#5#stem -1#7#6#exact -1#4#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#lc -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#16#exact 


provides 3,425 videos of 1,595 individual characters .
It provides 3,425 videos of 1,595 individual characters .
-1#1#0#exact -1#2#1#exact -1#3#2#exact -1#4#3#exact -1#5#4#exact -1#6#5#exact -1#7#6#exact -1#8#7#exact 


However , each character has only around 2.15 videos .
However , one character has only around 2.15 videos .
-1#0#0#exact -1#1#1#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact 


Such a small number of samples for each character is not sufficient to stably evaluate a face-matching or recognition approach , which is an important part of a face retrieval system .
Such a small number of samples for each character is not sufficient for stably evaluating a face matching or recognition approach , which is an important part of a face retrieval system .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9,10,11,12#9,10,11,12#para -1#13#13#exact -1#14#14#stem -1#15#15#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact -1#23#22#exact -1#24,25,26#23,24,25,26#para -1#28#27#exact -1#29#28#exact -1#30#29#exact -1#31#30#exact -1#32#31#exact 


In addition , there is no face dataset related to real-world news videos , which is our targeted domain .
In addition , there is no face dataset related to real-world news videos , which is our targeted domain .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact 


In view of all the above-mentioned considerations , we prepare new datasets for evaluating the approaches.
Because of all above mentioned reasons , we prepare new datasets for evaluating the approaches.
-1#0#0,1#para -1#1#2#exact -1#2#3#exact -1#13#4#exact -1#5#6#para -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#14#15#exact 


Figure 2 illustrates the overview of our framework .
Figure 2 illustrates the overview of our framework .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact 


In the off-line stage , the face tracks in all video shots are extracted using our face-track extraction approach ( described in Section 4 ) .
In the offline stage , face-tracks in all shots of videos are extracted using our face-track extraction approach ( described in Section 4 ) .
-1#0#0#exact -1#1#1#exact -1#3#3#exact -1#4#4#exact -1#6#8#exact -1#7#9#exact -1#9,10#10#para -1#8#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact 


Each extracted face track contains multiple face images of one individual character , varied under different viewpoints , illumination conditions , and expressions within a shot .
One extracted face-track contains multiple face images of one individual character , varied under different viewpoints , illumination conditions , and expressions within a shot .
-1#1#1#exact -1#5#2#exact -1#3#4#exact -1#4#5#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact 


Each single face image in a face track is represented by a feature vector .
A single face image in a face-track is represented by a feature vector .
-1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact 


The process consisting of face-track extraction and face image representation is performed once for the entire video dataset .
The process consisting of face-track extraction and face image representation is performed once for the entire video dataset .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact 


Our contribution here is making the face-track extraction approach robust to sudden illumination changes , scattered appearances of characters , and occlusions.
Our contribution here is to make the face-track extraction approach robust to sudden illumination changes , scattered appearance of characters , and occlusions.
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#5,6#4,5#para -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#stem -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact 


Given a face track as an input retrieval query , the online stage of our system starts by using our proposed face-track matching algorithm ( described in Section 5 ) to estimate the similarity between a query face track and each face track in the retrieved set containing all face tracks extracted from the dataset in the offline stage .
Given a face-track as an input retrieval query , the online stage of our system starts by using our proposed face-track matching algorithm ( described in Section 5 ) to estimate the similarity between a query face-track and each face-track in the retrieved set containing all face-tracks extracted from the dataset in the offline stage .
-1#0#0#exact -1#1#1#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact -1#28#29#exact -1#29#30#exact -1#30#31#exact -1#31#32#exact -1#32#33#exact -1#33#34#exact -1#34#35#exact -1#35#36#exact -1#37#39#exact -1#38#40#exact -1#40#43#exact -1#41#44#exact -1#42#45#exact -1#43#46#exact -1#44#47#exact -1#45#48#exact -1#47#51#exact -1#48#52#exact -1#49#53#exact -1#50#54#exact -1#51#55#exact -1#52#56#exact -1#53#57#exact -1#54#58#exact -1#55#59#exact 


A ranked list of the evaluated face tracks is returned as the retrieval result of the online stage .
A ranked list of the evaluated face-tracks is returned as retrieval results of the online stage .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#13#11#exact -1#10#12#exact -1#11,12#13,14#para -1#14#16#exact -1#15#17#exact -1#16#18#exact 


Because the retrieved set is huge , our approach targets an extremely efficient face-track matching strategy while maintaining a competitive performance with state-of-the-art approaches.
Since the retrieved set is huge , our approach targets an extremely efficient face-track matching strategy while maintaining competitive performance with state-ofthe-art approaches.
-1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18,19#para -1#19#20#exact -1#20#21#exact -1#22#23#exact 


Given a video shot with occurrences of multiple characters , face-track extraction is the process of extracting sets of face images .
Given a video shot with occurrences of multiple characters , face-track extraction is the process of extracting sets of face images .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact 


A set is supposed to contain the face images of only one character who appears in the shot .
A set is supposed to contain face images of only one character who appears in the shot .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#15#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#16#17#exact -1#17#18#exact 


Such sets of face images are called face tracks ( sometimes called face sequences ) .
Such sets of face images are called face-tracks ( sometimes called face sequences ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#11#7#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact 


A common strategy in the existing approaches to face-track extraction consists in detecting faces in frames and grouping detected faces of the same character .
A common strategy of existing approaches for face-track extraction consists of detecting faces in frames and grouping detected faces of the same character .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#13#3#exact -1#20#4#exact -1#4#5#exact -1#5,6#6,7#para -1#7#8#exact -1#8#9#exact -1#9,10#10,11#para -1#11#12#exact -1#12#13#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact 


Whereas detecting faces is done by using a standard face detector ( e.g. , Viola-Jones face detector ) \CITE , grouping detected faces requires comprehensive techniques to identify faces of the same character.
While detecting faces is done by using a standard face detector ( e.g. , Viola-Jones face detector ) \CITE , grouping detected faces requires comprehensive techniques to identify faces of the same character.
-1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact 


In this section , we first briefly introduce an approach to face-track extraction proposed by Everingham et al .
In this section , we first briefly introduce an approach for face-track extraction proposed by Everingham et al .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact 


We then present the problems with this approach as applied to news video and our proposed solutions.
Its problems as it is applied to news video and our proposed solutions to overcome the problems is then presented.
-1#18#1#exact -1#15#3#exact -1#16#4#exact -1#2#8#exact -1#5#9#exact -1#6#10#exact -1#7#11#exact -1#8#12#exact -1#9#13#exact -1#10#14#exact -1#11#15#exact 


To group detected faces into face tracks , connections should be established between faces belonging to the same character in different frames .
To group detected faces into face-tracks , connections between faces belonging to the same character in different frames should be established .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#9#5#stem -1#6#7#exact -1#7#8#exact -1#18#9#exact -1#19#10#exact -1#20#11#exact -1#8#12#exact -1#10#14#exact -1#11#15#exact -1#12#16#exact -1#13#17#exact -1#14#18#exact -1#15#19#exact -1#16#20#exact -1#17#21#exact -1#21#22#exact 


Motion analysis can be used to investigate such connections .
Motion analysis can be used to investigate such connections .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact 


If two faces in different frames are defined that they are translated faces of each other according to a motion , they are likely faces of the same character .
If two faces in different frames are defined that they are translated faces of each other according to a motion , they are likely faces of the same character .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact 


Everingham et al .
Everingham et al .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact 


in \CITE proposed the use of a KLT tracker for this purpose .
in \CITE propose to use KLT tracker for this purpose .
-1#0#0#exact -1#1#1#exact -1#2#2#stem -1#3,4#3,4#para -1#5#7#exact -1#6#8#exact -1#7#9#exact -1#8#10#exact -1#9#11#exact -1#10#12#exact 


Their algorithm starts by detecting interest points in the first frame of the shot and propagating them to the next frames based on local appearance matching .
Their algorithm starts by detecting interest points in the first frame of the shot and propagating them to the next frames based on local appearance matching .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact 


Points that cannot be propagated from one frame to the next are eliminated and replaced with new points .
Points which can not be propagated from one frame to the next are eliminated and replaced with new points .
-1#0,1#0,1#para -1#2,3#2#para -1#4#3#exact -1#5#4#exact -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact 


Given two faces in different frames , if the number of point tracks passing through both faces is larger than half of the total number of point tracks that are not common to both faces , the faces are grouped into one face track.
Given two faces in different frames , if the number of point tracks passing through both faces is larger than half of the total number of point tracks which are not in common to both faces , they are grouped into one face-track.
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#22,23,24,25#8,9,10#para -1#26#11#exact -1#27#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19,20,21#19,20,21,22#para -1#9,10#23,24,25#para -1#11#26#exact -1#12#27#exact -1#28,29,30,31#28,29,30#para -1#32#31#exact -1#33#32#exact -1#34#33#exact -1#35#34#exact -1#36#35#exact -1#8#36#exact -1#37,38#37,38#para -1#39#39#exact -1#40#40#exact -1#41#41#exact 


Although the approach by Everingham et al .
Although the approach by Everingham et al .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact 


has shown its efficiency and robustness with drama videos \CITE , directly applying the approach to news videos results in poor performance due to the following issues.
has demonstrated its efficiency and robustness on drama videos \CITE , directly applying the approach to news videos results poor performances due to following issues.
-1#0#0#exact -1#1,2#1,2#para -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19,20#para -1#20#21#stem -1#21#22#exact -1#22#23#exact -1#23#24,25#para -1#24#26#exact 


Tracking errors due to sudden illumination change .
Tracking errors due to sudden illumination change .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact 


Because the KLT tracker uses intensity variance for computing the image motion to find the correspondence between points in different frames , it is unreliable when there is a sudden and significant change in illumination .
Since the KLT tracker uses intensity variance for computing the image motion to find the correspondence between points in different frames , it is unreliable when there is a sudden and significant change in illumination .
-1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact 


As shown in Figure 3 ( top ) , points are distracted when a flash occurs .
As shown in Figure 3 ( top ) , points are distracted when flash occurs .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13,14#para -1#14#15#exact -1#15#16#exact 


As a result , the points are badly tracked .
As a result , the points are badly tracked .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact 


The flash breaks all connections between faces in the frames before and after its occurrence.
The flash breaks all connections between faces in frames before and after its occurrence.
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact 


Unadaptive track point generation .
Unadaptive track point generation .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact 


In \CITE , the track point generation is totally independent from face appearances .
In \CITE , track point generation is totally independent with face appearances .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact 


New points are generated at the first frame of the shot or at a frame in which some existing points cannot be propagated .
New points are generated at the first frame of the shot or at a frame in which some existing points can not be propagated .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20,21#20,21#para -1#23#22#exact -1#24#23#exact 


As a result , a face that , does not appear in the aforementioned frames , may not contain any point .
As a result , a face , which does not appear in the aforementioned frames , may not contain any point .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#7#exact -1#8,9,10,11#8,9,10,11,12#para -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact 


Its connections with other faces in the shot cannot be established for grouping.
Its connections with other faces in the shot cannot be established for grouping.
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact 


Tracking errors due to occlusion .
Tracking errors due to occlusion .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact 


To successfully connect actual faces of the same character in different frames , the track points generated for the first face should be tracked and retained inside the latter faces for a sufficient number of shared points between faces .
To successfully connect actual faces of the same character in different frames , track points generated for the first face should be tracked and retained inside the latter faces for a sufficient number of shared points between faces .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#17#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#26#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#27#28#exact -1#28#29#exact -1#29#30#exact -1#30#31#exact -1#31#32#exact -1#32#33#exact -1#33#34#exact -1#34#35#exact -1#35#36#exact -1#36#37#exact -1#37#38#exact -1#38#39#exact 


However , when occlusion occurs , the points are distracted by occluded regions .
However , when occlusion occurs , points are distracted by occluded regions .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6,7#para -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact 


Thus , the number of shared points drops , .
Thus , the number of shared points drops , .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact 


resulting in face connection failure .
It results in face connection failure .
-1#1#0#stem -1#2#1#exact -1#3#2#exact -1#4#3#exact -1#5#4#exact -1#6#5#exact 


As shown in Figure 3 ( bottom ) , when the woman moves the paper , which partially occludes her face in several frames , some points in her facial region are drifted with the paper .
As shown in Figure 3 ( bottom ) , when the woman moves the paper , which partially occludes her face in several frames , some points in her facial region are drifted with the paper .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact 


These points are not lost so they are not replaced by new points .
These points are not lost so they are not replaced by new points .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#8,9,10#7,8,9,10#para -1#11#11#exact -1#12#12#exact -1#13#13#exact 


However , they become meaningless in determining the connection between faces.
But , they become meaningless to determine the connection between faces.
-1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5,6#5,6#para -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact 


Based on the observed limitations of the approach in \CITE when applied to news videos , we integrate techniques to bypass these restrictions in our proposed approach to face-track extraction in news videos.
Based on above observed limitations of the approach in \CITE on news videos , we integrate techniques to bypass these liminations in our proposed approach for face-track extraction on news videos.
-1#0#0#exact -1#1#1#exact -1#6#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#7#6,7#para -1#8#8#exact -1#9#9#exact -1#17#12#exact -1#11#13#exact -1#12#14#exact -1#13#15#exact -1#14#16#exact -1#15#17#exact -1#16#18#exact -1#18#20#exact -1#19#21#exact -1#21#23#exact -1#22#24#exact -1#23#25#exact -1#24#26#exact -1#26#28#exact -1#27#29#exact -1#29#31#exact -1#30#32#exact 


First , unlike in \CITE , our approach does not compare all possible pairs of faces in a shot for face grouping\CITE; .
Firstly , \CITE , our approach does not compare all possible pairs of faces in a shot for face grouping as in \CITE .
-1#0#0#stem -1#1#1#exact -1#14#3#exact -1#2#4#exact -1#3#5#exact -1#4#6#exact -1#5#7#exact -1#6#8#exact -1#7#9#exact -1#8#10#exact -1#9#11#exact -1#10#12#exact -1#11#13#exact -1#12#14#exact -1#13#15#exact -1#21#16#exact -1#15#17#exact -1#16#18#exact -1#17#19#exact -1#18#20#exact -1#23#22#exact 


such pairwise comparison rapidly becomes intractable as the number of faces in a shot increases .
Such pair-wise comparison rapidly becomes intractable as the number of faces in a shot increases .
-1#0#0#lc -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact 


Instead , we group faces into face tracks according to the temporal order of their appearances .
Instead of that , we group faces into face-track following temporal order of their appearances .
-1#0#0#exact -1#3#1#exact -1#4#2#exact -1#5#3#exact -1#6#4#exact -1#7#5#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact 


A detected face in the current frame is considered for grouping into existing face tracks formed by previously detected faces only .
A detected face in the current frame is considered to group into existing face-tracks formed by previously detected faces only .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#10#10#stem -1#11#11#exact -1#12#12#exact -1#18#13#stem -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#19#20#exact -1#20#21#exact 


By doing this , we avoid greedy pairwise comparison.
By doing this , we avoid greedy pairwise comparison.
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact 


Second , as described in our first observation , a sudden illumination change in any frame causes the KLT tracker to fail to track points properly .
Secondly , as our first observation , a sudden illumination change in any frame make the KLT tracker failed to track points properly .
-1#0#0#stem -1#1#1#exact -1#2#2#exact -1#11#4#exact -1#3#5#exact -1#4#6#exact -1#5#7#exact -1#6#8#exact -1#7#9#exact -1#8#10#exact -1#9#11#exact -1#10#12#exact -1#12#14#exact -1#13#15#exact -1#14#16#syn -1#15#17#exact -1#16#18#exact -1#17#19#exact -1#19#20#exact -1#18#21#stem -1#20#23#exact -1#21#24#exact -1#22#25#exact -1#23#26#exact 


Because such illumination changes are very common and mostly occur simultaneously with important characters in a news video , finding a solution to this problem is vital .
Because such illumination changes are very common and they mostly appear together with important character in a news , a solution to this problem is vital .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#9#8#exact -1#12#11#exact -1#13#12#exact -1#14#13#stem -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#18#exact -1#19,20,21#19,20,21,22#para -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact 


We learn that the occurrences of such illumination changes are usually very short ( less than 3 frames ) .
We learn that the occurences of such illumination changes are usually very short ( less than 3 frames ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact 


and that the , faces that appear in those frames are less informative for recognition because most of the facial identity characteristics are lost due to over-lighting .
And , faces appeared in those frames are less informative for recognition since most of the facial identity characteristics are loss due to overlighting .
-1#0#0#lc -1#15#2#exact -1#1#3#exact -1#2#4#exact -1#3#6#stem -1#4#7#exact -1#5#8#exact -1#6#9#exact -1#7#10#exact -1#8#11#exact -1#9#12#exact -1#10#13#exact -1#11#14#exact -1#12,13#15,16#para -1#14#17#exact -1#16#19#exact -1#17#20#exact -1#18#21#exact -1#19#22#exact -1#20#23#para -1#21#24#exact -1#22#25#exact -1#24#27#exact 


Thus , the faces cannot enrich the information on its corresponding face track , but may only add noise .
, They can not enrich information of its corresponding face-track , but may add noise .
-1#0#1#exact -1#2,3#4#para -1#4#5#exact -1#5#6,7#para -1#7#9#exact -1#8#10#exact -1#10#13#exact -1#11#14#exact -1#12#15#exact -1#13#17#exact -1#14#18#exact -1#15#19#exact 


Therefore , our solution is to detect and skip all frames containing sudden illumination changes , which .
Therefore , our solution is to detect and skip all frames contain sudden illumination changes , .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#stem -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#17#exact 


we call flash frames.
We call such frames as flashframes.
-1#0#0#lc -1#1#1#exact 


To identify flash frames , we measure the brightness of the frames in the video shot .
To indetify flash-frames , we measures the brightness of frames in the video shot .
-1#0#0#exact -1#9#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#stem -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#11#10#exact -1#10#12#exact -1#12#13,14#para -1#13#15#exact -1#14#16#exact 


If the brightness of a frame is significantly increased compared with its neighbors , the frame is declared a flash frame and skipped in processing .
If the brightness of a frame significantly increases compared with those of its neighbors , the frame is declared as a flash-frame and is skipped for processing .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#17#6#exact -1#6#7#exact -1#7#8#stem -1#8#9#exact -1#9#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#23#16#exact -1#18#17#exact -1#20#18#exact -1#22#21#exact -1#24#22#exact -1#26#24#exact -1#27#25#exact 


Particularly , given a frame \SYM with t indicating its frame index , we compute the average luminosity L of the frame \SYM and its consecutive frames \SYM , where i = \SYM; t +W+ 1 , and W is the potential length of a sudden illumination change .
Particularly , given a frame \SYM with t indicates its frame index , we compute the average luminosity L of the frame \SYM and its consicutive frames \SYM , where i = \SYM; t +W+ 1 , and W is the potential length of a sudden illumination change .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#stem -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#36#exact -1#37#37#exact -1#38#38#exact -1#39#39#exact -1#40#40#exact -1#41#41#exact -1#42#42#exact -1#43#43#exact -1#44#44#exact -1#45#45#exact -1#46#46#exact -1#47#47#exact -1#48#48#exact 


Then , we compare the average luminosity L of each frame \SYM in the set S = \SYM with s = t; t +W to those of \SYM and \SYM .
Then , we compare the average luminosity L of each frame \SYM in the set S = \SYM with s = t; t +W to those of \SYM and \SYM .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact 


If L( \SYM ) > L( \SYM ) and L( \SYM ) > L( \SYM ) , \SYM is defined as flash frames according to a predefined brightness sensitive threshold \SYM .
If L( \SYM ) > L( \SYM ) and L( \SYM ) > L( \SYM ) , \SYM is defined as flash-frames regarding a predefined brightness sensitive threshold \SYM .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#23#25#exact -1#24#26#exact -1#25#27#exact -1#26#28#exact -1#27#29#exact -1#28#30#exact -1#29#31#exact 


In our experiments , we found that \SYM = 1:25 and W = {1; 2; 3} are optimal for detecting all flash frames with a low false alarm rate.
In our experiments , we found that \SYM = 1:25 and W = {1; 2; 3} are optimal for detecting all flash-frames with a low false alarm rate.
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact 


Given a video shot , our approach starts by finding the first frame in which faces are detected .
Given a video shot , our approach starts by finding the first frame in which faces are detected .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact 


All point-tracking and face-grouping processes are initialized from this frame , not at the first frame of the shot as in \CITE .
All point tracking and face grouping processes are initialized from this frame , not at the first frame of the shot as in \CITE .
-1#0#0#exact -1#3#2#exact -1#6#4#exact -1#7#5#exact -1#8#6#exact -1#9#7#exact -1#10#8#exact -1#11#9#exact -1#12#10#exact -1#13#11#exact -1#14#12#exact -1#15#13#exact -1#16#14#exact -1#17#15#exact -1#18#16#exact -1#19#17#exact -1#20#18#exact -1#21#19#exact -1#22#20#exact -1#23#21#exact -1#24#22#exact 


This helps us to save on computational cost and avoid tracking errors caused by transition effects between shots .
This helps us to save computational cost as well as to avoid tracking errors caused by transition effects between shots .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#6#exact -1#6#7#exact -1#11#9#exact -1#12#10#exact -1#13#11#exact -1#14#12#exact -1#15#13#exact -1#16#14#exact -1#17#15#exact -1#18#16#exact -1#19#17#exact -1#20#18#exact 


Initial track points will be generated for all detected faces in the frame .
Initial track points will be generated for all detected faces in the frame .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact 


Each face now becomes the first face of a corresponding newly formed face track.
Each face now becomes the first face of a corresponding newly formed face-track.
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact 


After the initialization , we sequentially process each frame , knowing all flash frames will be skipped .
After the initialization , we sequentially process each frame afterwards , knowing all flash-frames will be skipped .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact 


In a given frame , the points from the previous frame are tracked by the KLT tracker to update their locations .
At a given frame , points from the previous frame are tracked by the KLT tracker to update their locations .
-1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#13#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact 


If there are faces detected , each face is checked against all the existing face tracks formed in the previous frames to find out to which face track the face belongs .
If there are faces detected , each face is checked against all existing facetracks formed in the previous frames to find out which facetrack it belongs to .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#16#12#exact -1#12#13#exact -1#14#16#exact -1#15#17#exact -1#17#18,19#para -1#18#20#exact -1#19#21#exact -1#20#22#exact -1#21#23#exact -1#26#24#exact -1#22#25#exact -1#25#30#exact -1#27#31#exact 


The checking between a face and a face track is based on enumerating the points shared by both the face and the last face that appeared on the face track .
Checking between a face and a facetrack is based on enumerating points shared by both the face and the last appeared face of the face-track .
-1#15#0#lc -1#0#1#lc -1#1#2#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#16#7#exact -1#7#9#exact -1#8#10#exact -1#9#11#exact -1#10#12#exact -1#18#13#exact -1#11#14#exact -1#12#15#exact -1#13#16#exact -1#14#17#exact -1#23#18#exact -1#21#19#exact -1#17#20#exact -1#19#21,22#para -1#20#25#exact -1#25#30#exact 


If the enumerated number is larger than half of the total number of points that are not common to both faces , the face is grouped into the face track .
If the enumerated number is larger than half of the total number of points which are not in common to both faces , the faces is grouped into the face-track .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6,7,8,9#6,7,8#para -1#10,11,12#9,10,11,12#para -1#13#13#exact -1#14,15#14,15#para -1#16#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact -1#23#22#exact -1#25#23,24#para -1#26#25#exact -1#27#26#exact -1#28#27#exact -1#24#28#stem -1#30#30#exact 


Our grouping criterion here is similar to that in \CITE .
Our grouping criterion here is similar to \CITE .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4,5,6#4,5,6,7#para -1#7#9#exact -1#8#10#exact 


A face that cannot be grouped into any face track is treated as the initial face of a new face track .
A face which can not be grouped into any face-track is treated as an initial face of a new face-track .
-1#0#0#exact -1#1#1#exact -1#3,4#3#para -1#5#4#exact -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#15#8#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#14#13,14#para -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#20#21#exact 


We then generate new track points within such faces for tracking and grouping its corresponding faces in latter frames .
We then generate new track points inside such faces for tracking an grouping its corresponding faces in latter frames .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#syn -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact 


In our approach , track points are generated in conjunction with face appearances .
In our approach , track points are generated in conjunction with face appearances .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact 


We can ensure that there are track points for all faces that appear in the shot .
We can ensure that there are always track points for all faces appear in the shot .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact 


Consequently , our approach overcomes the second observed limitation in \CITE.
Consequently , our approach overcomes the second observed limitation of \CITE.
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#10#10#exact 


In other cases , when a face in the current frame is grouped into an existing face track , we prepare points for further tracking .
In other case , when a face in the current frame is grouped to an existing face-track , we prepare points for further tracking .
-1#0#0#exact -1#1#1#exact -1#2#2#stem -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#14#14#exact -1#15#15#exact -1#23#17#stem -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#24#25#exact 


We remove all points that are inside the last face that appeared on the face track but are not inside the current face , and vice versa .
We remove all points which are inside the last appeared face of the face-track but not inside the current face , and vice versa .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3,4#3,4#para -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#10#9#exact -1#9#11#exact -1#12#13#exact -1#19#14#exact -1#14#16#exact -1#15#17,18#para -1#16#19#exact -1#17#20#exact -1#18#21#exact -1#20#23#exact -1#21#24#exact -1#22#25#exact -1#23#26#exact -1#24#27#exact 


Because such points are likely tracked incorrectly , eliminating them prevents us from transferring tracking errors to latter frames .
Since such points are likely tracked incorrectly , eliminating them prevent us from transferring tracking errors to latter frames .
-1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10,11#10,11,12#para -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact 


Points that are shared by both faces are kept .
Points which are shared by both faces are kept .
-1#0,1#0,1#para -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact 


Besides , we generate additional points to replace the removed ones and to provide updated points .
Besides , we generate additional points to replace the removed ones and to provide updated points .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact 


By doing so , our tracking results over a long sequence of frames become more accurate and reliable .
By doing that , our tracking results through a long sequence of frames become more accurate and reliable .
-1#0#0#exact -1#1,2#1,2#para -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact 


As a result , we can partly bypass the third observed limitation of \CITE .
As a result , we can partly bypass the third observed limitation of \CITE .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact 


When a face is partly and slowly occluded , our approach can discard incorrectly tracked points and reproduce points for the face after it has been occluded .
When a face is partly and slowly occluded , our approach can discard incorrectly tracked points as well as reproduce points for the face after being occluded .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#19#17#exact -1#20#18#exact -1#21#19#exact -1#22#20#exact -1#23#21#exact -1#24#22#exact -1#25#25#para -1#26#26#exact -1#27#27#exact 


Thus , the connection between faces before and after the occlusion is retained.
Thus , the connection between faces before and after the occlusion are retained.
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6,7,8#6,7,8,9#para -1#10#10#exact -1#11#11#syn -1#12#12#exact 


Our approach continuously processes the next frame until the end of the shot is reached .
Our approach continuously process the next frame until reaching the end of the shot .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#stem -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#9,10,11,12#8,9,10#para -1#13#12#exact -1#8#14#stem -1#14#15#exact 


The pseudo-code is presented in Algorithm 1 as follows.
The pseudo-code is presented in the Algorithm 1 as follows.
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact 


Several approaches to matching face tracks have been proposed ( as presented in Section 2 ) .
There are several approaches have been proposed for matching face-tracks ( as presented in Section 2 ) .
-1#2#0#lc -1#3#1#exact -1#8#3#exact -1#4#6#exact -1#5#7#exact -1#6#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact 


However , although these approaches have shown high accuracy in benchmark datasets , their high computational costs limit their practical applications in large-scale datasets .
, Although these existing approaches achive high accuracy on benchmark datasets , their expensive computational costs limits their practical applications on large-scale datasets .
-1#0#1#exact -1#1#2#lc -1#2#3#exact -1#4#4#exact -1#6#7#exact -1#7#8#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#para -1#14#15#exact -1#15#16#exact -1#17#17,18#para -1#18#19#exact -1#19#20#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact 


This motivates us to target a matching approach that provides a good balance between accuracy and computational cost .
This motivate us to target an matching approach which is balanced between accuracy and computational cost .
-1#0#0#exact -1#1#1#stem -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#6#6#exact -1#7,8#7,8#para -1#9#9#para -1#10#11,12#para -1#11#13#exact -1#12#14#exact -1#13#15#exact -1#14#16#exact -1#15#17#exact -1#16#18#exact 


The approach should be extremely efficient while achieving a competitive performance with state-of-the-art approaches.
The approach should be extremely efficient while archiving competitive performance compare to state-of-the-art approachesf.
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#8#8,9#para -1#9#10#exact -1#12#12#exact 


To maintain competitive accuracy , we still use the plenteous information from the multiple faces of a face track to enrich the representation .
In order to maintain a competitive accuracy , we still employ plenteous information from multiple faces of a facetrack to enrich its representation .
-1#2#0#lc -1#3#1#exact -1#5#2#exact -1#6#3#exact -1#7#4#exact -1#8#5#exact -1#9#6#exact -1#10#7#syn -1#11#9#exact -1#12#10#exact -1#13#11#exact -1#14#12,13#para -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#19#19#exact -1#20#20#exact -1#22#21,22#para -1#23#23#exact 


However , instead of using all the faces in a face track , we propose taking a subsample of faces .
However , instead of using all faces in a face-track , we propose to subsample the faces .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#15#6#exact -1#16#7#exact -1#7#8#exact -1#8#9#exact -1#6#10#stem -1#10#12#exact -1#11#13#exact -1#12#14#exact -1#14#17#exact -1#17#20#exact 


In doing so , the required computational cost can be reduced while keeping the amount of information sufficient to improve accuracy .
By doing that , the require computational cost can be reduced while a sufficient amount of information is kept for improving accuracy .
-1#1,2#1,2#para -1#3#3#exact -1#4#4#exact -1#5#5#stem -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#18#12#syn -1#14,15#13,14,15#para -1#16#16#exact -1#13#17#exact -1#19,20#18,19#para -1#21#20#exact -1#22#21#exact 


We call our approach k-Faces.
We called our approach as k-Faces.
-1#0#0#exact -1#1#1#stem -1#2#2#exact -1#3#3#exact -1#5#4#exact 


Given a specific value of k , which indicates the expected size of the subsampled set of a face track , the approach starts by dividing each face track into k parts according to the temporal order of appearances .
Given a specific value of k , which indicates the expected size of the sub-sampled set of a face-track , the approach starts by dividing each face-track into k parts following its temporal order .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#27#29#exact -1#28#30#exact -1#29#31#exact -1#32#35#exact -1#33#36#exact -1#34#39#exact 


For each part , one face is selected to represent all faces within the part .
For each part , one face is selected to represent for all faces within the part .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact 


The mean face of k selected faces is then computed .
The mean face of k selected faces is then computed .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact 


The similarity between two face tracks is now the distance between their mean faces.
The similarity between two face-tracks is now the distance between their mean faces.
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact 


Let mA = {\SYM; \SYM; : :; \SYM} and mB = {\SYM ; \SYM; : :; \SYM} denote the mean faces of face tracks A and B , respectively , with N representing the number of dimensions of the feature space .
Let denote mA = {\SYM; \SYM; : :; \SYM} and mB = {\SYM ; \SYM; : :; \SYM} are two mean faces of two face-track A and B , respectively , with N imposes the number of dimension of the feature space .
-1#0#0#exact -1#2#1#exact -1#3#2#exact -1#4#3#exact -1#5#4#exact -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#1#17#exact -1#34#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact -1#25#24#exact -1#26#25#exact -1#27#26#exact -1#28#27#exact -1#29#28#exact -1#30#29#exact -1#31#30#exact -1#32#31#exact -1#18#32#syn -1#39#33#exact -1#35#34#exact -1#36#35#exact -1#37,38#36,37#para -1#40#39#exact -1#41#40#exact -1#42#41#exact 


We use following standard distance types to compute the distance between mA and mB.
We employ following standard distance types to compute the distance between mA and mB.
-1#0#0#exact -1#1#1#syn -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact 


Figure 4 illustrates our k-Faces , with the following .
An illustration of our k-Faces , is shown in Figure 4 .
-1#9#0#exact -1#10#1#exact -1#1#2#stem -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#11#9#exact 


pseudo-code: .
Its pseudo-code is presented as follows .
-1#6#1#exact 


Clearly , the higher the value of k selected , the more faces in each face track selected to compute the representative face and the .
Clearly , the higher value of k is selected , the more faces in each face-track are selected to compute the representative face of the face track .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4,5#4,5,6#para -1#6#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#22#15#exact -1#26#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#25#22#exact -1#24#24#exact -1#27#25#exact 


, better the approximations , which may result in higher accuracies .
And , better approximations , may result in higher accuracies .
-1#1#0#exact -1#2#1#exact -1#3#3#exact -1#4#4#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact 


However , the computational cost can overly increases .
However , the computational cost can overly increases .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact 


By using k as a predefined parameter , k-Faces provides users with flexibility in balancing the accuracy they expect and the cost they can afford ( or the time they can spend waiting for the result ).
By using k as a predefined parameter , k-Faces provides flexibility for users in balancing their expected accuracy and the cost which they can afford ( or time they can wait for the result ).
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#12#10#exact -1#10#12#exact -1#13#13#exact -1#14#14#exact -1#19#15#exact -1#17#16#exact -1#22#17#exact -1#30,31#18#para -1#18#19#exact -1#32#20#exact -1#20#21#exact -1#28#22#exact -1#29#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27,28,29#para -1#23#30#exact -1#16#32,33#para -1#33#34,35#para -1#34#36#exact 


Besides , because k-Faces averages multiple faces for the representative face of a face track , the effects of noisy or outlier faces on estimating the similarity of face tracks will be substantially reduced.
Besides that , since k-Faces averages multiple faces for a representative face of a face-track , the effects of noisy or outliers faces on estimating the similarity of face-tracks will be substantially reduced.
-1#0#0#exact -1#2#1#exact -1#4#3#exact -1#5#4#exact -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#9,10#8,9#para -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#22#13#stem -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#stem -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#29#30#exact -1#30#31#exact -1#31#32#exact -1#32#33#exact 


In this section , we present our experiments to evaluate the proposed approaches .
In this section , we present our experiments to evaluate the proposed approaches .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact 


The experiments are divided into two parts; .
The experiments are divided into two parts .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#7#7#exact 


the first , evaluates the performance of the proposed approach in face-track extraction , and the second in .
In the first part , we evaluate the performance of the proposed approach for face-track extraction , .
-1#1#0#exact -1#2#1#exact -1#4#2#exact -1#6#3#stem -1#7,8,9#4,5,6,7#para -1#11#8#exact -1#12#9#exact -1#0#10#lc -1#14#11#exact -1#15#12#exact -1#16#13#exact -1#10#15#exact -1#17#18#exact 


face-track matching.
Evaluation of the proposed approach for face-track matching is given in the second part.
-1#6#0#exact 


We tested our proposed approach to face-track extraction on 8 video sequences from different video broadcasting stations , including NHK News 7 , ABC News , and CNN News.
We tested our proposed approach for face-track extraction on 8 video sequences from different video broadcasting stations , including NHK News 7 , ABC News , and CNN News.
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact 


All shot boundaries are provided in advance .
All shot boundaries are provided in advance .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact 


A face detector based on the Viola-Jones approach \CITE is used to detect near frontal faces in every frame of the video sequences .
A face detector based on Viola-Jones approach \CITE was used for detecting near frontal faces in every frame of these video sequences .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8,9#9,10#para -1#10,11#11,12#para -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#20#20,21#para -1#21#22#exact -1#22#23#exact 


A conservative threshold is used to reduce the number of false positives ( i.e. , a non-face classified as a face ).
A conservative threshold is used to reduce the number of false positives ( i.e. , a non-face classified as a face ).
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#6,7,8,9#5,6,7,8,9#para -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact 


Ground-truth information on the face tracks in videos is manually prepared .
Ground-truth information on face-tracks in videos is manually prepared .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#4#6#exact -1#5#7#exact -1#6#8#exact -1#7#9#exact -1#8#10#exact -1#9#11#exact 


Each face track of a character appearing in a video shot is annotated by indexes of the frames in which the first face and the last face of that character occur .
A face-track of one character appearing in a video shot is annotated by indexes of the frames which the first face and the last face of that character occur .
-1#20#1#exact -1#2#3#exact -1#0#4#lc -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18,19#para -1#18#20#exact -1#19#21#exact -1#24#22#exact -1#21#23#exact -1#22#24#exact -1#23#25#exact -1#25#27#exact -1#26#28#exact -1#27#29#exact -1#28#30#exact -1#29#31#exact 


An approach is considered as exactly extracting a face track if it provides precise starting and ending frame indexes of the face track , compared to ground-truth annotation .
An approach is called exactly extracting a face-track if it provides precise starting and ending frame indexes of the face-track , compared to ground-truth annotation .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#8#10#exact -1#9#11#exact -1#10#12#exact -1#11#13#exact -1#12#14#exact -1#13#15#exact -1#14#16#exact -1#15#17#exact -1#16#18#exact -1#17#19#exact -1#18#20#exact -1#20#23#exact -1#21#24#exact -1#22#25#exact -1#23#26#exact -1#24#27#exact -1#25#28#exact 


Note that if a character moves out of the frame and then moves back into it again , annotators will divide the appearance of that character into two independent face tracks in ground-truth annotation .
Note that if a character moves out of the frame then moves in again , annotators will divide the appearance of that character into two independent face-tracks in our ground-truth .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10,11#para -1#11#12#exact -1#23#13,14#para -1#13#15,16#para -1#14#17#exact -1#15#18#exact -1#16#19#exact -1#17#20#exact -1#18#21#exact -1#19#22#exact -1#20#23#exact -1#21#24#exact -1#22#25#exact -1#24#26,27#para -1#25#28#exact -1#12#31#exact -1#29#32#exact -1#30#34#exact 


Table 1 shows the number of frames , faces , and face tracks .
The number of frames , faces , and face tracks are shown in Table 1 .
-1#13#0#exact -1#14#1#exact -1#10,11#2#para -1#0#3#lc -1#1#4#exact -1#2#5#exact -1#3#6#exact -1#4#7#exact -1#5#8#exact -1#6#9#exact -1#7#10#exact -1#8#11#exact -1#9#12#exact -1#15#13#exact 


In this experiment , we directly compare our approach with that proposed by Everingham et al .
In this experiment , we directly compare our approach with one proposed by Everingham et al .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#11,12#10,11#para -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact 


in \CITE.
in \CITE.
-1#0#0#exact -1#1#1#exact 


As shown in Table 2 , by detecting flash frames , our approach successfully overcomes the problem of face-track fragmentation due to illumination changes .
As shown in Table 2 , by detecting flash-frames , our approach successfully overcomes the problem of face-track fragmentation due to illumination changes .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact 


Meanwhile , the approach by Everingham et al .
Meanwhile , the approach by Everingham et al .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact 


almost completely fails to do that .
is almost failed to do that .
-1#1#0#exact -1#2#2#stem -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact 


In addition , the results also show that our approach is superior to that of Everingham et al .
In addition , the results also shows that our approach is superior to the approach by Everingham et al .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6,7#6,7#para -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact 


in handling problems caused by partial occlusion and the appearance of a character in the middle of a shot .
in handling problem caused by partial occlusion and appearance of character in the middle of a shot .
-1#0#0#exact -1#1#1#exact -1#2#2#stem -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#12#8#exact -1#8#9#exact -1#9#10#exact -1#15#11#exact -1#10#12#exact -1#13,14#13,14,15,16#para -1#16#18#exact -1#17#19#exact 


The only face tracks that we could not extract exactly are those fully occluded in some frames during their occurrences .
All face-tracks which we could not extract exactly are those fully occluded at some frames during their occurences .
-1#3#5#exact -1#4#6#exact -1#5#7#exact -1#6#8#exact -1#7#9#exact -1#8#10#exact -1#9#11#exact -1#10#12#exact -1#11#13#exact -1#13#15#exact -1#14#16#exact -1#15#17#exact -1#16#18#exact -1#18#20#exact 


In those cases , all points in the face regions are drifted to the background region .
In those cases , all points in face regions are drifted to background region .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7,8#para -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13,14#para -1#13#15#exact -1#14#16#exact 


After such full occlusions , there is no clue to regrouping the face of that person .
Thus , there is no clue to re-group face of that person after such full occlusions .
-1#12#0#lc -1#13#1#exact -1#14#2#exact -1#15#3#exact -1#1#4#exact -1#2#5#exact -1#3#6#exact -1#4#7#exact -1#5#8#exact -1#6#9#exact -1#8,9#11,12,13#para -1#10#14#exact -1#11#15#exact -1#16#16#exact 


, Using only a tracker is not enough to handle this problem .
To handle this problem , using only tracker is not enough .
-1#4#0#exact -1#5#1#lc -1#6#2#exact -1#7#4#exact -1#8#5#exact -1#9#6#exact -1#10#7#exact -1#0#8#lc -1#1#9#exact -1#2#10#exact -1#3#11#exact -1#11#12#exact 


One can apply visual information-based clustering to group the fragmented face track , as in \CITE , but this .
One can apply visual information based clustering to group the fragmented face-track , as in \CITE , .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#19#exact 


obviously , requires extra cost .
Obviously , extra cost is required .
-1#0#0#lc -1#1#1#exact -1#4,5#2#para -1#2#3#exact -1#3#4#exact -1#6#5#exact 


Nevertheless , we observe that full occlusion rarely happens in news video because the characters featured in the news are recorded with care , especially the important and well-known ones .
However , we observe that fully occlusion is rarely happened in news video since characters reported in the news are recorded with care , especially with important and well-known character .
-1#0#0#syn -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#syn -1#6#6#exact -1#8#7#exact -1#7#8,9#para -1#11#10#exact -1#12#11#exact -1#17#13#exact -1#14#14#exact -1#10#16#exact -1#18#17,18#para -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#26#25,26#para -1#27#27#exact -1#28#28#exact -1#30#30#exact 


This is a special characteristic of news videos .
This is a special property of news videos .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact 


The last column of the table shows the overall extraction performance of both approaches .
The last column of the table shows the overall extraction performance of both approaches .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact 


These facts clearly indicate that our approach is robust and outperforms that of Everingham et al .
These facts clearly indicate that our approach is robust and outperforms the approach of Everingham et al .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact 


in \CITE.
in \CITE.
-1#0#0#exact -1#1#1#exact 


In terms of speed , our approach is approximately 2 times slower than that of Everingham et al .
In terms of speed , our approach is approximately 2 times slower than the approach of Everingham .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#15#14#exact -1#16#15#exact -1#17#18#exact 


However , our complexity is somehow linear to the total number of faces , because we consequently enlarge face tracks according to the temporal order by checking new faces with only the last face that appeared on each face track .
However , our complexity is somehow linear to total number of face , because we consequently enlarge face-tracks following temporal order by checking new faces with only one last appeared face of each face-track .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8,9,10#8,9,10,11#para -1#24#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#11#18#exact -1#19#23#exact -1#20#24#exact -1#21#25#exact -1#22#26#exact -1#23#27#exact -1#30#28#stem -1#25#29#exact -1#26#30#exact -1#27,28#31,32#para -1#29#35#exact -1#31,32#36,37#para -1#34#40#exact 


Meanwhile , Everingham et al .
Meanwhile , Everingham et al .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact 


compared all pairs of faces in the shot .
compare all pairs of faces in the shot .
-1#0#0#stem -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact 


Their complexity is polynomial to the total number of faces .
Their complexity is polynomial to the total number of faces .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5,6,7,8#5,6,7#para -1#9#9#exact -1#10#10#exact 


If the number of faces increases , the gap in speed between our approach and that by Everingham et al .
If this number is getting larger , the gap in speed between our approach and the approach by Everingham et al .
-1#0#0#exact -1#15#1#exact -1#2,3#2,3#para -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12,13,14#12,13,14,15#para -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact 


will narrow rapidly.
will be narrowed rapidly.
-1#0#0#exact -1#2#1#stem -1#3#2#exact 


Because all the problems presented here , such as those due to flash , occlusion , and in-the-middle face appearance , are practically observed , overcoming them is vital for the practical application of our approach .
Because all presented problems here , such as those due to flash , occlusion , and in-the-middle face appearance , are practically observed , overcoming them is vital for practical application .
-1#0#0#exact -1#1#1#exact -1#3#3#exact -1#2#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact -1#28#29#exact -1#29,30#30,31,32#para -1#31#36#exact 


In this experiment , we show that our proposed techniques and solutions to the problems are robust and efficient enough for extracting face tracks in real-world news videos by successfully extracting 94% of all face tracks .
In this experiment , we show that our proposed techniques and solutions for the problems are robust and efficient enough for extracting face-tracks in real-world news videos by successfully extracting 94% of all face-tracks .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11,12#11,12#para -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact -1#28#29#exact -1#29#30#exact -1#30#31#exact -1#31#32#exact -1#32#33#exact -1#34#36#exact 


Based on our observations , other complex techniques can be applied to handle the problems .
From our observations , one can use other complex techniques to handle the problems .
-1#1#2#exact -1#2#3#exact -1#3#4#exact -1#7#5#exact -1#8#6#exact -1#9#7#exact -1#5#8#exact -1#6#10#syn -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact 


However , the trade-off between obtaining the 6% remaining face tracks and incurring an overly high computational cost should be considered with care.
However , a trade-o_ between completely obtaining 6% remaining face-tracks and an overly expensive computational cost should be considered with care.
-1#0#0#exact -1#1#1#exact -1#4#4#exact -1#6#5#exact -1#7#7#exact -1#8#8#exact -1#13#9#para -1#10#11#exact -1#11#13#exact -1#12#14#exact -1#14#16#exact -1#15#17#exact -1#16#18#exact -1#17#19#exact -1#18#20#exact -1#19#21#exact -1#20#22#exact 


Due to the limitations of existing public datasets , we prepared new datasets for the experiments .
Due to the limitations of existing public datasets , we prepare new datasets for experiments .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#stem -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14,15#para -1#15#16#exact 


Face tracks are extracted from videos of the datasets by using our proposed approach to face-track extraction ( see section 4.2 ) .
Face-tracks in videos of the datasets are extracted by using our proposed approach for face-track extraction ( see section 4.2 ) .
-1#6#2#exact -1#7#3#exact -1#2#5#exact -1#3#6#exact -1#4#7#exact -1#5#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact 


The identity of the character associated with each extracted face track is given by annotators .
Identity of the character associated with each extracted face-track is given by annotators .
-1#0#1#lc -1#1#2#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#9#11#exact -1#10#12#exact -1#11#13#exact -1#12#14#exact -1#13#15#exact 


Because our approach extracts face tracks in each video shot , the shot boundaries of videos are required .
Since our approach extract face-tracks in each video shot , shot boundaries for videos are required .
-1#1#1#exact -1#2#2#exact -1#3#3#stem -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#12#exact -1#11#13#exact -1#13#14,15#para -1#14#16#exact -1#15#17#exact -1#16#18#exact 


A simple shot boundary detector based on a color histogram of frames is used .
A simple shot boundary detector based on color histogram of frames is used .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact 


The whole process , including shot boundary detection and face-track extraction , is fully automated.
The whole process , including detecting shot boundaries and face-track extraction , is fully automatic.
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#6#5#exact -1#7#6#stem -1#5#7#stem -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact 


TRECVID dataset .
TRECVID Dataset .
-1#0#0#exact -1#1#1#lc -1#2#2#exact 


We used TRECVID news videos from 2004 to 2006 .
We used the TRECVID news videos from 2004 to 2006 .
-1#0#0#exact -1#1#1#exact -1#3#2#exact -1#4#3#exact -1#5#4#exact -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact 


This dataset contains 370 hours of videos in different languages , such as English , Chinese , and Arabic .
This dataset contains 370 hours of videos in different languages , such as English , Chinese , and Arabic .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact 


The total number of frames that we processed was approximately 35 million .
The total number of frames that we processed was approximately 35 millions frames .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#stem -1#13#12#exact 


Among those , 20 million faces were grouped into 157,524 face tracks .
Among those , 20 millions faces were grouped into 157,524 face tracks .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#stem -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact 


We filtered out short face tracks that had less than 10 faces , which .
We filtered out short face tracks that had less than ten faces , .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#syn -1#11#11#exact -1#12#12#exact -1#13#14#exact 


resulted in 35,836 face tracks .
This resulted in 35,836 face tracks .
-1#1#0#exact -1#2#1#exact -1#3#2#exact -1#4#3#exact -1#5#4#exact -1#6#5#exact 


Finally , we annotated 1,497 face tracks containing 405,887 faces of 41 well-known individual characters .
Finally , we annotated 1,497 face tracks containing 405,887 faces of 41 well known individual characters .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact 


NHKNews7 dataset .
NHKNews7 Dataset .
-1#0#0#exact -1#1#1#lc -1#2#2#exact 


This dataset consists of observations from the NHK News 7 program over 11 years .
This dataset is observed from NHKNews7 channel in 11 years .
-1#0#0#exact -1#1#1#exact -1#2#2,3#para -1#3#4#stem -1#4#5#exact -1#8#12#exact -1#9#13#exact -1#10#14#exact 


After the annotation process , 1,259,320 faces of 111 individuals are provided .
After the annotation process , 1,259,320 faces of 111 individuals are provided .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact 


The total number of face tracks is 5,567 .
The total number of face-tracks is 5,567 .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact 


Each character has from 4 to 550 face tracks .
Each character has from 4 to 550 face-tracks .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#8#9#exact 


In this dataset , we discard face tracks with fewer than 100 faces and more than 500 faces .
In this dataset , we discard facetracks with fewer than 100 faces and more than 500 faces .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#11#6#stem -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#16#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#17#18#exact 


Compared to the TRECVID dataset , the NHKNews7 dataset is much more challenging.
Compared to the TRECVID dataset , NHKNews7 dataset is much more challenging.
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact 


Table 4 shows a , comparison between our datasets and some public benchmark datasets .
In the Table 4 , we compare our datasets with some public benchmark datasets .
-1#2#0#exact -1#3#1#exact -1#4#4#exact -1#5,6#5#para -1#7#7#exact -1#8#8#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact 


Based on the results , it is obvious that our datasets are superior over the other datasets , such as MoBo and Honda / UCSD , on all statistical terms , including number of videos , number of characters , and average face-track length .
, It is obvious that our datasets are extremely higher than datasets , such as MoBo and Honda / UCSD , on all statistical terms , including the number of videos , characters , and average length of face-track .
-1#21#1#exact -1#27#2#exact -1#0#4#exact -1#2,3,4#5,6,7,8#para -1#5#9#exact -1#6#10#exact -1#7#11#exact -1#11#16#exact -1#12#17#exact -1#13#18#exact -1#14#19#exact -1#15#20#exact -1#16#21#exact -1#17#22#exact -1#18#23#exact -1#19#24#exact -1#20#25#exact -1#22#27#exact -1#23#28#exact -1#24#29#exact -1#25#30#exact -1#26#31#exact -1#28#32#exact -1#29#33#exact -1#30#34#exact -1#31#35#exact -1#37#37#exact -1#32#38#exact -1#33#39#exact -1#34#40#exact -1#35#41#exact -1#38#42#exact -1#36#43#exact -1#39#44#exact 


Compared to the YouTube Faces dataset , , we provide much more face tracks ( or video shots ) per character , although our datasets have smaller numbers of characters ( or subjects ) .
Compared to Youtube Faces dataset , although ours have less number of character ( or subjects ) , we provide much more face-tracks ( or video shots ) per character , .
-1#0#0#exact -1#1#1#exact -1#2#3#lc -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#17#7#exact -1#18#8#exact -1#19#9#exact -1#20#10#exact -1#21#11#exact -1#23#14#exact -1#24#15#exact -1#25#16#exact -1#26#17#exact -1#27#18#exact -1#28#19#exact -1#29#20#exact -1#30#21#exact -1#6#22#exact -1#7#23#stem -1#8#25#exact -1#10,11#27,28#para -1#12#29#stem -1#13#30#exact -1#14#31#exact -1#15#32#exact -1#16#33#exact -1#31#34#exact 


Thus , our datasets are more relevant in evaluating a face retrieval system.
Thus , ours are more relevant for evaluating retrieval system.
-1#0#0#exact -1#1#1#exact -1#2#2#stem -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#7#8#exact -1#8#11#exact -1#9#12#exact 


Figure 5 presents statistical information on our datasets .
Statistical information of our datasets is given in the Figure 5 .
-1#9#0#exact -1#10#1#exact -1#0#3#lc -1#1#4#exact -1#3#6#exact -1#4#7#exact -1#11#8#exact 


The datasets can be downloaded from http: / / satohlab .
The datasets can be downloaded at http: / / satohlab .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact 


ex.nii.ac.jp / users / ndthanh / NIIFacetrackDatasets .
ex.nii.ac.jp / users / ndthanh / NIIFacetrackDatasets .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact 


However , due to copyright issues , the face images in the face tracks cannot be published .
However , due to copyright issues , face images in face-tracks can not be published .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7,8#para -1#8#9#exact -1#9#10#exact -1#11,12#14,15#para -1#14#16#exact -1#15#17#exact 


Instead , we provide a feature vector , used in \CITE , for each face image .
Instead , we provide a feature vector , used in \CITE , for each face image .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact 


The feature vector of a face is extracted by computing the descriptors of the local appearance of the face around each of the located facial features .
A feature vector of a face is extracted by computing descriptors of the local appearance of the face around each of the located facial features .
-1#12#0#lc -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#16#10#exact -1#10#11#exact -1#11#12#exact -1#21#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#17#17,18#para -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact 


Before extracting the descriptors , the face is geometrically normalized to reduce the effect of pose variation .
Before extracting descriptors , the face is geometrically normalized to reduce the effect of pose variation .
-1#0#0#exact -1#1#1#exact -1#11#2#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#12,13#12,13,14#para -1#14#15#exact -1#15#16#exact -1#16#17#exact 


An affine transformation is estimated , which transforms the located facial feature points to a canonical set of feature positions .
They estimate an affine transformation , which transform the located facial feature points to a canonical set of feature positions .
-1#2#0#lc -1#3#1#exact -1#4#2#exact -1#5#5#exact -1#6#6#exact -1#7#7#stem -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact 


Then , the appearance descriptors around each facial feature are computed .
Then , appearance descriptors are computed around each facial feature .
-1#0#0#exact -1#1#1#exact -1#2#3#exact -1#3#4#exact -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#4#9#exact -1#5#10#exact -1#10#11#exact 


The final feature representation of the face is formed by concatenating all the descriptors of its facial features.
The final feature representation of the face is formed by concatenating all descriptors of its facial features.
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact 


We compared k-Faces with several approaches , including those based on pair-wise distances , MSM \CITE and CMSM \CITE.
We compare k-Faces with several approaches , including approaches based on pair-wise distances , MSM \CITE and CMSM \CITE.
-1#0#0#exact -1#1#1#stem -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact 


Given two face tracks having multiple face images represented as feature vectors , pair-wise-based approaches compute the distances between each possible pair of feature vectors in two face tracks .
Given two face-tracks having multiple face images represented as feature vectors , pair-wise based approaches compute distances between each possible pair of feature vectors in two face-tracks .
-1#0#0#exact -1#1#1#exact -1#5#2#exact -1#3#4#exact -1#4#5#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#14#14#exact -1#15#15#exact -1#16#16,17#para -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#27#29#exact 


The maximum distance , the minimum distance , or the mean distance of the computed pair-wise distances is the used as the similarity measurement between two face tracks .
They then use the maximum distance , the minimum distance , or the mean distance of the computed pair-wise distances as the similarity measurement between two face-tracks .
-1#3#0#lc -1#4#1#exact -1#5#2#exact -1#6#3#exact -1#7#4#exact -1#8#5#exact -1#9#6#exact -1#10#7#exact -1#11#8#exact -1#12#9#exact -1#13#10#exact -1#14#11#exact -1#15#12#exact -1#16#13#exact -1#17#14#exact -1#18#15#exact -1#19#16#exact -1#21#18#exact -1#2#19#stem -1#20#20#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#27#28#exact 


We refer to the approaches as pair:max , pair:min , and pair:mean , respectively ( see Figure 6 for the illustration ) .
We denote the approaches as pair:max , pair:min , and pair:mean , respectively ( see Figure 6 for illustration ) .
-1#0#0#exact -1#1#1#syn -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#20#exact -1#19#21#exact -1#20#22#exact 


The pair:min ( sometimes called min-min ) is a state-of-the-art approach widely used in other studies \CITE.
The pair:min ( sometimes called min-min ) is a state-of-the-art approach widely used in other studies \CITE.
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact 


Regarding \CITE , if the pair-wise-based approaches are representative of nonparametric sample-based approaches , MSM and CMSM are representative of approaches based on a parametric model .
Regarding to \CITE , if the pair-wise based approaches are representative for non-parametric sampled based approaches , MSM and CMSM are representative for approaches based on parametric model .
-1#0#0#exact -1#2#1#exact -1#3#2#exact -1#4#3#exact -1#5#4#exact -1#8#6#exact -1#9#7#exact -1#10#8#exact -1#15#12#exact -1#16#13#exact -1#17#14#exact -1#18#15#exact -1#19#16#exact -1#20#17#exact -1#21#18#exact -1#23#20#exact -1#24#21#exact -1#25#22#exact -1#26#24#exact -1#27#25#exact -1#28#26#exact 


MSM , introduced by Yamaguchi et al .
MSM , introduced by Yamaguchi et al .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact 


The similarity between the sets is computed using the angle between subspaces .
The similarity between the sets is computed using the angle between subspaces .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact 


CMSM is an extension of MSM , in which subspaces of the sets are projected onto a constraint subspace .
CMSM is an extension of MSM , in which subspaces of the sets are projected on a constraint subspace .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact 


In doing so , the subspaces are expected to be more separable .
By doing that , the subspaces are expected to be better separatable .
-1#1,2#1,2#para -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9,10#9,10#para -1#12#12#exact 


All of these approaches have shown their robustness in benchmark datasets , such as MoBo , HondaUCSD , and YouTube Faces .
All of these approaches had been shown their robustness on benchmark datasets , such as MoBo , HondaUCSD , and Youtube Faces .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4,5#4#para -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#lc -1#21#20#exact -1#22#21#exact 


Therefore , it is appealing to compare our k-Faces with them for a comprehensive evaluation.
Therefore , it is appealing to compare our k-Faces with them for a comprehensive evaluation.
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact 


Besides evaluating k-Faces with different values of k and different types of distance ( e.g. , Euclidean , L1 , and cosine ) , we try another criterion for selecting k representative faces in a face track .
Besides evaluating k-Faces with different values of k as well as different types of distance ( e.g. , Euclidean , L1 , cosine ) , we try another criterion to select k representative faces in a face-track .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#11#8,9#para -1#12#10#exact -1#13#11#exact -1#14#12#exact -1#15#13#exact -1#16#14#exact -1#17#15#exact -1#18#16#exact -1#19#17#exact -1#20#18#exact -1#21#19#exact -1#22#21#exact -1#23#22#exact -1#24#23#exact -1#25#24#exact -1#26#25#exact -1#27#26#exact -1#28#27#exact -1#29,30#28,29#para -1#31#30#exact -1#32#31#exact -1#33#32#exact -1#34#33#exact -1#35#34#exact -1#37#37#exact 


In the original way , we proposed selecting these faces by partitioning the face track according to the temporal order and choosing the middle face of each partition .
In the original way , we proposed to select these faces by partitioning the face-track following temporal order and selecting the middle face of each partition .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#19#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#22#13#exact -1#7#16#exact -1#20#17#exact -1#16#18#exact -1#17#19#exact -1#18#20#exact -1#8#21#syn -1#21#22,23#para -1#23#25#exact -1#24#26#exact -1#25#27#exact -1#26#28#exact 


However , another criterion that is based on clustering can be applied in selecting these representative faces .
However , an yet another criterion can be applied to select these representative faces is based on clustering .
-1#0#0#exact -1#1#1#exact -1#4#2#exact -1#5#3#exact -1#14#5#exact -1#15#6#exact -1#16#7#exact -1#17#8#exact -1#6#9#exact -1#7#10#exact -1#8#11#exact -1#9,10#12,13#para -1#11#14#exact -1#12#15#exact -1#13#16#exact -1#18#17#exact 


In this new way , all the faces in a face track will be clustered to k groups by using a clustering algorithm .
In this new way , all faces in a face-track will be clustered in to k groups by a clustering algorithm .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#10#12#exact -1#11#13#exact -1#12#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#20#exact -1#19#21#exact -1#20#22#exact -1#21#23#exact 


The centroid of each group is selected .
The centroid of each group is selected .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact 


Then , the mean of k centroids is used as the representative face for the face track .
Then , the mean of k centroids is used as the representative face for the face-track .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#16#17#exact 


In this experiment , we use the standard K-Means for clustering .
In this experiment , we use the standard K-Means for clustering .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact 


We refer to the former k-Faces as k-Faces.Temporal and to the latter k-Faces as k-Faces.KMeans.
We denote the former k-Faces as k-Faces.Temporal and the latter k-Faces as k-Faces.KMeans.
-1#0#0#exact -1#1#1#syn -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8,9#9,10,11#para -1#10#12#exact -1#11#13#exact -1#12#14#exact 


We evaluate the performance of a face-track matching approach by computing the average precision of the rank list that it returned .
We evaluate performance of a face-track matching approach by computing the average precision on the rank list returned by the approach .
-1#0#0#exact -1#1#1#exact -1#10#2#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#14#11#exact -1#11#12#exact -1#12#13#exact -1#19#15#exact -1#15#16#exact -1#16#17#exact -1#17#20#exact -1#21#21#exact 


In particular , in each dataset , a face track is alternatively picked out as a query face track , while the remaining face tracks are used as the retrieved database .
In particular , for each dataset , each face-track is alternatively picked out as a query facetrack , while the remaining face-tracks are used as the retrieved database .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3,4#3,4#para -1#5#5#exact -1#6#6#exact -1#14#7#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#15#16#exact -1#17#19#exact -1#18#20#exact -1#19#21#exact -1#20#22#exact -1#22#25#exact -1#23#26#exact -1#24#27#exact -1#25#28#exact -1#26#29#exact -1#27#30#exact -1#28#31#exact 


Given a query , the average precision of the returned ranked list is computed , .
, Average precision of the returned ranked list is computed , given a query .
-1#11#0#lc -1#12#1#exact -1#13#2#exact -1#0#3#exact -1#4#4#exact -1#1#5#lc -1#2#6#exact -1#3#7#exact -1#5#9#exact -1#6#10#exact -1#7#11#exact -1#8#12#exact -1#9#13#exact -1#10#14#exact -1#14#15#exact 


Finally , the mean of all average precision ( MAP ) values for all queries is reported as the overall evaluation metric for the approach with the given database.
Finally , the mean of all average precision ( MAP ) from all query is reported as the overall evaluation metric for the approach on the database.
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#21#12#exact -1#12#13#exact -1#13#14#stem -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#22#23#exact -1#23#24#exact -1#25#26#exact -1#26#28#exact 


Let r denote a rank in the returned face-track list , Pre( r ) the precision at rank r of the list , Nl the length of the list , Nhit the total number of face tracks matched with the query face track q , and I sMatched( k ) a binary function returning 1 if the face track at rank r is matched with q ( based on ground-truth annotations ) and , zero otherwise .
Let denote r as a rank in the returned face-track list , Pre( r ) as is the precision at the rank r of the list , Nl as the length of the list , Nhit as the total number of face-tracks matched with the query face-track q , and I sMatched( k ) as a binary function returning 1 if the face-track at rank r is matched with q ( based on ground-truth annotations ) , zero otherwise .
-1#0#0#exact -1#2#1#exact -1#1#2#exact -1#4#3#exact -1#5#4#exact -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#17#14#exact -1#18#15#exact -1#19#16#exact -1#21#17#exact -1#22#18#exact -1#23#19#exact -1#24#20#exact -1#25#21#exact -1#26#22#exact -1#27#23#exact -1#29,30,31,32#24,25,26#para -1#20#27#exact -1#33#28#exact -1#34#29#exact -1#35#30#exact -1#37,38,39,40#31,32,33#para -1#42#37#exact -1#43#38#exact -1#44#39#exact -1#45#40#exact -1#47#43#exact -1#48#44#exact -1#49#45#exact -1#50#46#exact -1#51#47#exact -1#52#48#exact -1#53#49#exact -1#55#50#exact -1#56#51#exact -1#57#52#exact -1#58#53#exact -1#59#54#exact -1#60#55#exact -1#61#56#exact -1#63#59#exact -1#64#60#exact -1#65#61#exact -1#66#62#exact -1#67#63#exact -1#68#64#exact -1#69#65#exact -1#70#66#exact -1#71#67#exact -1#72#68#exact -1#73#69#exact -1#74#70#exact -1#75#71#exact -1#76#73#exact -1#77#74#exact -1#78#75#exact -1#79#76#exact 


Then , the MAP of the evaluated approach can be computed as follows: \MATH
Then , the MAP of the evaluated approach can be computed as following: \MATH
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#13#13#exact 


The MAP is a standard metric for evaluating retrieval and matching systems .
MAP is a standard metric to evaluate retrieval and matching systems .
-1#0#1#exact -1#1#2#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5,6#6,7#para -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact 


Besides the MAP , we record the processing times of the approaches in each dataset to compare their efficiency.
Besides MAP , we record processing times of the approaches on each dataset for efficiency comparison.
-1#0#0#exact -1#8#1#exact -1#1#2#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6,7#para -1#6#8#exact -1#7#9#exact -1#9#11#exact -1#10,11#12,13#para -1#12#14#exact 


Figure 7 presents the mean average precision ( MAP ) of all the evaluated approaches in our two datasets , Trecvid and NHKNews7 .
Figure 7 presents Mean Average Precision ( MAP ) of all evaluated approaches on our two datasets , Trecvid and NHKNews7 .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#4#lc -1#4#5#lc -1#5#6#lc -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#13#exact -1#12#14#exact -1#14#16#exact -1#15#17#exact -1#16#18#exact -1#17#19#exact -1#18#20#exact -1#19#21#exact -1#20#22#exact -1#21#23#exact 


Generally , all the MAPs vary from 64.61% to 76.54% in the Trecvid dataset .
Generally , all MAPs vary from 64.61% to 76.54% on Trecvid dataset .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#10#12#exact -1#11#13#exact -1#12#14#exact 


Meanwhile , in the NHKNews7 dataset , the best MAP is 60.99% , and the worst is 42.75% .
Meanwhile , , the best MAP is 60.99% , and the worst MAP is 42.75% on NHKNews7 dataset .
-1#0#0#exact -1#1#1#exact -1#10#3#exact -1#16#4#exact -1#17#5#exact -1#2#6#exact -1#3#7#exact -1#4#8#exact -1#5#9#exact -1#6#10#exact -1#7#11#exact -1#8#12#exact -1#9#13#exact -1#11#14,15#para -1#13#16#exact -1#14#17#exact -1#18#18#exact 


The difference in the MAPs between the two datasets can be explained by following reasons .
The gap of MAPs between two datasets can be explained by following reasons .
-1#0#0#exact -1#1#1,2,3#para -1#3#4#exact -1#4#5#exact -1#5#7#exact -1#6#8#exact -1#7#9#exact -1#8#10#exact -1#9#11#exact -1#10#12#exact -1#11#13#exact -1#12#14#exact -1#13#15#exact 


First , the number of characters in NHKNews7 is larger than that in Trecvid , 111 characters in NHKNews7 compared to 41 characters in Trecvid .
Firstly , the number of characters in NHKNews7 is more larger than those in Trecvid , 111 characters in NHKNews7 compared to 41 characters in Trecvid .
-1#0#0#stem -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#10#9#exact -1#11#10#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact -1#23#22#exact -1#24#23#exact -1#25#24#exact -1#26#25#exact 


This clearly increases the probability of mismatching face tracks .
This clearly increases the probability of mismatching face-tracks .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#8#9#exact 


Second , the videos in NHKNews7 were recorded over a long time ( i.e. , 11 years ) .
Secondly , videos in NHKNews7 are recorded during a long time ( i.e. , 11 years ) .
-1#0#0#stem -1#1#1#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#syn -1#6#7#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact 


Thus , besides facial variations in each face track caused by the environmental conditions at the time of recording ( e.g. , illumination , pose , viewpoint ) , the face tracks of the character themselves also reflect the biological variations of the character over time; .
Thus , besides facial variations caused by enviromental conditions at the time of recording ( e.g. , illumination , pose , viewpoint ) in each face-track , face-tracks of a character themself also contain biological variation of the character during time .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#23#5#exact -1#24#6#exact -1#5#9#exact -1#6#10#exact -1#37#11#exact -1#8#13#exact -1#9,10,11,12#14,15,16#para -1#28#17#exact -1#13#18#exact -1#14#19#exact -1#15#20#exact -1#16#21#exact -1#17#22#exact -1#18#23#exact -1#19#24#exact -1#20#25#exact -1#21#26#exact -1#22#27#exact -1#26#28#exact -1#36#32#exact -1#30#33,34#para -1#32#36#exact -1#34#38,39#para -1#35#40#stem -1#38#42,43#para -1#41#46#exact 


for instance , a character may look older after several years ( see Figure 8 , for example ) .
For instance , a character may look older after several years ( see Figure 8 , for example ) .
-1#0#0#lc -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact 


For these reasons , matching faces in NHKNews7 becomes more challenging , which .
Due to those reasons , matching faces in NHKNews7 becomes more challenging , .
-1#2,3#1,2#para -1#4#3#exact -1#5#4#exact -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#13#exact 


resulted in decreased MAP( s ) for all the evaluated approaches.
It results in drops of MAP( s ) of all evaluated approaches.
-1#1#0#stem -1#2#1#exact -1#5#3#exact -1#6#4#exact -1#7#5#exact -1#9#7#exact -1#10#9#exact -1#11#10#exact 


A clear and consistent observation from both datasets is that pair:min ( i.e. , min-min ) always achieves the best MAPs , which are 76.54% and 60.99% in the two datasets , respectively .
A clear and consistent observation from both datasets is that pair:min ( i.e. , min-min ) always achieves the best MAPs , which are 76.54% and 60.99% on two dataset , respectively .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#28#27,28,29#para -1#29#30#stem -1#30#31#exact -1#31#32#exact -1#32#33#exact 


Among the distance types , L1 is the optimal for use with pair:min .
Among several distance types , L1 is the optimal one to be used with pair:min .
-1#0#0#exact -1#7#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#8#8#exact -1#10,11,12#9,10#para -1#13#11#exact -1#14#12#exact -1#15#13#exact 


A reasonable replacement is the Euclidean distance .
A reasonable replacement can be Euclidean distance .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3,4#3#para -1#5#5#exact -1#6#6#exact -1#7#7#exact 


However , there is a minor accuracy gap between pair:min using L1 and pair:min using the Euclidean distance .
However , there is a minor accuracy gap between pair:min using L1 and pair:min using Euclidean .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#16#exact -1#16#18#exact 


In addition , computing the Euclidean distance between two feature vectors is more expensive than computing their L1 distance .
And , computing Euclidean distance between two feature vectors is more expensive than computing their L1 distance .
-1#9,10#0,1#para -1#1#2#exact -1#2#3#exact -1#3#5#exact -1#4#6#exact -1#5#7#exact -1#6#8#exact -1#7#9#exact -1#8#10#exact -1#11,12#12,13,14#para -1#13#15#exact -1#14#16#exact -1#15#17#exact -1#16#18#exact -1#17#19#exact 


The results also show that pair:min is better than pair:mean .
The results also show that pair:min is better than pair:mean .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact 


This is because pair:mean uses the mean of all pair-wise distances between two face tracks as the similarity score .
This is because pair:mean uses the mean of all pair-wise distances between two face-tracks as their similarity score .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#14#15#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact 


By computing the mean , pair:mean reduces the effect of noisy pairs .
By computing the mean , pair:mean reduces the effect of noisy pairs .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact 


At the same time , it eliminates the influence of pairs containing identical faces , which can help to instantly determine that the faces belong to the same character .
At the same time , it eliminates the influence of pairs containing identical faces , which can help to instantly determine they are belong to the same character .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#25#22#exact -1#23#24#exact -1#24#25#exact -1#26#27#exact -1#27#28#exact -1#28#29#exact 


Thus , the discriminative power of the computed similarity score is reduced , compared to that computed by pair:min .
Thus , discriminative power of the computed similarity score is reduced , compared to one computed by pair:min .
-1#0#0#exact -1#1#1#exact -1#5#2#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact 


This causes the difference in MAPs between pair:min and pair:min .
It causes the gap of MAPs between pair:min and pair:min .
-1#1#1#exact -1#2#2#exact -1#3#3,4#para -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact 


More generally , this explains why such a gap between pair:min and pair:mean is larger in NHKNews7 than in Trecvid .
More generally , this explains why such a gap between pair:min and pair:mean on NHKNews7 is larger than on Trecvid .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#15#13#exact -1#16#14#exact -1#14#16#exact -1#17#17#exact -1#19#19#exact -1#20#20#exact 


Because the average length of face tracks on NHKNews7 is longer ( i.e. , each face track contains more sample faces of a character ) , there is a greater chance that two face tracks of the same character contain identical faces.
Since the average length of face-tracks on NHKNews7 is longer ( i.e. , each face-track contains more sample faces of a character ) , there is more chance that two face-tracks of the same character contain identical faces.
-1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#18#15#stem -1#15#17#exact -1#16#18#exact -1#17#19#exact -1#19#21#exact -1#20#22#exact -1#21#23#exact -1#22#24#exact -1#23#25#exact -1#24,25,26#26,27,28,29#para -1#27#30#exact -1#28#31#exact -1#29#32#exact -1#31#35#exact -1#32#36#exact -1#33#37#exact -1#34#38#exact -1#35#39#exact -1#36#40#exact -1#37#41#exact 


Regarding our k-Faces , its MAP increases when k increases .
About our k-Faces , its MAP increases when k increases .
-1#0#0#para -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact 


Between k-Faces.Temporal and k-Faces.KMeans , the impact of k on the MAP of k-Faces.KMeans is less significant .
Between k-Faces.Temporal and k-Faces.KMeans , the impact of k on MAP of k-Faces.KMeans is less significant .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10,11#para -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact 


Because k-Faces.KMeans always uses all the faces in a face track for clustering and selecting centroids for representative faces , the final mean face is less sensitive to k .
Since k-Faces.KMeans always use all faces in a facetrack for clustering and selecting centroids for representative faces , the final mean face is less sensitive to k .
-1#1#1#exact -1#2#2#exact -1#3#3#stem -1#4#4#exact -1#18#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#21#9#exact -1#9#11#exact -1#10#12#exact -1#11#13#exact -1#12#14#exact -1#13#15#exact -1#14#16#exact -1#15#17#exact -1#16#18#exact -1#17#19#exact -1#19#20,21#para -1#20#22#exact -1#22#23,24#para -1#23#25#exact -1#24#26#exact -1#25#27#exact -1#26#28#exact -1#27#29#exact 


In contrast , k plays an important role in k-Faces.Temporal .
On the contrary , k plays an important role in k-Faces.Temporal .
-1#9#0#lc -1#1,2#1#para -1#3#2#exact -1#4#3#exact -1#5#4#exact -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#10#9#exact -1#11#10#exact 


The higher the k set , the more representative faces of each face track selected .
The higher k is set , the more representative faces of each facetrack are selected .
-1#0#0#exact -1#1#1#exact -1#6#2#exact -1#2#3#exact -1#4#4#exact -1#5#5#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#14#14#exact -1#15#15#exact 


Thus , the final mean face of each face track becomes more reliable and accurate .
Thus , the final mean face of each facetrack becomes more reliable and accurate .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact 


The advantages of k-Faces.KMeans is that it can achieve high accuracy even when k is very small .
The advantages of k-Faces.KMeans is that it can achieve high accuracy even when k is very small .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact 


However , its disadvantage is the high computational cost of clustering faces on a high-dimensional feature space ( i.e. , 1,937 dimensions ) .
Meanwhile , its disadvantage is the expensive computational cost to perform clustering faces on a high dimensional feature space ( i.e. , 1937 dimensions ) .
-1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#15#6#exact -1#7#7#exact -1#8#8#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#17#15#exact -1#18#16#exact -1#19#17#exact -1#20#18#exact -1#21#19#exact -1#23#21#exact -1#24#22#exact -1#25#23#exact 


When k is large enough , there is no substantial difference in MAP between k-Faces.KMeans and k-Faces.Temporal.
When k is large enough , there is no substantial difference in MAP between k-Faces.KMeans and k-Faces.Temporal.
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact 


In both datasets , when k increases from 2 to 20 , the MAPs of k-Faces approaches grow rapidly .
On both datasets , when k increases from 2 to 20 , MAPs of k-Faces approaches grow rapidly .
-1#0,1#0,1#para -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12,13#para -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact 


However , the MAPs become stable from k = 20 upward .
However , theirs MAPs become stable from 20 afterwards .
-1#0#0#exact -1#1#1#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#9#exact -1#9#11#exact 


Because further increasing k does not help improve accuracy but increases the computational cost , we select k = 20 for investigating the trade-off between the accuracy and computational cost of k-Faces approaches in comparison to others .
Since keep increasing k does not help to obtain imporant accuracy improvement but expensive computational cost , we select k = 20 to investigate the trade-off between accuracy and computational costs of k-Faces approaches compared to others .
-1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#11#7#stem -1#10#8#exact -1#12#9#exact -1#24#11#exact -1#14#12#exact -1#15#13#exact -1#16#14#exact -1#17#15#exact -1#18#16#exact -1#19#17#exact -1#20#18#exact -1#21#19#exact -1#23#21,22#para -1#25#23#exact -1#26#24#exact -1#27,28#25,26,27#para -1#29#28#exact -1#30,31#29,30#para -1#32#31#exact -1#33#32#exact -1#34,35#33,34,35#para -1#36#36#exact -1#37#37#exact 


Table 5 shows the MAP and processing time of each approach .
We report MAP and processing time of each approach in the Table 5 .
-1#11#0#exact -1#12#1#exact -1#10#3#exact -1#2#4#exact -1#3#5#exact -1#4#6#exact -1#5#7#exact -1#6#8#exact -1#7#9#exact -1#8#10#exact -1#13#11#exact 


Processing time is divided into two parts , preprocessing and matching .
Processing time is separated into two parts , corresponding to preprocessing time and matching time .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#syn -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#10#8#exact -1#12#9#exact -1#13#10#exact -1#15#11#exact 


The preprocessing time refers to the time required to preprocess face tracks before matching .
Preprocessing time presents time required for preprocessing face-tracks before matching .
-1#0#1#lc -1#1#2#exact -1#3#6#exact -1#4#7#exact -1#2#10#syn -1#8#12#exact -1#9#13#exact -1#10#14#exact 


In k-Faces approaches , the preprocessing of face tracks includes selecting representative faces and computing their mean face .
With k-Faces approaches , preprocessing facetracks includes selecting representative faces and computing their mean face .
-1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#5#exact -1#14#7#exact -1#6#9#exact -1#7#10#exact -1#8#11#exact -1#9#12#exact -1#10#13#exact -1#11#14#exact -1#12#15#exact -1#13#16#exact -1#15#18#exact 


In MSM and CMSM , preprocessing includes computing subspaces for face tracks .
In MSM and CMSM , it indicates time for computing subspaces for face-tracks .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#9#7#exact -1#10#8#exact -1#11#9#exact -1#13#12#exact 


The matching time is averaged over one query run .
Matching time is averaged for one query run .
-1#0#1#lc -1#1#2#exact -1#2#3#exact -1#3#4#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact 


The time unit used is seconds.
Time unit is second.
-1#0#1#lc -1#1#2#exact -1#2#4#exact 


As shown in Table 5 , k-Faces.KMeans and k- Faces.Temporal achieve almost equal accuracy and consume the same amount of time for one query in both datasets .
According to Table 5 , k-Faces.KMeans and k- Faces.Temporal achieve almost equal accuracy and consume the same amount of time for one query on both datasets .
-1#1,2#2,3#para -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23,24#24,25#para -1#25#26#exact -1#26#27#exact 


However , k-Faces.Temporal is hundreds of times ( 240 times in Trecvid and 360 times in NHKNews7 ) faster than k-Faces.Temporal in the preprocessing phase .
However , k-Faces.Temporal is hundreds times ( 240 times on Trecvid and 360 times on NHKNews7 ) faster than k-Faces.Temporal in the preprocessing phase .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5,6#para -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#20#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact 


This suggests that in terms of both accuracy and efficiency , selecting representative faces based on temporal sampling is better than that based on clustering .
This suggest that , selecting presentative faces based on tempo .
-1#0#0#exact -1#1,2#1,2,3#para -1#3#10#exact -1#4#11#exact -1#6#13#exact -1#7#14#exact -1#8#15#exact -1#10#25#exact 


,
ral sampling is better than one based on clustering , in both terms of accuracy and efficiency.
-1#9#0#exact 


Compared to state-of-the-art approaches , our k- Faces.Temporal is thousands of times faster than the best approach , which is pair:min , and hundreds of times faster than MSM and CMSM in both datasets .
Compared to state-of-the-art approaches , our k- Faces.Temporal is thousands times faster than the best approach , which is pair:min , and hundred times faster than MSM and CMSM on both datasets .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10,11#para -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22,23#23,24,25#para -1#24#26#exact -1#25#27#exact -1#26#28#exact -1#27#29#exact -1#28#30#exact -1#29,30#31,32#para -1#31#33#exact -1#32#34#exact 


In terms of accuracy , k-Faces takes second place , with 73.65% in the Trevid dataset , after pair:min .
In terms of accuracy , k-Faces take second place , with 73.65% on Trevid dataset , after pair:min .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#stem -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact 


The difference in MAP between our approach and pair:min is 2.89% .
The gap with pair:min is 2.89% difference in MAP .
-1#0#0#exact -1#6#1#exact -1#7#2#exact -1#8#3#exact -1#3#8#exact -1#4#9#exact -1#5#10#exact -1#9#11#exact 


Meanwhile , k- Faces.Temporal is significantly better than MSM and CMSM , which respectively achieved 69.20% and 64.62% accuracy .
Meanwhile , it is significantly better than MSM and CMSM , which respectively achieve 69.20% and 64.62% .
-1#0#0#exact -1#1#1#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#stem -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#19#exact 


In the NHKNews7 dataset , k-Faces.Temporal is better than CMSM , but worse than pair:min and MSM .
On NHKNews7 dataset , our k-Faces.Temporal is still better than CMSM , but is worse than pair:min and MSM .
-1#1#2#exact -1#2#3#exact -1#3#4#exact -1#5#5#exact -1#6#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13,14,15#12,13#para -1#16#14#exact -1#17#15#exact -1#18#16#exact -1#19#17#exact 


Recommend-Me : recommending query regions for image search
Recommend-Me : recommending query regions for image search
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact 


This paper presents a novel recommendation system , named Recommend-Me , to facilitate users in searching and exploring images in unknown image databases .
This paper presents a novel recommendation system , named Recommend-Me , to faciliate users in searching and exploring images of an unknown image database .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#21#20#exact -1#22#21#exact -1#23#22#stem -1#24#23#exact 


Given an initial query image , Recommend-Me automatically shows its recommendations to users .
Given an initial query image , Recommend-Me automatically introduces its recommendations to users .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact 


The recommendations indicate which and how frequent items in the initial query image occur in the database .
The recommendations indicate which and how frequent items in the initial query image occur in the database .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact 


In this way , users can make their own decisions before any actual search .
So that , users can make their own decisions before any actual search .
-1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact 


If there is a recommendation matching their search intention , relevant search results are ensured .
If there is a recommendation matched their search intention , relevant search results are ensured .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#stem -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact 


Otherwise , users should refine their initial query image for a better query sample .
Otherwise , users should refine their initial query image for a better query sample .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact 


Or , they can start exploring the database by using the recommended items as hints .
Or , they can start exploring the database by using the recommended items as hints .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact 


Recommend-Me helps users to avoid unnecessary trials and poor searching experiences .
Recommend-Me helps users to avoid unnecessary trials and poor searching experiences .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact 


We describe an efficient approach for Recommend-Me to deal with quantifying occurrences of multiple candidate items in the images of the database .
We introduce an efficient approach for Recommend-Me to deal with quantifying occurences of multiple candidate items over images of the database .
-1#0#0#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#17,18,19#17,18,19,20#para -1#20#21#exact -1#21#22#exact 


Instead of scanning the database for each candidate item , the approach enumerate occurrences of multiple candidate items simultaneously by investigating pairs of highly similar regions , knowing one pair is formed by a region in the initial image and a region in an image of the database .
Instead of scanning the database for each candidate item repspectively , the approach enumerate occurences of multiple candidate items simultaneously by investigating pairs of highly similar regions , knowing one pair is formed by a region in the intial image and a region in an image of the database .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact -1#23#22#exact -1#24#23#exact -1#25#24#exact -1#26#25#exact -1#27#26#exact -1#28#27#exact -1#29#28#exact -1#30#29#exact -1#31#30#exact -1#32#31#exact -1#33#32#exact -1#34#33#exact -1#35#34#exact -1#36#35#exact -1#37#36#exact -1#39#38#exact -1#40#39#exact -1#41#40#exact -1#42#41#exact -1#43#42#exact -1#44,45#43,44,45,46#para -1#48#47#exact -1#49#48#exact 


We formulate the problem of finding such pairs as an optimization problem , which can be solved by a branch-and-bound algorithm .
We formulate the problem of finding such pairs as an opmization problem , which can be solved by a branch-and-bound algorithm .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact 


Experiments conducted on a real-life and publicly available dataset demonstrate the efficiency , robustness , and promising application of our system .
Experiments conducted on a real-life and publicly available dataset demonstrate the efficiency , the robustness and a promissing application of our system .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#14#13#exact -1#15#15#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact 


Thanks to the advances of modern technology , a large amount of digital images can be easily created and stored nowadays .
With the advances of modern technology , a large amount of digital images nowadays can be created and stored easily .
-1#1#2#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#14#14#exact -1#15#15#exact -1#19#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#13#20#exact -1#20#21#exact 


The resulting exponential growth of image repositories , however , has created an urgent need for effective ways of searching images .
As a result , the exponential growth of image repositories creates the urgent needs for searching images . Because of its importance and wide applications , image search has attracted more interest in recent years .
-1#4#0#lc -1#0,1,2#1#para -1#5#2#exact -1#6#3#exact -1#7#4#exact -1#8#5#exact -1#9#6#exact -1#3#7#exact -1#25#9#exact -1#28#10#exact -1#10#11#stem -1#11,12#12,13#para -1#13,14#14,15#para -1#19#18#exact -1#15#19#exact -1#16#20#exact -1#17#21#exact 


Moreover , image search has gained interest in recent years because of its importance and wide range of applications . In a typical scenario , users supply a query item , which is usually a region cropped from an image .
In a typical scenario of image search , users supply a query item which is usually represented by a region cropped from an image .
-1#7#1#exact -1#5#2#exact -1#6#3#exact -1#0#7#lc -1#4#11#exact -1#24#19#exact -1#1#21#exact -1#2#22#exact -1#3#23#exact -1#8#25#exact -1#9#26#exact -1#10#27#exact -1#11#28#exact -1#12#29#exact -1#13#31#exact -1#14#32#exact -1#15#33#exact -1#18#34#exact -1#19#35#exact -1#20#36#exact -1#21#37#exact -1#22#38#exact -1#23#39#exact 


The search system then returns a list of relevant images retrieved from a database .
The search system then returns a list of relevant images retrieved from a database .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact 


The images are expected to contain the query item .
The images are expected to contain the query item .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact 


Extensive studies have been conducted with an eye to improving the performance of this sort of search \CITE .
Several extensive works have been conducted with great interest on improving search performance \CITE .
-1#1#0#lc -1#2#1#syn -1#3#2#exact -1#4#3#exact -1#5#4#exact -1#6#5#exact -1#10#9#exact -1#12#11#exact -1#11#16#exact -1#13#17#exact -1#14#18#exact 


However , regardless of the powerfulness of state-of-the-art search techniques , there are still cases in which users are disappointed with their search results .
However , regardless of the powerfulness of state-of-the-art search techniques , there are still cases in which users are disappointed with search results .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact 


The reason is that relevant items are not in the database .
The reason is because relevant items are not in the database .
-1#0#0#exact -1#1#1#exact -1#2,3#2,3#para -1#4#4#exact -1#5#5#exact -1#6,7#6,7,8,9#para -1#10#10#exact -1#11#11#exact 


Under such circumstances , whatever the search technique is , results are obviously irrelevant and unexpected .
Under such circumstances , whatever the search technique is , results are obviously irrelevant and unexpected .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact 


A normal user without prior knowledge about a database has no choice but to search it by trial-and-error .
A normal user without prior knowledge about the retrieved database has no choice but search by trial-and-error .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13,14#para -1#15#16#exact -1#16#17#exact -1#17#18#exact 


We decided to tackle this problem to help users in searching and exploring images in unknown databases .
We tackle this problem to facilitate users in searching and exploring images of such unknown database .
-1#0#0#exact -1#4#2#exact -1#1#3#exact -1#2#4#exact -1#3#5#exact -1#5#7#syn -1#6#8#exact -1#7#9#exact -1#8#10#exact -1#9#11#exact -1#10#12#exact -1#11#13#exact -1#14#15#exact -1#15#16#stem -1#16#17#exact 


Our proposal is a novel recommendation system , named Recommend-Me .
Our proposal is a novel recommendation system , named Recommend-Me .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact 


The envisioned scheme can be described as follows ( see Figure \REF for an example ) .
The expected scheme can be described as follows ( see Figure \REF for an example ) .
-1#0#0#exact -1#1#1#para -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact 


Given an unknown database and an initial query image , Recommend-Me automatically presents its recommendations to the user .
Given an unknown database and an initial query image , our Recommend-Me automatically presents its recommendations to user .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14,15#13,14,15,16#para -1#17#17#exact -1#18#18#exact 


One recommendation is one item , bounded by a rectangular region , in the initial query image .
One recommendation is one item , bounded by a rectangular region , in the initial query image .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact 


Each recommended item is assigned a number to show in how many images of the database it occurs .
Each recommended item is assigned a number to clarify how many images of the database it occurs .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#9#9,10#para -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact 


Items with larger assigned numbers will be more recommended .
Items with higher assigned numbers will be more recommended .
-1#0#0#exact -1#1#1#exact -1#2#2#para -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact 


By providing such recommendations , Recommend-Me helps users to :
By providing such recommendations , Recommend-Me supports users to :
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact 


- avoid unexpected search experience with poor queries that are subjectively ( and sometimes randomly ) selected ,
- avoid unexpected search experience with poor queries that are subjectively ( and sometimes randomly ) selected ,
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact 


- rapidly refine the initial query image before any actual search , if the recommendations show that current search intention can not return relevant results ,
- rapidly refine the initial query image before any actual search , if the recommendations show that current search intention can not return relevant results ,
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact 


- explore the database using the recommendations as hints .
- explore the database using the recommendations as hints .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact 


Recommend-Me is a pure visual recommendation system .
Recommend-Me is a pure visual recommendation system .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact 


No extra information or knowledge is required for an input besides an initial query image and a database . //<" and the name of the database " ? ? Or " and the location and name of the database " ? ?>
No extra information or knowledge is required for input but an initial query image and a retrieved database .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#10#8#exact -1#8#9#exact -1#11#11,12#para -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#17#17#exact -1#18#18#exact 


To automatically generate recommendations , we need to address several issues .
To automatically generate recommendations , we need to address several critical issues .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#11#10#exact -1#12#11#exact 


First , there tends to be a huge pool of candidate items in the initial query image .
First , there is a huge pool of candidate items in the initial query image .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#para -1#4,5#4,5,6,7#para -1#6#8#exact -1#7#9#exact -1#8#10#exact -1#9#11#exact -1#10#12#exact -1#11#13#exact -1#12#14#exact -1#13#15#exact -1#14#16#exact -1#15#17#exact 


Basically , any rectangular region in the image can be considered as a candidate item .
Basically , any rectangular region in the image can be considered as a candidate item .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9,10#9,10,11,12#para -1#13#13#exact -1#14#14#exact -1#15#15#exact 


Examining all of them would incur an enormous computational cost .
Examining all of them requires enormous computational cost .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#5#7#exact -1#6#8#exact -1#7#9#exact -1#8#10#exact 


Second , even if a candidate item is known , enumerating its occurrences in the database is a not trivial task because it is subject to many variations in viewpoint , scale , rotation , occlusion , etc.
Second , even if a candidate item is known , enumerating its occurrences in the database is not trivial because it is subject to many variations such as viewpoint and scale changes , rotation or occlusion .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#18#exact -1#18#19#exact -1#19#21#exact -1#20#22#exact -1#21#23#exact -1#22#24#exact -1#23#25#exact -1#24#26#exact -1#25#27#exact -1#28#29#exact -1#32#30#exact -1#30#31#exact -1#33#33#exact -1#35#35#exact 


Furthermore , the cost of scanning all regions of the images of the database will inevitably be prohibitive for practical purposes .
Furthermore , scanning over all regions in images of the database will inevitably be prohibitive , if not infeasible for practical purposes .
-1#0#0#exact -1#1#1#exact -1#9#2#exact -1#8#4#exact -1#2#5#exact -1#4#6#exact -1#5#7#exact -1#7#8,9,10,11#para -1#10#13#exact -1#11#14#exact -1#12#15#exact -1#13#16#exact -1#14#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact 


In this paper , we employ state-of-the-art techniques such as SIFT and the Bag-of-Words ( BoW ) model to handle the task of matching regions with the above variations .
In this paper , we employ state-of-the-art techniques such as SIFT and Bag-of-Words ( BoW ) model to handle matching regions under variations .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#22,23#para -1#20#24#exact -1#22#28#exact -1#23#29#exact 


Our main focus is to devise an efficient approach for quantifying occurrences of candidate items in the database in order to generate recommendations .
Our main focus is an efficient approach for quantifying occurences of candidate items over the database to generate recommendations .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#16#4#exact -1#4#6#exact -1#5#7#exact -1#6#8#exact -1#7#9#exact -1#8#10#exact -1#10#12#exact -1#11#13#exact -1#12#14#exact -1#14#16#exact -1#15#17#exact -1#17#20,21#para -1#18#22#exact -1#19#23#exact 


The advantage in efficiency comes from our use of various methodologies .
The efficiency advantages of our approach come from various methodologies .
-1#0#0#exact -1#1#3#exact -1#6#4#stem -1#7#5#exact -1#4#6#exact -1#8#7,8,9#para -1#9#10#exact -1#10#11#exact 


Based on the observation that users are mostly interested in object-like items , we decided to use a selective search approach proposed by Van de Sande et al. \CITE to sample regions bounding object-like items in all images as a preprocessing step .
Based on an observation that users are mostly interested in object-like items , we use a selective search approach proposed by Van de Sande et al. \CITE to sample regions bounding object-like items in all images as a preprocessing step .
-1#0#0#exact -1#1#1#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#27#15#exact -1#14#16#exact -1#15#17#exact -1#16#18#exact -1#17#19#exact -1#18#20#exact -1#19#21#exact -1#20#22#exact -1#21#23#exact -1#22#24#exact -1#23#25#exact -1#24#26#exact -1#25#27#exact -1#26#28#exact -1#28#30#exact -1#29#31#exact -1#30#32#exact -1#31#33#exact -1#32#34#exact -1#33#35#exact -1#34#36#exact -1#35#37#exact -1#36#38#exact -1#37#39#exact -1#38#40#exact -1#39#41#exact -1#40#42#exact 


By applying this approach instead of a naive sampling approach such as sliding windows , we were able to dramatically reduce the number of items ( i.e. regions ) that need to be processed in each image .
By applying the approach instead of other naive sampling approach such as sliding windows , the number of items ( i.e. regions ) that need to be processed in each image dramatically reduces .
-1#0#0#exact -1#1#1#exact -1#2,3#2,3#para -1#4#4#exact -1#5#5#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#26#16#syn -1#25#18#exact -1#31#19#exact -1#15,16,17#20,21,22,23#para -1#18#24#exact -1#19#25#exact -1#20#26#exact -1#21#27#exact -1#22#28#exact -1#23#29#exact -1#24#30#exact -1#27#32,33#para -1#28#34#exact -1#29#35#exact -1#30#36#exact -1#33#37#exact 


Given two sets of regions , one containing regions of candidate items in the initial query image and the other containing regions of items in images of the database , our task is to find occurrences of all candidate items in the database .
Given two sets of regions , one contains regions of candidate items in the initial query image and the other contains regions of items in images of the database .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#stem -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#stem -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#43#exact 


This task can be equivalently treated as finding pairs of matched regions , knowing that a pair is formed by a region in one of the sets with a region in the other .
Finding occurences of all candidate items in the database can be equally treated as finding pairs of matched regions , knowing a pair is formed by a region in one of the sets with a region in the other .
-1#9#2#exact -1#10#3#exact -1#12#5#exact -1#13#6#exact -1#14#7#exact -1#15#8#exact -1#16#9#exact -1#17#10#exact -1#18#11#exact -1#19#12#exact -1#20#13#exact -1#21#15#exact -1#22#16#exact -1#23#17#exact -1#24#18#exact -1#25#19#exact -1#26#20#exact -1#27#21#exact -1#28#22#exact -1#29#23#exact -1#30#24#exact -1#31#25#exact -1#32#26#exact -1#33#27#exact -1#34#28#exact -1#35#29#exact -1#36#30#exact -1#37#31#exact -1#38#32#exact -1#39#33#exact 


So , if the top region pairs are found with sufficiently high similarity scores , we can enumerate the occurrences of the items .
So , if top region pairs with sufficient high similarity scores are found , we can enumerate occurences of the items .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#19#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#11#7#exact -1#12#8#exact -1#6#9#exact -1#7#10#stem -1#8#11#exact -1#9#12#exact -1#10#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#18#20#exact -1#20#21,22#para -1#21#23#exact 


Based on this insight , we can boost efficiency yet again by formulating the problem as an optimization problem that can be solved by applying a branch-and-bound algorithm .
Based on these insights , we make an yet another efficiency boost by formulating the problem as an optimization problem which can be solved by applying a branh-and-bound algorithm .
-1#0#0#exact -1#1#1#exact -1#3#3#stem -1#4#4#exact -1#5#5#exact -1#21#6#exact -1#11#7#exact -1#10#8#exact -1#8#9#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#22,23#20,21,22#para -1#24#23#exact -1#25#24#exact -1#26#25#exact -1#28#27#exact -1#29#28#exact 


In order to do that , we introduce a novel representation based on a hierarchical structure describing a set of region pairs and a corresponding function bounding the similarity scores of pairs over such a set .
In order to do that , we introduce a novel representation based on hierarchical structure to describe a set of region pairs and a corresponding function bounding the similarity scores of pairs over such a set .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#17#13#exact -1#13#14#exact -1#14#15#exact -1#15,16#16#para -1#23#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#34#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#35#35#exact -1#36#36#exact 


Related Work .
Related Works .
-1#0#0#exact -1#1#1#stem -1#2#2#exact 


On the topic of discovering common items , Recommend-Me is related to recent studies on mining common items in image databases such as \CITE .
With respect to discovering common items , Recommend-Me is related to recent studies on mining common items in image databases such as \CITE .
-1#13#0#lc -1#1#2#para -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact 


However , in contrast to these studies , Recommend-Me targets items which are shared by both an image database and the user 's particular interest inthe input initial image .
However , in contrast to these studies , Recommend-Me targets items which are shared by both an image database and user interest limited in an input initial image .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20,21#para -1#21#24#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact -1#28#29#exact 


Meanwhile , \CITE only aims at finding common items within the database .
Meanwhile , \CITE only aim at finding common items within the database .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#stem -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact 


One can employ these techniques to solve our problem by first identifying common items among the images of the database , then looking them up in the initial query image again to make recommendations .
One can employ these techniques to our problem by firstly figuring out common items among images of the database , then looking them up in the initial query image again for recommendations .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#stem -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15,16,17#15,16,17,18#para -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact -1#28#29#exact -1#29#30#exact -1#31#33#exact -1#32#34#exact 


However , doing that incurs the extra cost of mining unnecessary items that appear in the database , but not in the initial query image .
However , by doing that , extra costs for mining unnecessary items , which appear in the database but the initial query image , arise accordingly .
-1#0#0#exact -1#1#1#exact -1#3#2#exact -1#4#3#exact -1#16#5#exact -1#6#6#exact -1#7,8#7,8#para -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#14#13#exact -1#15#14#exact -1#19#15#exact -1#17#16#exact -1#5#17#exact -1#18#18#exact -1#20#21,22#para -1#21#23#exact -1#22#24#exact -1#26#25#exact 


One of the most related studies to ours is that of Zha et al in \CITE .
One of the most related works to Recommend-Me for query suggestion is proposed by Zha et al in \CITE .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#syn -1#6#6#exact -1#11#7,8#para -1#14#11#exact -1#15#12#exact -1#16#13#exact -1#17#14#exact -1#18#15#exact -1#19#16#exact 


They introduced a system , called Visual Query Suggestion ( VQS ) , that simultaneously provides both keyword and image suggestions to users .
They introduced a system called Visual Query Suggestion ( VQS ) which simultanously provides both keyword and image suggestions for users .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#12#14#stem -1#13#15#exact -1#14#16#exact -1#15#17#exact -1#16#18#exact -1#17#19#exact -1#18#20#exact -1#20#22#exact -1#21#23#exact 


There are clear differences between Recommend-Me and VQS .
There are clear differences between our Recommend-Me and VQS .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact 


VQS requires an initial text query for formulating the suggestion , and its suggestions are both keywords and images .
VQS requires an initial text query for suggestion formulation and its suggestions are both keywords and images .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#8#7#stem -1#7#8,9#para -1#9#11#exact -1#10#12#exact -1#11#13#exact -1#12#14#exact -1#13#15#exact -1#14#16#exact -1#15#17#exact -1#16#18#exact -1#17#19#exact 


On the other hand , Recommend-Me takes an image as input , and its outputs are regions in the image .
On the other hand , Recommend-Me takes an image as input and its outputs are regions in the image .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact 


Recommend-Me is a query suggestion system based on pure visual information .
Recommend-Me is a query suggestion system based on pure visual information .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact 


Above all , although both Recommend-Me and VQS aim at helping users search for images , their targeted problems are different .
Above all , although both Recommend-Me and VQS aim at facilitating users in searching images , the targeted problems are different .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#syn -1#11#11#exact -1#13#12#stem -1#14#14#exact -1#15#15#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact 


VQS proposes to help users to overcome their tendency to formulate ambiguous queries by precisely expressing search intents , assuming the relevant items are always available .
VQS proposes to help users to overcome query ambiguity formulation by precisely expressing search intents , assuming relevant items are always available .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#9#10#stem -1#8#11#stem -1#7#12#stem -1#10#13#exact -1#11#14#exact -1#12#15#exact -1#13#16#exact -1#14#17#exact -1#15#18#exact -1#16#19#exact -1#17#20,21#para -1#18#22#exact -1#19#23#exact -1#20#24#exact -1#21#25#exact -1#22#26#exact 


Meanwhile , Recommend-Me helps users to select queries based on the existence of relevant items in the retrieved database .
Meanwhile , Recommend-Me supports users to select queries based on the existence of their relevant items in the retrieved database .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9,10,11,12#9,10,11#para -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact 


To the best of our knowledge , Recommend-Me is the first attempt at this sort of targeted suggestion scheme .
To the best of our knowledge , Recommend-Me is the first attempt towards its targeted suggestion scheme .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#14#15,16#para -1#15#17#exact -1#16#18#exact -1#17#19#exact 


From a technical point of view , our solution is motivated by recent work on object localization and subimage retrieval based on branch-and-bound optimization \CITE .
From technical point of view , our solution is motivated by recent works for object localization and subimage retrieval based on branch-and-bound optimization \CITE .
-1#0#0#exact -1#1#2#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12,13#13#para -1#20#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact 


However , ours is differentiated from the other studies in that we represent sets of region pairs , instead of only sets of regions .
However , ours is differentiated in the way we represent sets of region pairs , instead of sets of regions only .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#6#6#exact -1#5#9#exact -1#8,9#10,11,12#para -1#10#13#exact -1#11#14#exact -1#12#15#exact -1#13#16#exact -1#14#17#exact -1#15#18#exact -1#16#19#exact -1#20#20#exact -1#17#21#exact -1#18#22#exact -1#19#23#exact -1#21#24#exact 


ESS and ESR \CITE use coordinate intervals for their presentation .
ESS and ESR \CITE use coordinate intervals for their presentation .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact 


In contrast , we utilize hierarchical structures in order to do that , since our regions are discrete .
Meanwhile , we utilize hierarchical structures in order to do that , since our regions are discrete .
-1#6#0#lc -1#1#2#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact 


Although coordinate intervals as in ESS ( or ESR ) can be extended to represent sets of region pairs , such a criterion in the context of the branch-and-bound algorithm may suffer from the curse-of-dimensionality problem since the number of dimensions required at least doubles .
Although coordinate intervals as in ESS ( or ESR ) can be extended to represent set of region pairs , such criterion may suffer the branch-and-bound algorithm from curse-of-dimensionality problem since the number of dimension required is at least doubled .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#stem -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#22#exact -1#31#24#exact -1#33#26#exact -1#24#27#exact -1#25#28#exact -1#26#29#exact -1#22#30#exact -1#23#31#exact -1#27#32#exact -1#28#34#exact -1#29#35#exact -1#30#36#exact -1#32#37,38#para -1#34#40#stem -1#35#41#exact -1#36,37,38#42,43#para -1#39#44#stem -1#40#45#exact 


Finally , ESS , ESR and Recommend-Me differ in that they have different approaches to constructing a bounding quality function and to computing bounding values over the sets .
Finally , ours and ESS , ESR do not share common approach to construct bounding quality function and to compute bounding values over the sets .
-1#0#0#exact -1#1#1#exact -1#4#2#exact -1#5#3#exact -1#6#4#exact -1#3#5#exact -1#11#13#stem -1#12#14#exact -1#13#15#stem -1#14#17#exact -1#15#18#exact -1#16#19#exact -1#17#20#exact -1#18#21#exact -1#19#22#stem -1#20#23#exact -1#21#24#exact -1#22#25#exact -1#23#26#exact -1#24#27#exact -1#25#28#exact 


The rest of this paper is organized as follows .
The rest of this paper is organized as follows .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact 


Section 2 presents an overview of the system .
Section 2 presents an overview of the system .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact 


The details of how we find region pairs with the highest similarity scores are given in Section 3 .
Details of our proposed approaches for finding region pairs with highest similarity scores are given in Section 3 .
-1#0#1#lc -1#1#2#exact -1#5,6#5#para -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9,10#para -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact 


Section 4 presents our experiments and evaluations .
Section 4 presents our experiments and evaluations .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact 


Section 5 concludes the paper .
Section 5 concludes our paper .
-1#0#0#exact -1#1#1#exact -1#2,3#2,3#para -1#4#4#exact -1#5#5#exact 


The framework of Recommend-Me consists of four main steps .
The framework of Recommend-Me consists of 4 main steps towards formulating final recommendations for users .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#syn -1#7#7#exact -1#8#8#exact -1#15#9#exact 


Figure \REF summarizes the pipeline .
Figure \REF summarizes the pipeline .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact 


Step 1 : Select candidate items in images .
Step 1 : Candidate item selection in images .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#4#lc -1#4#5#stem -1#6#6#exact -1#7#7#exact -1#8#8#exact 


Using all possible rectangular regions in images as candidate items is overly expensive in the subsequent processing .
Using all possible rectangular regions in images as candidate items is overly expensive for further processing .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#14#15#para -1#15#16#exact -1#16#17#exact 


More importantly , users are often attracted by object-like items .
More importantly , human users are often get attracted by object-like items .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#4#3#exact -1#5#4#exact -1#6#5#exact -1#8#6#exact -1#9#7#exact -1#10#8#exact -1#11#9#exact -1#12#10#exact 


Thus , we employ an approach proposed by Van de Sande et al. \CITE for item selection .
Thus , we employ an approach proposed by Van de Sande et al. \CITE for item selection .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact 


The approach starts by over-segmenting an image into disjoint regions .
The approach starts by oversegmenting an image into disjoint regions .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact 


Then , it performs a greedy search < ? ?> algorithm that iteratively merges the two most similar regions together until the whole image becomes a single region .
Then , it performs a greedy algorithm which iteratively merges the two most similar regions together until the whole image becomes a single region .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#10#exact -1#8#12#exact -1#9#13#exact -1#10#14#exact -1#11#15#exact -1#12#16#exact -1#13#17#exact -1#14#18#exact -1#15#19#exact -1#16#20#exact -1#17#21#exact -1#18#22#exact -1#19#23#exact -1#20#24#exact -1#21#25#exact -1#22#26#exact -1#23#27#exact -1#24#28#exact 


All regions throughout the hierarchy are considered to be candidate items .
All region throughout the hierarchy is considered as candidate items .
-1#0#0#exact -1#1#1#stem -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5,6#5,6#para -1#8#9#exact -1#9#10#exact -1#10#11#exact 


Each item is represented by its rectangular bounding region .
Each item is represented by its rectangular bounding region .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact 


Step 2 : Find top region pairs with the highest similarity scores .
Step 2 : Finding top region pairs with highest similarity scores .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#stem -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8,9#para -1#9#10#exact -1#10#11#exact -1#11#12#exact 


There will be a pool of region pairs if we compare each region in the initial query image with each region in images of the database .
There is a pool of region pairs if we compare each region in the initial query image with each region in images of the database .
-1#0#0#exact -1#1#1,2#para -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact 


However , only region pairs with sufficiently high similarity scores are meaningful for identifying occurrences of candidate items .
However , only region pairs with sufficient high similarity scores are meaningful for identifying occurrences of candidate items .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#stem -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact 


In this step , we use the approach explained in Section 3 to find the top \MATH ( the expected number of returned region pairs ) of such pairs in the pool .
In this step , we perform our proposed approach , explained in Section 3 , to find top \MATH ( an expected number of returned region pairs ) of such pairs in the pool .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#32#6#exact -1#8#7#exact -1#10#8#exact -1#11#9#exact -1#12#10#exact -1#13#11#exact -1#15#12#exact -1#16#13#exact -1#17#15#exact -1#18#16#exact -1#19#17#exact -1#21#18,19#para -1#22#20#exact -1#23#21#exact -1#24#22#exact -1#25#23#exact -1#26#24#exact -1#27#25#exact -1#28#26#exact -1#29#27#exact -1#30#28#exact -1#31#29#exact -1#33#31#exact -1#34#32#exact 


Step 3 : Group overlapping regions .
Step 3 : Grouping overlapping regions .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#stem -1#4#4#exact -1#5#5#exact -1#6#6#exact 


Given \MATH region pairs returned in Step 2 and assuming each region pair in the \MATH pairs is formed by a candidate item and its corresponding match , we can enumerate the number of occurrences of the items .
Given \MATH region pairs returned in Step 2 and assuming each region pair in \MATH pairs is formed by a candidate item and its corresponding match , we now can enumerate the number of occurences of the items .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#31#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact -1#29#29#exact -1#30#30#exact -1#36#31#exact -1#32#32#exact -1#33#33#exact -1#35#35#exact -1#37#36,37#para -1#38#38#exact 


However , there are likely several regions that overlap each other due to the merging done in Step 1 .
However , there are several regions highly overlap each other due to merging in Step 1 .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#5#exact -1#5#6#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#14#exact -1#13#16#exact -1#14#17#exact -1#15#18#exact -1#16#19#exact 


These regions would be perceived as the same item by users .
They are perceived as the same item by human being .
-1#1#2,3#para -1#2#4#exact -1#3#5#exact -1#4#6#exact -1#5#7#exact -1#6#8#exact -1#7#9#exact -1#10#11#exact 


Thus , we propose to use maximal clique analysis to group such regions so that the recommendations will be consistent .
Thus , we propose to use maximal clique analysis technique to group such regions for consistent recommendations .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#16#15,16#para -1#15#18,19#para -1#17#20#exact 


One clique is one group of regions .
One clique is one group of regions .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact 


Step 4 : Formulate recommendations .
Step 4 : Formulating recommendations .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#stem -1#4#4#exact -1#5#5#exact 


Finally , for each group of regions , we count the number of images containing at least one match of one member region of the group .
Finally , for each group of regions , we count the number of images containing at least one match of one member region of the group .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact 


The number indicates how frequent the item , represented by the group , occurs in the database .
The number indicates how frequent the item , represented by the group , occurs in the database .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact 


Using those numbers , we rank all groups and show them as recommendations to users .
Using those numbers , we rank all groups and then introduce them to users as our recommendations .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#11#10#exact -1#14#11#exact -1#16#12#exact -1#12#13#exact -1#13#14#exact -1#17#15#exact 


A representative of each group is a rectangular region located by averaging the coordinates of all member regions of the group .
Representative of each group is a rectangular region located by averaging coordinates of all member regions of the group .
-1#5#0#lc -1#0#1#lc -1#1#2#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#17#12#exact -1#11#13#exact -1#12#14#exact -1#13#15#exact -1#14#16#exact -1#15#17#exact -1#16#18#exact -1#18#19,20#para -1#19#21#exact 


In this section , we describe our approach for efficiently finding the top \MATH similar region pairs in the pool of all possible region pairs .
In this section , we introduce our proposed approach for efficiently finding top \MATH similar region pairs in the pool of all possible region pairs .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#6#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#18#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact 


Given two sets of regions \MATH and \MATH , the set of all possible region pairs can then be represented as \MATH .
Given two sets of regions \MATH and \MATH , the set of all possible region pairs then can be represented as \MATH .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16,17#16,17#para -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact 


By using the similarity function \MATH , we have to solve the following optimization problem in order to find the region pair \MATH with the highest similarity score .
With a similarity function \MATH , we have to solve the following optimization problem in order to find the region pair \MATH with the highest similarity score .
-1#18#2#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14,15,16,17#15,16,17,18,19#para -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact 


Because \MATH elements , it is expensive to perform this maximization exhaustively .
Because \MATH elements , it is expensive to perform this maximization exhaustively .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact 


We hence propose to use a branch-and-bound algorithm \CITE to solve the problem .
We propose to use a branch-and-bound algorithm \CITE for the problem .
-1#0#0#exact -1#1#2#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#9#11#exact -1#10#12#exact -1#11#13#exact 


Once \MATH is found , we can obtain the other top region pairs by continuing the search process with the remaining search space , in which the found top pairs have been eliminated .
Once \MATH is found , we can obtain the other top region pairs by continuing the search processs with the remaining search spaces , in which found top pairs eliminated .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#stem -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#27#exact -1#27#28#exact -1#28#29#exact -1#29#30,31,32#para -1#30#33#exact 


A general branch-and-bound algorithm works by hierarchically dividing the parameter space into disjoint parts ; this is called the branching step .
A general branch-and-bound algorithm works by hierarchically dividing the parameter space into disjoint parts , known as branching step .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#15,16#17,18#para -1#17#19#exact -1#18#20#exact -1#19#21#exact 


In the bounding step , each part is assigned an upper bound for which the quality function could take on any of the members of the part . //<The rewrite is grammatical but I don 't know what " the quality function could take on any of the members of the part " . Inparticular what are these members and can they be computed in a function ?>
In the bounding step , each part is assigned an upper bound value that the quality function could take on any of the members of the part .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12,13#13#para -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21,22,23,24,25#21,22,23,24#para -1#26#25,26#para -1#27#27#exact 


Those parts of the parameter space with higher upper bound values are examined first .
Parts of the parameter space with higher upper bound values are examined first .
-1#0#1#lc -1#1#2#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact 


Thus , many portions of the parameter space can be eliminated if their upper bound values imply that they cannot contain the maximum .
So , many portions of the parameter space can be eliminated if their upper bound values imply that they cannot contain the maximum .
-1#0#0#syn -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact 


In our problem , the parameter space is the set of all region pairs \MATH , and the quality function is the similarity function \MATH .
Adapting to our problem , the parameter space is the set of all region pairs \MATH , and the quality function is the similarity function \MATH .
-1#2#1#exact -1#3#2#exact -1#4#3#exact -1#5#4#exact -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact -1#23#22#exact -1#24#23#exact -1#25#24#exact -1#26#25#exact 


Assuming we can organize regions in \MATH and \MATH into two hierarchical structures \MATH and \MATH respectively , so that :
Assuming we can organize regions in \MATH and \MATH into two hierarchical structures \MATH and \MATH respectively , so that :
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact 


- all regions are leaf nodes of the structures and non-leaf nodes are {\it virtual} nodes ,
- all regions are leaf nodes of the structures and non-leaf nodes are {\it virtual} nodes ,
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact 


- if each node is represented by a histogram \MATH with \MATH bins , the value in each bin of a child node is constrained to be equal or smaller than the value in the same bin of its parent node .
- if each node is repsented by a histgoram \MATH with \MATH bins , the value at each bin of a child node is constrainted to be equal or smaller the value at the same bin of its parent node .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#23#5#syn -1#6#6#exact -1#7#7#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16,17#16,17#para -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#26#23#syn -1#25#25#exact -1#27#26,27#para -1#28#28#exact -1#29#29#exact -1#30,31#30,31,32#para -1#32,33,34#33,34,35#para -1#35#36#exact -1#36#37#exact -1#37#38#exact -1#38#39#exact -1#39#40#exact -1#40#41#exact 


Given such structures , we show in what follows how the branch-and-bound algorithm can be used to solve our problem .
Given such structures , we show in the following how a branch-and-bound algorithm applied to our problem .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7,8#8#para -1#9,10#9,10#para -1#11#11#exact -1#12#12#exact -1#13#15#syn -1#14#16#exact -1#15#18#exact -1#16#19#exact -1#17#20#exact 


Let \MATH and \MATH denote two nodes on \MATH and \MATH .
Let \MATH and \MATH denote two nodes on \MATH and \MATH .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact 


And let \MATH denote the set containing all leaf nodes explored from \MATH .
And , \MATH denotes the set containing all leaf nodes explored from \MATH .
-1#0#0#exact -1#2#2#exact -1#3#3#stem -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact 


If \MATH is a leaf node , \MATH .
If \MATH is a leaf node , \MATH .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact 


Otherwise , given \MATH with \MATH being direct child nodes of \MATH , \MATH can be recursively defined as follows : \MATH
Otherwise , given \MATH with \MATH are direct child nodes of \MATH , \MATH can be recursively defined as follows : \MATH
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#para -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact 


In a similar way , we have : \MATH
In a similar way , we have : \MATH
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact 


Letting \MATH indicate the set of node pairs formed by pairing nodes in \MATH with nodes in \MATH , we get : \MATH . //<the rewrite is a guess .>
Given \MATH indicates the set of node pairs formed by paring nodes in \MATH with nodes in \MATH , we have : \MATH
-1#1#1#exact -1#2#2#stem -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#syn -1#21#21#exact -1#22#22#exact 


Thus , if \MATH and \MATH are roots of \MATH and \MATH respectively , \MATH will be exactly the entire search space \MATH .
So , if \MATH and \MATH are roots of \MATH and \MATH respectively , \MATH will exactly be the entire search space \MATH .
-1#0#0#syn -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#17#16#exact -1#16#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact 


Branching Step .
Branching Step .
-1#0#0#exact -1#1#1#exact -1#2#2#exact 


Dividing up the search space ( i.e. set of region pairs ) covered by \MATH can be done straightforwardly by utilizing the hierarchical structures \MATH , \MATH at certain nodes \MATH , \MATH . //<The rewrite is better if it is correct .>
Dividing the search space ( i.e. set of region pairs ) covered by \MATH is straightforward by utilizing the hierarchical structures \MATH , \MATH at certain nodes \MATH , \MATH .
-1#0#0#exact -1#1#2#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15,16#para -1#15#18#stem -1#16#19#exact -1#17#20#exact -1#18#21#exact -1#19#22#exact -1#20#23#exact -1#21#24#exact -1#22#25#exact -1#23#26#exact -1#24#27#exact -1#25#28#exact -1#26#29#exact -1#27#30#exact -1#28#31#exact -1#29#32#exact -1#30#33#exact 


Regarding \REF , \REF and \REF , \MATH can be divided into disjoint parts as follows : \MATH
Regarding to \REF , \REF and \REF , \MATH can be divided into disjoint parts as follows : \MATH
-1#0#0#exact -1#2#1#exact -1#3#2#exact -1#4#3#exact -1#5#4#exact -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact 


Or , \MATH
Or , \MATH
-1#0#0#exact -1#1#1#exact -1#2#2#exact 


The way to divide can be based on the sizes of \MATH and \MATH .
Selecting which way to divide can be based on sizes of \MATH and \MATH .
-1#2#1#exact -1#3#2#exact -1#4#3#exact -1#5#4#exact -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact 


We divide the larger one first .
We select the larger one to be divided first .
-1#0#0#exact -1#5,6,7#1#para -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#8#5#exact -1#9#6#exact 


The branching step is illustrated in Figure \REF .
An illustration of a branching step is given in Figure \REF .
-1#4#1#exact -1#5#2#exact -1#6#3#exact -1#8#5#exact -1#9#6#exact -1#10#7#exact -1#11#8#exact 


Bounding Step .
Bounding Step .
-1#0#0#exact -1#1#1#exact -1#2#2#exact 


An essential requirement for the branch-and-bound algorithm is the quality bounding function \MATH used to determine whether a part of the search space should be examined . //<Or " determine the extent that " ? ?>
An essential requirement for branch-and-bound is the quality bounding function \MATH used to evaluate how necessary a part of the search space should be examined .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#6#4#exact -1#4#5#exact -1#5#7#exact -1#19#8#exact -1#7#9#exact -1#8#10#exact -1#9#11#exact -1#10#12#exact -1#11#13#exact -1#12#14#exact -1#17,18#17,18,19,20#para -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact 


In particular , \MATH bounds the upper values of \MATH over a set of node pairs ( i.e. region pairs ) .
Particularly , \MATH bounds the upper values of \MATH over a set of node pairs ( i.e. region pairs ) .
-1#0#0,1#para -1#1#2#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact 


Let us assume that we are evaluating the upper bound of \MATH over all region pairs in \MATH .
Assuming we are now evaluating the upper bound of \MATH over all region pairs in \MATH .
-1#1#4#exact -1#2#5#exact -1#4#6#exact -1#5#7#exact -1#6#8#exact -1#7#9#exact -1#8#10#exact -1#9#11#exact -1#10#12#exact -1#11#13#exact -1#12#14#exact -1#13#15#exact -1#14#16#exact -1#15#17#exact -1#16#18#exact 


Among the several distance formulas for estimating the similarity of two regions , we will use the Normalized Histogram Intersection ( NHI ) distance since it is well-balanced between computational efficiency and robustness~\cite{ESR} .
Among several types of distance for estimating the similarity of two regions , we stick to Normalized Histogram Intersection ( NHI ) distance since it is well-balanced between computational efficiency and robustness~\cite{ESR} .
-1#0#0#exact -1#7#1#exact -1#1#2#exact -1#4#3#exact -1#5#5#exact -1#6#6#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact -1#28#29#exact -1#29#30#exact -1#30#31#exact -1#31#32#exact -1#32#33#exact 


We will then rely on NHI to define \MATH bounding the values of \MATH , with : \MATH
We then rely on NHI to define \MATH bounding the values of \MATH , with : \MATH
-1#0#0#exact -1#1#2#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact 


Referring to constraint ( b ) in constructing \MATH and \MATH , we have : \MATH
Referring to the constraint ( b ) in constructing \MATH and \MATH , we have : \MATH
-1#0#0#exact -1#1#1#exact -1#3#2#exact -1#4#3#exact -1#5#4#exact -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact 


As a result , the bounding value \MATH over \MATH can be clearly observed as : \MATH . //<I 'm not sure what observed means in this context . Do you mean " can be derived as " ? ?>
As a result , the bounding value \MATH over \MATH can be clearly observed as : \MATH
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact 


We can efficiently evaluate \MATH for the set of region pairs \MATH because \MATH relies only on the histogram representation of single rectangular regions \MATH and \MATH .
We can efficiently evaluate \MATH for the set of region pairs \MATH because \MATH is relied only on histogram representation of single rectangular regions \MATH and \MATH .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#para -1#16#15#exact -1#17#16#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact 


Moreover , the normalization terms , which indicate the minimum number of visual words inside any member region of \MATH , \MATH , are computed once by using the integral image technique .
And , the normalization terms , which indicate the minimum number of visual words inside any member region of \MATH , \MATH , are computed once by using integral image technique .
-1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8,9,10,11#8,9#para -1#18#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#29#exact -1#29#30#exact -1#30#31#exact -1#31#32#exact 


Inspired by \CITE , we devised the algorithm to work in a best-first manner . //<The original describes the way you decided to write the algorithm . In contrast , the rewrite describes the way the algorithm works .>
Inspired by \CITE , we form the algorithm in best-first manner .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#6#6#exact -1#7#7#exact -1#5#9#syn -1#8#10#exact -1#9#12#exact -1#10#13#exact -1#11#14#exact 


The algorithm examines the set having the highest bounding value \MATH . //<" next " is unclear . The rewrite is a guess .>
The algorithm examines next the set having highest bounding value \MATH .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#4#3#exact -1#5#4#exact -1#6#5#exact -1#7#6,7#para -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#3#13#exact 


The algorithm stops if the set contain only one pair of region .
The algorithm stops if the set contain only one pair of region .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact 


Otherwise , the set is then divided into disjoint subsets for further search .
Otherwise , the set is then divided into disjoint subsets for further search .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact 


Pseudo-code for the algorithm using a priority queue to store sets of region pairs , is given as follows .
Pseudo-code for the algorithm using a priority queue to store sets of region pairs , is given as follows .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact 


To obtain more than one region pair , we simply repeat the loop in Algorithm 1 until the expected number of region pairs \MATH is reached .
To obtain more than one region pair , we simply continue the loop in the Algorithm 1 until the expected number of region pairs \MATH have been reached .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact -1#23#22#exact -1#24#23#exact -1#26#24#syn -1#27#25#exact -1#28#26#exact 


So far , our approach is based on an assumption that the sets of regions are already organized into hierarchical structures which satisfy constraints ( a ) and ( b ) .
So far , our approach is based on an assumption that the sets of regions are already organized into hierarchical structures which satisfy the constraints ( a ) and ( b ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#9,10,11#8,9,10,11#para -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#24#23#exact -1#25#24#exact -1#26#25#exact -1#27#26#exact -1#28#27#exact -1#29#28#exact -1#30#29#exact -1#31#30#exact -1#32#31#exact 


In the remaining of this section , we show how to organize such sets , given the initial query image and image database .
In the remaining of this section , we show how to organize such sets , given the initial query image and the image database .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#22#21#exact -1#23#22#exact -1#24#23#exact 


There are two type of region set .
There are two type of region set for organization .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#9#7#exact 


One is a set containing regions of one image .
One is set containing regions of one image .
-1#0#0#exact -1#1#1#exact -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact 


The other is a set containing regions of multiple images ( i.e. database ) .
The other is set containing regions of multiple images ( i.e. database ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact 


With the first type of set , by applying the selective search approach introduced in \CITE for item selection , regions in each image are already organized into a binary tree .
With the first type of set , by applying the selective search approach introduced in \CITE for item selection , regions in each image are already organized into a binary tree .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact 


Because such binary tree were constructed by bottom-up merging of regions , a parent region on the trees spatially covers its child regions in the image space ( see Figure \REF ) .
Because such binary tree were constructed by bottom-up merging regions , a parent region on the trees spatially covers its child regions in image space ( see Figure \REF ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24,25#para -1#24#26#exact -1#25#27#exact -1#26#28#exact -1#27#29#exact -1#28#30#exact -1#29#31#exact -1#30#32#exact 


As a result , constraint ( b ) is satisfied .
As a result , we have the constraint ( b ) satisfied .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#7#4#exact -1#8#5#exact -1#9#6#exact -1#10#7#exact -1#11#8,9#para -1#12#10#exact 


However , because we want to use all regions corresponding to all nodes throughout the tree as candidate item regions , constraint ( a ) will be violated if we keep using the tree for the branch-and-bound algorithm .
However , because we want to use all regions corresponding to all nodes throughout the tree as candidate item regions , the constraint ( a ) will be violated if we keep using the tree for the branch-and-bound based algorithm .
-1#0#0#exact -1#1#1#exact -1#2,3,4,5#2,3,4#para -1#10#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#22#21#exact -1#23#22#exact -1#24#23#exact -1#25#24#exact -1#26#25#exact -1#27#26#exact -1#28#27#exact -1#29#28#exact -1#30#29#exact -1#31#30#exact -1#32#31#exact -1#33#32#exact -1#34#33#exact -1#35#34#exact -1#36#35#exact -1#37#36#exact -1#39#37#exact -1#40#38#exact 


In other words , all current non-leaf nodes of the tree will be treated as {\it vitual nodes} and will not be used as candidate item regions .
In other words , all current non-leaf nodes of the tree will be treated as {\it vitual nodes} and will not be used as candidate item regions .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18,19,20,21#18,19,20#para -1#22#21,22#para -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact 


Our solution to this problem is straightforward .
Our solution to this problem is straightforward .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact 


We generate and attach a new leaf node to each non-leaf node of the current tree .
We generate and attach a new leaf node to each non-leaf nodes of the current tree .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#stem -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact 


The generated node is exactly the same as the non-leaf node it is attached to , which now becomes a virtual node .
The generated node is exactly the same as the non-leaf node it attach to , which now becomes a virtual node .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4,5,6,7,8#4,5,6,7#para -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#17,18#12#para -1#12,13#13,14#para -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#19#19,20#para -1#20#21#exact -1#21#22#exact 


By doing that , we keep the spatial covering property of the original binary tree for the new hierarchical structure .
By doing that , we keep the spatial covering property of the orginal binary tree for the new hierarchical structure .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact 


Moreover , all non-leaf nodes will be taken into account as candidate item regions via their attachments .
And , all non-leaf nodes will be taken into account as candidate item regions via their attachments .
-1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6,7,8,9#6,7,8#para -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact 


The new hierarchical structure therefore satisfies both constraints .
The new hierarchical structure therefore satisfy both the constraints ( a ) and ( b ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#stem -1#6#6#exact -1#8#7#exact -1#16#8#exact 


Figure X is an illustration of this organization .
An illustration is presented in Figure X .
-1#5#0#exact -1#6#1#exact -1#2#2#exact -1#0#3#lc -1#1#4#exact -1#7#8#exact 


With a set containing regions from multiple images , we perform a two-stage organization procedure .
With a set containing regions of multiple images , we perform a two-stage organization procedure .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4,5#4,5#para -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact 


In the first stage , regions in each image are organized into a hierarchical structure , as presented above .
At the first stage , regions in each image are organized into a hierarchical structure as we presented above .
-1#6#0#lc -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact 


If multiple hierarchical structures are returned by the first stage , we use their root nodes as the initial elements to construct an yet another hierarchical structure over them by divisive clustering . //<the rewrite is a guess .>
Given multiple hierarchical structures returned from the first stage , we use their root nodes as initial elements to construct an yet another hierarchical structure over them by divisive clustering .
-1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#5#exact -1#27#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17,18#para -1#17#19#exact -1#18#20#exact -1#19#21#exact -1#20#22#exact -1#21#23#exact -1#22#24#exact -1#23#25#exact -1#24#26#exact -1#25#27#exact -1#26#28#exact -1#28#30#exact -1#29#31#exact -1#30#32#exact 


We start with the full set of the elements .
We start with the full set of the elements .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact 


Then , we perform splits recursively as one moves down the hierarchy .
Then , splits are peformed recursively as one moves down the hierarcy .
-1#0#0#exact -1#1#1#exact -1#2#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#12#12#exact 


In each splitting step , the split set is divided into $k$ parts by using $k$-means clustering .
In each splitting step , the splitted set is divided into $k$ parts by using $k$-means clustering algorithm .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#stem -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#18#17#exact 


Once the hierarchical structure is completed , we compute a histogram representation for all of its non-leaf nodes .
Once the hierchical structure is completed , we then compute histogram representation for all of its non-leaf nodes .
-1#0#0#exact -1#1#1#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#9#8#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact 


The value at each histogram bin of a non-leaf node is the maximum of all values in the same bin of its child nodes .
The value at each hitogram bin of a non-leaf nodes is the maximum of all values at the same bin of its child nodes .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#stem -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16,17,18#16,17,18#para -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact 


This is to ensure constraint ( b ) is satisfied .
This is to ensure the constraint ( b ) sastified .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#5#4#exact -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#10#10#exact 


Finally , by unifying the results of both stages , we have a unique hierarchical structure over the set of regions of multiple images , which satisfies both constraints .
At last , by unifying results of both stages , we have a unique hierarchical structure over the set of regions of multiple images , which satisfies the both constraints .
-1#1#0#syn -1#2#1#exact -1#3#2#exact -1#4#3#exact -1#17#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#27#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#28#27#exact -1#29#28#exact -1#30#29#exact 


We illustratie this in Figure Y .
We show an illustration in Figure Y .
-1#0#0#exact -1#4#3#exact -1#5#4#exact -1#6#5#exact -1#7#6#exact 


So , given the initial query image and a database , we now can construct two hierarchical structures .
So , given the initial query image and a database , we now can construct two hierarchical structures .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact 


One is for the regions of the initial query image .
One is for regions of the initial query image .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#5#3#exact -1#3#4#exact -1#4#5#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact 


The other is for the regions of all images in the database .
The other is for regions of all images in the database .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#9#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#10#11#exact -1#11#12#exact 


Both structures then become the input for our approach to find the top region pairs with the highest similarity scores for making recommendations .
Both structures are then becomes input for our proposed approach to find top region pairs with highest similarity scores for recommendation generation .
-1#0#0#exact -1#1#1#exact -1#3#2#exact -1#4#3#stem -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16,17#para -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#22#stem -1#22#23#exact 


Note that because the hierarchy of the regions of images in the database is independent of the query , we construct it only one time .
Note that , because the hierarchical for regions of images in the database is independent of query , we construct it only one time .
-1#0#0#exact -1#1#1#exact -1#3#2#exact -1#4#3#exact -1#5#4#para -1#8#5#exact -1#11#6#exact -1#7#7#exact -1#15#8#exact -1#9#9#exact -1#10#10#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact 


A recommendation is a good one if it exactly locates an item in the database .
A recommendation is a good one if it exactly locates an item which exists in the database .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#14#12#exact -1#15#13#exact -1#16#14#exact -1#17#15#exact 


We call such recommendations" hit recommendations " , and a good recommendation system should accurately provide them to users .
We call such recommendations as hit recommendations . Thus , a good recommendation system should accurately provide such hit recommendation to users .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#5#4#exact -1#6#5#exact -1#9#7#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#20#17#exact -1#21#18#exact -1#22#19#exact 


More importantly , users always expect that hit recommendations are ranked higher than false recommendations ( if there are a number of them ) on the list of the recommendations by the system .
More importantly , users always expect that hit recommendations are ranked higher than false recommendations ( if there are some of them ) on the list of all recommendations introduced by the system .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#25#20#syn -1#26#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#20#27#exact -1#31#28#exact -1#28#29#exact -1#30#30#exact -1#32#31,32#para -1#33#33#exact 


Based on these insights , we evaluated the Recommend-Me system using two evaluation metrics : precision in pesenting recommendations and rank of the first hit recommendation on the list .
Based on those insights , we evaluate Recommend-Me system using two evaluation metrics : precision on introducing recommendation and rank of the first hit recommendation on the list .
-1#0#0#exact -1#1#1#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#stem -1#21#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#17,18#18,19#para -1#19#20#exact -1#20#21#exact -1#26#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#27#27,28#para -1#28#29#exact 


Given an initial query image with ground-truth annotations indicating the bounding box of an item known to existin the database , Recommend-Me will provide a recommendation if at least one of its recommendations is a hit recommendation .
Given an initial query image with ground-truth annotation indicates bounding box of an item known existed in the database , Recommend-Me is determined to precisely introduce recommendation if at least one of its recommendation is a hit recommendation .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#stem -1#8#8#stem -1#17#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#23#16#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#35#24#exact -1#26#25#exact -1#27#26#exact -1#28,29,30,31#27,28,29#para -1#32#30,31#para -1#33#32#stem -1#34#33#exact -1#36#34,35#para -1#37#36#exact -1#38#37#exact 


We used an approach from the Pascal VOC challenge to clarify whether a recommendation is a hit recommendation or not .
We apply an approach used in Pascal VOC challenge to clarify whether a recommendation is a hit recommendation .
-1#0#0#exact -1#4#1#exact -1#2#2#exact -1#3#3#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#20#exact 


In particular , the intersection area between a hit recommendation and an item should be larger than half their union area .
In particular , the intersection area between a hit recommendation and an item should be larger than half of their union area .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact 


Because our target is not to improve search techniques but to facilitate query selection , the search simply relies on standard techniques if users use an recommendation as a search query .
Because our target is not to improve search techniques but to facilitate query selection procedure , search performance simply relies on standard techniques if users take an recommendation as a search query .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#15#14#exact -1#29,30#15,16#para -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact -1#23#22#exact -1#24#23#exact -1#26#25#exact -1#27#26#exact -1#28#27#exact -1#16#28,29#para -1#31#30#exact -1#32#31#exact 


To evaluate the efficiency of Recommend-Me in finding \MATH region pairs with the highest similarity scores , we computed the number of evaluations for the quality bounding function in the branch-and-bound algorithm .
To evaluate the efficiency of Recommend-Me on finding \MATH region pairs with highest similarity scores , we compute the number of evaluation for the quality bounding function in the branch-and-bound algorithm .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#27#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#18#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#stem -1#23#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#stem -1#22#23#exact -1#28#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#29#30#exact -1#30#31#exact -1#31#32#exact 


This number was then divided by the size of all possible region pairs formed by regions in the initial query image and regions in images of the database . //< " the size of all possible region pairs " is unclear to me . Do you mean " the average size of all possible region pairs " or " the sizes of all possible region pairs " ?>
This number is then divided by the size of all possible region pairs formed by regions in the initial query image and regions in images of the database .
-1#0#0#exact -1#1#1#exact -1#2,3#2,3#para -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact 


The fraction was taken to be the efficiency improvement of Recommend-Me .
The fraction is reported as the efficiency improvement of Recommend-Me .
-1#0#0#exact -1#1#1#exact -1#2#2#syn -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact 


Note that regions in images were pre-selected as in Step 1 of our framework .
Note that , regions in images are pre-selected as in Step 1 of our framework .
-1#0#0#exact -1#1#1#exact -1#3#2#exact -1#4#3#exact -1#5#4#exact -1#6#5#syn -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact 


Feature presentation .
Feature presentation .
-1#0#0#exact -1#1#1#exact -1#2#2#exact 


We employed a BoF model to represent the features of images and regions in the images .
We employ BoF model to represent features of images and regions in the images .
-1#0#0#exact -1#1#1#stem -1#2#3#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6,7#7,8,9#para -1#8#10#exact -1#9#11#exact -1#10#12#exact -1#11#13#exact -1#12#14#exact -1#13#15#exact -1#14#16#exact 


Visual words in the images were located by using dense grid sampling and a Different-of-Gaussian ( DoG ) detector .
Visual words in images are located by dense grid sampling and Different-of-Gaussian( DoG ) detector .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#4#exact -1#4#5#syn -1#5#6#exact -1#6#7#exact -1#7#9#exact -1#8#10#exact -1#9#11#exact -1#10#12#exact -1#12#16#exact -1#13#17#exact -1#14#18#exact -1#15#19#exact 


A codebook of 2000 visual words was built using the standard K-Means algorithm .
A codebook of 2000 visual words is built using standard K-Means algorithm .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6,7#6,7#para -1#8#8#exact -1#9#9,10#para -1#10#11#exact -1#11#12#exact -1#12#13#exact 


%to cluster points on a set of random images .% Additionally , the set of points of interest obtained by the DoG in the query image was used to remove regions without any such points inside .
%to cluster points on a set of random images .% Additionally , the set of interest points obtained by DoG in the query image is used to remove regions without any of such points inside .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#16#15#exact -1#31#16#exact -1#15#17#exact -1#17#18#exact -1#18#19#exact -1#21#20#exact -1#19#21#exact -1#20#22#exact -1#22#24#exact -1#23#25#exact -1#24,25#26,27#para -1#26#28#exact -1#27#29#exact -1#28#30#exact -1#29#31#exact -1#30#32#exact -1#32#33#exact -1#33#34#exact -1#34#35#exact -1#35#36#exact 


This helped us to eliminate less meaningful regions such as the sky , solid color regions , etc. , from the recommendations .
This helps us to eliminate less meaningful regions such as a portion of the sky , solid color regions , etc for recommendation .
-1#0#0#exact -1#1#1#stem -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#13#10#exact -1#14#11#exact -1#15#12#exact -1#16#13#exact -1#17#14#exact -1#18#15#exact -1#19#16#exact -1#22#21#stem -1#23#22#exact 


Region selection in images .
Region selection in images .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact 


As mentioned above , we used the approach first introduced in \CITE on different color channels for the region selection .
As mentioned above , we use the approach introduced in \CITE on different color channel for region selection .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5,6#5,6#para -1#7#7#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#stem -1#15#16#exact -1#16#17,18#para -1#17#19#exact -1#18#20#exact 


In this experiment , we used two color channels , RGB and Hue , since the regions generated on those channels can cover 99 .72\% of the area of the annotated item regions in our dataset .
In this experiment , we used two color channels which are RGB and Hue , since regions generated on those channels can cover 99 .72\% area of the annotated item regions in our dataset .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#14#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#15#14#exact -1#27#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#26#25#exact -1#25#26,27#para -1#28#30#exact -1#29#31#exact -1#30#32#exact -1#31#33#exact -1#32#34#exact -1#33#35#exact -1#34#36#exact 


A virtual root node was created to compose two color-dependent binary trees into one unique binary tree for each image .
A virtual root node is created to compose two color-dependent binary trees into one unique binary tree for each image .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#syn -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact 


In addition , the rectangular regions which did not contain any visual word or were smaller than 40 x 40 pixels were discarded .% since they can form a meaningful recommendation .
In addition , rectangular regions which do not contain any visual word or are smaller than 40 x 40 pixels are discarded .% since they can form a meaningful recommendation .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6,7#7,8#para -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#syn -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#syn -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24,25,26,27#25,26,27#para -1#28#28,29#para -1#29#30#exact -1#30#31#exact 


Maximal clique analysis algorithm .
Maximal clique analysis algorithm .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact 


Given the set of regions in the initial query image , we built a graph in which two regions were connected if they nearly overlapped each other ( we use the approach of Pascal VOC with a tighter threshold , 0 .8 ) .
Given the set of regions in the initial query image , we build a graph in which two regions are connected if they highly overlap each other ( we use the approach of Pascal VOC with tighter threshold , 0 .8 ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12,13#12,13#para -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#syn -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#24#24#stem -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#34#34#exact -1#35#35#exact -1#36#37#exact -1#37#38#exact -1#38#39#exact -1#39#40#exact -1#40#41#exact -1#41#42#exact -1#42#43#exact 


The Bron-Kerbosch algorithm was then applied to find all maximal cliques in the graph .
Bron-Kerbosch algorithm is then applied to find all maximal cliques in the graph .
-1#11#0#lc -1#0#1#exact -1#1#2#exact -1#2#3#syn -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#12#13#exact -1#13#14#exact 


One clique was one group of regions .
One clique is one group of regions .
-1#0#0#exact -1#1#1#exact -1#2,3#2,3#para -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact 


Figure \REF shows the results of the evaluation .
Figure \REF shows our evaluation results .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#5#4#exact -1#4#6,7#para -1#6#8#exact 


The reported precision , rank of the first hit recommendation , and efficiency improvement are averages of Recommend-Me on 375 different initial query images and an individual value of \MATH .
The reported numbers of precision , rank of the first hit recommendation as well as efficiency improvement are averaged as we perform Recommend-Me with 375 different initial query images and an individual value of \MATH .
-1#0#0#exact -1#1#1#exact -1#4#2#exact -1#5#3#exact -1#6#4#exact -1#7#5#exact -1#8#6#exact -1#9#7#exact -1#10#8#exact -1#11#9#exact -1#29#11#exact -1#15#12#exact -1#16#13#exact -1#17#14#exact -1#18#15#stem -1#3#16#exact -1#22#17#exact -1#24#19#exact -1#25#20#exact -1#26#21#exact -1#27#22#exact -1#28#23#exact -1#30#25#exact -1#31#26#exact -1#32#27#exact -1#33#28#exact -1#34#29#exact -1#35#30#exact 


The results show that Recommend-Me can make hit recommendations to users with high precision ( approximately 80 .27\% ) .
The results show that Recommend-Me can successfully introduce hit recommendations to users with high precision ( approximately 80 .27\% ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#8#6#syn -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact 


On the returned list of all recommendations , hit recommendations usually take the first two places on the list .
On the returned list of all recommendations , a hit recommendation usually takes the first two places on the list .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#9#8#exact -1#10#9#stem -1#11#10#exact -1#12#11#stem -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact 


This help users to avoid choosing false recommendations ( if such false recommendations are highly ranked ) .
This help users to avoid choosing false recommendations ( if such false recommendations are highly ranked ) .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact 


There were two types of false recommendation in the top places of the list .
We observed that there are two types of false recommendations on the top places of the list .
-1#3#0#lc -1#4#1#syn -1#5#2#exact -1#6#3#exact -1#7#4#exact -1#8#5#exact -1#9#6#stem -1#11,12#7,8,9#para -1#13#10#exact -1#14#11#exact -1#15#12#exact -1#16#13#exact -1#17#14#exact 


The first type consisted of background regions ( e.g. trees , buildings , roads ) , which are easily found in many images .
The first type consists background regions ( e.g. trees , buildings , roads ) which are easily found in many images .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#stem -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#16#exact -1#15#17#exact -1#16#18#exact -1#17#19#exact -1#18#20#exact -1#19#21#exact -1#20#22#exact -1#21#23#exact 


The second type was items lacking manual annotations such as windows , cars , and humans .
The second type is the items lacking of manual annotation such as windows , cars and humans .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#syn -1#5#4#exact -1#6#5#exact -1#8#6#exact -1#9#7#stem -1#10#8#exact -1#11#9#exact -1#12#10#exact -1#13#11#exact -1#14#12#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact 


Thus , recommendations about those items are not counted as hit recommendations .
Thus , recommendations about those items are not counted as hit recommendations .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact 


However , if users are interested in using them as hints to explore the database , they may still be very helpful .
However , if users are interested in using them as hints to explore the database , they are still very much helpful .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17,18#17,18,19#para -1#19#20#exact -1#21#21#exact -1#22#22#exact 


Clearly , one can realize that the performance of Recommend-Me is influenced by \MATH .
Clearly , one can realize that the performance of Recommend-Me is under the influence of \MATH .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11,12,13,14#11,12#para -1#15#13#exact -1#16#14#exact 


By increasing \MATH , we can obtain more region pairs with sufficiently high similarity scores .
By increasing \MATH , we obtain more region pairs with sufficient hight similarity scores .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#stem -1#12#13#exact -1#13#14#exact -1#14#15#exact 


Thisgives more chances to get region pairs of the annotated item , thus improving precision .
It brings more chances to get region pairs of the annotated item , thus improves the precision .
-1#2#1#exact -1#3#2#exact -1#4#3#exact -1#5#4#exact -1#6#5#exact -1#7#6#exact -1#8#7#exact -1#9#8#exact -1#10#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#stem -1#16#14#exact -1#17#15#exact 


However , the trade-off is that more unexpected items are returned .
However , the trade-off is that more unexpected items are also returned .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#11#10#exact -1#12#11#exact 


This results in a drop in the average rank of the first hit recommendation .
This results in a drop of average rank of the first hit recommendation .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4,5#4,5#para -1#9#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact 


Figure 5( a ) demonstrates this circumstance .
Figure 5( a ) demonstrates this circumstance .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact 


When \MATH increases from 2000 to 10000 , the precision increases from 74 .67\% to 81 .97\% ; meanwhile , the average rank of the first hit recommendation drops to 2 .27 from 1 .78 .
When \MATH increases from 2000 to 10000 , the precision also increases from 74 .67\% to 81 .97\% ; meanwhile , the average rank of the first hit recommendation drops to 2 .27 from 1 .78 .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#11#10#exact -1#12#11#exact -1#13#12#exact -1#14#13#exact -1#15#14#exact -1#16#15#exact -1#17#16#exact -1#18#17#exact -1#19#18#exact -1#20#19#exact -1#21#20#exact -1#22#21#exact -1#23#22#exact -1#24#23#exact -1#25#24#exact -1#26#25#exact -1#27#26#exact -1#28#27#exact -1#29#28#exact -1#30#29#exact -1#31#30#exact -1#32#31#exact -1#33#32#exact -1#34#33#exact -1#35#34#exact -1#36#35#exact 


It is worth noting that keeping increasing \MATH may not always give better precision , since precision relies on not only \MATH but also the robustness of the region comparison techniques .
It is worth noting that keeping inreasing \MATH may not always give better precision since precision relies on not only \MATH but also the robustness of the region comparision techniques .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27#28#exact -1#29#30#exact -1#30#31#exact 


Recommend-Me cannot provide any hit recommendation for around 20\% of the initial query images due to the fact that our region comparison technique cannot deal with significant variations in the items .
Recommend-Me cannot provide any hit recommendation for around 20\% of initial query images due to the fact that our region comparision technique cannot deal with significant variations of items .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#15#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13,14#14,15,16,17#para -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact -1#25#26#exact -1#26#27#exact -1#27,28#28,29,30#para -1#29#31#exact 


Figure 5( b ) shows another circumstance when we increase \MATH .
Figure 5( b ) shows another circumstance when we increase \MATH .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact 


It is the decline in the efficiency improvement of Recommend-Me .
It is the decline of efficiency improvement of Recommend-Me .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4,5#5,6#para -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact 


This is because the branch-and-bound algorithm has to visit more parts of the total search space in order to find extra local opitimals .
This is because the branch-and-bound algorithm has to visit more parts of the total search space in order to find extra local optimals .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16,17#16,17,18,19#para -1#20#20#exact -1#21#21#exact -1#23#23#exact 


However , in all of our evaluations , Recommend-Me still performed around three times faster than the exhaustive search .
However , in all of our evaluations , Recommend-Me still performs around 3 times faster than the exhaustive search .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#stem -1#11#11#exact -1#12#12#syn -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact 


This advantage will be important for practical applications .
Its superiority is important for practical applications .
-1#2#2,3#para -1#3#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact 


Figure \REF presents examples of hit recommendations returned byRecommend-Me .
Figure \REF presents examples of hit recommendations returned by our Recommend-Me .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#11#9#exact 


We described oursystem , named Recommend-Me , for making visual query suggestions .
In this paper , we introduced a new system , named Recommend-Me , for visual query suggestion .
-1#4#0#lc -1#9#3#exact -1#10#4#exact -1#11#5#exact -1#12#6#exact -1#13#7#exact -1#14#9#exact -1#15#10#exact -1#16#11#stem -1#17#12#exact 


Given an initial query image and a retrieved database , Recommend-Me gives recommendations that impose conditions on which and how frequent items in the initial query image appear in the database .
Given an initial query image and a retrieved database , Recommend-Me introduces recommendations that imposes which and how frequent items in the initial query image appear in the database .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#12#12#exact -1#13#13#exact -1#14#14#stem -1#15#16,17#para -1#16#18#exact -1#17#19#exact -1#18#20#exact -1#19#21#exact -1#20#22#exact -1#21#23#exact -1#22#24#exact -1#23#25#exact -1#24#26#exact -1#25#27#exact -1#26#28#exact -1#27#29#exact -1#28#30#exact -1#29#31#exact 


Such recommendations help users to select the search query , to rapidly refine the initial query image or to explore the database .
Such recommendations support users to select search query , to rapidly refine the initial query image or to explore the database .
-1#0#0#exact -1#1#1#exact -1#2#2#para -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#12#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#19#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#20#21#exact -1#21#22#exact 


An efficient solution to make Recommend-Me practical was also presented .
An efficient solution to make Recommend-Me practical is presented .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7,8#para -1#8#9#exact -1#9#10#exact 


To the best of our knowledge , Recommend-Me is the first attempt at developing a targeted suggestion scheme .
To the best of our knowledge , Recommend-Me is the first attempt toward its targeted suggestion scheme .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact 


The results support the conclusion that the quality of the word-segmentation corpus is very important for building NLP applications .
The results support the conclusion that the quality of word-segmentation corpus is very important for building NLP applications .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3,4,5,6#3,4,5#para -1#7,8#6,7,8,9#para -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact 


The SMT results show that three out of six augmented models , VAR_SPLIT , VAR_FREQ and BASE , performed better than the ORG configuration .
The SMT results show that three out of six augmented models , VAR_SPLIT , VAR_FREQ and BASE , gave higher performance than the ORG configuration .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#20#18#stem -1#21#20#exact -1#22#21#exact -1#23#22#exact -1#24#23#exact -1#25#24#exact 


Among them , the best-performing model , VAR_SPLIT achieved 36 .91 BLEU score , which is 0 .55 higher than ORG .
Among them , the best model VAR_SPLIT achieved 36 .91 BLEU score , which is 0 .55 higher than ORG .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#5#5#exact -1#12#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact 


In TC results , all six augmented models achieved higher results than ORG .
In TC results , all six augmented models have higher results than ORG .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact 


In general , the augmented models performed better than the ORG .
In general , the augmented models are better than the ORG .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact 


Additionally , because our automatic methods for inconsistency detection could not cover all of the types of inconsistencies in word segmentation annotation , further improvement of corpus quality is demanded .
Additionally , because our automatic methods for inconsistency detection could not cover all types of inconsistency in word segmentation annotation , further improvement of corpus quality is demanded .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#14#13#exact -1#13#14,15#para -1#23#16#exact -1#15#17#stem -1#16#18#exact -1#17#19#exact -1#18#20#exact -1#19#21#exact -1#20#22#exact -1#21#23#exact -1#22#24#exact -1#24#25,26#para -1#25#27#exact -1#26#28#exact -1#27#29#exact -1#28#30#exact 


Comparing the results of STRUCT_AFFIX and STRUCT_NC with BASE in WS , TC , and SMT , we can observe that combining affxes with their head nouns resulted in slightly better results for WS and TC , and did not change the performance of SMT .
Comparing the results of STRUCT_AFFIX and STRUCT_NC with BASE in WS , TC , and SMT , we can observe that combining affxes with their head nouns resulted in slightly better results for WS , TC , and does not change the performance of SMT .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact -1#33#33#exact -1#37#34#exact -1#35#35#exact -1#36#36#exact -1#39,40#38,39,40#para -1#41#41#exact -1#42#42#exact -1#43#43#exact -1#44#44#exact -1#45#45#exact 


However , the combination of classifier nouns with their head nouns had negative effects on WS and SMT .
However , the combination of clasifier nouns with their head nouns had negative effects on WS and SMT .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact 


Another part of the scope of our experiment is to compare two solutions for controversial cases of word segmentation , splitting and combining .
Another intention of our experiment is to compare two solutions for controversial cases of word segmentation , splitting and combining .
-1#0#0#exact -1#13#2#exact -1#2#5#exact -1#3#6#exact -1#4#7#exact -1#5#8#exact -1#6#9#exact -1#7#10#exact -1#8#11#exact -1#9#12#exact -1#10#13#exact -1#11#14#exact -1#12#15#exact -1#14#17#exact -1#15#18#exact -1#16#19#exact -1#17#20#exact -1#18#21#exact -1#19#22#exact -1#20#23#exact 


Splitting and combining variations are reflected by VAR_COMB and VAR_SPLIT , while STRUCT_AFFIX and STRUCT_NC represent the combination of affixes or classifier nouns with the words that they modify .
Splitting and combining variations are reflected by VAR_COMB and VAR_SPLIT , while STRUCT_AFFIX and STRUCT_NC represent the combination of affxes or classifier nouns with the words they modify .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#27#exact -1#27#28#exact -1#28#29#exact 


STRUCT_AFFIX and STRUCT_NC are contrasted with BASE where affxes and classifier nouns remain untouched .
STRUCT_AFFIX and STRUCT_NC are contrasted with BASE where affxes and classifier nouns remain untouched .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact 


Comparing VAR_COMB and VAR_SPLIT in both the TC experiment and SMT experiment , we see that the VAR_SPLIT results are better in both cases .
Comparing VAR_COMB and VAR_SPLIT in both TC experiment and SMT experiment , we see that the VAR_SPLIT results are better in both cases .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#15#6#exact -1#6#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact 


Since the ratio of combined variations in the ORG corpus is 60 .9% , it can be observed that splitting seems to be better than combining for WS , TC and SMT .
Since the ratio of combined variations in the ORG corpus is 60 .9% , it can be observed that splitting seems to be better than combining for WS , TC and SMT .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#exact -1#27#27#exact -1#28#28#exact -1#29#29#exact -1#30#30#exact -1#31#31#exact -1#32#32#exact 


In this paper , we have provided a quantitative analysis of the difficulties in word segmentation , through the detection of problematic cases in the Vietnamese Treebank .
In this paper , we have shown a quantitative analysis of the diffculties in word segmentation , through the detection of problematic cases in the Vietnamese treebank .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact -1#22#22#exact -1#23#23#exact -1#24#24#exact -1#25#25#exact -1#26#26#lc -1#27#27#exact 


Based on the analysis , we automatically created data that represent the different word segmentation criteria , and evaluated the criteria indirectly through their applications .
Based on the analysis , we automatically created data representing the different word segmentation criteria , and evaluated the criteria indirectly through their applications .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9,10#9,10,11#para -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#21#exact -1#21#22#exact -1#22#23#exact -1#23#24#exact -1#24#25#exact 


Our experimental results showed that manual modification , done for annotation of special characters , and most other word segmentation criteria , significantly improved the performances of automatic word segmentation , text classification and statistical machine translation , in comparison with the use of the original VTB corpus .
Our experimental results showed that manual modification done for annotation of spe-cial characters and most of other word segmentation criteria significantly improved the performances of automatic word segmentation , text classification and statistical machine translation , comparing with the use of the original VTB corpus .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#28#7#exact -1#7#8#exact -1#8#9#exact -1#9#10#exact -1#10#11#exact -1#12#13#exact -1#35#14#exact -1#13#15#exact -1#14#16#exact -1#16#17#exact -1#17#18#exact -1#18#19#exact -1#19#20#exact -1#20#22#exact -1#21#23#exact -1#22#24#exact -1#23#25#exact -1#24#26#exact -1#25#27#exact -1#26#28#exact -1#27#29#exact -1#29#31#exact -1#30#32#exact -1#31#33#exact -1#32#34#exact -1#33#35#exact -1#34#36#exact -1#36#39#syn -1#37,38,39,40#40,41,42#para -1#41,42#43,44,45#para -1#43#46#exact -1#44#47#exact -1#45#48#exact 


Since the VTB corpus is the first effort in building a treebank for Vietnamese , and is the only corpus that is publicly available for NLP research , this study contributes to further improvement of the corpus quality , which is essential for building efficient NLP systems .
Since the VTB corpus is the first effort in building a treebank for Vietnamese , and is the only corpus publicly available for NLP research , this study contributes to further improvement of the corpus quality , which is essential for building effcient NLP systems .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#17#17#exact -1#18#18#exact -1#19#19#exact -1#37,38#20,21#para -1#20#22#exact -1#21#23#exact -1#22#24#exact -1#23#25#exact -1#24#26#exact -1#25#27#exact -1#26#28#exact -1#27#29#exact -1#28#30#exact -1#29#31#exact -1#30#32#exact -1#31#33#exact -1#32#34#exact -1#33#35#exact -1#34#36#exact -1#35#37#exact -1#36#38#exact -1#39,40#39,40,41,42#para -1#41#43#exact -1#43#45#exact -1#44#46#exact -1#45#47#exact 


One may question why MSM performed poorly in the Trecvid dataset , but was superior to k-Faces.Temporal in NHKNews7 .
One may concern that why MSM perform poorly on Trecvid dataset , but it is superior to our k-Faces.Temporal on NHKNews7 .
-1#0#0#exact -1#1#1#exact -1#4#3#exact -1#5#4#exact -1#6#5#stem -1#7#6#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#14#13#syn -1#15#14#exact -1#16#15#exact -1#18#16#exact -1#20#18#exact -1#21#19#exact 


The reason for this is the fact that the face tracks in the NHKNews7 dataset are larger than those in the Trecvid dataset .
This is due to the fact that face-tracks on NHKNews7 dataset is larger than those on Trecvid dataset .
-1#0#3#lc -1#1#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#9#13#exact -1#10#14#exact -1#11#15#syn -1#12#16#exact -1#13#17#exact -1#14#18#exact -1#16#21#exact -1#17#22#exact -1#18#23#exact 


Therefore , more sample faces in each face track can be used to obtain a reliable subspace .
Therefore , more sample faces in each face-track can be used to obtain a reliable subspace .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#8,9,10#9,10,11,12#para -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#15#16#exact -1#16#17#exact 


As expected , the results of this experiment show that our proposed approach is extremely efficient while achieving comparable performance with state-of-the-art approaches .
As expected , the results in this experiment demonstrate that our proposed approach is extremely efficient while archiving comparable performance with state-of-the-art approachesf.
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#6#6#exact -1#7#7#exact -1#8,9#8,9#para -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#15#15#exact -1#16#16#exact -1#18#18#exact -1#19#19#exact -1#20#20#exact -1#21#21#exact 


In this paper , we investigate face retrieval in large-scale news video datasets .
In this paper , we investigate face retrieval on large-scale news video datasets .
-1#0#0#exact -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#9#9#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact 


Our contribution is threefold .
Our contributions is 3-fold .
-1#0#0#exact -1#1#1#stem -1#2#2#exact -1#4#4#exact 


First , we present the practical problems encountered when a tracker is used to extract face tracks in news videos .
Firstly , we presented practical problems when a tracker is used to extract face-tracks in news videos .
-1#0#0#stem -1#1#1#exact -1#2#2#exact -1#3#3#stem -1#4,5#4,5,6#para -1#6#8#exact -1#7#9#exact -1#8#10#exact -1#9#11#exact -1#10#12#exact -1#11#13#exact -1#12#14#exact -1#14#17#exact -1#15#18#exact -1#16#19#exact -1#17#20#exact 


Based on these , we introduce techniques and solutions to overcome these problems to achieve robust face-track extraction .
Based on that , we introduce techniques and solutions to bypass the problems for robust face-track extraction .
-1#0#0#exact -1#1#1#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#9#9#exact -1#11,12#11,12#para -1#14#15#exact -1#15#16#exact -1#16#17#exact -1#17#18#exact 


Second , we present an approach for face-track matching that significantly reduces the computational cost while achieving competitive performance compared with state-of-the-art approaches .
Secondly , we present an approach for face-track matching which significantly reduces the computational cost and achive competitive performance compared to state-of-the-art approaches .
-1#0#0#stem -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#4#4#exact -1#5#5#exact -1#6#6#exact -1#7#7#exact -1#8#8#exact -1#10#10#exact -1#11#11#exact -1#12#12#exact -1#13#13#exact -1#14#14#exact -1#17#17#exact -1#18#18#exact -1#19,20#19,20#para -1#21#21#exact -1#22#22#exact -1#23#23#exact 


Third , we prepare datasets , evaluate state-of-the-art face retrieval approaches , and publish real-world face-track datasets of such scales that have never been considered in the literature.
Thirdly , we prepare , evaluate state-of-the-art face retreival approaches , and publish real-world face-track datasets whose scale have not been considered in literature ever.
-1#0#0#stem -1#1#1#exact -1#2#2#exact -1#3#3#exact -1#15#4#exact -1#4#5#exact -1#5#6#exact -1#6#7#exact -1#7#8#exact -1#9#10#exact -1#10#11#exact -1#11#12#exact -1#12#13#exact -1#13#14#exact -1#14#15#exact -1#17#19#stem -1#18#20,21#para -1#19,20#22,23#para -1#21#24#exact -1#22#25#exact 

