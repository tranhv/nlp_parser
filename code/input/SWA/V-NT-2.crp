0
<document>
<document>
1
<title>
<title>
2
Recommend-Me : recommending query regions for image search
Recommend-Me : recommending query regions for image search
3
</title>
</title>
4
<abstract>
<abstract>
5
<p>
<p>
6
This paper presents a novel recommendation system , named Recommend-Me , to faciliate users in searching and exploring images of an unknown image database .
This paper presents a novel recommendation system , named Recommend-Me , to facilitate users in searching and exploring images in unknown image databases .
7
Given an initial query image , Recommend-Me automatically introduces its recommendations to users .
Given an initial query image , Recommend-Me automatically shows its recommendations to users .
8
The recommendations indicate which and how frequent items in the initial query image occur in the database .
The recommendations indicate which and how frequent items in the initial query image occur in the database .
9
So that , users can make their own decisions before any actual search .
In this way , users can make their own decisions before any actual search .
10
If there is a recommendation matched their search intention , relevant search results are ensured .
If there is a recommendation matching their search intention , relevant search results are ensured .
11
Otherwise , users should refine their initial query image for a better query sample .
Otherwise , users should refine their initial query image for a better query sample .
12
Or , they can start exploring the database by using the recommended items as hints .
Or , they can start exploring the database by using the recommended items as hints .
13
Recommend-Me helps users to avoid unnecessary trials and poor searching experiences .
Recommend-Me helps users to avoid unnecessary trials and poor searching experiences .
14
</p>
</p>
15
<p>
<p>
16
We introduce an efficient approach for Recommend-Me to deal with quantifying occurences of multiple candidate items over images of the database .
We describe an efficient approach for Recommend-Me to deal with quantifying occurrences of multiple candidate items in the images of the database .
17
Instead of scanning the database for each candidate item repspectively , the approach enumerate occurences of multiple candidate items simultaneously by investigating pairs of highly similar regions , knowing one pair is formed by a region in the intial image and a region in an image of the database .
Instead of scanning the database for each candidate item , the approach enumerate occurrences of multiple candidate items simultaneously by investigating pairs of highly similar regions , knowing one pair is formed by a region in the initial image and a region in an image of the database .
18
We formulate the problem of finding such pairs as an opmization problem , which can be solved by a branch-and-bound algorithm .
We formulate the problem of finding such pairs as an optimization problem , which can be solved by a branch-and-bound algorithm .
19
Experiments conducted on a real-life and publicly available dataset demonstrate the efficiency , the robustness and a promissing application of our system .
Experiments conducted on a real-life and publicly available dataset demonstrate the efficiency , robustness , and promising application of our system .
20
</p>
</p>
21
</abstract>
</abstract>
22
<section label = " Introduction ">
<section label = " Introduction " >
23
<p>
<p>
24
With the advances of modern technology , a large amount of digital images nowadays can be created and stored easily .
Thanks to the advances of modern technology , a large amount of digital images can be easily created and stored nowadays .
25
As a result , the exponential growth of image repositories creates the urgent needs for searching images . Because of its importance and wide applications , image search has attracted more interest in recent years .
The resulting exponential growth of image repositories , however , has created an urgent need for effective ways of searching images .
26
</p>
</p>
27
<p>
<p>
28
In a typical scenario of image search , users supply a query item which is usually represented by a region cropped from an image .
Moreover , image search has gained interest in recent years because of its importance and wide range of applications . In a typical scenario , users supply a query item , which is usually a region cropped from an image .
29
The search system then returns a list of relevant images retrieved from a database .
The search system then returns a list of relevant images retrieved from a database .
30
The images are expected to contain the query item .
The images are expected to contain the query item .
31
Several extensive works have been conducted with great interest on improving search performance \CITE .
Extensive studies have been conducted with an eye to improving the performance of this sort of search \CITE .
32
However , regardless of the powerfulness of state-of-the-art search techniques , there are still cases in which users are disappointed with search results .
However , regardless of the powerfulness of state-of-the-art search techniques , there are still cases in which users are disappointed with their search results .
33
The reason is because relevant items are not in the database .
The reason is that relevant items are not in the database .
34
Under such circumstances , whatever the search technique is , results are obviously irrelevant and unexpected .
Under such circumstances , whatever the search technique is , results are obviously irrelevant and unexpected .
35
A normal user without prior knowledge about the retrieved database has no choice but search by trial-and-error .
A normal user without prior knowledge about a database has no choice but to search it by trial-and-error .
36
We tackle this problem to facilitate users in searching and exploring images of such unknown database .
We decided to tackle this problem to help users in searching and exploring images in unknown databases .
37
Our proposal is a novel recommendation system , named Recommend-Me .
Our proposal is a novel recommendation system , named Recommend-Me .
38
</p>
</p>
39
<p>
<p>
40
The expected scheme can be described as follows ( see Figure \REF for an example ) .
The envisioned scheme can be described as follows ( see Figure \REF for an example ) .
41
Given an unknown database and an initial query image , our Recommend-Me automatically presents its recommendations to user .
Given an unknown database and an initial query image , Recommend-Me automatically presents its recommendations to the user .
42
One recommendation is one item , bounded by a rectangular region , in the initial query image .
One recommendation is one item , bounded by a rectangular region , in the initial query image .
43
Each recommended item is assigned a number to clarify how many images of the database it occurs .
Each recommended item is assigned a number to show in how many images of the database it occurs .
44
Items with higher assigned numbers will be more recommended .
Items with larger assigned numbers will be more recommended .
45
By providing such recommendations , Recommend-Me supports users to :
By providing such recommendations , Recommend-Me helps users to :
46
</p>
</p>
47
<p>
<p>
48
- avoid unexpected search experience with poor queries that are subjectively ( and sometimes randomly ) selected ,
- avoid unexpected search experience with poor queries that are subjectively ( and sometimes randomly ) selected ,
49
</p>
</p>
50
<p>
<p>
51
- rapidly refine the initial query image before any actual search , if the recommendations show that current search intention can not return relevant results ,
- rapidly refine the initial query image before any actual search , if the recommendations show that current search intention can not return relevant results ,
52
</p>
</p>
53
<p>
<p>
54
- explore the database using the recommendations as hints .
- explore the database using the recommendations as hints .
55
</p>
</p>
56
<p>
<p>
57
Recommend-Me is a pure visual recommendation system .
Recommend-Me is a pure visual recommendation system .
58
No extra information or knowledge is required for input but an initial query image and a retrieved database .
No extra information or knowledge is required for an input besides an initial query image and a database . //<" and the name of the database " ? ? Or " and the location and name of the database " ? ?>
59
</p>
</p>
60
<p>
<p>
61
To automatically generate recommendations , we need to address several critical issues .
To automatically generate recommendations , we need to address several issues .
62
First , there is a huge pool of candidate items in the initial query image .
First , there tends to be a huge pool of candidate items in the initial query image .
63
Basically , any rectangular region in the image can be considered as a candidate item .
Basically , any rectangular region in the image can be considered as a candidate item .
64
Examining all of them requires enormous computational cost .
Examining all of them would incur an enormous computational cost .
65
Second , even if a candidate item is known , enumerating its occurrences in the database is not trivial because it is subject to many variations such as viewpoint and scale changes , rotation or occlusion .
Second , even if a candidate item is known , enumerating its occurrences in the database is a not trivial task because it is subject to many variations in viewpoint , scale , rotation , occlusion , etc.
66
Furthermore , scanning over all regions in images of the database will inevitably be prohibitive , if not infeasible for practical purposes .
Furthermore , the cost of scanning all regions of the images of the database will inevitably be prohibitive for practical purposes .
67
</p>
</p>
68
<p>
<p>
69
In this paper , we employ state-of-the-art techniques such as SIFT and Bag-of-Words ( BoW ) model to handle matching regions under variations .
In this paper , we employ state-of-the-art techniques such as SIFT and the Bag-of-Words ( BoW ) model to handle the task of matching regions with the above variations .
70
Our main focus is an efficient approach for quantifying occurences of candidate items over the database to generate recommendations .
Our main focus is to devise an efficient approach for quantifying occurrences of candidate items in the database in order to generate recommendations .
71
The efficiency advantages of our approach come from various methodologies .
The advantage in efficiency comes from our use of various methodologies .
72
Based on an observation that users are mostly interested in object-like items , we use a selective search approach proposed by Van de Sande et al. \CITE to sample regions bounding object-like items in all images as a preprocessing step .
Based on the observation that users are mostly interested in object-like items , we decided to use a selective search approach proposed by Van de Sande et al. \CITE to sample regions bounding object-like items in all images as a preprocessing step .
73
By applying the approach instead of other naive sampling approach such as sliding windows , the number of items ( i.e. regions ) that need to be processed in each image dramatically reduces .
By applying this approach instead of a naive sampling approach such as sliding windows , we were able to dramatically reduce the number of items ( i.e. regions ) that need to be processed in each image .
74
</p>
</p>
75
<p>
<p>
76
Given two sets of regions , one contains regions of candidate items in the initial query image and the other contains regions of items in images of the database .
Given two sets of regions , one containing regions of candidate items in the initial query image and the other containing regions of items in images of the database , our task is to find occurrences of all candidate items in the database .
77
Finding occurences of all candidate items in the database can be equally treated as finding pairs of matched regions , knowing a pair is formed by a region in one of the sets with a region in the other .
This task can be equivalently treated as finding pairs of matched regions , knowing that a pair is formed by a region in one of the sets with a region in the other .
78
So , if top region pairs with sufficient high similarity scores are found , we can enumerate occurences of the items .
So , if the top region pairs are found with sufficiently high similarity scores , we can enumerate the occurrences of the items .
79
Based on these insights , we make an yet another efficiency boost by formulating the problem as an optimization problem which can be solved by applying a branh-and-bound algorithm .
Based on this insight , we can boost efficiency yet again by formulating the problem as an optimization problem that can be solved by applying a branch-and-bound algorithm .
80
In order to do that , we introduce a novel representation based on hierarchical structure to describe a set of region pairs and a corresponding function bounding the similarity scores of pairs over such a set .
In order to do that , we introduce a novel representation based on a hierarchical structure describing a set of region pairs and a corresponding function bounding the similarity scores of pairs over such a set .
81
</p>
</p>
82
<p>
<p>
83
Related Works .
Related Work .
84
With respect to discovering common items , Recommend-Me is related to recent studies on mining common items in image databases such as \CITE .
On the topic of discovering common items , Recommend-Me is related to recent studies on mining common items in image databases such as \CITE .
85
However , in contrast to these studies , Recommend-Me targets items which are shared by both an image database and user interest limited in an input initial image .
However , in contrast to these studies , Recommend-Me targets items which are shared by both an image database and the user 's particular interest inthe input initial image .
86
Meanwhile , \CITE only aim at finding common items within the database .
Meanwhile , \CITE only aims at finding common items within the database .
87
One can employ these techniques to our problem by firstly figuring out common items among images of the database , then looking them up in the initial query image again for recommendations .
One can employ these techniques to solve our problem by first identifying common items among the images of the database , then looking them up in the initial query image again to make recommendations .
88
However , by doing that , extra costs for mining unnecessary items , which appear in the database but the initial query image , arise accordingly .
However , doing that incurs the extra cost of mining unnecessary items that appear in the database , but not in the initial query image .
89
</p>
</p>
90
<p>
<p>
91
One of the most related works to Recommend-Me for query suggestion is proposed by Zha et al in \CITE .
One of the most related studies to ours is that of Zha et al in \CITE .
92
They introduced a system called Visual Query Suggestion ( VQS ) which simultanously provides both keyword and image suggestions for users .
They introduced a system , called Visual Query Suggestion ( VQS ) , that simultaneously provides both keyword and image suggestions to users .
93
There are clear differences between our Recommend-Me and VQS .
There are clear differences between Recommend-Me and VQS .
94
VQS requires an initial text query for suggestion formulation and its suggestions are both keywords and images .
VQS requires an initial text query for formulating the suggestion , and its suggestions are both keywords and images .
95
On the other hand , Recommend-Me takes an image as input and its outputs are regions in the image .
On the other hand , Recommend-Me takes an image as input , and its outputs are regions in the image .
96
Recommend-Me is a query suggestion system based on pure visual information .
Recommend-Me is a query suggestion system based on pure visual information .
97
Above all , although both Recommend-Me and VQS aim at facilitating users in searching images , the targeted problems are different .
Above all , although both Recommend-Me and VQS aim at helping users search for images , their targeted problems are different .
98
VQS proposes to help users to overcome query ambiguity formulation by precisely expressing search intents , assuming relevant items are always available .
VQS proposes to help users to overcome their tendency to formulate ambiguous queries by precisely expressing search intents , assuming the relevant items are always available .
99
Meanwhile , Recommend-Me supports users to select queries based on the existence of their relevant items in the retrieved database .
Meanwhile , Recommend-Me helps users to select queries based on the existence of relevant items in the retrieved database .
100
To the best of our knowledge , Recommend-Me is the first attempt towards its targeted suggestion scheme .
To the best of our knowledge , Recommend-Me is the first attempt at this sort of targeted suggestion scheme .
101
</p>
</p>
102
<p>
<p>
103
From technical point of view , our solution is motivated by recent works for object localization and subimage retrieval based on branch-and-bound optimization \CITE .
From a technical point of view , our solution is motivated by recent work on object localization and subimage retrieval based on branch-and-bound optimization \CITE .
104
However , ours is differentiated in the way we represent sets of region pairs , instead of sets of regions only .
However , ours is differentiated from the other studies in that we represent sets of region pairs , instead of only sets of regions .
105
ESS and ESR \CITE use coordinate intervals for their presentation .
ESS and ESR \CITE use coordinate intervals for their presentation .
106
Meanwhile , we utilize hierarchical structures in order to do that , since our regions are discrete .
In contrast , we utilize hierarchical structures in order to do that , since our regions are discrete .
107
Although coordinate intervals as in ESS ( or ESR ) can be extended to represent set of region pairs , such criterion may suffer the branch-and-bound algorithm from curse-of-dimensionality problem since the number of dimension required is at least doubled .
Although coordinate intervals as in ESS ( or ESR ) can be extended to represent sets of region pairs , such a criterion in the context of the branch-and-bound algorithm may suffer from the curse-of-dimensionality problem since the number of dimensions required at least doubles .
108
Finally , ours and ESS , ESR do not share common approach to construct bounding quality function and to compute bounding values over the sets .
Finally , ESS , ESR and Recommend-Me differ in that they have different approaches to constructing a bounding quality function and to computing bounding values over the sets .
109
</p>
</p>
110
<p>
<p>
111
The rest of this paper is organized as follows .
The rest of this paper is organized as follows .
112
Section 2 presents an overview of the system .
Section 2 presents an overview of the system .
113
Details of our proposed approaches for finding region pairs with highest similarity scores are given in Section 3 .
The details of how we find region pairs with the highest similarity scores are given in Section 3 .
114
Section 4 presents our experiments and evaluations .
Section 4 presents our experiments and evaluations .
115
Section 5 concludes our paper .
Section 5 concludes the paper .
116
</p>
</p>
117
</section>
</section>
118
<section label = " Overview ">
<section label = " Overview ">
119
<p>
<p>
120
The framework of Recommend-Me consists of 4 main steps towards formulating final recommendations for users .
The framework of Recommend-Me consists of four main steps .
121
Figure \REF summarizes the pipeline .
Figure \REF summarizes the pipeline .
122
</p>
</p>
123
<p>
<p>
124
Step 1 : Candidate item selection in images .
Step 1 : Select candidate items in images .
125
Using all possible rectangular regions in images as candidate items is overly expensive for further processing .
Using all possible rectangular regions in images as candidate items is overly expensive in the subsequent processing .
126
More importantly , human users are often get attracted by object-like items .
More importantly , users are often attracted by object-like items .
127
Thus , we employ an approach proposed by Van de Sande et al. \CITE for item selection .
Thus , we employ an approach proposed by Van de Sande et al. \CITE for item selection .
128
The approach starts by oversegmenting an image into disjoint regions .
The approach starts by over-segmenting an image into disjoint regions .
129
Then , it performs a greedy algorithm which iteratively merges the two most similar regions together until the whole image becomes a single region .
Then , it performs a greedy search < ? ?> algorithm that iteratively merges the two most similar regions together until the whole image becomes a single region .
130
All region throughout the hierarchy is considered as candidate items .
All regions throughout the hierarchy are considered to be candidate items .
131
Each item is represented by its rectangular bounding region .
Each item is represented by its rectangular bounding region .
132
</p>
</p>
133
<p>
<p>
134
Step 2 : Finding top region pairs with highest similarity scores .
Step 2 : Find top region pairs with the highest similarity scores .
135
There is a pool of region pairs if we compare each region in the initial query image with each region in images of the database .
There will be a pool of region pairs if we compare each region in the initial query image with each region in images of the database .
136
However , only region pairs with sufficient high similarity scores are meaningful for identifying occurrences of candidate items .
However , only region pairs with sufficiently high similarity scores are meaningful for identifying occurrences of candidate items .
137
In this step , we perform our proposed approach , explained in Section 3 , to find top \MATH ( an expected number of returned region pairs ) of such pairs in the pool .
In this step , we use the approach explained in Section 3 to find the top \MATH ( the expected number of returned region pairs ) of such pairs in the pool .
138
</p>
</p>
139
<p>
<p>
140
Step 3 : Grouping overlapping regions .
Step 3 : Group overlapping regions .
141
Given \MATH region pairs returned in Step 2 and assuming each region pair in \MATH pairs is formed by a candidate item and its corresponding match , we now can enumerate the number of occurences of the items .
Given \MATH region pairs returned in Step 2 and assuming each region pair in the \MATH pairs is formed by a candidate item and its corresponding match , we can enumerate the number of occurrences of the items .
142
However , there are several regions highly overlap each other due to merging in Step 1 .
However , there are likely several regions that overlap each other due to the merging done in Step 1 .
143
They are perceived as the same item by human being .
These regions would be perceived as the same item by users .
144
Thus , we propose to use maximal clique analysis technique to group such regions for consistent recommendations .
Thus , we propose to use maximal clique analysis to group such regions so that the recommendations will be consistent .
145
One clique is one group of regions .
One clique is one group of regions .
146
</p>
</p>
147
<p>
<p>
148
Step 4 : Formulating recommendations .
Step 4 : Formulate recommendations .
149
Finally , for each group of regions , we count the number of images containing at least one match of one member region of the group .
Finally , for each group of regions , we count the number of images containing at least one match of one member region of the group .
150
The number indicates how frequent the item , represented by the group , occurs in the database .
The number indicates how frequent the item , represented by the group , occurs in the database .
151
Using those numbers , we rank all groups and then introduce them to users as our recommendations .
Using those numbers , we rank all groups and show them as recommendations to users .
152
Representative of each group is a rectangular region located by averaging coordinates of all member regions of the group .
A representative of each group is a rectangular region located by averaging the coordinates of all member regions of the group .
153
</p>
</p>
154
</section>
</section>
155
<section label = " Finding region pairs with the highest similarity scores ">
<section label = " Finding region pairs with the highest similarity scores ">
156
<p>
<p>
157
In this section , we introduce our proposed approach for efficiently finding top \MATH similar region pairs in the pool of all possible region pairs .
In this section , we describe our approach for efficiently finding the top \MATH similar region pairs in the pool of all possible region pairs .
158
</p>
</p>
159
<p>
<p>
160
Given two sets of regions \MATH and \MATH , the set of all possible region pairs then can be represented as \MATH .
Given two sets of regions \MATH and \MATH , the set of all possible region pairs can then be represented as \MATH .
161
With a similarity function \MATH , we have to solve the following optimization problem in order to find the region pair \MATH with the highest similarity score .
By using the similarity function \MATH , we have to solve the following optimization problem in order to find the region pair \MATH with the highest similarity score .
162
</p>
</p>
163
<p>
<p>
164
Because \MATH elements , it is expensive to perform this maximization exhaustively .
Because \MATH elements , it is expensive to perform this maximization exhaustively .
165
We propose to use a branch-and-bound algorithm \CITE for the problem .
We hence propose to use a branch-and-bound algorithm \CITE to solve the problem .
166
Once \MATH is found , we can obtain the other top region pairs by continuing the search processs with the remaining search spaces , in which found top pairs eliminated .
Once \MATH is found , we can obtain the other top region pairs by continuing the search process with the remaining search space , in which the found top pairs have been eliminated .
167
</p>
</p>
168
<p>
<p>
169
A general branch-and-bound algorithm works by hierarchically dividing the parameter space into disjoint parts , known as branching step .
A general branch-and-bound algorithm works by hierarchically dividing the parameter space into disjoint parts ; this is called the branching step .
170
In the bounding step , each part is assigned an upper bound value that the quality function could take on any of the members of the part .
In the bounding step , each part is assigned an upper bound for which the quality function could take on any of the members of the part . //<The rewrite is grammatical but I don 't know what " the quality function could take on any of the members of the part " . Inparticular what are these members and can they be computed in a function ?>
171
Parts of the parameter space with higher upper bound values are examined first .
Those parts of the parameter space with higher upper bound values are examined first .
172
So , many portions of the parameter space can be eliminated if their upper bound values imply that they cannot contain the maximum .
Thus , many portions of the parameter space can be eliminated if their upper bound values imply that they cannot contain the maximum .
173
Adapting to our problem , the parameter space is the set of all region pairs \MATH , and the quality function is the similarity function \MATH .
In our problem , the parameter space is the set of all region pairs \MATH , and the quality function is the similarity function \MATH .
174
</p>
</p>
175
<p>
<p>
176
Assuming we can organize regions in \MATH and \MATH into two hierarchical structures \MATH and \MATH respectively , so that :
Assuming we can organize regions in \MATH and \MATH into two hierarchical structures \MATH and \MATH respectively , so that :
177
</p>
</p>
178
<p>
<p>
179
- all regions are leaf nodes of the structures and non-leaf nodes are {\it virtual} nodes ,
- all regions are leaf nodes of the structures and non-leaf nodes are {\it virtual} nodes ,
180
</p>
</p>
181
<p>
<p>
182
- if each node is repsented by a histgoram \MATH with \MATH bins , the value at each bin of a child node is constrainted to be equal or smaller the value at the same bin of its parent node .
- if each node is represented by a histogram \MATH with \MATH bins , the value in each bin of a child node is constrained to be equal or smaller than the value in the same bin of its parent node .
183
</p>
</p>
184
<p>
<p>
185
Given such structures , we show in the following how a branch-and-bound algorithm applied to our problem .
Given such structures , we show in what follows how the branch-and-bound algorithm can be used to solve our problem .
186
</p>
</p>
187
<p>
<p>
188
Let \MATH and \MATH denote two nodes on \MATH and \MATH .
Let \MATH and \MATH denote two nodes on \MATH and \MATH .
189
And , \MATH denotes the set containing all leaf nodes explored from \MATH .
And let \MATH denote the set containing all leaf nodes explored from \MATH .
190
If \MATH is a leaf node , \MATH .
If \MATH is a leaf node , \MATH .
191
Otherwise , given \MATH with \MATH are direct child nodes of \MATH , \MATH can be recursively defined as follows : \MATH
Otherwise , given \MATH with \MATH being direct child nodes of \MATH , \MATH can be recursively defined as follows : \MATH
192
</p>
</p>
193
<p>
<p>
194
In a similar way , we have : \MATH
In a similar way , we have : \MATH
195
</p>
</p>
196
<p>
<p>
197
Given \MATH indicates the set of node pairs formed by paring nodes in \MATH with nodes in \MATH , we have : \MATH
Letting \MATH indicate the set of node pairs formed by pairing nodes in \MATH with nodes in \MATH , we get : \MATH . //<the rewrite is a guess .>
198
</p>
</p>
199
<p>
<p>
200
So , if \MATH and \MATH are roots of \MATH and \MATH respectively , \MATH will exactly be the entire search space \MATH .
Thus , if \MATH and \MATH are roots of \MATH and \MATH respectively , \MATH will be exactly the entire search space \MATH .
201
</p>
</p>
202
<p>
<p>
203
Branching Step .
Branching Step .
204
Dividing the search space ( i.e. set of region pairs ) covered by \MATH is straightforward by utilizing the hierarchical structures \MATH , \MATH at certain nodes \MATH , \MATH .
Dividing up the search space ( i.e. set of region pairs ) covered by \MATH can be done straightforwardly by utilizing the hierarchical structures \MATH , \MATH at certain nodes \MATH , \MATH . //<The rewrite is better if it is correct .>
205
Regarding to \REF , \REF and \REF , \MATH can be divided into disjoint parts as follows : \MATH
Regarding \REF , \REF and \REF , \MATH can be divided into disjoint parts as follows : \MATH
206
</p>
</p>
207
<p>
<p>
208
Or , \MATH
Or , \MATH
209
</p>
</p>
210
<p>
<p>
211
Selecting which way to divide can be based on sizes of \MATH and \MATH .
The way to divide can be based on the sizes of \MATH and \MATH .
212
We select the larger one to be divided first .
We divide the larger one first .
213
An illustration of a branching step is given in Figure \REF .
The branching step is illustrated in Figure \REF .
214
</p>
</p>
215
<p>
<p>
216
Bounding Step .
Bounding Step .
217
An essential requirement for branch-and-bound is the quality bounding function \MATH used to evaluate how necessary a part of the search space should be examined .
An essential requirement for the branch-and-bound algorithm is the quality bounding function \MATH used to determine whether a part of the search space should be examined . //<Or " determine the extent that " ? ?>
218
Particularly , \MATH bounds the upper values of \MATH over a set of node pairs ( i.e. region pairs ) .
In particular , \MATH bounds the upper values of \MATH over a set of node pairs ( i.e. region pairs ) .
219
</p>
</p>
220
<p>
<p>
221
Assuming we are now evaluating the upper bound of \MATH over all region pairs in \MATH .
Let us assume that we are evaluating the upper bound of \MATH over all region pairs in \MATH .
222
Among several types of distance for estimating the similarity of two regions , we stick to Normalized Histogram Intersection ( NHI ) distance since it is well-balanced between computational efficiency and robustness~\cite{ESR} .
Among the several distance formulas for estimating the similarity of two regions , we will use the Normalized Histogram Intersection ( NHI ) distance since it is well-balanced between computational efficiency and robustness~\cite{ESR} .
223
We then rely on NHI to define \MATH bounding the values of \MATH , with : \MATH
We will then rely on NHI to define \MATH bounding the values of \MATH , with : \MATH
224
</p>
</p>
225
<p>
<p>
226
Referring to the constraint ( b ) in constructing \MATH and \MATH , we have : \MATH
Referring to constraint ( b ) in constructing \MATH and \MATH , we have : \MATH
227
As a result , the bounding value \MATH over \MATH can be clearly observed as : \MATH
As a result , the bounding value \MATH over \MATH can be clearly observed as : \MATH . //<I 'm not sure what observed means in this context . Do you mean " can be derived as " ? ?>
228
</p>
</p>
229
<p>
<p>
230
We can efficiently evaluate \MATH for the set of region pairs \MATH because \MATH is relied only on histogram representation of single rectangular regions \MATH and \MATH .
We can efficiently evaluate \MATH for the set of region pairs \MATH because \MATH relies only on the histogram representation of single rectangular regions \MATH and \MATH .
231
And , the normalization terms , which indicate the minimum number of visual words inside any member region of \MATH , \MATH , are computed once by using integral image technique .
Moreover , the normalization terms , which indicate the minimum number of visual words inside any member region of \MATH , \MATH , are computed once by using the integral image technique .
232
</p>
</p>
233
<p>
<p>
234
Inspired by \CITE , we form the algorithm in best-first manner .
Inspired by \CITE , we devised the algorithm to work in a best-first manner . //<The original describes the way you decided to write the algorithm . In contrast , the rewrite describes the way the algorithm works .>
235
The algorithm examines next the set having highest bounding value \MATH .
The algorithm examines the set having the highest bounding value \MATH . //<" next " is unclear . The rewrite is a guess .>
236
The algorithm stops if the set contain only one pair of region .
The algorithm stops if the set contain only one pair of region .
237
Otherwise , the set is then divided into disjoint subsets for further search .
Otherwise , the set is then divided into disjoint subsets for further search .
238
Pseudo-code for the algorithm using a priority queue to store sets of region pairs , is given as follows .
Pseudo-code for the algorithm using a priority queue to store sets of region pairs , is given as follows .
239
</p>
</p>
240
<p>
<p>
241
</p>
</p>
242
<p>
<p>
243
To obtain more than one region pair , we simply continue the loop in the Algorithm 1 until the expected number of region pairs \MATH have been reached .
To obtain more than one region pair , we simply repeat the loop in Algorithm 1 until the expected number of region pairs \MATH is reached .
244
</p>
</p>
245
<p>
<p>
246
So far , our approach is based on an assumption that the sets of regions are already organized into hierarchical structures which satisfy the constraints ( a ) and ( b ) .
So far , our approach is based on an assumption that the sets of regions are already organized into hierarchical structures which satisfy constraints ( a ) and ( b ) .
247
In the remaining of this section , we show how to organize such sets , given the initial query image and the image database .
In the remaining of this section , we show how to organize such sets , given the initial query image and image database .
248
</p>
</p>
249
</subsection>
</subsection>
250
<subsection label = " Organizing regions into hierarchical structures ">
<subsection label = " Organizing regions into hierarchical structures ">
251
<p>
<p>
252
There are two type of region set for organization .
There are two type of region set .
253
One is set containing regions of one image .
One is a set containing regions of one image .
254
The other is set containing regions of multiple images ( i.e. database ) .
The other is a set containing regions of multiple images ( i.e. database ) .
255
With the first type of set , by applying the selective search approach introduced in \CITE for item selection , regions in each image are already organized into a binary tree .
With the first type of set , by applying the selective search approach introduced in \CITE for item selection , regions in each image are already organized into a binary tree .
256
Because such binary tree were constructed by bottom-up merging regions , a parent region on the trees spatially covers its child regions in image space ( see Figure \REF ) .
Because such binary tree were constructed by bottom-up merging of regions , a parent region on the trees spatially covers its child regions in the image space ( see Figure \REF ) .
257
As a result , we have the constraint ( b ) satisfied .
As a result , constraint ( b ) is satisfied .
258
</p>
</p>
259
<p>
<p>
260
However , because we want to use all regions corresponding to all nodes throughout the tree as candidate item regions , the constraint ( a ) will be violated if we keep using the tree for the branch-and-bound based algorithm .
However , because we want to use all regions corresponding to all nodes throughout the tree as candidate item regions , constraint ( a ) will be violated if we keep using the tree for the branch-and-bound algorithm .
261
In other words , all current non-leaf nodes of the tree will be treated as {\it vitual nodes} and will not be used as candidate item regions .
In other words , all current non-leaf nodes of the tree will be treated as {\it vitual nodes} and will not be used as candidate item regions .
262
Our solution to this problem is straightforward .
Our solution to this problem is straightforward .
263
We generate and attach a new leaf node to each non-leaf nodes of the current tree .
We generate and attach a new leaf node to each non-leaf node of the current tree .
264
The generated node is exactly the same as the non-leaf node it attach to , which now becomes a virtual node .
The generated node is exactly the same as the non-leaf node it is attached to , which now becomes a virtual node .
265
By doing that , we keep the spatial covering property of the orginal binary tree for the new hierarchical structure .
By doing that , we keep the spatial covering property of the original binary tree for the new hierarchical structure .
266
And , all non-leaf nodes will be taken into account as candidate item regions via their attachments .
Moreover , all non-leaf nodes will be taken into account as candidate item regions via their attachments .
267
The new hierarchical structure therefore satisfy both the constraints ( a ) and ( b ) .
The new hierarchical structure therefore satisfies both constraints .
268
An illustration is presented in Figure X .
Figure X is an illustration of this organization .
269
</p>
</p>
270
<p>
<p>
271
With a set containing regions of multiple images , we perform a two-stage organization procedure .
With a set containing regions from multiple images , we perform a two-stage organization procedure .
272
At the first stage , regions in each image are organized into a hierarchical structure as we presented above .
In the first stage , regions in each image are organized into a hierarchical structure , as presented above .
273
Given multiple hierarchical structures returned from the first stage , we use their root nodes as initial elements to construct an yet another hierarchical structure over them by divisive clustering .
If multiple hierarchical structures are returned by the first stage , we use their root nodes as the initial elements to construct an yet another hierarchical structure over them by divisive clustering . //<the rewrite is a guess .>
274
We start with the full set of the elements .
We start with the full set of the elements .
275
Then , splits are peformed recursively as one moves down the hierarcy .
Then , we perform splits recursively as one moves down the hierarchy .
276
In each splitting step , the splitted set is divided into $k$ parts by using $k$-means clustering algorithm .
In each splitting step , the split set is divided into $k$ parts by using $k$-means clustering .
277
Once the hierchical structure is completed , we then compute histogram representation for all of its non-leaf nodes .
Once the hierarchical structure is completed , we compute a histogram representation for all of its non-leaf nodes .
278
The value at each hitogram bin of a non-leaf nodes is the maximum of all values at the same bin of its child nodes .
The value at each histogram bin of a non-leaf node is the maximum of all values in the same bin of its child nodes .
279
This is to ensure the constraint ( b ) sastified .
This is to ensure constraint ( b ) is satisfied .
280
At last , by unifying results of both stages , we have a unique hierarchical structure over the set of regions of multiple images , which satisfies the both constraints .
Finally , by unifying the results of both stages , we have a unique hierarchical structure over the set of regions of multiple images , which satisfies both constraints .
281
We show an illustration in Figure Y .
We illustratie this in Figure Y .
282
</p>
</p>
283
<p>
<p>
284
So , given the initial query image and a database , we now can construct two hierarchical structures .
So , given the initial query image and a database , we now can construct two hierarchical structures .
285
One is for regions of the initial query image .
One is for the regions of the initial query image .
286
The other is for regions of all images in the database .
The other is for the regions of all images in the database .
287
Both structures are then becomes input for our proposed approach to find top region pairs with highest similarity scores for recommendation generation .
Both structures then become the input for our approach to find the top region pairs with the highest similarity scores for making recommendations .
288
Note that , because the hierarchical for regions of images in the database is independent of query , we construct it only one time .
Note that because the hierarchy of the regions of images in the database is independent of the query , we construct it only one time .
289
</subsection>
</subsection>
290
</section>
</section>
291
<section label = " Experiments ">
<section label = " Experiments ">
292
<subsection label = " Performance Evaluation ">
<subsection label = " Performance Evaluation ">
293
<p>
<p>
294
A recommendation is a good one if it exactly locates an item which exists in the database .
A recommendation is a good one if it exactly locates an item in the database .
295
We call such recommendations as hit recommendations . Thus , a good recommendation system should accurately provide such hit recommendation to users .
We call such recommendations" hit recommendations " , and a good recommendation system should accurately provide them to users .
296
More importantly , users always expect that hit recommendations are ranked higher than false recommendations ( if there are some of them ) on the list of all recommendations introduced by the system .
More importantly , users always expect that hit recommendations are ranked higher than false recommendations ( if there are a number of them ) on the list of the recommendations by the system .
297
Based on those insights , we evaluate Recommend-Me system using two evaluation metrics : precision on introducing recommendation and rank of the first hit recommendation on the list .
Based on these insights , we evaluated the Recommend-Me system using two evaluation metrics : precision in pesenting recommendations and rank of the first hit recommendation on the list .
298
</p>
</p>
299
<p>
<p>
300
Given an initial query image with ground-truth annotation indicates bounding box of an item known existed in the database , Recommend-Me is determined to precisely introduce recommendation if at least one of its recommendation is a hit recommendation .
Given an initial query image with ground-truth annotations indicating the bounding box of an item known to existin the database , Recommend-Me will provide a recommendation if at least one of its recommendations is a hit recommendation .
301
We apply an approach used in Pascal VOC challenge to clarify whether a recommendation is a hit recommendation .
We used an approach from the Pascal VOC challenge to clarify whether a recommendation is a hit recommendation or not .
302
In particular , the intersection area between a hit recommendation and an item should be larger than half of their union area .
In particular , the intersection area between a hit recommendation and an item should be larger than half their union area .
303
Because our target is not to improve search techniques but to facilitate query selection procedure , search performance simply relies on standard techniques if users take an recommendation as a search query .
Because our target is not to improve search techniques but to facilitate query selection , the search simply relies on standard techniques if users use an recommendation as a search query .
304
</p>
</p>
305
<p>
<p>
306
To evaluate the efficiency of Recommend-Me on finding \MATH region pairs with highest similarity scores , we compute the number of evaluation for the quality bounding function in the branch-and-bound algorithm .
To evaluate the efficiency of Recommend-Me in finding \MATH region pairs with the highest similarity scores , we computed the number of evaluations for the quality bounding function in the branch-and-bound algorithm .
307
This number is then divided by the size of all possible region pairs formed by regions in the initial query image and regions in images of the database .
This number was then divided by the size of all possible region pairs formed by regions in the initial query image and regions in images of the database . //< " the size of all possible region pairs " is unclear to me . Do you mean " the average size of all possible region pairs " or " the sizes of all possible region pairs " ?>
308
The fraction is reported as the efficiency improvement of Recommend-Me .
The fraction was taken to be the efficiency improvement of Recommend-Me .
309
Note that , regions in images are pre-selected as in Step 1 of our framework .
Note that regions in images were pre-selected as in Step 1 of our framework .
310
</p>
</p>
311
</subsection>
</subsection>
312
<subsection label = " Experimental Setting ">
<subsection label = " Experimental Setting ">
313
Feature presentation .
Feature presentation .
314
We employ BoF model to represent features of images and regions in the images .
We employed a BoF model to represent the features of images and regions in the images .
315
Visual words in images are located by dense grid sampling and Different-of-Gaussian( DoG ) detector .
Visual words in the images were located by using dense grid sampling and a Different-of-Gaussian ( DoG ) detector .
316
A codebook of 2000 visual words is built using standard K-Means algorithm .
A codebook of 2000 visual words was built using the standard K-Means algorithm .
317
%to cluster points on a set of random images .% Additionally , the set of interest points obtained by DoG in the query image is used to remove regions without any of such points inside .
%to cluster points on a set of random images .% Additionally , the set of points of interest obtained by the DoG in the query image was used to remove regions without any such points inside .
318
This helps us to eliminate less meaningful regions such as a portion of the sky , solid color regions , etc for recommendation .
This helped us to eliminate less meaningful regions such as the sky , solid color regions , etc. , from the recommendations .
319
</p>
</p>
320
<p>
<p>
321
Region selection in images .
Region selection in images .
322
As mentioned above , we use the approach introduced in \CITE on different color channel for region selection .
As mentioned above , we used the approach first introduced in \CITE on different color channels for the region selection .
323
In this experiment , we used two color channels which are RGB and Hue , since regions generated on those channels can cover 99 .72\% area of the annotated item regions in our dataset .
In this experiment , we used two color channels , RGB and Hue , since the regions generated on those channels can cover 99 .72\% of the area of the annotated item regions in our dataset .
324
A virtual root node is created to compose two color-dependent binary trees into one unique binary tree for each image .
A virtual root node was created to compose two color-dependent binary trees into one unique binary tree for each image .
325
In addition , rectangular regions which do not contain any visual word or are smaller than 40 x 40 pixels are discarded .% since they can form a meaningful recommendation .
In addition , the rectangular regions which did not contain any visual word or were smaller than 40 x 40 pixels were discarded .% since they can form a meaningful recommendation .
326
</p>
</p>
327
<p>
<p>
328
Maximal clique analysis algorithm .
Maximal clique analysis algorithm .
329
Given the set of regions in the initial query image , we build a graph in which two regions are connected if they highly overlap each other ( we use the approach of Pascal VOC with tighter threshold , 0 .8 ) .
Given the set of regions in the initial query image , we built a graph in which two regions were connected if they nearly overlapped each other ( we use the approach of Pascal VOC with a tighter threshold , 0 .8 ) .
330
Bron-Kerbosch algorithm is then applied to find all maximal cliques in the graph .
The Bron-Kerbosch algorithm was then applied to find all maximal cliques in the graph .
331
One clique is one group of regions .
One clique was one group of regions .
332
</p>
</p>
333
</subsection>
</subsection>
334
<subsection label = " Experimental Results ">
<subsection label = " Experimental Results ">
335
Figure \REF shows our evaluation results .
Figure \REF shows the results of the evaluation .
336
The reported numbers of precision , rank of the first hit recommendation as well as efficiency improvement are averaged as we perform Recommend-Me with 375 different initial query images and an individual value of \MATH .
The reported precision , rank of the first hit recommendation , and efficiency improvement are averages of Recommend-Me on 375 different initial query images and an individual value of \MATH .
337
The results show that Recommend-Me can successfully introduce hit recommendations to users with high precision ( approximately 80 .27\% ) .
The results show that Recommend-Me can make hit recommendations to users with high precision ( approximately 80 .27\% ) .
338
On the returned list of all recommendations , a hit recommendation usually takes the first two places on the list .
On the returned list of all recommendations , hit recommendations usually take the first two places on the list .
339
This help users to avoid choosing false recommendations ( if such false recommendations are highly ranked ) .
This help users to avoid choosing false recommendations ( if such false recommendations are highly ranked ) .
340
</p>
</p>
341
<p>
<p>
342
We observed that there are two types of false recommendations on the top places of the list .
There were two types of false recommendation in the top places of the list .
343
The first type consists background regions ( e.g. trees , buildings , roads ) which are easily found in many images .
The first type consisted of background regions ( e.g. trees , buildings , roads ) , which are easily found in many images .
344
The second type is the items lacking of manual annotation such as windows , cars and humans .
The second type was items lacking manual annotations such as windows , cars , and humans .
345
Thus , recommendations about those items are not counted as hit recommendations .
Thus , recommendations about those items are not counted as hit recommendations .
346
However , if users are interested in using them as hints to explore the database , they are still very much helpful .
However , if users are interested in using them as hints to explore the database , they may still be very helpful .
347
</p>
</p>
348
<p>
<p>
349
Clearly , one can realize that the performance of Recommend-Me is under the influence of \MATH .
Clearly , one can realize that the performance of Recommend-Me is influenced by \MATH .
350
By increasing \MATH , we obtain more region pairs with sufficient hight similarity scores .
By increasing \MATH , we can obtain more region pairs with sufficiently high similarity scores .
351
It brings more chances to get region pairs of the annotated item , thus improves the precision .
Thisgives more chances to get region pairs of the annotated item , thus improving precision .
352
However , the trade-off is that more unexpected items are also returned .
However , the trade-off is that more unexpected items are returned .
353
This results in a drop of average rank of the first hit recommendation .
This results in a drop in the average rank of the first hit recommendation .
354
Figure 5( a ) demonstrates this circumstance .
Figure 5( a ) demonstrates this circumstance .
355
When \MATH increases from 2000 to 10000 , the precision also increases from 74 .67\% to 81 .97\% ; meanwhile , the average rank of the first hit recommendation drops to 2 .27 from 1 .78 .
When \MATH increases from 2000 to 10000 , the precision increases from 74 .67\% to 81 .97\% ; meanwhile , the average rank of the first hit recommendation drops to 2 .27 from 1 .78 .
356
It is worth noting that keeping inreasing \MATH may not always give better precision since precision relies on not only \MATH but also the robustness of the region comparision techniques .
It is worth noting that keeping increasing \MATH may not always give better precision , since precision relies on not only \MATH but also the robustness of the region comparison techniques .
357
Recommend-Me cannot provide any hit recommendation for around 20\% of initial query images due to the fact that our region comparision technique cannot deal with significant variations of items .
Recommend-Me cannot provide any hit recommendation for around 20\% of the initial query images due to the fact that our region comparison technique cannot deal with significant variations in the items .
358
</p>
</p>
359
<p>
<p>
360
Figure 5( b ) shows another circumstance when we increase \MATH .
Figure 5( b ) shows another circumstance when we increase \MATH .
361
It is the decline of efficiency improvement of Recommend-Me .
It is the decline in the efficiency improvement of Recommend-Me .
362
This is because the branch-and-bound algorithm has to visit more parts of the total search space in order to find extra local optimals .
This is because the branch-and-bound algorithm has to visit more parts of the total search space in order to find extra local opitimals .
363
However , in all of our evaluations , Recommend-Me still performs around 3 times faster than the exhaustive search .
However , in all of our evaluations , Recommend-Me still performed around three times faster than the exhaustive search .
364
Its superiority is important for practical applications .
This advantage will be important for practical applications .
365
Figure \REF presents examples of hit recommendations returned by our Recommend-Me .
Figure \REF presents examples of hit recommendations returned byRecommend-Me .
366
</p>
</p>
367
</subsection>
</subsection>
368
</section>
</section>
369
<section label = " Conclusion ">
<section label = " Conclusion ">
370
<p>
<p>
371
In this paper , we introduced a new system , named Recommend-Me , for visual query suggestion .
We described oursystem , named Recommend-Me , for making visual query suggestions .
372
Given an initial query image and a retrieved database , Recommend-Me introduces recommendations that imposes which and how frequent items in the initial query image appear in the database .
Given an initial query image and a retrieved database , Recommend-Me gives recommendations that impose conditions on which and how frequent items in the initial query image appear in the database .
373
Such recommendations support users to select search query , to rapidly refine the initial query image or to explore the database .
Such recommendations help users to select the search query , to rapidly refine the initial query image or to explore the database .
374
An efficient solution to make Recommend-Me practical is presented .
An efficient solution to make Recommend-Me practical was also presented .
375
To the best of our knowledge , Recommend-Me is the first attempt toward its targeted suggestion scheme .
To the best of our knowledge , Recommend-Me is the first attempt at developing a targeted suggestion scheme .
376
</p>
</p>
377
</section>
</section>
378
</document>
</document>
